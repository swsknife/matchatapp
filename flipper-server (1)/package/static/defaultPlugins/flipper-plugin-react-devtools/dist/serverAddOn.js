"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// plugins/public/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "plugins/public/node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data2 = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data2))
          ws.pause();
      });
      ws.once("error", function error2(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error2(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// plugins/public/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "plugins/public/node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// plugins/public/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "plugins/public/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset2 = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset2);
        offset2 += buf.length;
      }
      if (offset2 < totalLength)
        return target.slice(0, offset2);
      return target;
    }
    function _mask(source, mask, output, offset2, length3) {
      for (let i = 0; i < length3; i++) {
        output[offset2 + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data2) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data2))
        return data2;
      let buf;
      if (data2 instanceof ArrayBuffer) {
        buf = Buffer.from(data2);
      } else if (ArrayBuffer.isView(data2)) {
        buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        buf = Buffer.from(data2);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      module2.exports = {
        concat,
        mask(source, mask, output, offset2, length3) {
          if (length3 < 48)
            _mask(source, mask, output, offset2, length3);
          else
            bufferUtil.mask(source, mask, output, offset2, length3);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// plugins/public/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "plugins/public/node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// plugins/public/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "plugins/public/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data2, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data2, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data2, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data2);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data3 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data3);
        });
      }
      _compress(data2, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data2);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data3 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data3 = data3.slice(0, data3.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data3);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// plugins/public/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "plugins/public/node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF8 = require("utf-8-validate");
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        },
        tokenChars
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
    }
  }
});

// plugins/public/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "plugins/public/node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver2 = class extends Writable {
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n2) {
        this._bufferedBytes -= n2;
        if (n2 === this._buffers[0].length)
          return this._buffers.shift();
        if (n2 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n2);
          return buf.slice(0, n2);
        }
        const dst = Buffer.allocUnsafe(n2);
        do {
          const buf = this._buffers[0];
          const offset2 = dst.length - n2;
          if (n2 >= buf.length) {
            dst.set(this._buffers.shift(), offset2);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset2);
            this._buffers[0] = buf.slice(n2);
          }
          n2 -= buf.length;
        } while (n2 > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error2(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error2(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error2(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error2(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error2(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error2(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error2(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error2(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error2(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error2(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error2(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error2(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error2(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data2 = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data2 = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data2, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data2);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data2, cb);
          return;
        }
        if (data2.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data2);
        }
        return this.dataMessage();
      }
      decompress(data2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error2(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data2;
            if (this._binaryType === "nodebuffer") {
              data2 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data2 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data2 = fragments;
            }
            this.emit("message", data2, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error2(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data2) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data2.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data2.length === 1) {
            return error2(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data2.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error2(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data2.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error2(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data2);
        } else {
          this.emit("pong", data2);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver2;
    function error2(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error2);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// plugins/public/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "plugins/public/node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender2 = class {
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data2, options) {
        let mask;
        let merge = false;
        let offset2 = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset2 = 6;
        }
        let dataLength;
        if (typeof data2 === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data2 = Buffer.from(data2);
            dataLength = data2.length;
          }
        } else {
          dataLength = data2.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset2 += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset2 += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset2 : offset2);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data2];
        target[1] |= 128;
        target[offset2 - 4] = mask[0];
        target[offset2 - 3] = mask[1];
        target[offset2 - 2] = mask[2];
        target[offset2 - 1] = mask[3];
        if (skipMasking)
          return [target, data2];
        if (merge) {
          applyMask(data2, mask, target, offset2, dataLength);
          return [target];
        }
        applyMask(data2, mask, data2, 0, dataLength);
        return [target, data2];
      }
      close(code, data2, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data2 === void 0 || !data2.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length3 = Buffer.byteLength(data2);
          if (length3 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length3);
          buf.writeUInt16BE(code, 0);
          if (typeof data2 === "string") {
            buf.write(data2, 2);
          } else {
            buf.set(data2, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(buf, options), cb);
        }
      }
      ping(data2, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer(data2);
          byteLength = data2.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data2, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data2, options), cb);
        }
      }
      pong(data2, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer(data2);
          byteLength = data2.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data2, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data2, options), cb);
        }
      }
      send(data2, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data2 === "string") {
          byteLength = Buffer.byteLength(data2);
          readOnly = false;
        } else {
          data2 = toBuffer(data2);
          byteLength = data2.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
          } else {
            this.dispatch(data2, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender2.frame(data2, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      dispatch(data2, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender2.frame(data2, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data2, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender2.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// plugins/public/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "plugins/public/node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, listener, options = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data2, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data2 : data2.toString()
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "error") {
          wrapper = function onError2(error2) {
            const event = new ErrorEvent("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener.call(this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = listener;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
  }
});

// plugins/public/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "plugins/public/node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse4(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse4 };
  }
});

// plugins/public/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "plugins/public/node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash: createHash2 } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP: NOOP2
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse4 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket2 = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data2) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data2, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data2, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
      }
      pong(data2, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data2, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        const opts = {
          binary: typeof data2 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalHost = parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (parsedUrl.host !== websocket._originalHost) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          delete opts.headers.host;
          opts.auth = void 0;
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse4(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data2, cb) {
      if (data2) {
        const length3 = toBuffer(data2).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length3;
        else
          websocket._bufferedAmount += length3;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data2, isBinary) {
      this[kWebSocket].emit("message", data2, isBinary);
    }
    function receiverOnPing(data2) {
      const websocket = this[kWebSocket];
      websocket.pong(data2, !websocket._isServer, NOOP2);
      websocket.emit("ping", data2);
    }
    function receiverOnPong(data2) {
      this[kWebSocket].emit("pong", data2);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP2);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// plugins/public/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "plugins/public/node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse4(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse4 };
  }
});

// plugins/public/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "plugins/public/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash: createHash2 } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"] : false;
        const version3 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version3 !== 8 && version3 !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version3 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
  }
});

// plugins/public/node_modules/rollup/dist/es/shared/rollup.js
function decode(mappings) {
  var decoded = [];
  var line = [];
  var segment = [
    0,
    0,
    0,
    0,
    0
  ];
  var j = 0;
  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {
    var c = mappings.charCodeAt(i);
    if (c === 44) {
      segmentify(line, segment, j);
      j = 0;
    } else if (c === 59) {
      segmentify(line, segment, j);
      j = 0;
      decoded.push(line);
      line = [];
      segment[0] = 0;
    } else {
      var integer = charToInteger[c];
      if (integer === void 0) {
        throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
      }
      var hasContinuationBit = integer & 32;
      integer &= 31;
      value += integer << shift;
      if (hasContinuationBit) {
        shift += 5;
      } else {
        var shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = value === 0 ? -2147483648 : -value;
        }
        segment[j] += value;
        j++;
        value = shift = 0;
      }
    }
  }
  segmentify(line, segment, j);
  decoded.push(line);
  return decoded;
}
function segmentify(line, segment, j) {
  if (j === 4)
    line.push([segment[0], segment[1], segment[2], segment[3]]);
  else if (j === 5)
    line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
  else if (j === 1)
    line.push([segment[0]]);
}
function encode(decoded) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  var mappings = "";
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ";";
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0;
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(",");
  }
  return mappings;
}
function encodeInteger(num) {
  var result = "";
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars$1[clamped];
  } while (num > 0);
  return result;
}
function guessIndent(code) {
  var lines = code.split("\n");
  var tabbed = lines.filter(function(line) {
    return /^\t+/.test(line);
  });
  var spaced = lines.filter(function(line) {
    return /^ {2,}/.test(line);
  });
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  var min = spaced.reduce(function(previous, current2) {
    var numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  var fromParts = from.split(/[/\\]/);
  var toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    var i = fromParts.length;
    while (i--) {
      fromParts[i] = "..";
    }
  }
  return fromParts.concat(toParts).join("/");
}
function isObject$1(thing) {
  return toString$1.call(thing) === "[object Object]";
}
function getLocator$1(source) {
  var originalLines = source.split("\n");
  var lineOffsets = [];
  for (var i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate2(index) {
    var i2 = 0;
    var j = lineOffsets.length;
    while (i2 < j) {
      var m = i2 + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i2 = m + 1;
      }
    }
    var line = i2 - 1;
    var column = index - lineOffsets[line];
    return { line, column };
  };
}
function relative(from, to) {
  const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
  const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
  if (fromParts[0] === ".")
    fromParts.shift();
  if (toParts[0] === ".")
    toParts.shift();
  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  while (toParts[0] === ".." && fromParts.length > 0) {
    toParts.shift();
    fromParts.pop();
  }
  while (fromParts.pop()) {
    toParts.unshift("..");
  }
  return toParts.join("/");
}
function getOrCreate(map, key, init) {
  const existing = map.get(key);
  if (existing) {
    return existing;
  }
  const value = init();
  map.set(key, value);
  return value;
}
function getLocator(source, options) {
  if (options === void 0) {
    options = {};
  }
  var offsetLine = options.offsetLine || 0;
  var offsetColumn = options.offsetColumn || 0;
  var originalLines = source.split("\n");
  var start = 0;
  var lineRanges = originalLines.map(function(line, i2) {
    var end = start + line.length + 1;
    var range = { start, end, line: i2 };
    start = end;
    return range;
  });
  var i = 0;
  function rangeContains(range, index) {
    return range.start <= index && index < range.end;
  }
  function getLocation(range, index) {
    return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
  }
  function locate2(search, startIndex) {
    if (typeof search === "string") {
      search = source.indexOf(search, startIndex || 0);
    }
    var range = lineRanges[i];
    var d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search))
        return getLocation(range, search);
      i += d;
      range = lineRanges[i];
    }
  }
  return locate2;
}
function locate(source, search, options) {
  if (typeof options === "number") {
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  }
  return getLocator(source, options)(search, options && options.startIndex);
}
function spaces(i) {
  let result = "";
  while (i--)
    result += " ";
  return result;
}
function tabsToSpaces(str) {
  return str.replace(/^\t+/, (match) => match.split("	").join("  "));
}
function getCodeFrame(source, line, column) {
  let lines = source.split("\n");
  const frameStart = Math.max(0, line - 3);
  let frameEnd = Math.min(line + 2, lines.length);
  lines = lines.slice(frameStart, frameEnd);
  while (!/\S/.test(lines[lines.length - 1])) {
    lines.pop();
    frameEnd -= 1;
  }
  const digits = String(frameEnd).length;
  return lines.map((str, i) => {
    const isErrorLine = frameStart + i + 1 === line;
    let lineNum = String(i + frameStart + 1);
    while (lineNum.length < digits)
      lineNum = ` ${lineNum}`;
    if (isErrorLine) {
      const indicator = spaces(digits + 2 + tabsToSpaces(str.slice(0, column)).length) + "^";
      return `${lineNum}: ${tabsToSpaces(str)}
${indicator}`;
    }
    return `${lineNum}: ${tabsToSpaces(str)}`;
  }).join("\n");
}
function printQuotedStringList(list, verbs) {
  const isSingleItem = list.length <= 1;
  const quotedList = list.map((item) => `"${item}"`);
  let output = isSingleItem ? quotedList[0] : `${quotedList.slice(0, -1).join(", ")} and ${quotedList.slice(-1)[0]}`;
  if (verbs) {
    output += ` ${isSingleItem ? verbs[0] : verbs[1]}`;
  }
  return output;
}
function isAbsolute(path4) {
  return ABSOLUTE_PATH_REGEX.test(path4);
}
function isRelative(path4) {
  return RELATIVE_PATH_REGEX.test(path4);
}
function normalize(path4) {
  return path4.replace(BACKSLASH_REGEX, "/");
}
function getAliasName(id) {
  const base2 = (0, import_path.basename)(id);
  return base2.substring(0, base2.length - (0, import_path.extname)(id).length);
}
function relativeId(id) {
  if (!isAbsolute(id))
    return id;
  return relative((0, import_path.resolve)(), id);
}
function isPathFragment(name) {
  return name[0] === "/" || name[0] === "." && (name[1] === "/" || name[1] === ".") || isAbsolute(name);
}
function getImportPath(importerId, targetPath, stripJsExtension, ensureFileName) {
  let relativePath = normalize(relative((0, import_path.dirname)(importerId), targetPath));
  if (stripJsExtension && relativePath.endsWith(".js")) {
    relativePath = relativePath.slice(0, -3);
  }
  if (ensureFileName) {
    if (relativePath === "")
      return "../" + (0, import_path.basename)(targetPath);
    if (UPPER_DIR_REGEX.test(relativePath)) {
      return relativePath.split("/").concat(["..", (0, import_path.basename)(targetPath)]).join("/");
    }
  }
  return !relativePath ? "." : relativePath.startsWith("..") ? relativePath : "./" + relativePath;
}
function error(base2) {
  if (!(base2 instanceof Error))
    base2 = Object.assign(new Error(base2.message), base2);
  throw base2;
}
function augmentCodeLocation(props, pos, source, id) {
  if (typeof pos === "object") {
    const { line, column } = pos;
    props.loc = { column, file: id, line };
  } else {
    props.pos = pos;
    const { line, column } = locate(source, pos, { offsetLine: 1 });
    props.loc = { column, file: id, line };
  }
  if (props.frame === void 0) {
    const { line, column } = props.loc;
    props.frame = getCodeFrame(source, line, column);
  }
}
function errAssetNotFinalisedForFileName(name) {
  return {
    code: Errors.ASSET_NOT_FINALISED,
    message: `Plugin error - Unable to get file name for asset "${name}". Ensure that the source is set and that generate is called first.`
  };
}
function errCannotEmitFromOptionsHook() {
  return {
    code: Errors.CANNOT_EMIT_FROM_OPTIONS_HOOK,
    message: `Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.`
  };
}
function errChunkNotGeneratedForFileName(name) {
  return {
    code: Errors.CHUNK_NOT_GENERATED,
    message: `Plugin error - Unable to get file name for chunk "${name}". Ensure that generate is called first.`
  };
}
function errChunkInvalid({ fileName, code }, exception) {
  const errorProps = {
    code: Errors.CHUNK_INVALID,
    message: `Chunk "${fileName}" is not valid JavaScript: ${exception.message}.`
  };
  augmentCodeLocation(errorProps, exception.loc, code, fileName);
  return errorProps;
}
function errCircularReexport(exportName, importedModule) {
  return {
    code: Errors.CIRCULAR_REEXPORT,
    id: importedModule,
    message: `"${exportName}" cannot be exported from ${relativeId(importedModule)} as it is a reexport that references itself.`
  };
}
function errCyclicCrossChunkReexport(exportName, exporter, reexporter, importer) {
  return {
    code: Errors.CYCLIC_CROSS_CHUNK_REEXPORT,
    exporter,
    importer,
    message: `Export "${exportName}" of module ${relativeId(exporter)} was reexported through module ${relativeId(reexporter)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in ${relativeId(importer)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`,
    reexporter
  };
}
function errAssetReferenceIdNotFoundForSetSource(assetReferenceId) {
  return {
    code: Errors.ASSET_NOT_FOUND,
    message: `Plugin error - Unable to set the source for unknown asset "${assetReferenceId}".`
  };
}
function errAssetSourceAlreadySet(name) {
  return {
    code: Errors.ASSET_SOURCE_ALREADY_SET,
    message: `Unable to set the source for asset "${name}", source already set.`
  };
}
function errNoAssetSourceSet(assetName) {
  return {
    code: Errors.ASSET_SOURCE_MISSING,
    message: `Plugin error creating asset "${assetName}" - no asset source set.`
  };
}
function errBadLoader(id) {
  return {
    code: Errors.BAD_LOADER,
    message: `Error loading ${relativeId(id)}: plugin load hook should return a string, a { code, map } object, or nothing/null`
  };
}
function errDeprecation(deprecation) {
  return {
    code: Errors.DEPRECATED_FEATURE,
    ...typeof deprecation === "string" ? { message: deprecation } : deprecation
  };
}
function errFileReferenceIdNotFoundForFilename(assetReferenceId) {
  return {
    code: Errors.FILE_NOT_FOUND,
    message: `Plugin error - Unable to get file name for unknown file "${assetReferenceId}".`
  };
}
function errFileNameConflict(fileName) {
  return {
    code: Errors.FILE_NAME_CONFLICT,
    message: `The emitted file "${fileName}" overwrites a previously emitted file of the same name.`
  };
}
function errInputHookInOutputPlugin(pluginName, hookName) {
  return {
    code: Errors.INPUT_HOOK_IN_OUTPUT_PLUGIN,
    message: `The "${hookName}" hook used by the output plugin ${pluginName} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
  };
}
function errCannotAssignModuleToChunk(moduleId, assignToAlias, currentAlias) {
  return {
    code: Errors.INVALID_CHUNK,
    message: `Cannot assign ${relativeId(moduleId)} to the "${assignToAlias}" chunk as it is already in the "${currentAlias}" chunk.`
  };
}
function errInvalidExportOptionValue(optionValue) {
  return {
    code: Errors.INVALID_EXPORT_OPTION,
    message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${optionValue}"`,
    url: `https://rollupjs.org/guide/en/#outputexports`
  };
}
function errIncompatibleExportOptionValue(optionValue, keys2, entryModule) {
  return {
    code: "INVALID_EXPORT_OPTION",
    message: `"${optionValue}" was specified for "output.exports", but entry module "${relativeId(entryModule)}" has the following exports: ${keys2.join(", ")}`
  };
}
function errInternalIdCannotBeExternal(source, importer) {
  return {
    code: Errors.INVALID_EXTERNAL_ID,
    message: `'${source}' is imported as an external by ${relativeId(importer)}, but is already an existing non-external module id.`
  };
}
function errInvalidOption(option, urlHash, explanation, value) {
  return {
    code: Errors.INVALID_OPTION,
    message: `Invalid value ${value !== void 0 ? `${JSON.stringify(value)} ` : ""}for option "${option}" - ${explanation}.`,
    url: `https://rollupjs.org/guide/en/#${urlHash}`
  };
}
function errInvalidRollupPhaseForAddWatchFile() {
  return {
    code: Errors.INVALID_ROLLUP_PHASE,
    message: `Cannot call addWatchFile after the build has finished.`
  };
}
function errInvalidRollupPhaseForChunkEmission() {
  return {
    code: Errors.INVALID_ROLLUP_PHASE,
    message: `Cannot emit chunks after module loading has finished.`
  };
}
function errMissingExport(exportName, importingModule, importedModule) {
  return {
    code: Errors.MISSING_EXPORT,
    message: `'${exportName}' is not exported by ${relativeId(importedModule)}, imported by ${relativeId(importingModule)}`,
    url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
  };
}
function errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: Errors.MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" cannot be external.`
  };
}
function errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore) {
  return {
    code: Errors.MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(unresolvedId)}" that should be implicitly loaded before "${relativeId(implicitlyLoadedBefore)}" could not be resolved.`
  };
}
function errImplicitDependantIsNotIncluded(module2) {
  const implicitDependencies = Array.from(module2.implicitlyLoadedBefore, (dependency) => relativeId(dependency.id)).sort();
  return {
    code: Errors.MISSING_IMPLICIT_DEPENDANT,
    message: `Module "${relativeId(module2.id)}" that should be implicitly loaded before ${printQuotedStringList(implicitDependencies)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
  };
}
function errMixedExport(facadeModuleId, name) {
  return {
    code: Errors.MIXED_EXPORTS,
    id: facadeModuleId,
    message: `Entry module "${relativeId(facadeModuleId)}" is using named and default exports together. Consumers of your bundle will have to use \`${name || "chunk"}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`,
    url: `https://rollupjs.org/guide/en/#outputexports`
  };
}
function errNamespaceConflict(name, reexportingModuleId, sources) {
  return {
    code: Errors.NAMESPACE_CONFLICT,
    message: `Conflicting namespaces: "${relativeId(reexportingModuleId)}" re-exports "${name}" from one of the modules ${printQuotedStringList(sources.map((moduleId) => relativeId(moduleId)))} (will be ignored)`,
    name,
    reexporter: reexportingModuleId,
    sources
  };
}
function errAmbiguousExternalNamespaces(name, reexportingModule, usedModule, sources) {
  return {
    code: Errors.AMBIGUOUS_EXTERNAL_NAMESPACES,
    message: `Ambiguous external namespace resolution: "${relativeId(reexportingModule)}" re-exports "${name}" from one of the external modules ${printQuotedStringList(sources.map((module2) => relativeId(module2)))}, guessing "${relativeId(usedModule)}".`,
    name,
    reexporter: reexportingModule,
    sources
  };
}
function errNoTransformMapOrAstWithoutCode(pluginName) {
  return {
    code: Errors.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE,
    message: `The plugin "${pluginName}" returned a "map" or "ast" without returning a "code". This will be ignored.`
  };
}
function errPreferNamedExports(facadeModuleId) {
  const file = relativeId(facadeModuleId);
  return {
    code: Errors.PREFER_NAMED_EXPORTS,
    id: facadeModuleId,
    message: `Entry module "${file}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${file}" to use named exports only.`,
    url: `https://rollupjs.org/guide/en/#outputexports`
  };
}
function errSyntheticNamedExportsNeedNamespaceExport(id, syntheticNamedExportsOption) {
  return {
    code: Errors.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT,
    id,
    message: `Module "${relativeId(id)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(syntheticNamedExportsOption)}' needs ${typeof syntheticNamedExportsOption === "string" && syntheticNamedExportsOption !== "default" ? `an explicit export named "${syntheticNamedExportsOption}"` : "a default export"} that does not reexport an unresolved named export of the same module.`
  };
}
function errUnexpectedNamedImport(id, imported, isReexport) {
  const importType = isReexport ? "reexport" : "import";
  return {
    code: Errors.UNEXPECTED_NAMED_IMPORT,
    id,
    message: `The named export "${imported}" was ${importType}ed from the external module ${relativeId(id)} even though its interop type is "defaultOnly". Either remove or change this ${importType} or change the value of the "output.interop" option.`,
    url: "https://rollupjs.org/guide/en/#outputinterop"
  };
}
function errUnexpectedNamespaceReexport(id) {
  return {
    code: Errors.UNEXPECTED_NAMED_IMPORT,
    id,
    message: `There was a namespace "*" reexport from the external module ${relativeId(id)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
    url: "https://rollupjs.org/guide/en/#outputinterop"
  };
}
function errEntryCannotBeExternal(unresolvedId) {
  return {
    code: Errors.UNRESOLVED_ENTRY,
    message: `Entry module cannot be external (${relativeId(unresolvedId)}).`
  };
}
function errUnresolvedEntry(unresolvedId) {
  return {
    code: Errors.UNRESOLVED_ENTRY,
    message: `Could not resolve entry module (${relativeId(unresolvedId)}).`
  };
}
function errUnresolvedImport(source, importer) {
  return {
    code: Errors.UNRESOLVED_IMPORT,
    message: `Could not resolve '${source}' from ${relativeId(importer)}`
  };
}
function errUnresolvedImportTreatedAsExternal(source, importer) {
  return {
    code: Errors.UNRESOLVED_IMPORT,
    importer: relativeId(importer),
    message: `'${source}' is imported by ${relativeId(importer)}, but could not be resolved \u2013 treating it as an external dependency`,
    source,
    url: "https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency"
  };
}
function errExternalSyntheticExports(source, importer) {
  return {
    code: Errors.EXTERNAL_SYNTHETIC_EXPORTS,
    importer: relativeId(importer),
    message: `External '${source}' can not have 'syntheticNamedExports' enabled.`,
    source
  };
}
function errFailedValidation(message) {
  return {
    code: Errors.VALIDATION_ERROR,
    message
  };
}
function errAlreadyClosed() {
  return {
    code: Errors.ALREADY_CLOSED,
    message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.'
  };
}
function warnDeprecation(deprecation, activeDeprecation, options) {
  warnDeprecationWithOptions(deprecation, activeDeprecation, options.onwarn, options.strictDeprecations);
}
function warnDeprecationWithOptions(deprecation, activeDeprecation, warn, strictDeprecations) {
  if (activeDeprecation || strictDeprecations) {
    const warning = errDeprecation(deprecation);
    if (strictDeprecations) {
      return error(warning);
    }
    warn(warning);
  }
}
function isLegal(str) {
  if (startsWithDigit(str) || RESERVED_NAMES$1.has(str)) {
    return false;
  }
  return !illegalCharacters.test(str);
}
function makeLegal(str) {
  str = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(illegalCharacters, "_");
  if (startsWithDigit(str) || RESERVED_NAMES$1.has(str))
    str = `_${str}`;
  return str || "_";
}
function createInclusionContext() {
  return {
    brokenFlow: BROKEN_FLOW_NONE,
    includedCallArguments: /* @__PURE__ */ new Set(),
    includedLabels: /* @__PURE__ */ new Set()
  };
}
function createHasEffectsContext() {
  return {
    accessed: new PathTracker(),
    assigned: new PathTracker(),
    brokenFlow: BROKEN_FLOW_NONE,
    called: new DiscriminatedPathTracker(),
    ignore: {
      breaks: false,
      continues: false,
      labels: /* @__PURE__ */ new Set(),
      returnYield: false
    },
    includedLabels: /* @__PURE__ */ new Set(),
    instantiated: new DiscriminatedPathTracker(),
    replacedVariableInits: /* @__PURE__ */ new Map()
  };
}
function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
  return Object.create(inheritedDescriptions, memberDescriptions);
}
function getLiteralMembersForValue(value) {
  switch (typeof value) {
    case "boolean":
      return literalBooleanMembers;
    case "number":
      return literalNumberMembers;
    case "string":
      return literalStringMembers;
  }
  return /* @__PURE__ */ Object.create(null);
}
function hasMemberEffectWhenCalled(members, memberName, callOptions, context) {
  if (typeof memberName !== "string" || !members[memberName]) {
    return true;
  }
  if (!members[memberName].callsArgs)
    return false;
  for (const argIndex of members[memberName].callsArgs) {
    if (callOptions.args[argIndex] && callOptions.args[argIndex].hasEffectsWhenCalledAtPath(EMPTY_PATH, {
      args: NO_ARGS,
      thisParam: null,
      withNew: false
    }, context))
      return true;
  }
  return false;
}
function getMemberReturnExpressionWhenCalled(members, memberName) {
  if (typeof memberName !== "string" || !members[memberName])
    return UNKNOWN_EXPRESSION;
  return members[memberName].returns;
}
function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {
}
function handlePureAnnotationsOfNode(node, state, type = node.type) {
  const { annotations } = state;
  let comment = annotations[state.annotationIndex];
  while (comment && node.start >= comment.end) {
    markPureNode(node, comment, state.code);
    comment = annotations[++state.annotationIndex];
  }
  if (comment && comment.end <= node.end) {
    base$1[type](node, state, handlePureAnnotationsOfNode);
    while ((comment = annotations[state.annotationIndex]) && comment.end <= node.end) {
      ++state.annotationIndex;
      annotateNode(node, comment, false);
    }
  }
}
function markPureNode(node, comment, code) {
  const annotatedNodes = [];
  let invalidAnnotation;
  const codeInBetween = code.slice(comment.end, node.start);
  if (doesNotMatchOutsideComment(codeInBetween, neitherWithespaceNorBrackets)) {
    const parentStart = node.start;
    while (true) {
      annotatedNodes.push(node);
      switch (node.type) {
        case ExpressionStatement$1:
        case ChainExpression$1:
          node = node.expression;
          continue;
        case SequenceExpression$1:
          if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
            node = node.expressions[0];
            continue;
          }
          invalidAnnotation = true;
          break;
        case ConditionalExpression$1:
          if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
            node = node.test;
            continue;
          }
          invalidAnnotation = true;
          break;
        case LogicalExpression$1:
        case BinaryExpression$1:
          if (doesNotMatchOutsideComment(code.slice(parentStart, node.start), noWhitespace)) {
            node = node.left;
            continue;
          }
          invalidAnnotation = true;
          break;
        case CallExpression$1:
        case NewExpression$1:
          break;
        default:
          invalidAnnotation = true;
      }
      break;
    }
  } else {
    invalidAnnotation = true;
  }
  if (invalidAnnotation) {
    annotateNode(node, comment, false);
  } else {
    for (const node2 of annotatedNodes) {
      annotateNode(node2, comment, true);
    }
  }
}
function doesNotMatchOutsideComment(code, forbiddenChars) {
  let nextMatch;
  while ((nextMatch = forbiddenChars.exec(code)) !== null) {
    if (nextMatch[0] === "/") {
      const charCodeAfterSlash = code.charCodeAt(forbiddenChars.lastIndex);
      if (charCodeAfterSlash === 42) {
        forbiddenChars.lastIndex = code.indexOf("*/", forbiddenChars.lastIndex + 1) + 2;
        continue;
      } else if (charCodeAfterSlash === 47) {
        forbiddenChars.lastIndex = code.indexOf("\n", forbiddenChars.lastIndex + 1) + 1;
        continue;
      }
    }
    forbiddenChars.lastIndex = 0;
    return false;
  }
  return true;
}
function addAnnotations(comments, esTreeAst, code) {
  const annotations = [];
  const sourceMappingComments = [];
  for (const comment of comments) {
    if (pureCommentRegex.test(comment.value)) {
      annotations.push(comment);
    } else if (SOURCEMAPPING_URL_RE.test(comment.value)) {
      sourceMappingComments.push(comment);
    }
  }
  for (const comment of sourceMappingComments) {
    annotateNode(esTreeAst, comment, false);
  }
  handlePureAnnotationsOfNode(esTreeAst, {
    annotationIndex: 0,
    annotations,
    code
  });
}
function annotateNode(node, comment, valid) {
  const key = valid ? ANNOTATION_KEY : INVALID_COMMENT_KEY;
  const property = node[key];
  if (property) {
    property.push(comment);
  } else {
    node[key] = [comment];
  }
}
function getAndCreateKeys(esTreeNode) {
  keys[esTreeNode.type] = Object.keys(esTreeNode).filter((key) => typeof esTreeNode[key] === "object" && key.charCodeAt(0) !== 95);
  return keys[esTreeNode.type];
}
function toBase64(num) {
  let outStr = "";
  do {
    const curDigit = num % base;
    num = Math.floor(num / base);
    outStr = chars[curDigit] + outStr;
  } while (num !== 0);
  return outStr;
}
function getSafeName(baseName, usedNames) {
  let safeName = baseName;
  let count = 1;
  while (usedNames.has(safeName) || RESERVED_NAMES$1.has(safeName)) {
    safeName = `${baseName}$${toBase64(count++)}`;
  }
  usedNames.add(safeName);
  return safeName;
}
function treeshakeNode(node, code, start, end) {
  code.remove(start, end);
  if (node.annotations) {
    for (const annotation of node.annotations) {
      if (annotation.start < start) {
        code.remove(annotation.start, annotation.end);
      } else {
        return;
      }
    }
  }
}
function removeAnnotations(node, code) {
  if (!node.annotations && node.parent.type === ExpressionStatement$1) {
    node = node.parent;
  }
  if (node.annotations) {
    for (const annotation of node.annotations) {
      code.remove(annotation.start, annotation.end);
    }
  }
}
function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
  let searchPos, charCodeAfterSlash;
  searchPos = code.indexOf(searchString, start);
  while (true) {
    start = code.indexOf("/", start);
    if (start === -1 || start >= searchPos)
      return searchPos;
    charCodeAfterSlash = code.charCodeAt(++start);
    ++start;
    start = charCodeAfterSlash === 47 ? code.indexOf("\n", start) + 1 : code.indexOf("*/", start) + 2;
    if (start > searchPos) {
      searchPos = code.indexOf(searchString, start);
    }
  }
}
function findNonWhiteSpace(code, index) {
  NON_WHITESPACE.lastIndex = index;
  const result = NON_WHITESPACE.exec(code);
  return result.index;
}
function findFirstLineBreakOutsideComment(code) {
  let lineBreakPos, charCodeAfterSlash, start = 0;
  lineBreakPos = code.indexOf("\n", start);
  while (true) {
    start = code.indexOf("/", start);
    if (start === -1 || start > lineBreakPos)
      return [lineBreakPos, lineBreakPos + 1];
    charCodeAfterSlash = code.charCodeAt(start + 1);
    if (charCodeAfterSlash === 47)
      return [start, lineBreakPos + 1];
    start = code.indexOf("*/", start + 3) + 2;
    if (start > lineBreakPos) {
      lineBreakPos = code.indexOf("\n", start);
    }
  }
}
function renderStatementList(statements, code, start, end, options) {
  let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
  let nextNode = statements[0];
  let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
  if (nextNodeNeedsBoundaries) {
    nextNodeStart = start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
  }
  for (let nextIndex2 = 1; nextIndex2 <= statements.length; nextIndex2++) {
    currentNode = nextNode;
    currentNodeStart = nextNodeStart;
    currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
    nextNode = statements[nextIndex2];
    nextNodeNeedsBoundaries = nextNode === void 0 ? false : !nextNode.included || nextNode.needsBoundaries;
    if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
      nextNodeStart = currentNode.end + findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === void 0 ? end : nextNode.start))[1];
      if (currentNode.included) {
        currentNodeNeedsBoundaries ? currentNode.render(code, options, {
          end: nextNodeStart,
          start: currentNodeStart
        }) : currentNode.render(code, options);
      } else {
        treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
      }
    } else {
      currentNode.render(code, options);
    }
  }
}
function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
  const splitUpNodes = [];
  let node, nextNode, nextNodeStart, contentEnd, char;
  let separator = start - 1;
  for (let nextIndex2 = 0; nextIndex2 < nodes.length; nextIndex2++) {
    nextNode = nodes[nextIndex2];
    if (node !== void 0) {
      separator = node.end + findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ",");
    }
    nextNodeStart = contentEnd = separator + 1 + findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
    while (char = code.original.charCodeAt(nextNodeStart), char === 32 || char === 9 || char === 10 || char === 13)
      nextNodeStart++;
    if (node !== void 0) {
      splitUpNodes.push({
        contentEnd,
        end: nextNodeStart,
        node,
        separator,
        start
      });
    }
    node = nextNode;
    start = nextNodeStart;
  }
  splitUpNodes.push({
    contentEnd: end,
    end,
    node,
    separator: null,
    start
  });
  return splitUpNodes;
}
function removeLineBreaks(code, start, end) {
  while (true) {
    const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
    if (removeStart === -1) {
      break;
    }
    code.remove(start + removeStart, start += removeEnd);
  }
}
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "PropertyDefinition":
        return parent.computed || node === parent.value;
      case "Property":
        return parent.computed || node === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
function getGlobalAtPath(path4) {
  let currentGlobal = knownGlobals;
  for (const pathSegment of path4) {
    if (typeof pathSegment !== "string") {
      return null;
    }
    currentGlobal = currentGlobal[pathSegment];
    if (!currentGlobal) {
      return null;
    }
  }
  return currentGlobal[ValueProperties];
}
function isPureGlobal(path4) {
  const globalAtPath = getGlobalAtPath(path4);
  return globalAtPath !== null && globalAtPath.pure;
}
function isGlobalMember(path4) {
  if (path4.length === 1) {
    return path4[0] === "undefined" || getGlobalAtPath(path4) !== null;
  }
  return getGlobalAtPath(path4.slice(0, -1)) !== null;
}
function closestParentFunctionOrProgram(node) {
  while (node && !/^Program|Function/.test(node.type)) {
    node = node.parent;
  }
  return node;
}
function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = "") {
  if (exportedVariables.length === 1 && exportNamesByVariable.get(exportedVariables[0]).length === 1) {
    const variable = exportedVariables[0];
    return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
  } else {
    const fields = [];
    for (const variable of exportedVariables) {
      for (const exportName of exportNamesByVariable.get(variable)) {
        fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
      }
    }
    return `exports(${getObject(fields, { lineBreakIndent: null })})`;
  }
}
function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
  code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
  code.appendLeft(expressionEnd, ")");
}
function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
  const { _, getDirectReturnIifeLeft } = options.snippets;
  code.prependRight(expressionStart, getDirectReturnIifeLeft(["v"], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
  code.appendLeft(expressionEnd, ")");
}
function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
  const { _, getPropertyAccess } = options.snippets;
  code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
  if (needsParens) {
    code.prependRight(expressionStart, "(");
    code.appendLeft(expressionEnd, ")");
  }
}
function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
  const { _ } = options.snippets;
  code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
  if (needsParens) {
    code.prependRight(expressionStart, "(");
    code.appendLeft(expressionEnd, ")");
  }
}
function getResolvablePropertyKey(memberExpression) {
  return memberExpression.computed ? getResolvableComputedPropertyKey(memberExpression.property) : memberExpression.property.name;
}
function getResolvableComputedPropertyKey(propertyKey) {
  if (propertyKey instanceof Literal) {
    return String(propertyKey.value);
  }
  return null;
}
function getPathIfNotComputed(memberExpression) {
  const nextPathKey = memberExpression.propertyKey;
  const object = memberExpression.object;
  if (typeof nextPathKey === "string") {
    if (object instanceof Identifier) {
      return [
        { key: object.name, pos: object.start },
        { key: nextPathKey, pos: memberExpression.property.start }
      ];
    }
    if (object instanceof MemberExpression) {
      const parentPath = getPathIfNotComputed(object);
      return parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }];
    }
  }
  return null;
}
function getStringFromPath(path4) {
  let pathString = path4[0].key;
  for (let index = 1; index < path4.length; index++) {
    pathString += "." + path4[index].key;
  }
  return pathString;
}
function getDeclarationStart(code, start) {
  return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, "default", start) + 7);
}
function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
  const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
  code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
  const generatorStarPos = findFirstOccurrenceOutsideComment(code, "*");
  if (generatorStarPos === -1) {
    return declarationEnd;
  }
  return declarationEnd + generatorStarPos + 1;
}
function getToStringTagValue(getObject) {
  return getObject([["value", "'Module'"]], {
    lineBreakIndent: null
  });
}
function getInteropHelper(resolution, exportMode, interop) {
  return exportMode === "external" ? namespaceInteropHelpersByInteropType[String(interop(resolution instanceof ExternalModule ? resolution.id : null))] : exportMode === "default" ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE : null;
}
function isReassignedExportsMember(variable, exportNamesByVariable) {
  return variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned;
}
function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
  for (const declarator of declarations) {
    if (!declarator.id.included)
      return false;
    if (declarator.id.type === Identifier$1) {
      if (exportNamesByVariable.has(declarator.id.variable))
        return false;
    } else {
      const exportedVariables = [];
      declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
      if (exportedVariables.length > 0)
        return false;
    }
  }
  return true;
}
function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
  var _a;
  let singleSystemExport = null;
  if (options.format === "system") {
    for (const { node } of separatedNodes) {
      if (node.id instanceof Identifier && node.init && aggregatedSystemExports.length === 0 && ((_a = options.exportNamesByVariable.get(node.id.variable)) === null || _a === void 0 ? void 0 : _a.length) === 1) {
        singleSystemExport = node.id.variable;
        aggregatedSystemExports.push(singleSystemExport);
      } else {
        node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
      }
    }
    if (aggregatedSystemExports.length > 1) {
      singleSystemExport = null;
    } else if (singleSystemExport) {
      aggregatedSystemExports.length = 0;
    }
  }
  return singleSystemExport;
}
function getId(m) {
  return m.id;
}
function getOriginalLocation(sourcemapChain, location) {
  const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !!sourcemap.mappings);
  traceSourcemap:
    while (filteredSourcemapChain.length > 0) {
      const sourcemap = filteredSourcemapChain.pop();
      const line = sourcemap.mappings[location.line - 1];
      if (line) {
        const filteredLine = line.filter((segment) => segment.length > 1);
        const lastSegment = filteredLine[filteredLine.length - 1];
        for (const segment of filteredLine) {
          if (segment[0] >= location.column || segment === lastSegment) {
            location = {
              column: segment[3],
              line: segment[2] + 1
            };
            continue traceSourcemap;
          }
        }
      }
      throw new Error("Can't resolve original location of error.");
    }
  return location;
}
function getPersistedLabel(label, level) {
  switch (level) {
    case 1:
      return `# ${label}`;
    case 2:
      return `## ${label}`;
    case 3:
      return label;
    default:
      return `${"  ".repeat(level - 4)}- ${label}`;
  }
}
function timeStartImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  const startMemory = import_process.default.memoryUsage().heapUsed;
  const startTime = import_perf_hooks.performance.now();
  const timer = timers.get(label);
  if (timer === void 0) {
    timers.set(label, {
      memory: 0,
      startMemory,
      startTime,
      time: 0,
      totalMemory: 0
    });
  } else {
    timer.startMemory = startMemory;
    timer.startTime = startTime;
  }
}
function timeEndImpl(label, level = 3) {
  label = getPersistedLabel(label, level);
  const timer = timers.get(label);
  if (timer !== void 0) {
    const currentMemory = import_process.default.memoryUsage().heapUsed;
    timer.memory += currentMemory - timer.startMemory;
    timer.time += import_perf_hooks.performance.now() - timer.startTime;
    timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
  }
}
function getTimings() {
  const newTimings = {};
  for (const [label, { memory, time, totalMemory }] of timers) {
    newTimings[label] = [time, memory, totalMemory];
  }
  return newTimings;
}
function getPluginWithTimers(plugin, index) {
  for (const hook of TIMED_PLUGIN_HOOKS) {
    if (hook in plugin) {
      let timerLabel = `plugin ${index}`;
      if (plugin.name) {
        timerLabel += ` (${plugin.name})`;
      }
      timerLabel += ` - ${hook}`;
      const func = plugin[hook];
      plugin[hook] = function(...args) {
        timeStart(timerLabel, 4);
        const result = func.apply(this, args);
        timeEnd(timerLabel, 4);
        if (result && typeof result.then === "function") {
          timeStart(`${timerLabel} (async)`, 4);
          return result.then((hookResult) => {
            timeEnd(`${timerLabel} (async)`, 4);
            return hookResult;
          });
        }
        return result;
      };
    }
  }
  return plugin;
}
function initialiseTimers(inputOptions) {
  if (inputOptions.perf) {
    timers = /* @__PURE__ */ new Map();
    timeStart = timeStartImpl;
    timeEnd = timeEndImpl;
    inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
  } else {
    timeStart = NOOP;
    timeEnd = NOOP;
  }
}
function markModuleAndImpureDependenciesAsExecuted(baseModule) {
  baseModule.isExecuted = true;
  const modules = [baseModule];
  const visitedModules = /* @__PURE__ */ new Set();
  for (const module2 of modules) {
    for (const dependency of [...module2.dependencies, ...module2.implicitlyLoadedBefore]) {
      if (!(dependency instanceof ExternalModule) && !dependency.isExecuted && (dependency.info.moduleSideEffects || module2.implicitlyLoadedBefore.has(dependency)) && !visitedModules.has(dependency.id)) {
        dependency.isExecuted = true;
        visitedModules.add(dependency.id);
        modules.push(dependency);
      }
    }
  }
}
function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = /* @__PURE__ */ new Map()) {
  const searchedModules = searchedNamesAndModules.get(name);
  if (searchedModules) {
    if (searchedModules.has(target)) {
      return isExportAllSearch ? [null] : error(errCircularReexport(name, target.id));
    }
    searchedModules.add(target);
  } else {
    searchedNamesAndModules.set(name, /* @__PURE__ */ new Set([target]));
  }
  return target.getVariableForExportName(name, {
    importerForSideEffects,
    isExportAllSearch,
    searchedNamesAndModules
  });
}
function getAndExtendSideEffectModules(variable, module2) {
  const sideEffectModules = getOrCreate(module2.sideEffectDependenciesByVariable, variable, () => /* @__PURE__ */ new Set());
  let currentVariable = variable;
  const referencedVariables = /* @__PURE__ */ new Set([currentVariable]);
  while (true) {
    const importingModule = currentVariable.module;
    currentVariable = currentVariable instanceof ExportDefaultVariable ? currentVariable.getDirectOriginalVariable() : currentVariable instanceof SyntheticNamedExportVariable ? currentVariable.syntheticNamespace : null;
    if (!currentVariable || referencedVariables.has(currentVariable)) {
      break;
    }
    referencedVariables.add(currentVariable);
    sideEffectModules.add(importingModule);
    const originalSideEffects = importingModule.sideEffectDependenciesByVariable.get(currentVariable);
    if (originalSideEffects) {
      for (const module3 of originalSideEffects) {
        sideEffectModules.add(module3);
      }
    }
  }
  return sideEffectModules;
}
function setAlternativeExporterIfCyclic(variable, importer, reexporter) {
  if (variable.module instanceof Module && variable.module !== reexporter) {
    const exporterCycles = variable.module.cycles;
    if (exporterCycles.size > 0) {
      const importerCycles = reexporter.cycles;
      for (const cycleSymbol of importerCycles) {
        if (exporterCycles.has(cycleSymbol)) {
          importer.alternativeReexportModules.set(variable, reexporter);
          break;
        }
      }
    }
  }
}
function removeJsExtension(name) {
  return name.endsWith(".js") ? name.slice(0, -3) : name;
}
function getCompleteAmdId(options, chunkId) {
  if (options.autoId) {
    return `${options.basePath ? options.basePath + "/" : ""}${removeJsExtension(chunkId)}`;
  }
  return options.id || "";
}
function getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, mechanism = "return ") {
  const { _, cnst, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n: n2, s } = snippets;
  if (!namedExportsMode) {
    return `${n2}${n2}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;
  }
  let exportBlock = "";
  for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
    if (reexports && namedExportsMode) {
      for (const specifier of reexports) {
        if (specifier.reexported !== "*") {
          const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
          if (exportBlock)
            exportBlock += n2;
          if (specifier.imported !== "*" && specifier.needsLiveBinding) {
            const [left, right] = getDirectReturnFunction([], {
              functionReturn: true,
              lineBreakIndent: null,
              name: null
            });
            exportBlock += `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n2}${t}enumerable:${_}true,${n2}${t}get:${_}${left}${importName}${right}${n2}});`;
          } else {
            exportBlock += `exports${getPropertyAccess(specifier.reexported)}${_}=${_}${importName};`;
          }
        }
      }
    }
  }
  for (const { exported, local } of exports) {
    const lhs = `exports${getPropertyAccess(exported)}`;
    const rhs = local;
    if (lhs !== rhs) {
      if (exportBlock)
        exportBlock += n2;
      exportBlock += `${lhs}${_}=${_}${rhs};`;
    }
  }
  for (const { name, reexports } of dependencies) {
    if (reexports && namedExportsMode) {
      for (const specifier of reexports) {
        if (specifier.reexported === "*") {
          if (exportBlock)
            exportBlock += n2;
          const copyPropertyIfNecessary = `{${n2}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!exports.hasOwnProperty(k))${_}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s}${n2}}`;
          exportBlock += cnst === "var" && specifier.needsLiveBinding ? `Object.keys(${name}).forEach(${getFunctionIntro(["k"], {
            isAsync: false,
            name: null
          })}${copyPropertyIfNecessary});` : `for${_}(${cnst} k in ${name})${_}${copyPropertyIfNecessary}`;
        }
      }
    }
  }
  if (exportBlock) {
    return `${n2}${n2}${exportBlock}`;
  }
  return "";
}
function getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess) {
  if (exports.length > 0) {
    return exports[0].local;
  } else {
    for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
      if (reexports) {
        return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
      }
    }
  }
}
function getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {
  if (imported === "default") {
    if (!isChunk) {
      const moduleInterop = String(interop(moduleId));
      const variableName = defaultInteropHelpersByInteropType[moduleInterop] ? defaultVariableName : moduleVariableName;
      return isDefaultAProperty(moduleInterop, externalLiveBindings) ? `${variableName}${getPropertyAccess("default")}` : variableName;
    }
    return depNamedExportsMode ? `${moduleVariableName}${getPropertyAccess("default")}` : moduleVariableName;
  }
  if (imported === "*") {
    return (isChunk ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[String(interop(moduleId))]) ? namespaceVariableName : moduleVariableName;
  }
  return `${moduleVariableName}${getPropertyAccess(imported)}`;
}
function getEsModuleValue(getObject) {
  return getObject([["value", "true"]], {
    lineBreakIndent: null
  });
}
function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _, getObject }) {
  if (hasNamedExports) {
    if (addEsModule) {
      if (addNamespaceToStringTag) {
        return `Object.defineProperties(exports,${_}${getObject([
          ["__esModule", getEsModuleValue(getObject)],
          [null, `[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}`]
        ], {
          lineBreakIndent: null
        })});`;
      }
      return `Object.defineProperty(exports,${_}'__esModule',${_}${getEsModuleValue(getObject)});`;
    }
    if (addNamespaceToStringTag) {
      return `Object.defineProperty(exports,${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)});`;
    }
  }
  return "";
}
function getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, indent3, snippets) {
  const { _, cnst, n: n2 } = snippets;
  const neededInteropHelpers = /* @__PURE__ */ new Set();
  const interopStatements = [];
  const addInteropStatement = (helperVariableName, helper, dependencyVariableName) => {
    neededInteropHelpers.add(helper);
    interopStatements.push(`${cnst} ${helperVariableName}${_}=${_}/*#__PURE__*/${helper}(${dependencyVariableName});`);
  };
  for (const { defaultVariableName, imports, id, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
    if (isChunk) {
      for (const { imported, reexported } of [
        ...imports || [],
        ...reexports || []
      ]) {
        if (imported === "*" && reexported !== "*") {
          if (!namedExportsMode) {
            addInteropStatement(namespaceVariableName, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, name);
          }
          break;
        }
      }
    } else {
      const moduleInterop = String(interop(id));
      let hasDefault = false;
      let hasNamespace = false;
      for (const { imported, reexported } of [
        ...imports || [],
        ...reexports || []
      ]) {
        let helper;
        let variableName;
        if (imported === "default") {
          if (!hasDefault) {
            hasDefault = true;
            if (defaultVariableName !== namespaceVariableName) {
              variableName = defaultVariableName;
              helper = defaultInteropHelpersByInteropType[moduleInterop];
            }
          }
        } else if (imported === "*" && reexported !== "*") {
          if (!hasNamespace) {
            hasNamespace = true;
            helper = namespaceInteropHelpersByInteropType[moduleInterop];
            variableName = namespaceVariableName;
          }
        }
        if (helper) {
          addInteropStatement(variableName, helper, name);
        }
      }
    }
  }
  return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent3, snippets, externalLiveBindings, freeze, namespaceToStringTag)}${interopStatements.length > 0 ? `${interopStatements.join(n2)}${n2}${n2}` : ""}`;
}
function removeExtensionFromRelativeAmdId(id) {
  return id[0] === "." ? removeJsExtension(id) : id;
}
function warnOnBuiltins(warn, dependencies) {
  const externalBuiltins = dependencies.map(({ id }) => id).filter((id) => id in builtins);
  if (!externalBuiltins.length)
    return;
  warn({
    code: "MISSING_NODE_BUILTINS",
    message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`,
    modules: externalBuiltins
  });
}
function amd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, warn }, { amd: amd2, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
  warnOnBuiltins(warn, dependencies);
  const deps = dependencies.map((m) => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
  const args = dependencies.map((m) => m.name);
  const { n: n2, getNonArrowFunctionIntro, _ } = snippets;
  if (namedExportsMode && hasExports) {
    args.unshift(`exports`);
    deps.unshift(`'exports'`);
  }
  if (accessedGlobals.has("require")) {
    args.unshift("require");
    deps.unshift(`'require'`);
  }
  if (accessedGlobals.has("module")) {
    args.unshift("module");
    deps.unshift(`'module'`);
  }
  const completeAmdId = getCompleteAmdId(amd2, id);
  const params = (completeAmdId ? `'${completeAmdId}',${_}` : ``) + (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
  const useStrict = strict ? `${_}'use strict';` : "";
  magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
  return magicString.indent(t).prepend(`${amd2.define}(${params}(${getNonArrowFunctionIntro(args, {
    isAsync: false,
    name: null
  })}{${useStrict}${n2}${n2}`).append(`${n2}${n2}}));`);
}
function cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
  const { _, n: n2 } = snippets;
  const useStrict = strict ? `'use strict';${n2}${n2}` : "";
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, snippets);
  if (namespaceMarkers) {
    namespaceMarkers += n2 + n2;
  }
  const importBlock = getImportBlock$1(dependencies, snippets, compact);
  const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
  magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, `module.exports${_}=${_}`);
  return magicString.append(`${exportBlock}${outro}`);
}
function getImportBlock$1(dependencies, { _, cnst, n: n2 }, compact) {
  let importBlock = "";
  let definingVariable = false;
  for (const { id, name, reexports, imports } of dependencies) {
    if (!reexports && !imports) {
      if (importBlock) {
        importBlock += compact && !definingVariable ? "," : `;${n2}`;
      }
      definingVariable = false;
      importBlock += `require('${id}')`;
    } else {
      importBlock += compact && definingVariable ? "," : `${importBlock ? `;${n2}` : ""}${cnst} `;
      definingVariable = true;
      importBlock += `${name}${_}=${_}require('${id}')`;
    }
  }
  if (importBlock) {
    return `${importBlock};${n2}${n2}`;
  }
  return "";
}
function es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, namespaceToStringTag }) {
  const { _, n: n2 } = snippets;
  const importBlock = getImportBlock(dependencies, _);
  if (importBlock.length > 0)
    intro += importBlock.join(n2) + n2 + n2;
  intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag);
  if (intro)
    magicString.prepend(intro);
  const exportBlock = getExportBlock(exports, snippets);
  if (exportBlock.length)
    magicString.append(n2 + n2 + exportBlock.join(n2).trim());
  if (outro)
    magicString.append(outro);
  return magicString.trim();
}
function getImportBlock(dependencies, _) {
  const importBlock = [];
  for (const { id, reexports, imports, name } of dependencies) {
    if (!reexports && !imports) {
      importBlock.push(`import${_}'${id}';`);
      continue;
    }
    if (imports) {
      let defaultImport = null;
      let starImport = null;
      const importedNames = [];
      for (const specifier of imports) {
        if (specifier.imported === "default") {
          defaultImport = specifier;
        } else if (specifier.imported === "*") {
          starImport = specifier;
        } else {
          importedNames.push(specifier);
        }
      }
      if (starImport) {
        importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);
      }
      if (defaultImport && importedNames.length === 0) {
        importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);
      } else if (importedNames.length > 0) {
        importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ""}{${_}${importedNames.map((specifier) => {
          if (specifier.imported === specifier.local) {
            return specifier.imported;
          } else {
            return `${specifier.imported} as ${specifier.local}`;
          }
        }).join(`,${_}`)}${_}}${_}from${_}'${id}';`);
      }
    }
    if (reexports) {
      let starExport = null;
      const namespaceReexports = [];
      const namedReexports = [];
      for (const specifier of reexports) {
        if (specifier.reexported === "*") {
          starExport = specifier;
        } else if (specifier.imported === "*") {
          namespaceReexports.push(specifier);
        } else {
          namedReexports.push(specifier);
        }
      }
      if (starExport) {
        importBlock.push(`export${_}*${_}from${_}'${id}';`);
      }
      if (namespaceReexports.length > 0) {
        if (!imports || !imports.some((specifier) => specifier.imported === "*" && specifier.local === name)) {
          importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);
        }
        for (const specifier of namespaceReexports) {
          importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);
        }
      }
      if (namedReexports.length > 0) {
        importBlock.push(`export${_}{${_}${namedReexports.map((specifier) => {
          if (specifier.imported === specifier.reexported) {
            return specifier.imported;
          } else {
            return `${specifier.imported} as ${specifier.reexported}`;
          }
        }).join(`,${_}`)}${_}}${_}from${_}'${id}';`);
      }
    }
  }
  return importBlock;
}
function getExportBlock(exports, { _, cnst }) {
  const exportBlock = [];
  const exportDeclaration = [];
  for (const specifier of exports) {
    if (specifier.expression) {
      exportBlock.push(`${cnst} ${specifier.local}${_}=${_}${specifier.expression};`);
    }
    exportDeclaration.push(specifier.exported === specifier.local ? specifier.local : `${specifier.local} as ${specifier.exported}`);
  }
  if (exportDeclaration.length) {
    exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
  }
  return exportBlock;
}
function setupNamespace(name, root, globals, { _, getPropertyAccess, s }, compact) {
  const parts = name.split(".");
  parts[0] = (typeof globals === "function" ? globals(parts[0]) : globals[parts[0]]) || parts[0];
  parts.pop();
  let propertyPath = root;
  return parts.map((part) => {
    propertyPath += getPropertyAccess(part);
    return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}${s}`;
  }).join(compact ? "," : "\n") + (compact && parts.length ? ";" : "\n");
}
function assignToDeepVariable(deepName, root, globals, assignment, { _, getPropertyAccess }) {
  const parts = deepName.split(".");
  parts[0] = (typeof globals === "function" ? globals(parts[0]) : globals[parts[0]]) || parts[0];
  const last = parts.pop();
  let propertyPath = root;
  let deepAssignment = parts.map((part) => {
    propertyPath += getPropertyAccess(part);
    return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
  }).concat(`${propertyPath}${getPropertyAccess(last)}`).join(`,${_}`) + `${_}=${_}${assignment}`;
  if (parts.length > 0) {
    deepAssignment = `(${deepAssignment})`;
  }
  return deepAssignment;
}
function trimEmptyImports(dependencies) {
  let i = dependencies.length;
  while (i--) {
    const { imports, reexports } = dependencies[i];
    if (imports || reexports) {
      return dependencies.slice(0, i + 1);
    }
  }
  return [];
}
function iife(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, namedExportsMode, outro, snippets, warn }, { compact, esModule, extend: extend2, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
  const { _, cnst, getNonArrowFunctionIntro, getPropertyAccess, n: n2 } = snippets;
  const isNamespaced = name && name.includes(".");
  const useVariableAssignment = !extend2 && !isNamespaced;
  if (name && useVariableAssignment && !isLegal(name)) {
    return error({
      code: "ILLEGAL_IDENTIFIER_AS_NAME",
      message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`
    });
  }
  warnOnBuiltins(warn, dependencies);
  const external = trimEmptyImports(dependencies);
  const deps = external.map((dep) => dep.globalName || "null");
  const args = external.map((m) => m.name);
  if (hasExports && !name) {
    warn({
      code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT",
      message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`
    });
  }
  if (namedExportsMode && hasExports) {
    if (extend2) {
      deps.unshift(`this${keypath(name, getPropertyAccess)}${_}=${_}this${keypath(name, getPropertyAccess)}${_}||${_}{}`);
      args.unshift("exports");
    } else {
      deps.unshift("{}");
      args.unshift("exports");
    }
  }
  const useStrict = strict ? `${t}'use strict';${n2}` : "";
  const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
  magicString.prepend(`${intro}${interopBlock}`);
  let wrapperIntro = `(${getNonArrowFunctionIntro(args, {
    isAsync: false,
    name: null
  })}{${n2}${useStrict}${n2}`;
  if (hasExports) {
    if (name && !(extend2 && namedExportsMode)) {
      wrapperIntro = (useVariableAssignment ? `${cnst} ${name}` : `this${keypath(name, getPropertyAccess)}`) + `${_}=${_}${wrapperIntro}`;
    }
    if (isNamespaced) {
      wrapperIntro = setupNamespace(name, "this", globals, snippets, compact) + wrapperIntro;
    }
  }
  let wrapperOutro = `${n2}${n2}})(${deps.join(`,${_}`)});`;
  if (hasExports && !extend2 && namedExportsMode) {
    wrapperOutro = `${n2}${n2}${t}return exports;${wrapperOutro}`;
  }
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
  return magicString.indent(t).prepend(wrapperIntro).append(wrapperOutro);
}
function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, namespaceToStringTag, strict, systemNullSetters }) {
  const { _, getFunctionIntro, getNonArrowFunctionIntro, n: n2, s } = snippets;
  const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);
  const registeredName = name ? `'${name}',${_}` : "";
  const wrapperParams = accessedGlobals.has("module") ? ["exports", "module"] : hasExports ? ["exports"] : [];
  let wrapperStart = `System.register(${registeredName}[` + dependencies.map(({ id }) => `'${id}'`).join(`,${_}`) + `],${_}(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n2}${t}${strict ? "'use strict';" : ""}` + getStarExcludesBlock(starExcludes, t, snippets) + getImportBindingsBlock(importBindings, t, snippets) + `${n2}${t}return${_}{${setters.length ? `${n2}${t}${t}setters:${_}[${setters.map((setter) => setter ? `${getFunctionIntro(["module"], {
    isAsync: false,
    name: null
  })}{${n2}${t}${t}${t}${setter}${n2}${t}${t}}` : systemNullSetters ? `null` : `${getFunctionIntro([], { isAsync: false, name: null })}{}`).join(`,${_}`)}],` : ""}${n2}`;
  wrapperStart += `${t}${t}execute:${_}(${getNonArrowFunctionIntro([], {
    isAsync: usesTopLevelAwait,
    name: null
  })}{${n2}${n2}`;
  const wrapperEnd = `${t}${t}})${n2}${t}}${s}${n2}}));`;
  magicString.prepend(intro + getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag) + getHoistedExportsBlock(exports, t, snippets));
  magicString.append(`${outro}${n2}${n2}` + getSyntheticExportsBlock(exports, t, snippets) + getMissingExportsBlock(exports, t, snippets));
  return magicString.indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);
}
function analyzeDependencies(dependencies, exports, t, { _, cnst, getObject, getPropertyAccess, n: n2 }) {
  const importBindings = [];
  const setters = [];
  let starExcludes = null;
  for (const { imports, reexports } of dependencies) {
    const setter = [];
    if (imports) {
      for (const specifier of imports) {
        importBindings.push(specifier.local);
        if (specifier.imported === "*") {
          setter.push(`${specifier.local}${_}=${_}module;`);
        } else {
          setter.push(`${specifier.local}${_}=${_}module${getPropertyAccess(specifier.imported)};`);
        }
      }
    }
    if (reexports) {
      const reexportedNames = [];
      let hasStarReexport = false;
      for (const { imported, reexported } of reexports) {
        if (reexported === "*") {
          hasStarReexport = true;
        } else {
          reexportedNames.push([
            reexported,
            imported === "*" ? "module" : `module${getPropertyAccess(imported)}`
          ]);
        }
      }
      if (reexportedNames.length > 1 || hasStarReexport) {
        const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });
        if (hasStarReexport) {
          if (!starExcludes) {
            starExcludes = getStarExcludes({ dependencies, exports });
          }
          setter.push(`${cnst} setter${_}=${_}${exportMapping};`, `for${_}(${cnst} name in module)${_}{`, `${t}if${_}(!_starExcludes[name])${_}setter[name]${_}=${_}module[name];`, "}", "exports(setter);");
        } else {
          setter.push(`exports(${exportMapping});`);
        }
      } else {
        const [key, value] = reexportedNames[0];
        setter.push(`exports('${key}',${_}${value});`);
      }
    }
    setters.push(setter.join(`${n2}${t}${t}${t}`));
  }
  return { importBindings, setters, starExcludes };
}
function getExportsBlock(exports, t, { _, n: n2 }) {
  if (exports.length === 0) {
    return "";
  }
  if (exports.length === 1) {
    return `exports('${exports[0].name}',${_}${exports[0].value});${n2}${n2}`;
  }
  return `exports({${n2}` + exports.map(({ name, value }) => `${t}${name}:${_}${value}`).join(`,${n2}`) + `${n2}});${n2}${n2}`;
}
function globalProp(name, globalVar, getPropertyAccess) {
  if (!name)
    return "null";
  return `${globalVar}${keypath(name, getPropertyAccess)}`;
}
function safeAccess(name, globalVar, { _, getPropertyAccess }) {
  let propertyPath = globalVar;
  return name.split(".").map((part) => propertyPath += getPropertyAccess(part)).join(`${_}&&${_}`);
}
function umd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, warn }, { amd: amd2, compact, esModule, extend: extend2, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
  const { _, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n: n2, s } = snippets;
  const factoryVar = compact ? "f" : "factory";
  const globalVar = compact ? "g" : "global";
  if (hasExports && !name) {
    return error({
      code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT",
      message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'
    });
  }
  warnOnBuiltins(warn, dependencies);
  const amdDeps = dependencies.map((m) => `'${removeExtensionFromRelativeAmdId(m.id)}'`);
  const cjsDeps = dependencies.map((m) => `require('${m.id}')`);
  const trimmedImports = trimEmptyImports(dependencies);
  const globalDeps = trimmedImports.map((module2) => globalProp(module2.globalName, globalVar, getPropertyAccess));
  const factoryParams = trimmedImports.map((m) => m.name);
  if (namedExportsMode && (hasExports || noConflict)) {
    amdDeps.unshift(`'exports'`);
    cjsDeps.unshift(`exports`);
    globalDeps.unshift(assignToDeepVariable(name, globalVar, globals, `${extend2 ? `${globalProp(name, globalVar, getPropertyAccess)}${_}||${_}` : ""}{}`, snippets));
    factoryParams.unshift("exports");
  }
  const completeAmdId = getCompleteAmdId(amd2, id);
  const amdParams = (completeAmdId ? `'${completeAmdId}',${_}` : ``) + (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
  const define2 = amd2.define;
  const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
  const useStrict = strict ? `${_}'use strict';${n2}` : ``;
  let iifeExport;
  if (noConflict) {
    const noConflictExportsVar = compact ? "e" : "exports";
    let factory;
    if (!namedExportsMode && hasExports) {
      factory = `${cnst} ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(name, globalVar, globals, `${factoryVar}(${globalDeps.join(`,${_}`)})`, snippets)};`;
    } else {
      const module2 = globalDeps.shift();
      factory = `${cnst} ${noConflictExportsVar}${_}=${_}${module2};${n2}${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
    }
    iifeExport = `(${getFunctionIntro([], { isAsync: false, name: null })}{${n2}${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVar, snippets)};${n2}${t}${t}${factory}${n2}${t}${t}${noConflictExportsVar}.noConflict${_}=${_}${getFunctionIntro([], {
      isAsync: false,
      name: null
    })}{${_}${globalProp(name, globalVar, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVar}${s}${_}};${n2}${t}})()`;
  } else {
    iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
    if (!namedExportsMode && hasExports) {
      iifeExport = assignToDeepVariable(name, globalVar, globals, iifeExport, snippets);
    }
  }
  const iifeNeedsGlobal = hasExports || noConflict && namedExportsMode || globalDeps.length > 0;
  const wrapperParams = [factoryVar];
  if (iifeNeedsGlobal) {
    wrapperParams.unshift(globalVar);
  }
  const globalArg = iifeNeedsGlobal ? `this,${_}` : "";
  const iifeStart = iifeNeedsGlobal ? `(${globalVar}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVar}${_}||${_}self,${_}` : "";
  const iifeEnd = iifeNeedsGlobal ? ")" : "";
  const cjsIntro = iifeNeedsGlobal ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n2}` : "";
  const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n2}` + cjsIntro + `${t}typeof ${define2}${_}===${_}'function'${_}&&${_}${define2}.amd${_}?${_}${define2}(${amdParams}${factoryVar})${_}:${n2}${t}${iifeStart}${iifeExport}${iifeEnd};${n2}})(${globalArg}(${getNonArrowFunctionIntro(factoryParams, {
    isAsync: false,
    name: null
  })}{${useStrict}${n2}`;
  const wrapperOutro = n2 + n2 + "}));";
  magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
  const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
  let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, snippets);
  if (namespaceMarkers) {
    namespaceMarkers = n2 + n2 + namespaceMarkers;
  }
  magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
  return magicString.trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);
}
function getLinkMap(warn) {
  return function linkMap(source, map) {
    if (map.mappings) {
      return new Link(map, [source]);
    }
    warn({
      code: "SOURCEMAP_BROKEN",
      message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
      plugin: map.plugin,
      url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`
    });
    return new Link({
      mappings: [],
      names: []
    }, [source]);
  };
}
function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
  let source;
  if (!originalSourcemap) {
    source = new Source(id, originalCode);
  } else {
    const sources = originalSourcemap.sources;
    const sourcesContent = originalSourcemap.sourcesContent || [];
    const directory = (0, import_path.dirname)(id) || ".";
    const sourceRoot = originalSourcemap.sourceRoot || ".";
    const baseSources = sources.map((source2, i) => new Source((0, import_path.resolve)(directory, sourceRoot, source2), sourcesContent[i]));
    source = new Link(originalSourcemap, baseSources);
  }
  return sourcemapChain.reduce(linkMap, source);
}
function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
  const linkMap = getLinkMap(warn);
  const moduleSources = modules.filter((module2) => !module2.excludeFromSourcemap).map((module2) => getCollapsedSourcemap(module2.id, module2.originalCode, module2.originalSourcemap, module2.sourcemapChain, linkMap));
  const link = new Link(map, moduleSources);
  const source = bundleSourcemapChain.reduce(linkMap, link);
  let { sources, sourcesContent, names, mappings } = source.traceMappings();
  if (file) {
    const directory = (0, import_path.dirname)(file);
    sources = sources.map((source2) => (0, import_path.relative)(directory, source2));
    file = (0, import_path.basename)(file);
  }
  sourcesContent = excludeContent ? null : sourcesContent;
  return new SourceMap({ file, mappings, names, sources, sourcesContent });
}
function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
  if (!sourcemapChain.length) {
    return originalSourcemap;
  }
  const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
  const map = source.traceMappings();
  return { version: 3, ...map };
}
function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
  const reversedModules = modules.slice().reverse();
  for (const module2 of reversedModules) {
    module2.scope.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);
  }
  deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);
  DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports);
  for (const module2 of reversedModules) {
    module2.scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
  }
}
function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, syntheticExports) {
  for (const dependency of dependenciesToBeDeconflicted.dependencies) {
    if (preserveModules || dependency instanceof ExternalModule) {
      dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames);
    }
  }
  for (const variable of imports) {
    const module2 = variable.module;
    const name = variable.name;
    if (variable.isNamespace && (preserveModules || module2 instanceof ExternalModule)) {
      variable.setRenderNames(null, (module2 instanceof ExternalModule ? module2 : chunkByModule.get(module2)).variableName);
    } else if (module2 instanceof ExternalModule && name === "default") {
      variable.setRenderNames(null, getSafeName([...module2.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === "*" && exportedVariable.included) ? module2.suggestedVariableName + "__default" : module2.suggestedVariableName, usedNames));
    } else {
      variable.setRenderNames(null, getSafeName(name, usedNames));
    }
  }
  for (const variable of syntheticExports) {
    variable.setRenderNames(null, getSafeName(variable.name, usedNames));
  }
}
function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule) {
  for (const chunkOrExternalModule of dependencies) {
    chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.suggestedVariableName, usedNames);
  }
  for (const externalModuleOrChunk of deconflictedNamespace) {
    externalModuleOrChunk.namespaceVariableName = getSafeName(`${externalModuleOrChunk.suggestedVariableName}__namespace`, usedNames);
  }
  for (const externalModule of deconflictedDefault) {
    if (deconflictedNamespace.has(externalModule) && canDefaultBeTakenFromNamespace(String(interop(externalModule.id)), externalLiveBindings)) {
      externalModule.defaultVariableName = externalModule.namespaceVariableName;
    } else {
      externalModule.defaultVariableName = getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames);
    }
  }
  for (const variable of imports) {
    const module2 = variable.module;
    if (module2 instanceof ExternalModule) {
      const name = variable.name;
      if (name === "default") {
        const moduleInterop = String(interop(module2.id));
        const variableName = defaultInteropHelpersByInteropType[moduleInterop] ? module2.defaultVariableName : module2.variableName;
        if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {
          variable.setRenderNames(variableName, "default");
        } else {
          variable.setRenderNames(null, variableName);
        }
      } else if (name === "*") {
        variable.setRenderNames(null, namespaceInteropHelpersByInteropType[String(interop(module2.id))] ? module2.namespaceVariableName : module2.variableName);
      } else {
        variable.setRenderNames(module2.variableName, null);
      }
    } else {
      const chunk = chunkByModule.get(module2);
      if (preserveModules && variable.isNamespace) {
        variable.setRenderNames(null, chunk.exportMode === "default" ? chunk.namespaceVariableName : chunk.variableName);
      } else if (chunk.exportMode === "default") {
        variable.setRenderNames(null, chunk.variableName);
      } else {
        variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));
      }
    }
  }
}
function deconflictTopLevelVariables(usedNames, modules, includedNamespaces) {
  for (const module2 of modules) {
    for (const variable of module2.scope.variables.values()) {
      if (variable.included && !(variable.renderBaseName || variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable)) {
        variable.setRenderNames(null, getSafeName(variable.name, usedNames));
      }
    }
    if (includedNamespaces.has(module2)) {
      const namespace = module2.namespace;
      namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
    }
  }
}
function escapeId(id) {
  if (!id.match(needsEscapeRegEx))
    return id;
  return id.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
function assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {
  let nameIndex = 0;
  for (const variable of exports) {
    let [exportName] = variable.name;
    if (exportsByName.has(exportName)) {
      do {
        exportName = toBase64(++nameIndex);
        if (exportName.charCodeAt(0) === 49) {
          nameIndex += 9 * 64 ** (exportName.length - 1);
          exportName = toBase64(nameIndex);
        }
      } while (RESERVED_NAMES$1.has(exportName) || exportsByName.has(exportName));
    }
    exportsByName.set(exportName, variable);
    exportNamesByVariable.set(variable, [exportName]);
  }
}
function assignExportsToNames(exports, exportsByName, exportNamesByVariable) {
  for (const variable of exports) {
    let nameIndex = 0;
    let exportName = variable.name;
    while (exportsByName.has(exportName)) {
      exportName = variable.name + "$" + ++nameIndex;
    }
    exportsByName.set(exportName, variable);
    exportNamesByVariable.set(variable, [exportName]);
  }
}
function getExportMode(chunk, { exports: exportMode, name, format }, unsetOptions, facadeModuleId, warn) {
  const exportKeys = chunk.getExportNames();
  if (exportMode === "default") {
    if (exportKeys.length !== 1 || exportKeys[0] !== "default") {
      return error(errIncompatibleExportOptionValue("default", exportKeys, facadeModuleId));
    }
  } else if (exportMode === "none" && exportKeys.length) {
    return error(errIncompatibleExportOptionValue("none", exportKeys, facadeModuleId));
  }
  if (exportMode === "auto") {
    if (exportKeys.length === 0) {
      exportMode = "none";
    } else if (exportKeys.length === 1 && exportKeys[0] === "default") {
      if (format === "cjs" && unsetOptions.has("exports")) {
        warn(errPreferNamedExports(facadeModuleId));
      }
      exportMode = "default";
    } else {
      if (format !== "es" && format !== "system" && exportKeys.includes("default")) {
        warn(errMixedExport(facadeModuleId, name));
      }
      exportMode = "named";
    }
  }
  return exportMode;
}
function guessIndentString(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getIndentString3(modules, options) {
  if (options.indent !== true)
    return options.indent;
  for (const module2 of modules) {
    const indent3 = guessIndentString(module2.originalCode);
    if (indent3 !== null)
      return indent3;
  }
  return "	";
}
function getStaticDependencies(chunk, orderedModules, chunkByModule) {
  const staticDependencyBlocks = [];
  const handledDependencies = /* @__PURE__ */ new Set();
  for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {
    const module2 = orderedModules[modulePos];
    if (!handledDependencies.has(module2)) {
      const staticDependencies = [];
      addStaticDependencies(module2, staticDependencies, handledDependencies, chunk, chunkByModule);
      staticDependencyBlocks.unshift(staticDependencies);
    }
  }
  const dependencies = /* @__PURE__ */ new Set();
  for (const block of staticDependencyBlocks) {
    for (const dependency of block) {
      dependencies.add(dependency);
    }
  }
  return dependencies;
}
function addStaticDependencies(module2, staticDependencies, handledModules, chunk, chunkByModule) {
  const dependencies = module2.getDependenciesToBeIncluded();
  for (const dependency of dependencies) {
    if (dependency instanceof ExternalModule) {
      staticDependencies.push(dependency);
      continue;
    }
    const dependencyChunk = chunkByModule.get(dependency);
    if (dependencyChunk !== chunk) {
      staticDependencies.push(dependencyChunk);
      continue;
    }
    if (!handledModules.has(dependency)) {
      handledModules.add(dependency);
      addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule);
    }
  }
}
function decodedSourcemap(map) {
  if (!map)
    return null;
  if (typeof map === "string") {
    map = JSON.parse(map);
  }
  if (map.mappings === "") {
    return {
      mappings: [],
      names: [],
      sources: [],
      version: 3
    };
  }
  const mappings = typeof map.mappings === "string" ? decode(map.mappings) : map.mappings;
  return { ...map, mappings };
}
function renderChunk({ code, options, outputPluginDriver, renderChunk: renderChunk2, sourcemapChain }) {
  const renderChunkReducer = (code2, result, plugin) => {
    if (result == null)
      return code2;
    if (typeof result === "string")
      result = {
        code: result,
        map: void 0
      };
    if (result.map !== null) {
      const map = decodedSourcemap(result.map);
      sourcemapChain.push(map || { missing: true, plugin: plugin.name });
    }
    return result.code;
  };
  return outputPluginDriver.hookReduceArg0("renderChunk", [code, renderChunk2, options], renderChunkReducer);
}
function renderNamePattern(pattern, patternName, replacements) {
  if (isPathFragment(pattern))
    return error(errFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths.`));
  return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
    if (!replacements.hasOwnProperty(type)) {
      return error(errFailedValidation(`"[${type}]" is not a valid placeholder in "${patternName}" pattern.`));
    }
    const replacement = replacements[type]();
    if (isPathFragment(replacement))
      return error(errFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
    return replacement;
  });
}
function makeUnique(name, existingNames) {
  const existingNamesLowercase = new Set(Object.keys(existingNames).map((key) => key.toLowerCase()));
  if (!existingNamesLowercase.has(name.toLocaleLowerCase()))
    return name;
  const ext = (0, import_path.extname)(name);
  name = name.substring(0, name.length - ext.length);
  let uniqueName, uniqueIndex = 1;
  while (existingNamesLowercase.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))
    ;
  return uniqueName;
}
function getGlobalName(module2, globals, hasExports, warn) {
  const globalName = typeof globals === "function" ? globals(module2.id) : globals[module2.id];
  if (globalName) {
    return globalName;
  }
  if (hasExports) {
    warn({
      code: "MISSING_GLOBAL_NAME",
      guess: module2.variableName,
      message: `No name was provided for external module '${module2.id}' in output.globals \u2013 guessing '${module2.variableName}'`,
      source: module2.id
    });
    return module2.variableName;
  }
}
function getChunkNameFromModule(module2) {
  var _a, _b, _c, _d;
  return (_d = (_b = (_a = module2.chunkNames.find(({ isUserDefined }) => isUserDefined)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : (_c = module2.chunkNames[0]) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : getAliasName(module2.id);
}
function generateAssetFileName(name, source, outputOptions, bundle) {
  const emittedName = outputOptions.sanitizeFileName(name || "asset");
  return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === "function" ? outputOptions.assetFileNames({ name, source, type: "asset" }) : outputOptions.assetFileNames, "output.assetFileNames", {
    ext: () => (0, import_path.extname)(emittedName).substring(1),
    extname: () => (0, import_path.extname)(emittedName),
    hash() {
      return createHash().update(emittedName).update(":").update(source).digest("hex").substring(0, 8);
    },
    name: () => emittedName.substring(0, emittedName.length - (0, import_path.extname)(emittedName).length)
  }), bundle);
}
function reserveFileNameInBundle(fileName, bundle, warn) {
  if (fileName in bundle) {
    warn(errFileNameConflict(fileName));
  }
  bundle[fileName] = FILE_PLACEHOLDER;
}
function hasValidType(emittedFile) {
  return Boolean(emittedFile && (emittedFile.type === "asset" || emittedFile.type === "chunk"));
}
function hasValidName(emittedFile) {
  const validatedName = emittedFile.fileName || emittedFile.name;
  return !validatedName || typeof validatedName === "string" && !isPathFragment(validatedName);
}
function getValidSource(source, emittedFile, fileReferenceId) {
  if (!(typeof source === "string" || source instanceof Uint8Array)) {
    const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;
    return error(errFailedValidation(`Could not set source for ${typeof assetName === "string" ? `asset "${assetName}"` : "unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`));
  }
  return source;
}
function getAssetFileName(file, referenceId) {
  if (typeof file.fileName !== "string") {
    return error(errAssetNotFinalisedForFileName(file.name || referenceId));
  }
  return file.fileName;
}
function getChunkFileName(file, facadeChunkByModule) {
  var _a;
  const fileName = file.fileName || file.module && ((_a = facadeChunkByModule === null || facadeChunkByModule === void 0 ? void 0 : facadeChunkByModule.get(file.module)) === null || _a === void 0 ? void 0 : _a.id);
  if (!fileName)
    return error(errChunkNotGeneratedForFileName(file.fileName || file.name));
  return fileName;
}
function findExistingAssetFileNameWithSource(bundle, source) {
  for (const [fileName, outputFile] of Object.entries(bundle)) {
    if (outputFile.type === "asset" && areSourcesEqual(source, outputFile.source))
      return fileName;
  }
  return null;
}
function areSourcesEqual(sourceA, sourceB) {
  if (typeof sourceA === "string") {
    return sourceA === sourceB;
  }
  if (typeof sourceB === "string") {
    return false;
  }
  if ("equals" in sourceA) {
    return sourceA.equals(sourceB);
  }
  if (sourceA.length !== sourceB.length) {
    return false;
  }
  for (let index = 0; index < sourceA.length; index++) {
    if (sourceA[index] !== sourceB[index]) {
      return false;
    }
  }
  return true;
}
async function createAddons(options, outputPluginDriver) {
  try {
    let [banner, footer, intro, outro] = await Promise.all([
      outputPluginDriver.hookReduceValue("banner", options.banner(), [], concatSep),
      outputPluginDriver.hookReduceValue("footer", options.footer(), [], concatSep),
      outputPluginDriver.hookReduceValue("intro", options.intro(), [], concatDblSep),
      outputPluginDriver.hookReduceValue("outro", options.outro(), [], concatDblSep)
    ]);
    if (intro)
      intro += "\n\n";
    if (outro)
      outro = `

${outro}`;
    if (banner.length)
      banner += "\n";
    if (footer.length)
      footer = "\n" + footer;
    return { banner, footer, intro, outro };
  } catch (err) {
    return error({
      code: "ADDON_ERROR",
      message: `Could not retrieve ${err.hook}. Check configuration of plugin ${err.plugin}.
	Error Message: ${err.message}`
    });
  }
}
function getChunkAssignments(entryModules, manualChunkAliasByEntry) {
  const chunkDefinitions = [];
  const modulesInManualChunks = new Set(manualChunkAliasByEntry.keys());
  const manualChunkModulesByAlias = /* @__PURE__ */ Object.create(null);
  for (const [entry, alias] of manualChunkAliasByEntry) {
    const chunkModules = manualChunkModulesByAlias[alias] = manualChunkModulesByAlias[alias] || [];
    addStaticDependenciesToManualChunk(entry, chunkModules, modulesInManualChunks);
  }
  for (const [alias, modules] of Object.entries(manualChunkModulesByAlias)) {
    chunkDefinitions.push({ alias, modules });
  }
  const assignedEntryPointsByModule = /* @__PURE__ */ new Map();
  const { dependentEntryPointsByModule, dynamicEntryModules } = analyzeModuleGraph(entryModules);
  const dynamicallyDependentEntryPointsByDynamicEntry = getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules);
  const staticEntries = new Set(entryModules);
  function assignEntryToStaticDependencies(entry, dynamicDependentEntryPoints) {
    const modulesToHandle = /* @__PURE__ */ new Set([entry]);
    for (const module2 of modulesToHandle) {
      const assignedEntryPoints = getOrCreate(assignedEntryPointsByModule, module2, () => /* @__PURE__ */ new Set());
      if (dynamicDependentEntryPoints && areEntryPointsContainedOrDynamicallyDependent(dynamicDependentEntryPoints, dependentEntryPointsByModule.get(module2))) {
        continue;
      } else {
        assignedEntryPoints.add(entry);
      }
      for (const dependency of module2.getDependenciesToBeIncluded()) {
        if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
          modulesToHandle.add(dependency);
        }
      }
    }
  }
  function areEntryPointsContainedOrDynamicallyDependent(entryPoints, containedIn) {
    const entriesToCheck = new Set(entryPoints);
    for (const entry of entriesToCheck) {
      if (!containedIn.has(entry)) {
        if (staticEntries.has(entry))
          return false;
        const dynamicallyDependentEntryPoints = dynamicallyDependentEntryPointsByDynamicEntry.get(entry);
        for (const dependentEntry of dynamicallyDependentEntryPoints) {
          entriesToCheck.add(dependentEntry);
        }
      }
    }
    return true;
  }
  for (const entry of entryModules) {
    if (!modulesInManualChunks.has(entry)) {
      assignEntryToStaticDependencies(entry, null);
    }
  }
  for (const entry of dynamicEntryModules) {
    if (!modulesInManualChunks.has(entry)) {
      assignEntryToStaticDependencies(entry, dynamicallyDependentEntryPointsByDynamicEntry.get(entry));
    }
  }
  chunkDefinitions.push(...createChunks([...entryModules, ...dynamicEntryModules], assignedEntryPointsByModule));
  return chunkDefinitions;
}
function addStaticDependenciesToManualChunk(entry, manualChunkModules, modulesInManualChunks) {
  const modulesToHandle = /* @__PURE__ */ new Set([entry]);
  for (const module2 of modulesToHandle) {
    modulesInManualChunks.add(module2);
    manualChunkModules.push(module2);
    for (const dependency of module2.dependencies) {
      if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {
        modulesToHandle.add(dependency);
      }
    }
  }
}
function analyzeModuleGraph(entryModules) {
  const dynamicEntryModules = /* @__PURE__ */ new Set();
  const dependentEntryPointsByModule = /* @__PURE__ */ new Map();
  const entriesToHandle = new Set(entryModules);
  for (const currentEntry of entriesToHandle) {
    const modulesToHandle = /* @__PURE__ */ new Set([currentEntry]);
    for (const module2 of modulesToHandle) {
      getOrCreate(dependentEntryPointsByModule, module2, () => /* @__PURE__ */ new Set()).add(currentEntry);
      for (const dependency of module2.getDependenciesToBeIncluded()) {
        if (!(dependency instanceof ExternalModule)) {
          modulesToHandle.add(dependency);
        }
      }
      for (const { resolution } of module2.dynamicImports) {
        if (resolution instanceof Module && resolution.includedDynamicImporters.length > 0) {
          dynamicEntryModules.add(resolution);
          entriesToHandle.add(resolution);
        }
      }
      for (const dependency of module2.implicitlyLoadedBefore) {
        dynamicEntryModules.add(dependency);
        entriesToHandle.add(dependency);
      }
    }
  }
  return { dependentEntryPointsByModule, dynamicEntryModules };
}
function getDynamicDependentEntryPoints(dependentEntryPointsByModule, dynamicEntryModules) {
  const dynamicallyDependentEntryPointsByDynamicEntry = /* @__PURE__ */ new Map();
  for (const dynamicEntry of dynamicEntryModules) {
    const dynamicDependentEntryPoints = getOrCreate(dynamicallyDependentEntryPointsByDynamicEntry, dynamicEntry, () => /* @__PURE__ */ new Set());
    for (const importer of [
      ...dynamicEntry.includedDynamicImporters,
      ...dynamicEntry.implicitlyLoadedAfter
    ]) {
      for (const entryPoint of dependentEntryPointsByModule.get(importer)) {
        dynamicDependentEntryPoints.add(entryPoint);
      }
    }
  }
  return dynamicallyDependentEntryPointsByDynamicEntry;
}
function createChunks(allEntryPoints, assignedEntryPointsByModule) {
  const chunkModules = /* @__PURE__ */ Object.create(null);
  for (const [module2, assignedEntryPoints] of assignedEntryPointsByModule) {
    let chunkSignature = "";
    for (const entry of allEntryPoints) {
      chunkSignature += assignedEntryPoints.has(entry) ? "X" : "_";
    }
    const chunk = chunkModules[chunkSignature];
    if (chunk) {
      chunk.push(module2);
    } else {
      chunkModules[chunkSignature] = [module2];
    }
  }
  return Object.values(chunkModules).map((modules) => ({
    alias: null,
    modules
  }));
}
function commondir(files) {
  if (files.length === 0)
    return "/";
  if (files.length === 1)
    return (0, import_path.dirname)(files[0]);
  const commonSegments = files.slice(1).reduce((commonSegments2, file) => {
    const pathSegements = file.split(/\/+|\\+/);
    let i;
    for (i = 0; commonSegments2[i] === pathSegements[i] && i < Math.min(commonSegments2.length, pathSegements.length); i++)
      ;
    return commonSegments2.slice(0, i);
  }, files[0].split(/\/+|\\+/));
  return commonSegments.length > 1 ? commonSegments.join("/") : "/";
}
function sortByExecutionOrder(units) {
  units.sort(compareExecIndex);
}
function analyseModuleExecution(entryModules) {
  let nextExecIndex = 0;
  const cyclePaths = [];
  const analysedModules = /* @__PURE__ */ new Set();
  const dynamicImports = /* @__PURE__ */ new Set();
  const parents = /* @__PURE__ */ new Map();
  const orderedModules = [];
  const analyseModule = (module2) => {
    if (module2 instanceof Module) {
      for (const dependency of module2.dependencies) {
        if (parents.has(dependency)) {
          if (!analysedModules.has(dependency)) {
            cyclePaths.push(getCyclePath(dependency, module2, parents));
          }
          continue;
        }
        parents.set(dependency, module2);
        analyseModule(dependency);
      }
      for (const dependency of module2.implicitlyLoadedBefore) {
        dynamicImports.add(dependency);
      }
      for (const { resolution } of module2.dynamicImports) {
        if (resolution instanceof Module) {
          dynamicImports.add(resolution);
        }
      }
      orderedModules.push(module2);
    }
    module2.execIndex = nextExecIndex++;
    analysedModules.add(module2);
  };
  for (const curEntry of entryModules) {
    if (!parents.has(curEntry)) {
      parents.set(curEntry, null);
      analyseModule(curEntry);
    }
  }
  for (const curEntry of dynamicImports) {
    if (!parents.has(curEntry)) {
      parents.set(curEntry, null);
      analyseModule(curEntry);
    }
  }
  return { cyclePaths, orderedModules };
}
function getCyclePath(module2, parent, parents) {
  const cycleSymbol = Symbol(module2.id);
  const path4 = [relativeId(module2.id)];
  let nextModule = parent;
  module2.cycles.add(cycleSymbol);
  while (nextModule !== module2) {
    nextModule.cycles.add(cycleSymbol);
    path4.push(relativeId(nextModule.id));
    nextModule = parents.get(nextModule);
  }
  path4.push(path4[0]);
  path4.reverse();
  return path4;
}
function getGenerateCodeSnippets({ compact, generatedCode: { arrowFunctions, constBindings, objectShorthand, reservedNamesAsProps } }) {
  const { _, n: n2, s } = compact ? { _: "", n: "", s: "" } : { _: " ", n: "\n", s: ";" };
  const cnst = constBindings ? "const" : "var";
  const getNonArrowFunctionIntro = (params, { isAsync, name }) => `${isAsync ? `async ` : ""}function${name ? ` ${name}` : ""}${_}(${params.join(`,${_}`)})${_}`;
  const getFunctionIntro = arrowFunctions ? (params, { isAsync, name }) => {
    const singleParam = params.length === 1;
    const asyncString = isAsync ? `async${singleParam ? " " : _}` : "";
    return `${name ? `${cnst} ${name}${_}=${_}` : ""}${asyncString}${singleParam ? params[0] : `(${params.join(`,${_}`)})`}${_}=>${_}`;
  } : getNonArrowFunctionIntro;
  const getDirectReturnFunction = (params, { functionReturn, lineBreakIndent, name }) => [
    `${getFunctionIntro(params, {
      isAsync: false,
      name
    })}${arrowFunctions ? lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : "" : `{${lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : _}${functionReturn ? "return " : ""}`}`,
    arrowFunctions ? `${name ? ";" : ""}${lineBreakIndent ? `${n2}${lineBreakIndent.base}` : ""}` : `${s}${lineBreakIndent ? `${n2}${lineBreakIndent.base}` : _}}`
  ];
  const isValidPropName = reservedNamesAsProps ? (name) => validPropName.test(name) : (name) => !RESERVED_NAMES$1.has(name) && validPropName.test(name);
  return {
    _,
    cnst,
    getDirectReturnFunction,
    getDirectReturnIifeLeft: (params, returned, { needsArrowReturnParens, needsWrappedFunction }) => {
      const [left, right] = getDirectReturnFunction(params, {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${wrapIfNeeded(`${left}${wrapIfNeeded(returned, arrowFunctions && needsArrowReturnParens)}${right}`, arrowFunctions || needsWrappedFunction)}(`;
    },
    getFunctionIntro,
    getNonArrowFunctionIntro,
    getObject(fields, { lineBreakIndent }) {
      const prefix = lineBreakIndent ? `${n2}${lineBreakIndent.base}${lineBreakIndent.t}` : _;
      return `{${fields.map(([key, value]) => {
        if (key === null)
          return `${prefix}${value}`;
        const needsQuotes = !isValidPropName(key);
        return key === value && objectShorthand && !needsQuotes ? prefix + key : `${prefix}${needsQuotes ? `'${key}'` : key}:${_}${value}`;
      }).join(`,`)}${fields.length === 0 ? "" : lineBreakIndent ? `${n2}${lineBreakIndent.base}` : _}}`;
    },
    getPropertyAccess: (name) => isValidPropName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,
    n: n2,
    s
  };
}
function getAbsoluteEntryModulePaths(chunks) {
  const absoluteEntryModulePaths = [];
  for (const chunk of chunks) {
    for (const entryModule of chunk.entryModules) {
      if (isAbsolute(entryModule.id)) {
        absoluteEntryModulePaths.push(entryModule.id);
      }
    }
  }
  return absoluteEntryModulePaths;
}
function validateOptionsForMultiChunkOutput(outputOptions, onWarn) {
  if (outputOptions.format === "umd" || outputOptions.format === "iife")
    return error(errInvalidOption("output.format", "outputformat", "UMD and IIFE output formats are not supported for code-splitting builds", outputOptions.format));
  if (typeof outputOptions.file === "string")
    return error(errInvalidOption("output.file", "outputdir", 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
  if (outputOptions.sourcemapFile)
    return error(errInvalidOption("output.sourcemapFile", "outputsourcemapfile", '"output.sourcemapFile" is only supported for single-file builds'));
  if (!outputOptions.amd.autoId && outputOptions.amd.id)
    onWarn(errInvalidOption("output.amd.id", "outputamd", 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
}
function getIncludedModules(modulesById) {
  return [...modulesById.values()].filter((module2) => module2 instanceof Module && (module2.isIncluded() || module2.info.isEntry || module2.includedDynamicImporters.length > 0));
}
function addModuleToManualChunk(alias, module2, manualChunkAliasByEntry) {
  const existingAlias = manualChunkAliasByEntry.get(module2);
  if (typeof existingAlias === "string" && existingAlias !== alias) {
    return error(errCannotAssignModuleToChunk(module2.id, alias, existingAlias));
  }
  manualChunkAliasByEntry.set(module2, alias);
}
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code) {
      return true;
    }
  }
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
function kw(name, options) {
  if (options === void 0)
    options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
function codePointToString$1(ch) {
  if (ch <= 65535) {
    return String.fromCharCode(ch);
  }
  ch -= 65536;
  return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
}
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
  let skipped = null;
  let replaceContext = null;
  if (skip) {
    skipped = /* @__PURE__ */ new Set();
    for (const skippedCall of skip) {
      if (source === skippedCall.source && importer === skippedCall.importer) {
        skipped.add(skippedCall.plugin);
      }
    }
    replaceContext = (pluginContext, plugin) => ({
      ...pluginContext,
      resolve: (source2, importer2, { custom, isEntry: isEntry2, skipSelf } = BLANK) => {
        return moduleLoaderResolveId(source2, importer2, custom, isEntry2, skipSelf ? [...skip, { importer: importer2, plugin, source: source2 }] : skip);
      }
    });
  }
  return pluginDriver.hookFirst("resolveId", [source, importer, { custom: customOptions, isEntry }], replaceContext, skipped);
}
async function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry) {
  const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry);
  if (pluginResult != null)
    return pluginResult;
  if (importer !== void 0 && !isAbsolute(source) && source[0] !== ".")
    return null;
  return addJsExtensionIfNecessary(importer ? (0, import_path.resolve)((0, import_path.dirname)(importer), source) : (0, import_path.resolve)(source), preserveSymlinks);
}
async function addJsExtensionIfNecessary(file, preserveSymlinks) {
  var _a, _b;
  return (_b = (_a = await findFile(file, preserveSymlinks)) !== null && _a !== void 0 ? _a : await findFile(file + ".mjs", preserveSymlinks)) !== null && _b !== void 0 ? _b : await findFile(file + ".js", preserveSymlinks);
}
async function findFile(file, preserveSymlinks) {
  try {
    const stats = await import_fs.promises.lstat(file);
    if (!preserveSymlinks && stats.isSymbolicLink())
      return await findFile(await import_fs.promises.realpath(file), preserveSymlinks);
    if (preserveSymlinks && stats.isSymbolicLink() || stats.isFile()) {
      const name = (0, import_path.basename)(file);
      const files = await import_fs.promises.readdir((0, import_path.dirname)(file));
      if (files.includes(name))
        return file;
    }
  } catch (_a) {
  }
}
function throwPluginError(err, plugin, { hook, id } = {}) {
  if (typeof err === "string")
    err = { message: err };
  if (err.code && err.code !== Errors.PLUGIN_ERROR) {
    err.pluginCode = err.code;
  }
  err.code = Errors.PLUGIN_ERROR;
  err.plugin = plugin;
  if (hook) {
    err.hook = hook;
  }
  if (id) {
    err.id = id;
  }
  return error(err);
}
function warnDeprecatedHooks(plugins, options) {
  for (const { active, deprecated, replacement } of deprecatedHooks) {
    for (const plugin of plugins) {
      if (deprecated in plugin) {
        warnDeprecation({
          message: `The "${deprecated}" hook used by plugin ${plugin.name} is deprecated. The "${replacement}" hook should be used instead.`,
          plugin: plugin.name
        }, active, options);
      }
    }
  }
}
function createPluginCache(cache) {
  return {
    delete(id) {
      return delete cache[id];
    },
    get(id) {
      const item = cache[id];
      if (!item)
        return void 0;
      item[0] = 0;
      return item[1];
    },
    has(id) {
      const item = cache[id];
      if (!item)
        return false;
      item[0] = 0;
      return true;
    },
    set(id, value) {
      cache[id] = [0, value];
    }
  };
}
function getTrackedPluginCache(pluginCache, onUse) {
  return {
    delete(id) {
      onUse();
      return pluginCache.delete(id);
    },
    get(id) {
      onUse();
      return pluginCache.get(id);
    },
    has(id) {
      onUse();
      return pluginCache.has(id);
    },
    set(id, value) {
      onUse();
      return pluginCache.set(id, value);
    }
  };
}
function uncacheablePluginError(pluginName) {
  if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) || pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {
    return error({
      code: "ANONYMOUS_PLUGIN_CACHE",
      message: "A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey."
    });
  }
  return error({
    code: "DUPLICATE_PLUGIN_NAME",
    message: `The plugin name ${pluginName} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
  });
}
function getCacheForUncacheablePlugin(pluginName) {
  return {
    delete() {
      return uncacheablePluginError(pluginName);
    },
    get() {
      return uncacheablePluginError(pluginName);
    },
    has() {
      return uncacheablePluginError(pluginName);
    },
    set() {
      return uncacheablePluginError(pluginName);
    }
  };
}
async function transform(source, module2, pluginDriver, warn) {
  const id = module2.id;
  const sourcemapChain = [];
  let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);
  const originalCode = source.code;
  let ast = source.ast;
  const transformDependencies = [];
  const emittedFiles = [];
  let customTransformCache = false;
  const useCustomTransformCache = () => customTransformCache = true;
  let pluginName = "";
  const curSource = source.code;
  function transformReducer(previousCode, result, plugin) {
    let code2;
    let map;
    if (typeof result === "string") {
      code2 = result;
    } else if (result && typeof result === "object") {
      module2.updateOptions(result);
      if (result.code == null) {
        if (result.map || result.ast) {
          warn(errNoTransformMapOrAstWithoutCode(plugin.name));
        }
        return previousCode;
      }
      ({ code: code2, map, ast } = result);
    } else {
      return previousCode;
    }
    if (map !== null) {
      sourcemapChain.push(decodedSourcemap(typeof map === "string" ? JSON.parse(map) : map) || {
        missing: true,
        plugin: plugin.name
      });
    }
    return code2;
  }
  let code;
  try {
    code = await pluginDriver.hookReduceArg0("transform", [curSource, id], transformReducer, (pluginContext, plugin) => {
      pluginName = plugin.name;
      return {
        ...pluginContext,
        addWatchFile(id2) {
          transformDependencies.push(id2);
          pluginContext.addWatchFile(id2);
        },
        cache: customTransformCache ? pluginContext.cache : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),
        emitAsset(name, source2) {
          emittedFiles.push({ name, source: source2, type: "asset" });
          return pluginContext.emitAsset(name, source2);
        },
        emitChunk(id2, options) {
          emittedFiles.push({ id: id2, name: options && options.name, type: "chunk" });
          return pluginContext.emitChunk(id2, options);
        },
        emitFile(emittedFile) {
          emittedFiles.push(emittedFile);
          return pluginDriver.emitFile(emittedFile);
        },
        error(err, pos) {
          if (typeof err === "string")
            err = { message: err };
          if (pos)
            augmentCodeLocation(err, pos, curSource, id);
          err.id = id;
          err.hook = "transform";
          return pluginContext.error(err);
        },
        getCombinedSourcemap() {
          const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn);
          if (!combinedMap) {
            const magicString = new MagicString$1(originalCode);
            return magicString.generateMap({ hires: true, includeContent: true, source: id });
          }
          if (originalSourcemap !== combinedMap) {
            originalSourcemap = combinedMap;
            sourcemapChain.length = 0;
          }
          return new SourceMap({
            ...combinedMap,
            file: null,
            sourcesContent: combinedMap.sourcesContent
          });
        },
        setAssetSource() {
          return this.error({
            code: "INVALID_SETASSETSOURCE",
            message: `setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`
          });
        },
        warn(warning, pos) {
          if (typeof warning === "string")
            warning = { message: warning };
          if (pos)
            augmentCodeLocation(warning, pos, curSource, id);
          warning.id = id;
          warning.hook = "transform";
          pluginContext.warn(warning);
        }
      };
    });
  } catch (err) {
    throwPluginError(err, pluginName, { hook: "transform", id });
  }
  if (!customTransformCache) {
    if (emittedFiles.length)
      module2.transformFiles = emittedFiles;
  }
  return {
    ast,
    code,
    customTransformCache,
    originalCode,
    originalSourcemap,
    sourcemapChain,
    transformDependencies
  };
}
function normalizeRelativeExternalId(source, importer) {
  return isRelative(source) ? importer ? (0, import_path.resolve)(importer, "..", source) : (0, import_path.resolve)(source) : source;
}
function addChunkNamesToModule(module2, { fileName, name }, isUserDefined, priority) {
  var _a;
  if (fileName !== null) {
    module2.chunkFileNames.add(fileName);
  } else if (name !== null) {
    let namePosition = 0;
    while (((_a = module2.chunkNames[namePosition]) === null || _a === void 0 ? void 0 : _a.priority) < priority)
      namePosition++;
    module2.chunkNames.splice(namePosition, 0, { isUserDefined, name, priority });
  }
}
function isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) {
  return makeAbsoluteExternalsRelative === true || makeAbsoluteExternalsRelative === "ifRelativeSource" && isRelative(source) || !isAbsolute(id);
}
async function waitForDependencyResolution(loadPromise) {
  const [resolveStaticDependencyPromises, resolveDynamicImportPromises] = await loadPromise;
  return Promise.all([...resolveStaticDependencyPromises, ...resolveDynamicImportPromises]);
}
function getDeprecatedContextHandler(handler, handlerName, newHandlerName, pluginName, activeDeprecation, options) {
  let deprecationWarningShown = false;
  return (...args) => {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      warnDeprecation({
        message: `The "this.${handlerName}" plugin context function used by plugin ${pluginName} is deprecated. The "this.${newHandlerName}" plugin context function should be used instead.`,
        plugin: pluginName
      }, activeDeprecation, options);
    }
    return handler(...args);
  };
}
function getPluginContext(plugin, pluginCache, graph, options, fileEmitter, existingPluginNames) {
  let cacheable = true;
  if (typeof plugin.cacheKey !== "string") {
    if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) || plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) || existingPluginNames.has(plugin.name)) {
      cacheable = false;
    } else {
      existingPluginNames.add(plugin.name);
    }
  }
  let cacheInstance;
  if (!pluginCache) {
    cacheInstance = NO_CACHE;
  } else if (cacheable) {
    const cacheKey = plugin.cacheKey || plugin.name;
    cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = /* @__PURE__ */ Object.create(null)));
  } else {
    cacheInstance = getCacheForUncacheablePlugin(plugin.name);
  }
  const context = {
    addWatchFile(id) {
      if (graph.phase >= BuildPhase.GENERATE) {
        return this.error(errInvalidRollupPhaseForAddWatchFile());
      }
      graph.watchFiles[id] = true;
    },
    cache: cacheInstance,
    emitAsset: getDeprecatedContextHandler((name, source) => fileEmitter.emitFile({ name, source, type: "asset" }), "emitAsset", "emitFile", plugin.name, true, options),
    emitChunk: getDeprecatedContextHandler((id, options2) => fileEmitter.emitFile({ id, name: options2 && options2.name, type: "chunk" }), "emitChunk", "emitFile", plugin.name, true, options),
    emitFile: fileEmitter.emitFile.bind(fileEmitter),
    error(err) {
      return throwPluginError(err, plugin.name);
    },
    getAssetFileName: getDeprecatedContextHandler(fileEmitter.getFileName, "getAssetFileName", "getFileName", plugin.name, true, options),
    getChunkFileName: getDeprecatedContextHandler(fileEmitter.getFileName, "getChunkFileName", "getFileName", plugin.name, true, options),
    getFileName: fileEmitter.getFileName,
    getModuleIds: () => graph.modulesById.keys(),
    getModuleInfo: graph.getModuleInfo,
    getWatchFiles: () => Object.keys(graph.watchFiles),
    isExternal: getDeprecatedContextHandler((id, parentId, isResolved = false) => options.external(id, parentId, isResolved), "isExternal", "resolve", plugin.name, true, options),
    load(resolvedId) {
      return graph.moduleLoader.preloadModule(resolvedId);
    },
    meta: {
      rollupVersion: version$1,
      watchMode: graph.watchMode
    },
    get moduleIds() {
      function* wrappedModuleIds() {
        warnDeprecation({
          message: `Accessing "this.moduleIds" on the plugin context by plugin ${plugin.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,
          plugin: plugin.name
        }, false, options);
        yield* moduleIds;
      }
      const moduleIds = graph.modulesById.keys();
      return wrappedModuleIds();
    },
    parse: graph.contextParse.bind(graph),
    resolve(source, importer, { custom, isEntry, skipSelf } = BLANK) {
      return graph.moduleLoader.resolveId(source, importer, custom, isEntry, skipSelf ? [{ importer, plugin, source }] : null);
    },
    resolveId: getDeprecatedContextHandler((source, importer) => graph.moduleLoader.resolveId(source, importer, BLANK, void 0).then((resolveId2) => resolveId2 && resolveId2.id), "resolveId", "resolve", plugin.name, true, options),
    setAssetSource: fileEmitter.setAssetSource,
    warn(warning) {
      if (typeof warning === "string")
        warning = { message: warning };
      if (warning.code)
        warning.pluginCode = warning.code;
      warning.code = "PLUGIN_WARNING";
      warning.plugin = plugin.name;
      options.onwarn(warning);
    }
  };
  return context;
}
function throwInvalidHookError(hookName, pluginName) {
  return error({
    code: "INVALID_PLUGIN_HOOK",
    message: `Error running plugin hook ${hookName} for ${pluginName}, expected a function hook.`
  });
}
function normalizeEntryModules(entryModules) {
  if (Array.isArray(entryModules)) {
    return entryModules.map((id) => ({
      fileName: null,
      id,
      implicitlyLoadedAfter: [],
      importer: void 0,
      name: null
    }));
  }
  return Object.entries(entryModules).map(([name, id]) => ({
    fileName: null,
    id,
    implicitlyLoadedAfter: [],
    importer: void 0,
    name
  }));
}
function ensureArray(items) {
  if (Array.isArray(items)) {
    return items.filter(Boolean);
  }
  if (items) {
    return [items];
  }
  return [];
}
function formatAction([pluginName, hookName, args]) {
  const action = `(${pluginName}) ${hookName}`;
  const s = JSON.stringify;
  switch (hookName) {
    case "resolveId":
      return `${action} ${s(args[0])} ${s(args[1])}`;
    case "load":
      return `${action} ${s(args[0])}`;
    case "transform":
      return `${action} ${s(args[1])}`;
    case "shouldTransformCachedModule":
      return `${action} ${s(args[0].id)}`;
    case "moduleParsed":
      return `${action} ${s(args[0].id)}`;
  }
  return action;
}
async function catchUnfinishedHookActions(pluginDriver, callback) {
  let handleEmptyEventLoop;
  const emptyEventLoopPromise = new Promise((_, reject) => {
    handleEmptyEventLoop = () => {
      const unfulfilledActions = pluginDriver.getUnfulfilledHookActions();
      reject(new Error(`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:
` + [...unfulfilledActions].map(formatAction).join("\n")));
    };
    import_process.default.once("beforeExit", handleEmptyEventLoop);
  });
  const result = await Promise.race([callback(), emptyEventLoopPromise]);
  import_process.default.off("beforeExit", handleEmptyEventLoop);
  return result;
}
function warnUnknownOptions(passedOptions, validOptions, optionType, warn, ignoredKeys = /$./) {
  const validOptionSet = new Set(validOptions);
  const unknownOptions = Object.keys(passedOptions).filter((key) => !(validOptionSet.has(key) || ignoredKeys.test(key)));
  if (unknownOptions.length > 0) {
    warn({
      code: "UNKNOWN_OPTION",
      message: `Unknown ${optionType}: ${unknownOptions.join(", ")}. Allowed options: ${[
        ...validOptionSet
      ].sort().join(", ")}`
    });
  }
}
function normalizeInputOptions(config) {
  var _a, _b, _c;
  const unsetOptions = /* @__PURE__ */ new Set();
  const context = (_a = config.context) !== null && _a !== void 0 ? _a : "undefined";
  const onwarn = getOnwarn(config);
  const strictDeprecations = config.strictDeprecations || false;
  const options = {
    acorn: getAcorn(config),
    acornInjectPlugins: getAcornInjectPlugins(config),
    cache: getCache(config),
    context,
    experimentalCacheExpiry: (_b = config.experimentalCacheExpiry) !== null && _b !== void 0 ? _b : 10,
    external: getIdMatcher(config.external),
    inlineDynamicImports: getInlineDynamicImports$1(config, onwarn, strictDeprecations),
    input: getInput(config),
    makeAbsoluteExternalsRelative: (_c = config.makeAbsoluteExternalsRelative) !== null && _c !== void 0 ? _c : true,
    manualChunks: getManualChunks$1(config, onwarn, strictDeprecations),
    maxParallelFileReads: getMaxParallelFileReads(config),
    moduleContext: getModuleContext(config, context),
    onwarn,
    perf: config.perf || false,
    plugins: ensureArray(config.plugins),
    preserveEntrySignatures: getPreserveEntrySignatures(config, unsetOptions),
    preserveModules: getPreserveModules$1(config, onwarn, strictDeprecations),
    preserveSymlinks: config.preserveSymlinks || false,
    shimMissingExports: config.shimMissingExports || false,
    strictDeprecations,
    treeshake: getTreeshake(config, onwarn, strictDeprecations)
  };
  warnUnknownOptions(config, [...Object.keys(options), "watch"], "input options", options.onwarn, /^(output)$/);
  return { options, unsetOptions };
}
function sanitizeFileName(name) {
  const match = DRIVE_LETTER_REGEX.exec(name);
  const driveLetter = match ? match[0] : "";
  return driveLetter + name.substr(driveLetter.length).replace(INVALID_CHAR_REGEX, "_");
}
function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {
  var _a, _b, _c, _d, _e, _f, _g;
  const unsetOptions = new Set(unsetInputOptions);
  const compact = config.compact || false;
  const format = getFormat(config);
  const inlineDynamicImports = getInlineDynamicImports(config, inputOptions);
  const preserveModules = getPreserveModules(config, inlineDynamicImports, inputOptions);
  const file = getFile(config, preserveModules, inputOptions);
  const preferConst = getPreferConst(config, inputOptions);
  const generatedCode = getGeneratedCode(config, preferConst);
  const outputOptions = {
    amd: getAmd(config),
    assetFileNames: (_a = config.assetFileNames) !== null && _a !== void 0 ? _a : "assets/[name]-[hash][extname]",
    banner: getAddon(config, "banner"),
    chunkFileNames: (_b = config.chunkFileNames) !== null && _b !== void 0 ? _b : "[name]-[hash].js",
    compact,
    dir: getDir(config, file),
    dynamicImportFunction: getDynamicImportFunction(config, inputOptions),
    entryFileNames: getEntryFileNames(config, unsetOptions),
    esModule: (_c = config.esModule) !== null && _c !== void 0 ? _c : true,
    exports: getExports(config, unsetOptions),
    extend: config.extend || false,
    externalLiveBindings: (_d = config.externalLiveBindings) !== null && _d !== void 0 ? _d : true,
    file,
    footer: getAddon(config, "footer"),
    format,
    freeze: (_e = config.freeze) !== null && _e !== void 0 ? _e : true,
    generatedCode,
    globals: config.globals || {},
    hoistTransitiveImports: (_f = config.hoistTransitiveImports) !== null && _f !== void 0 ? _f : true,
    indent: getIndent(config, compact),
    inlineDynamicImports,
    interop: getInterop(config, inputOptions),
    intro: getAddon(config, "intro"),
    manualChunks: getManualChunks(config, inlineDynamicImports, preserveModules, inputOptions),
    minifyInternalExports: getMinifyInternalExports(config, format, compact),
    name: config.name,
    namespaceToStringTag: getNamespaceToStringTag(config, generatedCode, inputOptions),
    noConflict: config.noConflict || false,
    outro: getAddon(config, "outro"),
    paths: config.paths || {},
    plugins: ensureArray(config.plugins),
    preferConst,
    preserveModules,
    preserveModulesRoot: getPreserveModulesRoot(config),
    sanitizeFileName: typeof config.sanitizeFileName === "function" ? config.sanitizeFileName : config.sanitizeFileName === false ? (id) => id : sanitizeFileName,
    sourcemap: config.sourcemap || false,
    sourcemapExcludeSources: config.sourcemapExcludeSources || false,
    sourcemapFile: config.sourcemapFile,
    sourcemapPathTransform: config.sourcemapPathTransform,
    strict: (_g = config.strict) !== null && _g !== void 0 ? _g : true,
    systemNullSetters: config.systemNullSetters || false,
    validate: config.validate || false
  };
  warnUnknownOptions(config, Object.keys(outputOptions), "output options", inputOptions.onwarn);
  return { options: outputOptions, unsetOptions };
}
function getExports(config, unsetOptions) {
  const configExports = config.exports;
  if (configExports == null) {
    unsetOptions.add("exports");
  } else if (!["default", "named", "none", "auto"].includes(configExports)) {
    return error(errInvalidExportOptionValue(configExports));
  }
  return configExports || "auto";
}
function rollup(rawInputOptions) {
  return rollupInternal(rawInputOptions, null);
}
async function rollupInternal(rawInputOptions, watcher) {
  const { options: inputOptions, unsetOptions: unsetInputOptions } = await getInputOptions(rawInputOptions, watcher !== null);
  initialiseTimers(inputOptions);
  const graph = new Graph(inputOptions, watcher);
  const useCache = rawInputOptions.cache !== false;
  delete inputOptions.cache;
  delete rawInputOptions.cache;
  timeStart("BUILD", 1);
  await catchUnfinishedHookActions(graph.pluginDriver, async () => {
    try {
      await graph.pluginDriver.hookParallel("buildStart", [inputOptions]);
      await graph.build();
    } catch (err) {
      const watchFiles = Object.keys(graph.watchFiles);
      if (watchFiles.length > 0) {
        err.watchFiles = watchFiles;
      }
      await graph.pluginDriver.hookParallel("buildEnd", [err]);
      await graph.pluginDriver.hookParallel("closeBundle", []);
      throw err;
    }
    await graph.pluginDriver.hookParallel("buildEnd", []);
  });
  timeEnd("BUILD", 1);
  const result = {
    cache: useCache ? graph.getCache() : void 0,
    async close() {
      if (result.closed)
        return;
      result.closed = true;
      await graph.pluginDriver.hookParallel("closeBundle", []);
    },
    closed: false,
    async generate(rawOutputOptions) {
      if (result.closed)
        return error(errAlreadyClosed());
      return handleGenerateWrite(false, inputOptions, unsetInputOptions, rawOutputOptions, graph);
    },
    watchFiles: Object.keys(graph.watchFiles),
    async write(rawOutputOptions) {
      if (result.closed)
        return error(errAlreadyClosed());
      return handleGenerateWrite(true, inputOptions, unsetInputOptions, rawOutputOptions, graph);
    }
  };
  if (inputOptions.perf)
    result.getTimings = getTimings;
  return result;
}
async function getInputOptions(rawInputOptions, watchMode) {
  if (!rawInputOptions) {
    throw new Error("You must supply an options object to rollup");
  }
  const rawPlugins = ensureArray(rawInputOptions.plugins);
  const { options, unsetOptions } = normalizeInputOptions(await rawPlugins.reduce(applyOptionHook(watchMode), Promise.resolve(rawInputOptions)));
  normalizePlugins(options.plugins, ANONYMOUS_PLUGIN_PREFIX);
  return { options, unsetOptions };
}
function applyOptionHook(watchMode) {
  return async (inputOptions, plugin) => {
    if (plugin.options) {
      return await plugin.options.call({ meta: { rollupVersion: version$1, watchMode } }, await inputOptions) || inputOptions;
    }
    return inputOptions;
  };
}
function normalizePlugins(plugins, anonymousPrefix) {
  plugins.forEach((plugin, index) => {
    if (!plugin.name) {
      plugin.name = `${anonymousPrefix}${index + 1}`;
    }
  });
}
function handleGenerateWrite(isWrite, inputOptions, unsetInputOptions, rawOutputOptions, graph) {
  const { options: outputOptions, outputPluginDriver, unsetOptions } = getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);
  return catchUnfinishedHookActions(outputPluginDriver, async () => {
    const bundle = new Bundle2(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);
    const generated = await bundle.generate(isWrite);
    if (isWrite) {
      if (!outputOptions.dir && !outputOptions.file) {
        return error({
          code: "MISSING_OPTION",
          message: 'You must specify "output.file" or "output.dir" for the build.'
        });
      }
      await Promise.all(Object.values(generated).map((chunk) => writeOutputFile(chunk, outputOptions)));
      await outputPluginDriver.hookParallel("writeBundle", [outputOptions, generated]);
    }
    return createOutput(generated);
  });
}
function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {
  if (!rawOutputOptions) {
    throw new Error("You must supply an options object");
  }
  const rawPlugins = ensureArray(rawOutputOptions.plugins);
  normalizePlugins(rawPlugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX);
  const outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins);
  return {
    ...getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver),
    outputPluginDriver
  };
}
function getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver) {
  return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync("outputOptions", [rawOutputOptions.output || rawOutputOptions], (outputOptions, result) => result || outputOptions, (pluginContext) => {
    const emitError = () => pluginContext.error(errCannotEmitFromOptionsHook());
    return {
      ...pluginContext,
      emitFile: emitError,
      setAssetSource: emitError
    };
  }), inputOptions, unsetInputOptions);
}
function createOutput(outputBundle) {
  return {
    output: Object.values(outputBundle).filter((outputFile) => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => {
      const fileTypeA = getSortingFileType(outputFileA);
      const fileTypeB = getSortingFileType(outputFileB);
      if (fileTypeA === fileTypeB)
        return 0;
      return fileTypeA < fileTypeB ? -1 : 1;
    })
  };
}
function getSortingFileType(file) {
  if (file.type === "asset") {
    return SortingFileType.ASSET;
  }
  if (file.isEntry) {
    return SortingFileType.ENTRY_CHUNK;
  }
  return SortingFileType.SECONDARY_CHUNK;
}
async function writeOutputFile(outputFile, outputOptions) {
  const fileName = (0, import_path.resolve)(outputOptions.dir || (0, import_path.dirname)(outputOptions.file), outputFile.fileName);
  await import_fs.promises.mkdir((0, import_path.dirname)(fileName), { recursive: true });
  let writeSourceMapPromise;
  let source;
  if (outputFile.type === "asset") {
    source = outputFile.source;
  } else {
    source = outputFile.code;
    if (outputOptions.sourcemap && outputFile.map) {
      let url;
      if (outputOptions.sourcemap === "inline") {
        url = outputFile.map.toUrl();
      } else {
        url = `${(0, import_path.basename)(outputFile.fileName)}.map`;
        writeSourceMapPromise = import_fs.promises.writeFile(`${fileName}.map`, outputFile.map.toString());
      }
      if (outputOptions.sourcemap !== "hidden") {
        source += `//# ${SOURCEMAPPING_URL}=${url}
`;
      }
    }
  }
  return Promise.all([import_fs.promises.writeFile(fileName, source), writeSourceMapPromise]);
}
var import_path, import_process, import_perf_hooks, import_crypto, import_fs, version$1, charToInteger, chars$1, i$1, BitSet, Chunk$1, btoa, SourceMap, toString$1, Mappings, n, warned, MagicString, hasOwnProp, Bundle$1, MagicString$1, ANY_SLASH_REGEX, UnknownKey, UnknownInteger, EMPTY_PATH, UNKNOWN_PATH, UNKNOWN_INTEGER_PATH, EntitiesKey, PathTracker, SHARED_RECURSION_TRACKER, DiscriminatedPathTracker, UnknownValue, ExpressionEntity, UNKNOWN_EXPRESSION, Variable, ExternalVariable, BLANK, EMPTY_OBJECT, EMPTY_ARRAY, ABSOLUTE_PATH_REGEX, RELATIVE_PATH_REGEX, BACKSLASH_REGEX, UPPER_DIR_REGEX, Errors, RESERVED_NAMES, RESERVED_NAMES$1, illegalCharacters, startsWithDigit, ExternalModule, utils$3, path$1, WIN_SLASH, WIN_NO_SLASH, DOT_LITERAL, PLUS_LITERAL, QMARK_LITERAL, SLASH_LITERAL, ONE_CHAR, QMARK, END_ANCHOR, START_ANCHOR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK_NO_DOT, STAR, POSIX_CHARS, WINDOWS_CHARS, POSIX_REGEX_SOURCE$1, constants$2, utils$2, CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET, isPathSeparator, depth, scan$1, scan_1, constants$1, utils$1, MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS, expandRange, syntaxError, parse$1, parse_1, path, scan, parse, utils, constants, isObject, picomatch$1, extractors, extractAssignedNames, reservedWords$1, builtins$1, forbiddenIdentifiers, BROKEN_FLOW_NONE, BROKEN_FLOW_BREAK_CONTINUE, BROKEN_FLOW_ERROR_RETURN_LABEL, NO_ARGS, UNDEFINED_EXPRESSION, returnsUnknown, UNKNOWN_LITERAL_BOOLEAN, returnsBoolean, UNKNOWN_LITERAL_NUMBER, returnsNumber, UNKNOWN_LITERAL_STRING, returnsString, objectMembers, literalBooleanMembers, literalNumberMembers, literalStringMembers, base$1, ArrowFunctionExpression$1, BinaryExpression$1, BlockStatement$1, CallExpression$1, ChainExpression$1, ConditionalExpression$1, ExpressionStatement$1, Identifier$1, ImportDefaultSpecifier$1, ImportNamespaceSpecifier$1, LogicalExpression$1, NewExpression$1, Program$1, Property$1, ReturnStatement$1, SequenceExpression$1, SOURCEMAPPING_URL, whiteSpaceNoNewline, SOURCEMAPPING_URL_RE, ANNOTATION_KEY, INVALID_COMMENT_KEY, neitherWithespaceNorBrackets, noWhitespace, pureCommentRegex, keys, INCLUDE_PARAMETERS, NodeBase, SpreadElement, EVENT_ACCESSED, EVENT_ASSIGNED, EVENT_CALLED, Method, METHOD_RETURNS_BOOLEAN, METHOD_RETURNS_STRING, METHOD_RETURNS_NUMBER, METHOD_RETURNS_UNKNOWN, INTEGER_REG_EXP, ObjectEntity, isInteger, OBJECT_PROTOTYPE_FALLBACK, OBJECT_PROTOTYPE, NEW_ARRAY_PROPERTIES, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY, METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_MUTATES_SELF_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_UNKNOWN, METHOD_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_MUTATES_SELF_RETURNS_SELF, METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF, ARRAY_PROTOTYPE, ArrayExpression, ArrayPattern, LocalVariable, chars, base, Scope$1, ChildScope, ParameterScope, ReturnValueScope, NO_SEMICOLON, NON_WHITESPACE, BlockScope, ExpressionStatement, BlockStatement, ValueProperties, PURE, IMPURE, O, PF, C, PC, ARRAY_TYPE, INTL_MEMBER, knownGlobals, GlobalVariable, tdzVariableKinds, Identifier, RestElement, ArrowFunctionExpression, ObjectPattern, AssignmentExpression, AssignmentPattern, ArgumentsVariable, ThisVariable, FunctionScope, FunctionNode, AwaitExpression, binaryOperators, BinaryExpression, BreakStatement, Literal, MAX_PATH_DEPTH, MemberExpression, CallExpression, CatchScope, CatchClause, ChainExpression, ClassBodyScope, ClassBody, MethodBase, MethodDefinition, ObjectMember, ClassNode, ClassDeclaration, ClassExpression, MultiExpression, ConditionalExpression, ContinueStatement, DoWhileStatement, EmptyStatement, ExportAllDeclaration, FunctionDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ForInStatement, ForOfStatement, ForStatement, FunctionExpression, TrackingScope, unset, IfStatement, ImportDeclaration, ImportDefaultSpecifier, INTEROP_DEFAULT_VARIABLE, INTEROP_DEFAULT_LEGACY_VARIABLE, INTEROP_NAMESPACE_VARIABLE, INTEROP_NAMESPACE_DEFAULT_VARIABLE, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, MERGE_NAMESPACES_VARIABLE, defaultInteropHelpersByInteropType, isDefaultAProperty, namespaceInteropHelpersByInteropType, canDefaultBeTakenFromNamespace, getHelpersBlock, HELPER_GENERATORS, getDefaultLiveBinding, getDefaultStatic, createNamespaceObject, loopOverKeys, loopOverNamespaces, copyNonDefaultOwnPropertyLiveBinding, copyOwnPropertyLiveBinding, copyPropertyLiveBinding, copyPropertyStatic, getFrozen, getWithToStringTag, HELPER_NAMES, ImportExpression, accessedImportGlobals, ImportNamespaceSpecifier, ImportSpecifier, LabeledStatement, LogicalExpression, ASSET_PREFIX, CHUNK_PREFIX, FILE_PREFIX, MetaProperty, accessedMetaUrlGlobals, accessedFileUrlGlobals, getResolveUrl, getRelativeUrlFromDocument, getGenericImportMetaMechanism, getUrlFromDocument, relativeUrlMechanisms, importMetaMechanisms, NewExpression, ObjectExpression, PrivateIdentifier, Program, Property, PropertyDefinition, ReturnStatement, SequenceExpression, StaticBlock, Super, SwitchCase, SwitchStatement, TaggedTemplateExpression, TemplateElement, TemplateLiteral, UndefinedVariable, ExportDefaultVariable, ModuleScope, ThisExpression, ThrowStatement, TryStatement, unaryOperators, UnaryExpression, UnknownNode, UpdateExpression, VariableDeclaration, VariableDeclarator, WhileStatement, YieldExpression, nodeConstructors, MISSING_EXPORT_SHIM_VARIABLE, ExportShimVariable, NamespaceVariable, SyntheticNamedExportVariable, BuildPhase, NOOP, timers, timeStart, timeEnd, TIMED_PLUGIN_HOOKS, MISSING_EXPORT_SHIM_DESCRIPTION, Module, getDefineProperty, builtins, keypath, getStarExcludes, getStarExcludesBlock, getImportBindingsBlock, getHoistedExportsBlock, getSyntheticExportsBlock, getMissingExportsBlock, finalisers, Source, Link, createHash, DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT, needsEscapeRegEx, quoteNewlineRegEx, backSlashRegEx, NON_ASSET_EXTENSIONS, Chunk2, QUERY_HASH_REGEX, FILE_PLACEHOLDER, FileEmitter, concatSep, concatDblSep, compareExecIndex, wrapIfNeeded, validPropName, Bundle2, reservedWords, ecma5AndLessKeywords, keywords$1, keywordRelationalOperator, nonASCIIidentifierStartChars, nonASCIIidentifierChars, nonASCIIidentifierStart, nonASCIIidentifier, astralIdentifierStartCodes, astralIdentifierCodes, TokenType, beforeExpr, startsExpr, keywords, types$1, lineBreak, lineBreakG, nonASCIIwhitespace, skipWhiteSpace, ref, hasOwnProperty, toString5, hasOwn, isArray, loneSurrogate, Position, SourceLocation, defaultOptions, warnedAboutEcmaVersion, SCOPE_TOP, SCOPE_FUNCTION, SCOPE_ASYNC, SCOPE_GENERATOR, SCOPE_ARROW, SCOPE_SIMPLE_CATCH, SCOPE_SUPER, SCOPE_DIRECT_SUPER, SCOPE_CLASS_STATIC_BLOCK, SCOPE_VAR, BIND_NONE, BIND_VAR, BIND_LEXICAL, BIND_FUNCTION, BIND_SIMPLE_CATCH, BIND_OUTSIDE, Parser, prototypeAccessors, pp$9, literal, pp$8, loopLabel, switchLabel, empty$1, FUNC_STATEMENT, FUNC_HANGING_STATEMENT, FUNC_NULLABLE_ID, pp$7, TokContext, types, pp$6, pp$5, empty, pp$4, pp$3, Scope, Node, pp$2, ecma9BinaryProperties, ecma10BinaryProperties, ecma11BinaryProperties, ecma12BinaryProperties, ecma13BinaryProperties, unicodeBinaryProperties, unicodeGeneralCategoryValues, ecma9ScriptValues, ecma10ScriptValues, ecma11ScriptValues, ecma12ScriptValues, ecma13ScriptValues, unicodeScriptValues, data, ecmaVersion, i, list, pp$1, RegExpValidationState, Token, pp, INVALID_TEMPLATE_ESCAPE_ERROR, version, Queue, ANONYMOUS_PLUGIN_PREFIX, ANONYMOUS_OUTPUT_PLUGIN_PREFIX, deprecatedHooks, NO_CACHE, RESOLVE_DEPENDENCIES, ModuleLoader, GlobalScope, inputHookNames, inputHooks, PluginDriver, Graph, defaultOnWarn, treeshakePresets, generatedCodePresets, objectifyOption, objectifyOptionWithPresets, getOptionWithPreset, getHashFromObjectOption, getOnwarn, getAcorn, getAcornInjectPlugins, getCache, getIdMatcher, getInlineDynamicImports$1, getInput, getManualChunks$1, getMaxParallelFileReads, getModuleContext, getPreserveEntrySignatures, getPreserveModules$1, getTreeshake, getHasModuleSideEffects, INVALID_CHAR_REGEX, DRIVE_LETTER_REGEX, getFile, getFormat, getInlineDynamicImports, getPreserveModules, getPreferConst, getPreserveModulesRoot, getAmd, getAddon, getDir, getDynamicImportFunction, getEntryFileNames, getGeneratedCode, getIndent, ALLOWED_INTEROP_TYPES, getInterop, getManualChunks, getMinifyInternalExports, getNamespaceToStringTag, SortingFileType;
var init_rollup = __esm({
  "plugins/public/node_modules/rollup/dist/es/shared/rollup.js"() {
    import_path = __toESM(require("path"), 1);
    import_process = __toESM(require("process"), 1);
    import_perf_hooks = require("perf_hooks");
    import_crypto = require("crypto");
    import_fs = require("fs");
    version$1 = "2.70.1";
    charToInteger = {};
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for (i$1 = 0; i$1 < chars$1.length; i$1++) {
      charToInteger[chars$1.charCodeAt(i$1)] = i$1;
    }
    BitSet = function BitSet2(arg) {
      this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
    };
    BitSet.prototype.add = function add(n2) {
      this.bits[n2 >> 5] |= 1 << (n2 & 31);
    };
    BitSet.prototype.has = function has(n2) {
      return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
    };
    Chunk$1 = function Chunk(start, end, content) {
      this.start = start;
      this.end = end;
      this.original = content;
      this.intro = "";
      this.outro = "";
      this.content = content;
      this.storeName = false;
      this.edited = false;
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    };
    Chunk$1.prototype.appendLeft = function appendLeft(content) {
      this.outro += content;
    };
    Chunk$1.prototype.appendRight = function appendRight(content) {
      this.intro = this.intro + content;
    };
    Chunk$1.prototype.clone = function clone() {
      var chunk = new Chunk$1(this.start, this.end, this.original);
      chunk.intro = this.intro;
      chunk.outro = this.outro;
      chunk.content = this.content;
      chunk.storeName = this.storeName;
      chunk.edited = this.edited;
      return chunk;
    };
    Chunk$1.prototype.contains = function contains(index) {
      return this.start < index && index < this.end;
    };
    Chunk$1.prototype.eachNext = function eachNext(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.next;
      }
    };
    Chunk$1.prototype.eachPrevious = function eachPrevious(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.previous;
      }
    };
    Chunk$1.prototype.edit = function edit(content, storeName, contentOnly) {
      this.content = content;
      if (!contentOnly) {
        this.intro = "";
        this.outro = "";
      }
      this.storeName = storeName;
      this.edited = true;
      return this;
    };
    Chunk$1.prototype.prependLeft = function prependLeft(content) {
      this.outro = content + this.outro;
    };
    Chunk$1.prototype.prependRight = function prependRight(content) {
      this.intro = content + this.intro;
    };
    Chunk$1.prototype.split = function split(index) {
      var sliceIndex = index - this.start;
      var originalBefore = this.original.slice(0, sliceIndex);
      var originalAfter = this.original.slice(sliceIndex);
      this.original = originalBefore;
      var newChunk = new Chunk$1(index, this.end, originalAfter);
      newChunk.outro = this.outro;
      this.outro = "";
      this.end = index;
      if (this.edited) {
        newChunk.edit("", false);
        this.content = "";
      } else {
        this.content = originalBefore;
      }
      newChunk.next = this.next;
      if (newChunk.next) {
        newChunk.next.previous = newChunk;
      }
      newChunk.previous = this;
      this.next = newChunk;
      return newChunk;
    };
    Chunk$1.prototype.toString = function toString() {
      return this.intro + this.content + this.outro;
    };
    Chunk$1.prototype.trimEnd = function trimEnd(rx) {
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.start + trimmed.length).edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
      }
    };
    Chunk$1.prototype.trimStart = function trimStart(rx) {
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.end - trimmed.length);
          this.edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
      }
    };
    btoa = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    } else if (typeof Buffer === "function") {
      btoa = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
      };
    }
    SourceMap = function SourceMap2(properties) {
      this.version = 3;
      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = encode(properties.mappings);
    };
    SourceMap.prototype.toString = function toString2() {
      return JSON.stringify(this);
    };
    SourceMap.prototype.toUrl = function toUrl() {
      return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
    };
    toString$1 = Object.prototype.toString;
    Mappings = function Mappings2(hires) {
      this.hires = hires;
      this.generatedCodeLine = 0;
      this.generatedCodeColumn = 0;
      this.raw = [];
      this.rawSegments = this.raw[this.generatedCodeLine] = [];
      this.pending = null;
    };
    Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
      if (content.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
      } else if (this.pending) {
        this.rawSegments.push(this.pending);
      }
      this.advance(content);
      this.pending = null;
    };
    Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
      var originalCharIndex = chunk.start;
      var first = true;
      while (originalCharIndex < chunk.end) {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === "\n") {
          loc.line += 1;
          loc.column = 0;
          this.generatedCodeLine += 1;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
          first = true;
        } else {
          loc.column += 1;
          this.generatedCodeColumn += 1;
          first = false;
        }
        originalCharIndex += 1;
      }
      this.pending = null;
    };
    Mappings.prototype.advance = function advance(str) {
      if (!str) {
        return;
      }
      var lines = str.split("\n");
      if (lines.length > 1) {
        for (var i = 0; i < lines.length - 1; i++) {
          this.generatedCodeLine++;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    n = "\n";
    warned = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    MagicString = function MagicString2(string, options) {
      if (options === void 0)
        options = {};
      var chunk = new Chunk$1(0, string.length, string);
      Object.defineProperties(this, {
        original: { writable: true, value: string },
        outro: { writable: true, value: "" },
        intro: { writable: true, value: "" },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options.filename },
        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: new BitSet() },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent(string) }
      });
      this.byStart[0] = chunk;
      this.byEnd[string.length] = chunk;
    };
    MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
      this.sourcemapLocations.add(char);
    };
    MagicString.prototype.append = function append(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.outro += content;
      return this;
    };
    MagicString.prototype.appendLeft = function appendLeft2(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.appendLeft(content);
      } else {
        this.intro += content;
      }
      return this;
    };
    MagicString.prototype.appendRight = function appendRight2(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.appendRight(content);
      } else {
        this.outro += content;
      }
      return this;
    };
    MagicString.prototype.clone = function clone2() {
      var cloned = new MagicString(this.original, { filename: this.filename });
      var originalChunk = this.firstChunk;
      var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
      while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
          clonedChunk.next = nextClonedChunk;
          nextClonedChunk.previous = clonedChunk;
          clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
      }
      cloned.lastChunk = clonedChunk;
      if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
      }
      cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
      cloned.intro = this.intro;
      cloned.outro = this.outro;
      return cloned;
    };
    MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
      var this$1$1 = this;
      options = options || {};
      var sourceIndex = 0;
      var names = Object.keys(this.storedNames);
      var mappings = new Mappings(options.hires);
      var locate2 = getLocator$1(this.original);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.firstChunk.eachNext(function(chunk) {
        var loc = locate2(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
          mappings.addEdit(
            sourceIndex,
            chunk.content,
            loc,
            chunk.storeName ? names.indexOf(chunk.original) : -1
          );
        } else {
          mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: [options.source ? getRelativePath(options.file || "", options.source) : null],
        sourcesContent: options.includeContent ? [this.original] : [null],
        names,
        mappings: mappings.raw
      };
    };
    MagicString.prototype.generateMap = function generateMap(options) {
      return new SourceMap(this.generateDecodedMap(options));
    };
    MagicString.prototype.getIndentString = function getIndentString() {
      return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString.prototype.indent = function indent(indentStr, options) {
      var pattern = /^[^\r\n]/gm;
      if (isObject$1(indentStr)) {
        options = indentStr;
        indentStr = void 0;
      }
      indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
      if (indentStr === "") {
        return this;
      }
      options = options || {};
      var isExcluded = {};
      if (options.exclude) {
        var exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
        exclusions.forEach(function(exclusion) {
          for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
            isExcluded[i] = true;
          }
        });
      }
      var shouldIndentNextCharacter = options.indentStart !== false;
      var replacer = function(match) {
        if (shouldIndentNextCharacter) {
          return "" + indentStr + match;
        }
        shouldIndentNextCharacter = true;
        return match;
      };
      this.intro = this.intro.replace(pattern, replacer);
      var charIndex = 0;
      var chunk = this.firstChunk;
      while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
          if (!isExcluded[charIndex]) {
            chunk.content = chunk.content.replace(pattern, replacer);
            if (chunk.content.length) {
              shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
            }
          }
        } else {
          charIndex = chunk.start;
          while (charIndex < end) {
            if (!isExcluded[charIndex]) {
              var char = this.original[charIndex];
              if (char === "\n") {
                shouldIndentNextCharacter = true;
              } else if (char !== "\r" && shouldIndentNextCharacter) {
                shouldIndentNextCharacter = false;
                if (charIndex === chunk.start) {
                  chunk.prependRight(indentStr);
                } else {
                  this._splitChunk(chunk, charIndex);
                  chunk = chunk.next;
                  chunk.prependRight(indentStr);
                }
              }
            }
            charIndex += 1;
          }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
      }
      this.outro = this.outro.replace(pattern, replacer);
      return this;
    };
    MagicString.prototype.insert = function insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    };
    MagicString.prototype.insertLeft = function insertLeft(index, content) {
      if (!warned.insertLeft) {
        console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
        warned.insertLeft = true;
      }
      return this.appendLeft(index, content);
    };
    MagicString.prototype.insertRight = function insertRight(index, content) {
      if (!warned.insertRight) {
        console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
        warned.insertRight = true;
      }
      return this.prependRight(index, content);
    };
    MagicString.prototype.move = function move(start, end, index) {
      if (index >= start && index <= end) {
        throw new Error("Cannot move a selection inside itself");
      }
      this._split(start);
      this._split(end);
      this._split(index);
      var first = this.byStart[start];
      var last = this.byEnd[end];
      var oldLeft = first.previous;
      var oldRight = last.next;
      var newRight = this.byStart[index];
      if (!newRight && last === this.lastChunk) {
        return this;
      }
      var newLeft = newRight ? newRight.previous : this.lastChunk;
      if (oldLeft) {
        oldLeft.next = oldRight;
      }
      if (oldRight) {
        oldRight.previous = oldLeft;
      }
      if (newLeft) {
        newLeft.next = first;
      }
      if (newRight) {
        newRight.previous = last;
      }
      if (!first.previous) {
        this.firstChunk = last.next;
      }
      if (!last.next) {
        this.lastChunk = first.previous;
        this.lastChunk.next = null;
      }
      first.previous = newLeft;
      last.next = newRight || null;
      if (!newLeft) {
        this.firstChunk = first;
      }
      if (!newRight) {
        this.lastChunk = last;
      }
      return this;
    };
    MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
      if (typeof content !== "string") {
        throw new TypeError("replacement content must be a string");
      }
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (end > this.original.length) {
        throw new Error("end is out of bounds");
      }
      if (start === end) {
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      }
      this._split(start);
      this._split(end);
      if (options === true) {
        if (!warned.storeName) {
          console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
          warned.storeName = true;
        }
        options = { storeName: true };
      }
      var storeName = options !== void 0 ? options.storeName : false;
      var contentOnly = options !== void 0 ? options.contentOnly : false;
      if (storeName) {
        var original = this.original.slice(start, end);
        this.storedNames[original] = true;
      }
      var first = this.byStart[start];
      var last = this.byEnd[end];
      if (first) {
        if (end > first.end && first.next !== this.byStart[first.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        first.edit(content, storeName, contentOnly);
        if (first !== last) {
          var chunk = first.next;
          while (chunk !== last) {
            chunk.edit("", false);
            chunk = chunk.next;
          }
          chunk.edit("", false);
        }
      } else {
        var newChunk = new Chunk$1(start, end, "").edit(content, storeName);
        last.next = newChunk;
        newChunk.previous = last;
      }
      return this;
    };
    MagicString.prototype.prepend = function prepend(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.intro = content + this.intro;
      return this;
    };
    MagicString.prototype.prependLeft = function prependLeft2(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.prependLeft(content);
      } else {
        this.intro = content + this.intro;
      }
      return this;
    };
    MagicString.prototype.prependRight = function prependRight2(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.prependRight(content);
      } else {
        this.outro = content + this.outro;
      }
      return this;
    };
    MagicString.prototype.remove = function remove(start, end) {
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (start === end) {
        return this;
      }
      if (start < 0 || end > this.original.length) {
        throw new Error("Character is out of bounds");
      }
      if (start > end) {
        throw new Error("end must be greater than start");
      }
      this._split(start);
      this._split(end);
      var chunk = this.byStart[start];
      while (chunk) {
        chunk.intro = "";
        chunk.outro = "";
        chunk.edit("");
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
      }
      return this;
    };
    MagicString.prototype.lastChar = function lastChar() {
      if (this.outro.length) {
        return this.outro[this.outro.length - 1];
      }
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length) {
          return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
          return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
          return chunk.intro[chunk.intro.length - 1];
        }
      } while (chunk = chunk.previous);
      if (this.intro.length) {
        return this.intro[this.intro.length - 1];
      }
      return "";
    };
    MagicString.prototype.lastLine = function lastLine() {
      var lineIndex = this.outro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
      }
      var lineStr = this.outro;
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length > 0) {
          lineIndex = chunk.outro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.outro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
          lineIndex = chunk.content.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.content.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
          lineIndex = chunk.intro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.intro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.intro + lineStr;
        }
      } while (chunk = chunk.previous);
      lineIndex = this.intro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
      }
      return this.intro + lineStr;
    };
    MagicString.prototype.slice = function slice(start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = this.original.length;
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      var result = "";
      var chunk = this.firstChunk;
      while (chunk && (chunk.start > start || chunk.end <= start)) {
        if (chunk.start < end && chunk.end >= end) {
          return result;
        }
        chunk = chunk.next;
      }
      if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
      }
      var startChunk = chunk;
      while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
          result += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
          throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
          result += chunk.outro;
        }
        if (containsEnd) {
          break;
        }
        chunk = chunk.next;
      }
      return result;
    };
    MagicString.prototype.snip = function snip(start, end) {
      var clone4 = this.clone();
      clone4.remove(0, start);
      clone4.remove(end, clone4.original.length);
      return clone4;
    };
    MagicString.prototype._split = function _split(index) {
      if (this.byStart[index] || this.byEnd[index]) {
        return;
      }
      var chunk = this.lastSearchedChunk;
      var searchForward = index > chunk.end;
      while (chunk) {
        if (chunk.contains(index)) {
          return this._splitChunk(chunk, index);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      }
    };
    MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
      if (chunk.edited && chunk.content.length) {
        var loc = getLocator$1(this.original)(index);
        throw new Error(
          "Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")'
        );
      }
      var newChunk = chunk.split(index);
      this.byEnd[index] = chunk;
      this.byStart[index] = newChunk;
      this.byEnd[newChunk.end] = newChunk;
      if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
      }
      this.lastSearchedChunk = chunk;
      return true;
    };
    MagicString.prototype.toString = function toString3() {
      var str = this.intro;
      var chunk = this.firstChunk;
      while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
      }
      return str + this.outro;
    };
    MagicString.prototype.isEmpty = function isEmpty() {
      var chunk = this.firstChunk;
      do {
        if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
          return false;
        }
      } while (chunk = chunk.next);
      return true;
    };
    MagicString.prototype.length = function length() {
      var chunk = this.firstChunk;
      var length3 = 0;
      do {
        length3 += chunk.intro.length + chunk.content.length + chunk.outro.length;
      } while (chunk = chunk.next);
      return length3;
    };
    MagicString.prototype.trimLines = function trimLines() {
      return this.trim("[\\r\\n]");
    };
    MagicString.prototype.trim = function trim(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var chunk = this.lastChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        if (chunk.end !== end) {
          if (this.lastChunk === chunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.previous;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimEnd = function trimEnd2(charType) {
      this.trimEndAborted(charType);
      return this;
    };
    MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var chunk = this.firstChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
          if (chunk === this.lastChunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.next;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimStart = function trimStart2(charType) {
      this.trimStartAborted(charType);
      return this;
    };
    hasOwnProp = Object.prototype.hasOwnProperty;
    Bundle$1 = function Bundle(options) {
      if (options === void 0)
        options = {};
      this.intro = options.intro || "";
      this.separator = options.separator !== void 0 ? options.separator : "\n";
      this.sources = [];
      this.uniqueSources = [];
      this.uniqueSourceIndexByFilename = {};
    };
    Bundle$1.prototype.addSource = function addSource(source) {
      if (source instanceof MagicString) {
        return this.addSource({
          content: source,
          filename: source.filename,
          separator: this.separator
        });
      }
      if (!isObject$1(source) || !source.content) {
        throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      }
      ["filename", "indentExclusionRanges", "separator"].forEach(function(option) {
        if (!hasOwnProp.call(source, option)) {
          source[option] = source.content[option];
        }
      });
      if (source.separator === void 0) {
        source.separator = this.separator;
      }
      if (source.filename) {
        if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
          this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
          this.uniqueSources.push({ filename: source.filename, content: source.content.original });
        } else {
          var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
          if (source.content.original !== uniqueSource.content) {
            throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
          }
        }
      }
      this.sources.push(source);
      return this;
    };
    Bundle$1.prototype.append = function append2(str, options) {
      this.addSource({
        content: new MagicString(str),
        separator: options && options.separator || ""
      });
      return this;
    };
    Bundle$1.prototype.clone = function clone3() {
      var bundle = new Bundle$1({
        intro: this.intro,
        separator: this.separator
      });
      this.sources.forEach(function(source) {
        bundle.addSource({
          filename: source.filename,
          content: source.content.clone(),
          separator: source.separator
        });
      });
      return bundle;
    };
    Bundle$1.prototype.generateDecodedMap = function generateDecodedMap2(options) {
      var this$1$1 = this;
      if (options === void 0)
        options = {};
      var names = [];
      this.sources.forEach(function(source) {
        Object.keys(source.content.storedNames).forEach(function(name) {
          if (!~names.indexOf(name)) {
            names.push(name);
          }
        });
      });
      var mappings = new Mappings(options.hires);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.sources.forEach(function(source, i) {
        if (i > 0) {
          mappings.advance(this$1$1.separator);
        }
        var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
        var magicString = source.content;
        var locate2 = getLocator$1(magicString.original);
        if (magicString.intro) {
          mappings.advance(magicString.intro);
        }
        magicString.firstChunk.eachNext(function(chunk) {
          var loc = locate2(chunk.start);
          if (chunk.intro.length) {
            mappings.advance(chunk.intro);
          }
          if (source.filename) {
            if (chunk.edited) {
              mappings.addEdit(
                sourceIndex,
                chunk.content,
                loc,
                chunk.storeName ? names.indexOf(chunk.original) : -1
              );
            } else {
              mappings.addUneditedChunk(
                sourceIndex,
                chunk,
                magicString.original,
                loc,
                magicString.sourcemapLocations
              );
            }
          } else {
            mappings.advance(chunk.content);
          }
          if (chunk.outro.length) {
            mappings.advance(chunk.outro);
          }
        });
        if (magicString.outro) {
          mappings.advance(magicString.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: this.uniqueSources.map(function(source) {
          return options.file ? getRelativePath(options.file, source.filename) : source.filename;
        }),
        sourcesContent: this.uniqueSources.map(function(source) {
          return options.includeContent ? source.content : null;
        }),
        names,
        mappings: mappings.raw
      };
    };
    Bundle$1.prototype.generateMap = function generateMap2(options) {
      return new SourceMap(this.generateDecodedMap(options));
    };
    Bundle$1.prototype.getIndentString = function getIndentString2() {
      var indentStringCounts = {};
      this.sources.forEach(function(source) {
        var indentStr = source.content.indentStr;
        if (indentStr === null) {
          return;
        }
        if (!indentStringCounts[indentStr]) {
          indentStringCounts[indentStr] = 0;
        }
        indentStringCounts[indentStr] += 1;
      });
      return Object.keys(indentStringCounts).sort(function(a, b) {
        return indentStringCounts[a] - indentStringCounts[b];
      })[0] || "	";
    };
    Bundle$1.prototype.indent = function indent2(indentStr) {
      var this$1$1 = this;
      if (!arguments.length) {
        indentStr = this.getIndentString();
      }
      if (indentStr === "") {
        return this;
      }
      var trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
      this.sources.forEach(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
        var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
        source.content.indent(indentStr, {
          exclude: source.indentExclusionRanges,
          indentStart
        });
        trailingNewline = source.content.lastChar() === "\n";
      });
      if (this.intro) {
        this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function(match, index) {
          return index > 0 ? indentStr + match : match;
        });
      }
      return this;
    };
    Bundle$1.prototype.prepend = function prepend2(str) {
      this.intro = str + this.intro;
      return this;
    };
    Bundle$1.prototype.toString = function toString4() {
      var this$1$1 = this;
      var body = this.sources.map(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
        var str = (i > 0 ? separator : "") + source.content.toString();
        return str;
      }).join("");
      return this.intro + body;
    };
    Bundle$1.prototype.isEmpty = function isEmpty2() {
      if (this.intro.length && this.intro.trim()) {
        return false;
      }
      if (this.sources.some(function(source) {
        return !source.content.isEmpty();
      })) {
        return false;
      }
      return true;
    };
    Bundle$1.prototype.length = function length2() {
      return this.sources.reduce(function(length3, source) {
        return length3 + source.content.length();
      }, this.intro.length);
    };
    Bundle$1.prototype.trimLines = function trimLines2() {
      return this.trim("[\\r\\n]");
    };
    Bundle$1.prototype.trim = function trim2(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    Bundle$1.prototype.trimStart = function trimStart3(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (!this.intro) {
        var source;
        var i = 0;
        do {
          source = this.sources[i++];
          if (!source) {
            break;
          }
        } while (!source.content.trimStartAborted(charType));
      }
      return this;
    };
    Bundle$1.prototype.trimEnd = function trimEnd3(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      var source;
      var i = this.sources.length - 1;
      do {
        source = this.sources[i--];
        if (!source) {
          this.intro = this.intro.replace(rx, "");
          break;
        }
      } while (!source.content.trimEndAborted(charType));
      return this;
    };
    MagicString$1 = MagicString;
    ANY_SLASH_REGEX = /[/\\]/;
    UnknownKey = Symbol("Unknown Key");
    UnknownInteger = Symbol("Unknown Integer");
    EMPTY_PATH = [];
    UNKNOWN_PATH = [UnknownKey];
    UNKNOWN_INTEGER_PATH = [UnknownInteger];
    EntitiesKey = Symbol("Entities");
    PathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Set() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path4, entity) {
        const trackedEntities = this.getEntities(path4);
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
      withTrackedEntityAtPath(path4, entity, onUntracked, returnIfTracked) {
        const trackedEntities = this.getEntities(path4);
        if (trackedEntities.has(entity))
          return returnIfTracked;
        trackedEntities.add(entity);
        const result = onUntracked();
        trackedEntities.delete(entity);
        return result;
      }
      getEntities(path4) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path4) {
          currentPaths = currentPaths[pathSegment] = currentPaths[pathSegment] || Object.create(null, { [EntitiesKey]: { value: /* @__PURE__ */ new Set() } });
        }
        return currentPaths[EntitiesKey];
      }
    };
    SHARED_RECURSION_TRACKER = new PathTracker();
    DiscriminatedPathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Map() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path4, discriminator, entity) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path4) {
          currentPaths = currentPaths[pathSegment] = currentPaths[pathSegment] || Object.create(null, { [EntitiesKey]: { value: /* @__PURE__ */ new Map() } });
        }
        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, () => /* @__PURE__ */ new Set());
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
    };
    UnknownValue = Symbol("Unknown Value");
    ExpressionEntity = class {
      constructor() {
        this.included = false;
      }
      deoptimizePath(_path) {
      }
      deoptimizeThisOnEventAtPath(_event, _path, thisParameter, _recursionTracker) {
        thisParameter.deoptimizePath(UNKNOWN_PATH);
      }
      getLiteralValueAtPath(_path, _recursionTracker, _origin) {
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(_path, _callOptions, _recursionTracker, _origin) {
        return UNKNOWN_EXPRESSION;
      }
      hasEffectsWhenAccessedAtPath(_path, _context) {
        return true;
      }
      hasEffectsWhenAssignedAtPath(_path, _context) {
        return true;
      }
      hasEffectsWhenCalledAtPath(_path, _callOptions, _context) {
        return true;
      }
      include(_context, _includeChildrenRecursively) {
        this.included = true;
      }
      includeCallArguments(context, args) {
        for (const arg of args) {
          arg.include(context, false);
        }
      }
    };
    UNKNOWN_EXPRESSION = new class UnknownExpression extends ExpressionEntity {
    }();
    Variable = class extends ExpressionEntity {
      constructor(name) {
        super();
        this.name = name;
        this.alwaysRendered = false;
        this.initReached = false;
        this.isId = false;
        this.isReassigned = false;
        this.kind = null;
        this.renderBaseName = null;
        this.renderName = null;
      }
      addReference(_identifier) {
      }
      getBaseVariableName() {
        return this.renderBaseName || this.renderName || this.name;
      }
      getName(getPropertyAccess) {
        const name = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;
      }
      hasEffectsWhenAccessedAtPath(path4, _context) {
        return path4.length > 0;
      }
      include() {
        this.included = true;
      }
      markCalledFromTryStatement() {
      }
      setRenderNames(baseName, name) {
        this.renderBaseName = baseName;
        this.renderName = name;
      }
    };
    ExternalVariable = class extends Variable {
      constructor(module2, name) {
        super(name);
        this.referenced = false;
        this.module = module2;
        this.isNamespace = name === "*";
      }
      addReference(identifier) {
        this.referenced = true;
        if (this.name === "default" || this.name === "*") {
          this.module.suggestName(identifier.name);
        }
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > (this.isNamespace ? 1 : 0);
      }
      include() {
        if (!this.included) {
          this.included = true;
          this.module.used = true;
        }
      }
    };
    BLANK = Object.freeze(/* @__PURE__ */ Object.create(null));
    EMPTY_OBJECT = Object.freeze({});
    EMPTY_ARRAY = Object.freeze([]);
    ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
    RELATIVE_PATH_REGEX = /^\.?\.(\/|$)/;
    BACKSLASH_REGEX = /\\/g;
    UPPER_DIR_REGEX = /^(\.\.\/)*\.\.$/;
    (function(Errors2) {
      Errors2["ALREADY_CLOSED"] = "ALREADY_CLOSED";
      Errors2["ASSET_NOT_FINALISED"] = "ASSET_NOT_FINALISED";
      Errors2["ASSET_NOT_FOUND"] = "ASSET_NOT_FOUND";
      Errors2["ASSET_SOURCE_ALREADY_SET"] = "ASSET_SOURCE_ALREADY_SET";
      Errors2["ASSET_SOURCE_MISSING"] = "ASSET_SOURCE_MISSING";
      Errors2["BAD_LOADER"] = "BAD_LOADER";
      Errors2["CANNOT_EMIT_FROM_OPTIONS_HOOK"] = "CANNOT_EMIT_FROM_OPTIONS_HOOK";
      Errors2["CHUNK_NOT_GENERATED"] = "CHUNK_NOT_GENERATED";
      Errors2["CHUNK_INVALID"] = "CHUNK_INVALID";
      Errors2["CIRCULAR_REEXPORT"] = "CIRCULAR_REEXPORT";
      Errors2["CYCLIC_CROSS_CHUNK_REEXPORT"] = "CYCLIC_CROSS_CHUNK_REEXPORT";
      Errors2["DEPRECATED_FEATURE"] = "DEPRECATED_FEATURE";
      Errors2["EXTERNAL_SYNTHETIC_EXPORTS"] = "EXTERNAL_SYNTHETIC_EXPORTS";
      Errors2["FILE_NAME_CONFLICT"] = "FILE_NAME_CONFLICT";
      Errors2["FILE_NOT_FOUND"] = "FILE_NOT_FOUND";
      Errors2["INPUT_HOOK_IN_OUTPUT_PLUGIN"] = "INPUT_HOOK_IN_OUTPUT_PLUGIN";
      Errors2["INVALID_CHUNK"] = "INVALID_CHUNK";
      Errors2["INVALID_EXPORT_OPTION"] = "INVALID_EXPORT_OPTION";
      Errors2["INVALID_EXTERNAL_ID"] = "INVALID_EXTERNAL_ID";
      Errors2["INVALID_OPTION"] = "INVALID_OPTION";
      Errors2["INVALID_PLUGIN_HOOK"] = "INVALID_PLUGIN_HOOK";
      Errors2["INVALID_ROLLUP_PHASE"] = "INVALID_ROLLUP_PHASE";
      Errors2["MISSING_EXPORT"] = "MISSING_EXPORT";
      Errors2["MISSING_IMPLICIT_DEPENDANT"] = "MISSING_IMPLICIT_DEPENDANT";
      Errors2["MIXED_EXPORTS"] = "MIXED_EXPORTS";
      Errors2["NAMESPACE_CONFLICT"] = "NAMESPACE_CONFLICT";
      Errors2["AMBIGUOUS_EXTERNAL_NAMESPACES"] = "AMBIGUOUS_EXTERNAL_NAMESPACES";
      Errors2["NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE"] = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE";
      Errors2["PLUGIN_ERROR"] = "PLUGIN_ERROR";
      Errors2["PREFER_NAMED_EXPORTS"] = "PREFER_NAMED_EXPORTS";
      Errors2["SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT"] = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT";
      Errors2["UNEXPECTED_NAMED_IMPORT"] = "UNEXPECTED_NAMED_IMPORT";
      Errors2["UNRESOLVED_ENTRY"] = "UNRESOLVED_ENTRY";
      Errors2["UNRESOLVED_IMPORT"] = "UNRESOLVED_IMPORT";
      Errors2["VALIDATION_ERROR"] = "VALIDATION_ERROR";
    })(Errors || (Errors = {}));
    RESERVED_NAMES = /* @__PURE__ */ new Set([
      "await",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "NaN",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "static",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "undefined",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ]);
    RESERVED_NAMES$1 = RESERVED_NAMES;
    illegalCharacters = /[^$_a-zA-Z0-9]/g;
    startsWithDigit = (str) => /\d/.test(str[0]);
    ExternalModule = class {
      constructor(options, id, moduleSideEffects, meta, renormalizeRenderPath) {
        this.options = options;
        this.id = id;
        this.renormalizeRenderPath = renormalizeRenderPath;
        this.declarations = /* @__PURE__ */ new Map();
        this.defaultVariableName = "";
        this.dynamicImporters = [];
        this.execIndex = Infinity;
        this.exportedVariables = /* @__PURE__ */ new Map();
        this.importers = [];
        this.mostCommonSuggestion = 0;
        this.nameSuggestions = /* @__PURE__ */ new Map();
        this.namespaceVariableName = "";
        this.reexported = false;
        this.renderPath = void 0;
        this.used = false;
        this.variableName = "";
        this.suggestedVariableName = makeLegal(id.split(/[\\/]/).pop());
        const { importers, dynamicImporters } = this;
        const info = this.info = {
          ast: null,
          code: null,
          dynamicallyImportedIdResolutions: EMPTY_ARRAY,
          dynamicallyImportedIds: EMPTY_ARRAY,
          get dynamicImporters() {
            return dynamicImporters.sort();
          },
          hasDefaultExport: null,
          get hasModuleSideEffects() {
            warnDeprecation("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.", false, options);
            return info.moduleSideEffects;
          },
          id,
          implicitlyLoadedAfterOneOf: EMPTY_ARRAY,
          implicitlyLoadedBefore: EMPTY_ARRAY,
          importedIdResolutions: EMPTY_ARRAY,
          importedIds: EMPTY_ARRAY,
          get importers() {
            return importers.sort();
          },
          isEntry: false,
          isExternal: true,
          isIncluded: null,
          meta,
          moduleSideEffects,
          syntheticNamedExports: false
        };
        Object.defineProperty(this.info, "hasModuleSideEffects", {
          enumerable: false
        });
      }
      getVariableForExportName(name) {
        const declaration = this.declarations.get(name);
        if (declaration)
          return [declaration];
        const externalVariable = new ExternalVariable(this, name);
        this.declarations.set(name, externalVariable);
        this.exportedVariables.set(externalVariable, name);
        return [externalVariable];
      }
      setRenderPath(options, inputBase) {
        this.renderPath = typeof options.paths === "function" ? options.paths(this.id) : options.paths[this.id];
        if (!this.renderPath) {
          this.renderPath = this.renormalizeRenderPath ? normalize((0, import_path.relative)(inputBase, this.id)) : this.id;
        }
      }
      suggestName(name) {
        var _a;
        const value = ((_a = this.nameSuggestions.get(name)) !== null && _a !== void 0 ? _a : 0) + 1;
        this.nameSuggestions.set(name, value);
        if (value > this.mostCommonSuggestion) {
          this.mostCommonSuggestion = value;
          this.suggestedVariableName = name;
        }
      }
      warnUnusedImports() {
        const unused = Array.from(this.declarations).filter(([name, declaration]) => name !== "*" && !declaration.included && !this.reexported && !declaration.referenced).map(([name]) => name);
        if (unused.length === 0)
          return;
        const importersSet = /* @__PURE__ */ new Set();
        for (const name of unused) {
          for (const importer of this.declarations.get(name).module.importers) {
            importersSet.add(importer);
          }
        }
        const importersArray = [...importersSet];
        this.options.onwarn({
          code: "UNUSED_EXTERNAL_IMPORT",
          message: `${printQuotedStringList(unused, ["is", "are"])} imported from external module "${this.id}" but never used in ${printQuotedStringList(importersArray.map((importer) => relativeId(importer)))}.`,
          names: unused,
          source: this.id,
          sources: importersArray
        });
      }
    };
    utils$3 = {};
    path$1 = import_path.default;
    WIN_SLASH = "\\\\/";
    WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    DOT_LITERAL = "\\.";
    PLUS_LITERAL = "\\+";
    QMARK_LITERAL = "\\?";
    SLASH_LITERAL = "\\/";
    ONE_CHAR = "(?=.)";
    QMARK = "[^/]";
    END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    NO_DOT = `(?!${DOT_LITERAL})`;
    NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    STAR = `${QMARK}*?`;
    POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    constants$2 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path$1.sep,
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports) {
      const path4 = import_path.default;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$2;
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.isWindows = (options) => {
        if (options && typeof options.windows === "boolean") {
          return options.windows;
        }
        return win322 === true || path4.sep === "\\";
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend3 = options.contains ? "" : "^";
        const append3 = options.contains ? "" : "$";
        let output = `${prepend3}(?:${input})${append3}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$3);
    utils$2 = utils$3;
    ({
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = constants$2);
    isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    scan$1 = (input, options) => {
      const opts = options || {};
      const length3 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length3;
      const peek = () => str.charCodeAt(index + 1);
      const advance3 = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length3) {
        code = advance3();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance3();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance3())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance3()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance3())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance3();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance3())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance3())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance3();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base2 = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base2 = "";
        glob = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils$2.removeBackslashes(glob);
        if (base2 && backslashes === true) {
          base2 = utils$2.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    scan_1 = scan$1;
    constants$1 = constants$2;
    utils$1 = utils$3;
    ({
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$1);
    expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      return value;
    };
    syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    parse$1 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$1.isWindows(options);
      const PLATFORM_CHARS = constants$1.globChars(win322);
      const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$1.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance3 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append3 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance3();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append3(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR2 });
        push({ type: "paren", extglob: true, value: advance3(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$1(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$1.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance3();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance3();
          } else {
            value += advance3();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance3();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append3({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils$1.escapeRegex(value);
          prev.value += value;
          append3({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append3({ value });
          if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils$1.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL2 });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL2 });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL2 });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils$1.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT2 });
            continue;
          }
          push({ type: "qmark", value, output: QMARK2 });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance3());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance3());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$1.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$1.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$1.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$1.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils$1.isWindows(options);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$1.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL2 + match[2];
          }
        }
      };
      const output = utils$1.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL2}?`;
      }
      return source;
    };
    parse_1 = parse$1;
    path = import_path.default;
    scan = scan_1;
    parse = parse_1;
    utils = utils$3;
    constants = constants$2;
    isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    picomatch$1 = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch$1(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = utils.isWindows(options);
      const regex = isState ? picomatch$1.compileRe(glob, options) : picomatch$1.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch$1(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch$1.test(input, regex, options, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch$1.test = (input, regex, options, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch$1.matchBase(input, regex, options, posix3);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch$1.matchBase = (input, glob, options, posix3 = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch$1.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch$1.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);
    picomatch$1.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch$1.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch$1.scan = (input, options) => scan(input, options);
    picomatch$1.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend3 = opts.contains ? "" : "^";
      const append3 = opts.contains ? "" : "$";
      let source = `${prepend3}(?:${state.output})${append3}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch$1.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch$1.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch$1.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch$1.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch$1.constants = constants;
    extractors = {
      ArrayPattern(names, param) {
        for (const element of param.elements) {
          if (element)
            extractors[element.type](names, element);
        }
      },
      AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
      },
      Identifier(names, param) {
        names.push(param.name);
      },
      MemberExpression() {
      },
      ObjectPattern(names, param) {
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractors.RestElement(names, prop);
          } else {
            extractors[prop.value.type](names, prop.value);
          }
        }
      },
      RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
      }
    };
    extractAssignedNames = function extractAssignedNames2(param) {
      const names = [];
      extractors[param.type](names, param);
      return names;
    };
    reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins$1}`.split(" "));
    forbiddenIdentifiers.add("");
    BROKEN_FLOW_NONE = 0;
    BROKEN_FLOW_BREAK_CONTINUE = 1;
    BROKEN_FLOW_ERROR_RETURN_LABEL = 2;
    NO_ARGS = [];
    UNDEFINED_EXPRESSION = new class UndefinedExpression extends ExpressionEntity {
      getLiteralValueAtPath() {
        return void 0;
      }
    }();
    returnsUnknown = {
      value: {
        callsArgs: null,
        returns: UNKNOWN_EXPRESSION
      }
    };
    UNKNOWN_LITERAL_BOOLEAN = new class UnknownBoolean extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path4[0]);
        }
        return UNKNOWN_EXPRESSION;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length === 1) {
          return hasMemberEffectWhenCalled(literalBooleanMembers, path4[0], callOptions, context);
        }
        return true;
      }
    }();
    returnsBoolean = {
      value: {
        callsArgs: null,
        returns: UNKNOWN_LITERAL_BOOLEAN
      }
    };
    UNKNOWN_LITERAL_NUMBER = new class UnknownNumber extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalNumberMembers, path4[0]);
        }
        return UNKNOWN_EXPRESSION;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length === 1) {
          return hasMemberEffectWhenCalled(literalNumberMembers, path4[0], callOptions, context);
        }
        return true;
      }
    }();
    returnsNumber = {
      value: {
        callsArgs: null,
        returns: UNKNOWN_LITERAL_NUMBER
      }
    };
    UNKNOWN_LITERAL_STRING = new class UnknownString extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalStringMembers, path4[0]);
        }
        return UNKNOWN_EXPRESSION;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length === 1) {
          return hasMemberEffectWhenCalled(literalStringMembers, path4[0], callOptions, context);
        }
        return true;
      }
    }();
    returnsString = {
      value: {
        callsArgs: null,
        returns: UNKNOWN_LITERAL_STRING
      }
    };
    objectMembers = assembleMemberDescriptions({
      hasOwnProperty: returnsBoolean,
      isPrototypeOf: returnsBoolean,
      propertyIsEnumerable: returnsBoolean,
      toLocaleString: returnsString,
      toString: returnsString,
      valueOf: returnsUnknown
    });
    literalBooleanMembers = assembleMemberDescriptions({
      valueOf: returnsBoolean
    }, objectMembers);
    literalNumberMembers = assembleMemberDescriptions({
      toExponential: returnsString,
      toFixed: returnsString,
      toLocaleString: returnsString,
      toPrecision: returnsString,
      valueOf: returnsNumber
    }, objectMembers);
    literalStringMembers = assembleMemberDescriptions({
      anchor: returnsString,
      at: returnsUnknown,
      big: returnsString,
      blink: returnsString,
      bold: returnsString,
      charAt: returnsString,
      charCodeAt: returnsNumber,
      codePointAt: returnsUnknown,
      concat: returnsString,
      endsWith: returnsBoolean,
      fixed: returnsString,
      fontcolor: returnsString,
      fontsize: returnsString,
      includes: returnsBoolean,
      indexOf: returnsNumber,
      italics: returnsString,
      lastIndexOf: returnsNumber,
      link: returnsString,
      localeCompare: returnsNumber,
      match: returnsUnknown,
      matchAll: returnsUnknown,
      normalize: returnsString,
      padEnd: returnsString,
      padStart: returnsString,
      repeat: returnsString,
      replace: {
        value: {
          callsArgs: [1],
          returns: UNKNOWN_LITERAL_STRING
        }
      },
      replaceAll: {
        value: {
          callsArgs: [1],
          returns: UNKNOWN_LITERAL_STRING
        }
      },
      search: returnsNumber,
      slice: returnsString,
      small: returnsString,
      split: returnsUnknown,
      startsWith: returnsBoolean,
      strike: returnsString,
      sub: returnsString,
      substr: returnsString,
      substring: returnsString,
      sup: returnsString,
      toLocaleLowerCase: returnsString,
      toLocaleUpperCase: returnsString,
      toLowerCase: returnsString,
      toString: returnsString,
      toUpperCase: returnsString,
      trim: returnsString,
      trimEnd: returnsString,
      trimLeft: returnsString,
      trimRight: returnsString,
      trimStart: returnsString,
      valueOf: returnsString
    }, objectMembers);
    base$1 = {};
    base$1.Program = base$1.BlockStatement = base$1.StaticBlock = function(node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var stmt = list[i];
        c(stmt, st, "Statement");
      }
    };
    base$1.Statement = skipThrough;
    base$1.EmptyStatement = ignore;
    base$1.ExpressionStatement = base$1.ParenthesizedExpression = base$1.ChainExpression = function(node, st, c) {
      return c(node.expression, st, "Expression");
    };
    base$1.IfStatement = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Statement");
      if (node.alternate) {
        c(node.alternate, st, "Statement");
      }
    };
    base$1.LabeledStatement = function(node, st, c) {
      return c(node.body, st, "Statement");
    };
    base$1.BreakStatement = base$1.ContinueStatement = ignore;
    base$1.WithStatement = function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.SwitchStatement = function(node, st, c) {
      c(node.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];
        if (cs.test) {
          c(cs.test, st, "Expression");
        }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      }
    };
    base$1.SwitchCase = function(node, st, c) {
      if (node.test) {
        c(node.test, st, "Expression");
      }
      for (var i = 0, list = node.consequent; i < list.length; i += 1) {
        var cons = list[i];
        c(cons, st, "Statement");
      }
    };
    base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function(node, st, c) {
      if (node.argument) {
        c(node.argument, st, "Expression");
      }
    };
    base$1.ThrowStatement = base$1.SpreadElement = function(node, st, c) {
      return c(node.argument, st, "Expression");
    };
    base$1.TryStatement = function(node, st, c) {
      c(node.block, st, "Statement");
      if (node.handler) {
        c(node.handler, st);
      }
      if (node.finalizer) {
        c(node.finalizer, st, "Statement");
      }
    };
    base$1.CatchClause = function(node, st, c) {
      if (node.param) {
        c(node.param, st, "Pattern");
      }
      c(node.body, st, "Statement");
    };
    base$1.WhileStatement = base$1.DoWhileStatement = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.ForStatement = function(node, st, c) {
      if (node.init) {
        c(node.init, st, "ForInit");
      }
      if (node.test) {
        c(node.test, st, "Expression");
      }
      if (node.update) {
        c(node.update, st, "Expression");
      }
      c(node.body, st, "Statement");
    };
    base$1.ForInStatement = base$1.ForOfStatement = function(node, st, c) {
      c(node.left, st, "ForInit");
      c(node.right, st, "Expression");
      c(node.body, st, "Statement");
    };
    base$1.ForInit = function(node, st, c) {
      if (node.type === "VariableDeclaration") {
        c(node, st);
      } else {
        c(node, st, "Expression");
      }
    };
    base$1.DebuggerStatement = ignore;
    base$1.FunctionDeclaration = function(node, st, c) {
      return c(node, st, "Function");
    };
    base$1.VariableDeclaration = function(node, st, c) {
      for (var i = 0, list = node.declarations; i < list.length; i += 1) {
        var decl = list[i];
        c(decl, st);
      }
    };
    base$1.VariableDeclarator = function(node, st, c) {
      c(node.id, st, "Pattern");
      if (node.init) {
        c(node.init, st, "Expression");
      }
    };
    base$1.Function = function(node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      for (var i = 0, list = node.params; i < list.length; i += 1) {
        var param = list[i];
        c(param, st, "Pattern");
      }
      c(node.body, st, node.expression ? "Expression" : "Statement");
    };
    base$1.Pattern = function(node, st, c) {
      if (node.type === "Identifier") {
        c(node, st, "VariablePattern");
      } else if (node.type === "MemberExpression") {
        c(node, st, "MemberPattern");
      } else {
        c(node, st);
      }
    };
    base$1.VariablePattern = ignore;
    base$1.MemberPattern = skipThrough;
    base$1.RestElement = function(node, st, c) {
      return c(node.argument, st, "Pattern");
    };
    base$1.ArrayPattern = function(node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Pattern");
        }
      }
    };
    base$1.ObjectPattern = function(node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        if (prop.type === "Property") {
          if (prop.computed) {
            c(prop.key, st, "Expression");
          }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };
    base$1.Expression = skipThrough;
    base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
    base$1.ArrayExpression = function(node, st, c) {
      for (var i = 0, list = node.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Expression");
        }
      }
    };
    base$1.ObjectExpression = function(node, st, c) {
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        c(prop, st);
      }
    };
    base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
    base$1.SequenceExpression = function(node, st, c) {
      for (var i = 0, list = node.expressions; i < list.length; i += 1) {
        var expr = list[i];
        c(expr, st, "Expression");
      }
    };
    base$1.TemplateLiteral = function(node, st, c) {
      for (var i = 0, list = node.quasis; i < list.length; i += 1) {
        var quasi = list[i];
        c(quasi, st);
      }
      for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
        var expr = list$1[i$1];
        c(expr, st, "Expression");
      }
    };
    base$1.TemplateElement = ignore;
    base$1.UnaryExpression = base$1.UpdateExpression = function(node, st, c) {
      c(node.argument, st, "Expression");
    };
    base$1.BinaryExpression = base$1.LogicalExpression = function(node, st, c) {
      c(node.left, st, "Expression");
      c(node.right, st, "Expression");
    };
    base$1.AssignmentExpression = base$1.AssignmentPattern = function(node, st, c) {
      c(node.left, st, "Pattern");
      c(node.right, st, "Expression");
    };
    base$1.ConditionalExpression = function(node, st, c) {
      c(node.test, st, "Expression");
      c(node.consequent, st, "Expression");
      c(node.alternate, st, "Expression");
    };
    base$1.NewExpression = base$1.CallExpression = function(node, st, c) {
      c(node.callee, st, "Expression");
      if (node.arguments) {
        for (var i = 0, list = node.arguments; i < list.length; i += 1) {
          var arg = list[i];
          c(arg, st, "Expression");
        }
      }
    };
    base$1.MemberExpression = function(node, st, c) {
      c(node.object, st, "Expression");
      if (node.computed) {
        c(node.property, st, "Expression");
      }
    };
    base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function(node, st, c) {
      if (node.declaration) {
        c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
      }
      if (node.source) {
        c(node.source, st, "Expression");
      }
    };
    base$1.ExportAllDeclaration = function(node, st, c) {
      if (node.exported) {
        c(node.exported, st);
      }
      c(node.source, st, "Expression");
    };
    base$1.ImportDeclaration = function(node, st, c) {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        c(spec, st);
      }
      c(node.source, st, "Expression");
    };
    base$1.ImportExpression = function(node, st, c) {
      c(node.source, st, "Expression");
    };
    base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.PrivateIdentifier = base$1.Literal = ignore;
    base$1.TaggedTemplateExpression = function(node, st, c) {
      c(node.tag, st, "Expression");
      c(node.quasi, st, "Expression");
    };
    base$1.ClassDeclaration = base$1.ClassExpression = function(node, st, c) {
      return c(node, st, "Class");
    };
    base$1.Class = function(node, st, c) {
      if (node.id) {
        c(node.id, st, "Pattern");
      }
      if (node.superClass) {
        c(node.superClass, st, "Expression");
      }
      c(node.body, st);
    };
    base$1.ClassBody = function(node, st, c) {
      for (var i = 0, list = node.body; i < list.length; i += 1) {
        var elt = list[i];
        c(elt, st);
      }
    };
    base$1.MethodDefinition = base$1.PropertyDefinition = base$1.Property = function(node, st, c) {
      if (node.computed) {
        c(node.key, st, "Expression");
      }
      if (node.value) {
        c(node.value, st, "Expression");
      }
    };
    ArrowFunctionExpression$1 = "ArrowFunctionExpression";
    BinaryExpression$1 = "BinaryExpression";
    BlockStatement$1 = "BlockStatement";
    CallExpression$1 = "CallExpression";
    ChainExpression$1 = "ChainExpression";
    ConditionalExpression$1 = "ConditionalExpression";
    ExpressionStatement$1 = "ExpressionStatement";
    Identifier$1 = "Identifier";
    ImportDefaultSpecifier$1 = "ImportDefaultSpecifier";
    ImportNamespaceSpecifier$1 = "ImportNamespaceSpecifier";
    LogicalExpression$1 = "LogicalExpression";
    NewExpression$1 = "NewExpression";
    Program$1 = "Program";
    Property$1 = "Property";
    ReturnStatement$1 = "ReturnStatement";
    SequenceExpression$1 = "SequenceExpression";
    SOURCEMAPPING_URL = "sourceMa";
    SOURCEMAPPING_URL += "ppingURL";
    whiteSpaceNoNewline = "[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]";
    SOURCEMAPPING_URL_RE = new RegExp(`^#${whiteSpaceNoNewline}+${SOURCEMAPPING_URL}=.+`);
    ANNOTATION_KEY = "_rollupAnnotations";
    INVALID_COMMENT_KEY = "_rollupRemoved";
    neitherWithespaceNorBrackets = /[^\s(]/g;
    noWhitespace = /\S/g;
    pureCommentRegex = /[@#]__PURE__/;
    keys = {
      Literal: [],
      Program: ["body"]
    };
    INCLUDE_PARAMETERS = "variables";
    NodeBase = class extends ExpressionEntity {
      constructor(esTreeNode, parent, parentScope) {
        super();
        this.esTreeNode = esTreeNode;
        this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
        this.parent = parent;
        this.context = parent.context;
        this.createScope(parentScope);
        this.parseNode(esTreeNode);
        this.initialise();
        this.context.magicString.addSourcemapLocation(this.start);
        this.context.magicString.addSourcemapLocation(this.end);
      }
      addExportedVariables(_variables, _exportNamesByVariable) {
      }
      bind() {
        for (const key of this.keys) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              if (child !== null)
                child.bind();
            }
          } else {
            value.bind();
          }
        }
      }
      createScope(parentScope) {
        this.scope = parentScope;
      }
      hasEffects(context) {
        if (this.deoptimized === false)
          this.applyDeoptimizations();
        for (const key of this.keys) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              if (child !== null && child.hasEffects(context))
                return true;
            }
          } else if (value.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        if (this.deoptimized === false)
          this.applyDeoptimizations();
        this.included = true;
        for (const key of this.keys) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              if (child !== null)
                child.include(context, includeChildrenRecursively);
            }
          } else {
            value.include(context, includeChildrenRecursively);
          }
        }
      }
      includeAsSingleStatement(context, includeChildrenRecursively) {
        this.include(context, includeChildrenRecursively);
      }
      initialise() {
      }
      insertSemicolon(code) {
        if (code.original[this.end - 1] !== ";") {
          code.appendLeft(this.end, ";");
        }
      }
      parseNode(esTreeNode) {
        for (const [key, value] of Object.entries(esTreeNode)) {
          if (this.hasOwnProperty(key))
            continue;
          if (key.charCodeAt(0) === 95) {
            if (key === ANNOTATION_KEY) {
              this.annotations = value;
            } else if (key === INVALID_COMMENT_KEY) {
              for (const { start, end } of value)
                this.context.magicString.remove(start, end);
            }
          } else if (typeof value !== "object" || value === null) {
            this[key] = value;
          } else if (Array.isArray(value)) {
            this[key] = [];
            for (const child of value) {
              this[key].push(child === null ? null : new (this.context.getNodeConstructor(child.type))(child, this, this.scope));
            }
          } else {
            this[key] = new (this.context.getNodeConstructor(value.type))(value, this, this.scope);
          }
        }
      }
      render(code, options) {
        for (const key of this.keys) {
          const value = this[key];
          if (value === null)
            continue;
          if (Array.isArray(value)) {
            for (const child of value) {
              if (child !== null)
                child.render(code, options);
            }
          } else {
            value.render(code, options);
          }
        }
      }
      shouldBeIncluded(context) {
        return this.included || !context.brokenFlow && this.hasEffects(createHasEffectsContext());
      }
      applyDeoptimizations() {
      }
    };
    SpreadElement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        if (path4.length > 0) {
          this.argument.deoptimizeThisOnEventAtPath(event, [UnknownKey, ...path4], thisParameter, recursionTracker);
        }
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const { propertyReadSideEffects } = this.context.options.treeshake;
        return this.argument.hasEffects(context) || propertyReadSideEffects && (propertyReadSideEffects === "always" || this.argument.hasEffectsWhenAccessedAtPath(UNKNOWN_PATH, context));
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
        this.context.requestTreeshakingPass();
      }
    };
    EVENT_ACCESSED = 0;
    EVENT_ASSIGNED = 1;
    EVENT_CALLED = 2;
    Method = class extends ExpressionEntity {
      constructor(description) {
        super();
        this.description = description;
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter) {
        if (event === EVENT_CALLED && path4.length === 0 && this.description.mutatesSelfAsArray) {
          thisParameter.deoptimizePath(UNKNOWN_INTEGER_PATH);
        }
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions) {
        if (path4.length > 0) {
          return UNKNOWN_EXPRESSION;
        }
        return this.description.returnsPrimitive || (this.description.returns === "self" ? callOptions.thisParam || UNKNOWN_EXPRESSION : this.description.returns());
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenAssignedAtPath(path4) {
        return path4.length > 0;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        var _a, _b;
        if (path4.length > 0 || this.description.mutatesSelfAsArray === true && ((_a = callOptions.thisParam) === null || _a === void 0 ? void 0 : _a.hasEffectsWhenAssignedAtPath(UNKNOWN_INTEGER_PATH, context))) {
          return true;
        }
        if (!this.description.callsArgs) {
          return false;
        }
        for (const argIndex of this.description.callsArgs) {
          if ((_b = callOptions.args[argIndex]) === null || _b === void 0 ? void 0 : _b.hasEffectsWhenCalledAtPath(EMPTY_PATH, {
            args: NO_ARGS,
            thisParam: null,
            withNew: false
          }, context)) {
            return true;
          }
        }
        return false;
      }
      includeCallArguments(context, args) {
        for (const arg of args) {
          arg.include(context, false);
        }
      }
    };
    METHOD_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_RETURNS_STRING = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_STRING
      })
    ];
    METHOD_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    INTEGER_REG_EXP = /^\d+$/;
    ObjectEntity = class extends ExpressionEntity {
      constructor(properties, prototypeExpression, immutable = false) {
        super();
        this.prototypeExpression = prototypeExpression;
        this.immutable = immutable;
        this.allProperties = [];
        this.deoptimizedPaths = /* @__PURE__ */ Object.create(null);
        this.expressionsToBeDeoptimizedByKey = /* @__PURE__ */ Object.create(null);
        this.gettersByKey = /* @__PURE__ */ Object.create(null);
        this.hasUnknownDeoptimizedInteger = false;
        this.hasUnknownDeoptimizedProperty = false;
        this.propertiesAndGettersByKey = /* @__PURE__ */ Object.create(null);
        this.propertiesAndSettersByKey = /* @__PURE__ */ Object.create(null);
        this.settersByKey = /* @__PURE__ */ Object.create(null);
        this.thisParametersToBeDeoptimized = /* @__PURE__ */ new Set();
        this.unknownIntegerProps = [];
        this.unmatchableGetters = [];
        this.unmatchablePropertiesAndGetters = [];
        this.unmatchableSetters = [];
        if (Array.isArray(properties)) {
          this.buildPropertyMaps(properties);
        } else {
          this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
          for (const propertiesForKey of Object.values(properties)) {
            this.allProperties.push(...propertiesForKey);
          }
        }
      }
      deoptimizeAllProperties() {
        var _a;
        if (this.hasUnknownDeoptimizedProperty) {
          return;
        }
        this.hasUnknownDeoptimizedProperty = true;
        for (const properties of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey))) {
          for (const property of properties) {
            property.deoptimizePath(UNKNOWN_PATH);
          }
        }
        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath([UnknownKey, UnknownKey]);
        this.deoptimizeCachedEntities();
      }
      deoptimizeIntegerProperties() {
        if (this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger) {
          return;
        }
        this.hasUnknownDeoptimizedInteger = true;
        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const property of propertiesAndGetters) {
              property.deoptimizePath(UNKNOWN_PATH);
            }
          }
        }
        this.deoptimizeCachedIntegerEntities();
      }
      deoptimizePath(path4) {
        var _a;
        if (this.hasUnknownDeoptimizedProperty || this.immutable)
          return;
        const key = path4[0];
        if (path4.length === 1) {
          if (typeof key !== "string") {
            if (key === UnknownInteger) {
              return this.deoptimizeIntegerProperties();
            }
            return this.deoptimizeAllProperties();
          }
          if (!this.deoptimizedPaths[key]) {
            this.deoptimizedPaths[key] = true;
            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
            if (expressionsToBeDeoptimized) {
              for (const expression of expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
              }
            }
          }
        }
        const subPath = path4.length === 1 ? UNKNOWN_PATH : path4.slice(1);
        for (const property of typeof key === "string" ? (this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters).concat(this.settersByKey[key] || this.unmatchableSetters) : this.allProperties) {
          property.deoptimizePath(subPath);
        }
        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path4.length === 1 ? [UnknownKey, UnknownKey] : path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        var _a;
        const [key, ...subPath] = path4;
        if (this.hasUnknownDeoptimizedProperty || (event === EVENT_CALLED || path4.length > 1) && typeof key === "string" && this.deoptimizedPaths[key]) {
          thisParameter.deoptimizePath(UNKNOWN_PATH);
          return;
        }
        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = event === EVENT_CALLED || path4.length > 1 ? [
          this.propertiesAndGettersByKey,
          this.propertiesAndGettersByKey,
          this.unmatchablePropertiesAndGetters
        ] : event === EVENT_ACCESSED ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof key === "string") {
          if (propertiesForExactMatchByKey[key]) {
            const properties = relevantPropertiesByKey[key];
            if (properties) {
              for (const property of properties) {
                property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
              }
            }
            if (!this.immutable) {
              this.thisParametersToBeDeoptimized.add(thisParameter);
            }
            return;
          }
          for (const property of relevantUnmatchableProperties) {
            property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
          }
          if (INTEGER_REG_EXP.test(key)) {
            for (const property of this.unknownIntegerProps) {
              property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
            }
          }
        } else {
          for (const properties of Object.values(relevantPropertiesByKey).concat([
            relevantUnmatchableProperties
          ])) {
            for (const property of properties) {
              property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
            }
          }
          for (const property of this.unknownIntegerProps) {
            property.deoptimizeThisOnEventAtPath(event, subPath, thisParameter, recursionTracker);
          }
        }
        if (!this.immutable) {
          this.thisParametersToBeDeoptimized.add(thisParameter);
        }
        (_a = this.prototypeExpression) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (path4.length === 0) {
          return UnknownValue;
        }
        const key = path4[0];
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getLiteralValueAtPath(path4.slice(1), recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getLiteralValueAtPath(path4, recursionTracker, origin);
        }
        if (path4.length === 1) {
          return void 0;
        }
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        if (path4.length === 0) {
          return UNKNOWN_EXPRESSION;
        }
        const key = path4[0];
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getReturnExpressionWhenCalledAtPath(path4.slice(1), callOptions, recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
        }
        return UNKNOWN_EXPRESSION;
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        const [key, ...subPath] = path4;
        if (path4.length > 1) {
          if (typeof key !== "string") {
            return true;
          }
          const expressionAtPath = this.getMemberExpression(key);
          if (expressionAtPath) {
            return expressionAtPath.hasEffectsWhenAccessedAtPath(subPath, context);
          }
          if (this.prototypeExpression) {
            return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path4, context);
          }
          return true;
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof key === "string") {
          if (this.propertiesAndGettersByKey[key]) {
            const getters = this.gettersByKey[key];
            if (getters) {
              for (const getter of getters) {
                if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
                  return true;
              }
            }
            return false;
          }
          for (const getter of this.unmatchableGetters) {
            if (getter.hasEffectsWhenAccessedAtPath(subPath, context)) {
              return true;
            }
          }
        } else {
          for (const getters of Object.values(this.gettersByKey).concat([this.unmatchableGetters])) {
            for (const getter of getters) {
              if (getter.hasEffectsWhenAccessedAtPath(subPath, context))
                return true;
            }
          }
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.hasEffectsWhenAccessedAtPath(path4, context);
        }
        return false;
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        const [key, ...subPath] = path4;
        if (path4.length > 1) {
          if (typeof key !== "string") {
            return true;
          }
          const expressionAtPath = this.getMemberExpression(key);
          if (expressionAtPath) {
            return expressionAtPath.hasEffectsWhenAssignedAtPath(subPath, context);
          }
          if (this.prototypeExpression) {
            return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path4, context);
          }
          return true;
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof key === "string") {
          if (this.propertiesAndSettersByKey[key]) {
            const setters = this.settersByKey[key];
            if (setters) {
              for (const setter of setters) {
                if (setter.hasEffectsWhenAssignedAtPath(subPath, context))
                  return true;
              }
            }
            return false;
          }
          for (const property of this.unmatchableSetters) {
            if (property.hasEffectsWhenAssignedAtPath(subPath, context)) {
              return true;
            }
          }
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.hasEffectsWhenAssignedAtPath(path4, context);
        }
        return false;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        const key = path4[0];
        const expressionAtPath = this.getMemberExpression(key);
        if (expressionAtPath) {
          return expressionAtPath.hasEffectsWhenCalledAtPath(path4.slice(1), callOptions, context);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.hasEffectsWhenCalledAtPath(path4, callOptions, context);
        }
        return true;
      }
      buildPropertyMaps(properties) {
        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
        const unmatchablePropertiesAndSetters = [];
        for (let index = properties.length - 1; index >= 0; index--) {
          const { key, kind, property } = properties[index];
          allProperties.push(property);
          if (typeof key !== "string") {
            if (key === UnknownInteger) {
              unknownIntegerProps.push(property);
              continue;
            }
            if (kind === "set")
              unmatchableSetters.push(property);
            if (kind === "get")
              unmatchableGetters.push(property);
            if (kind !== "get")
              unmatchablePropertiesAndSetters.push(property);
            if (kind !== "set")
              unmatchablePropertiesAndGetters.push(property);
          } else {
            if (kind === "set") {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
                settersByKey[key] = [property, ...unmatchableSetters];
              }
            } else if (kind === "get") {
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
                gettersByKey[key] = [property, ...unmatchableGetters];
              }
            } else {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
              }
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
              }
            }
          }
        }
      }
      deoptimizeCachedEntities() {
        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
        for (const expression of this.thisParametersToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_PATH);
        }
      }
      deoptimizeCachedIntegerEntities() {
        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const expression of expressionsToBeDeoptimized) {
              expression.deoptimizeCache();
            }
          }
        }
        for (const expression of this.thisParametersToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
        }
      }
      getMemberExpression(key) {
        if (this.hasUnknownDeoptimizedProperty || typeof key !== "string" || this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key) || this.deoptimizedPaths[key]) {
          return UNKNOWN_EXPRESSION;
        }
        const properties = this.propertiesAndGettersByKey[key];
        if ((properties === null || properties === void 0 ? void 0 : properties.length) === 1) {
          return properties[0];
        }
        if (properties || this.unmatchablePropertiesAndGetters.length > 0 || this.unknownIntegerProps.length && INTEGER_REG_EXP.test(key)) {
          return UNKNOWN_EXPRESSION;
        }
        return null;
      }
      getMemberExpressionAndTrackDeopt(key, origin) {
        if (typeof key !== "string") {
          return UNKNOWN_EXPRESSION;
        }
        const expression = this.getMemberExpression(key);
        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
          const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key] = this.expressionsToBeDeoptimizedByKey[key] || [];
          expressionsToBeDeoptimized.push(origin);
        }
        return expression;
      }
    };
    isInteger = (prop) => typeof prop === "string" && /^\d+$/.test(prop);
    OBJECT_PROTOTYPE_FALLBACK = new class ObjectPrototypeFallbackExpression extends ExpressionEntity {
      deoptimizeThisOnEventAtPath(event, path4, thisParameter) {
        if (event === EVENT_CALLED && path4.length === 1 && !isInteger(path4[0])) {
          thisParameter.deoptimizePath(UNKNOWN_PATH);
        }
      }
      getLiteralValueAtPath(path4) {
        return path4.length === 1 && isInteger(path4[0]) ? void 0 : UnknownValue;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenAssignedAtPath(path4) {
        return path4.length > 1;
      }
    }();
    OBJECT_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      hasOwnProperty: METHOD_RETURNS_BOOLEAN,
      isPrototypeOf: METHOD_RETURNS_BOOLEAN,
      propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      valueOf: METHOD_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE_FALLBACK, true);
    NEW_ARRAY_PROPERTIES = [
      { key: UnknownInteger, kind: "init", property: UNKNOWN_EXPRESSION },
      { key: "length", kind: "init", property: UNKNOWN_LITERAL_NUMBER }
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    ARRAY_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
      concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
      entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      fill: METHOD_MUTATES_SELF_RETURNS_SELF,
      filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      groupBy: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      groupByToMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      includes: METHOD_RETURNS_BOOLEAN,
      indexOf: METHOD_RETURNS_NUMBER,
      join: METHOD_RETURNS_STRING,
      keys: METHOD_RETURNS_UNKNOWN,
      lastIndexOf: METHOD_RETURNS_NUMBER,
      map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
      reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
      shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
      splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
      values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE, true);
    ArrayExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      deoptimizePath(path4) {
        this.getObjectEntity().deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        const properties = [
          { key: "length", kind: "init", property: UNKNOWN_LITERAL_NUMBER }
        ];
        let hasSpread = false;
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element instanceof SpreadElement || hasSpread) {
            if (element) {
              hasSpread = true;
              properties.unshift({ key: UnknownInteger, kind: "init", property: element });
            }
          } else if (!element) {
            properties.push({ key: String(index), kind: "init", property: UNDEFINED_EXPRESSION });
          } else {
            properties.push({ key: String(index), kind: "init", property: element });
          }
        }
        return this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE);
      }
    };
    ArrayPattern = class extends NodeBase {
      addExportedVariables(variables, exportNamesByVariable) {
        for (const element of this.elements) {
          if (element !== null) {
            element.addExportedVariables(variables, exportNamesByVariable);
          }
        }
      }
      declare(kind) {
        const variables = [];
        for (const element of this.elements) {
          if (element !== null) {
            variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));
          }
        }
        return variables;
      }
      deoptimizePath(path4) {
        if (path4.length === 0) {
          for (const element of this.elements) {
            if (element !== null) {
              element.deoptimizePath(path4);
            }
          }
        }
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        if (path4.length > 0)
          return true;
        for (const element of this.elements) {
          if (element !== null && element.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
            return true;
        }
        return false;
      }
      markDeclarationReached() {
        for (const element of this.elements) {
          if (element !== null) {
            element.markDeclarationReached();
          }
        }
      }
    };
    LocalVariable = class extends Variable {
      constructor(name, declarator, init, context) {
        super(name);
        this.calledFromTryStatement = false;
        this.additionalInitializers = null;
        this.expressionsToBeDeoptimized = [];
        this.declarations = declarator ? [declarator] : [];
        this.init = init;
        this.deoptimizationTracker = context.deoptimizationTracker;
        this.module = context.module;
      }
      addDeclaration(identifier, init) {
        this.declarations.push(identifier);
        const additionalInitializers = this.markInitializersForDeoptimization();
        if (init !== null) {
          additionalInitializers.push(init);
        }
      }
      consolidateInitializers() {
        if (this.additionalInitializers !== null) {
          for (const initializer of this.additionalInitializers) {
            initializer.deoptimizePath(UNKNOWN_PATH);
          }
          this.additionalInitializers = null;
        }
      }
      deoptimizePath(path4) {
        var _a, _b;
        if (this.isReassigned || this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path4, this)) {
          return;
        }
        if (path4.length === 0) {
          if (!this.isReassigned) {
            this.isReassigned = true;
            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
            this.expressionsToBeDeoptimized = [];
            for (const expression of expressionsToBeDeoptimized) {
              expression.deoptimizeCache();
            }
            (_a = this.init) === null || _a === void 0 ? void 0 : _a.deoptimizePath(UNKNOWN_PATH);
          }
        } else {
          (_b = this.init) === null || _b === void 0 ? void 0 : _b.deoptimizePath(path4);
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        if (this.isReassigned || !this.init) {
          return thisParameter.deoptimizePath(UNKNOWN_PATH);
        }
        recursionTracker.withTrackedEntityAtPath(path4, this.init, () => this.init.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker), void 0);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (this.isReassigned || !this.init) {
          return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getLiteralValueAtPath(path4, recursionTracker, origin);
        }, UnknownValue);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        if (this.isReassigned || !this.init) {
          return UNKNOWN_EXPRESSION;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
        }, UNKNOWN_EXPRESSION);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        if (this.isReassigned)
          return true;
        return this.init && !context.accessed.trackEntityAtPathAndGetIfTracked(path4, this) && this.init.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        if (this.included)
          return true;
        if (path4.length === 0)
          return false;
        if (this.isReassigned)
          return true;
        return this.init && !context.accessed.trackEntityAtPathAndGetIfTracked(path4, this) && this.init.hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (this.isReassigned)
          return true;
        return this.init && !(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path4, callOptions, this) && this.init.hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include() {
        if (!this.included) {
          this.included = true;
          for (const declaration of this.declarations) {
            if (!declaration.included)
              declaration.include(createInclusionContext(), false);
            let node = declaration.parent;
            while (!node.included) {
              node.included = true;
              if (node.type === Program$1)
                break;
              node = node.parent;
            }
          }
        }
      }
      includeCallArguments(context, args) {
        if (this.isReassigned || this.init && context.includedCallArguments.has(this.init)) {
          for (const arg of args) {
            arg.include(context, false);
          }
        } else if (this.init) {
          context.includedCallArguments.add(this.init);
          this.init.includeCallArguments(context, args);
          context.includedCallArguments.delete(this.init);
        }
      }
      markCalledFromTryStatement() {
        this.calledFromTryStatement = true;
      }
      markInitializersForDeoptimization() {
        if (this.additionalInitializers === null) {
          this.additionalInitializers = this.init === null ? [] : [this.init];
          this.init = UNKNOWN_EXPRESSION;
          this.isReassigned = true;
        }
        return this.additionalInitializers;
      }
    };
    chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    base = 64;
    Scope$1 = class {
      constructor() {
        this.children = [];
        this.variables = /* @__PURE__ */ new Map();
      }
      addDeclaration(identifier, context, init, _isHoisted) {
        const name = identifier.name;
        let variable = this.variables.get(name);
        if (variable) {
          variable.addDeclaration(identifier, init);
        } else {
          variable = new LocalVariable(identifier.name, identifier, init || UNDEFINED_EXPRESSION, context);
          this.variables.set(name, variable);
        }
        return variable;
      }
      contains(name) {
        return this.variables.has(name);
      }
      findVariable(_name) {
        throw new Error("Internal Error: findVariable needs to be implemented by a subclass");
      }
    };
    ChildScope = class extends Scope$1 {
      constructor(parent) {
        super();
        this.accessedOutsideVariables = /* @__PURE__ */ new Map();
        this.parent = parent;
        parent.children.push(this);
      }
      addAccessedDynamicImport(importExpression) {
        (this.accessedDynamicImports || (this.accessedDynamicImports = /* @__PURE__ */ new Set())).add(importExpression);
        if (this.parent instanceof ChildScope) {
          this.parent.addAccessedDynamicImport(importExpression);
        }
      }
      addAccessedGlobals(globals, accessedGlobalsByScope) {
        const accessedGlobals = accessedGlobalsByScope.get(this) || /* @__PURE__ */ new Set();
        for (const name of globals) {
          accessedGlobals.add(name);
        }
        accessedGlobalsByScope.set(this, accessedGlobals);
        if (this.parent instanceof ChildScope) {
          this.parent.addAccessedGlobals(globals, accessedGlobalsByScope);
        }
      }
      addNamespaceMemberAccess(name, variable) {
        this.accessedOutsideVariables.set(name, variable);
        this.parent.addNamespaceMemberAccess(name, variable);
      }
      addReturnExpression(expression) {
        this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);
      }
      addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope) {
        for (const variable of this.accessedOutsideVariables.values()) {
          if (variable.included) {
            usedNames.add(variable.getBaseVariableName());
            if (format === "system" && exportNamesByVariable.has(variable)) {
              usedNames.add("exports");
            }
          }
        }
        const accessedGlobals = accessedGlobalsByScope.get(this);
        if (accessedGlobals) {
          for (const name of accessedGlobals) {
            usedNames.add(name);
          }
        }
      }
      contains(name) {
        return this.variables.has(name) || this.parent.contains(name);
      }
      deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {
        const usedNames = /* @__PURE__ */ new Set();
        this.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);
        if (this.accessedDynamicImports) {
          for (const importExpression of this.accessedDynamicImports) {
            if (importExpression.inlineNamespace) {
              usedNames.add(importExpression.inlineNamespace.getBaseVariableName());
            }
          }
        }
        for (const [name, variable] of this.variables) {
          if (variable.included || variable.alwaysRendered) {
            variable.setRenderNames(null, getSafeName(name, usedNames));
          }
        }
        for (const scope of this.children) {
          scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
        }
      }
      findLexicalBoundary() {
        return this.parent.findLexicalBoundary();
      }
      findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
          return knownVariable;
        }
        const variable = this.parent.findVariable(name);
        this.accessedOutsideVariables.set(name, variable);
        return variable;
      }
    };
    ParameterScope = class extends ChildScope {
      constructor(parent, context) {
        super(parent);
        this.parameters = [];
        this.hasRest = false;
        this.context = context;
        this.hoistedBodyVarScope = new ChildScope(this);
      }
      addParameterDeclaration(identifier) {
        const name = identifier.name;
        let variable = this.hoistedBodyVarScope.variables.get(name);
        if (variable) {
          variable.addDeclaration(identifier, null);
        } else {
          variable = new LocalVariable(name, identifier, UNKNOWN_EXPRESSION, this.context);
        }
        this.variables.set(name, variable);
        return variable;
      }
      addParameterVariables(parameters, hasRest) {
        this.parameters = parameters;
        for (const parameterList of parameters) {
          for (const parameter of parameterList) {
            parameter.alwaysRendered = true;
          }
        }
        this.hasRest = hasRest;
      }
      includeCallArguments(context, args) {
        let calledFromTryStatement = false;
        let argIncluded = false;
        const restParam = this.hasRest && this.parameters[this.parameters.length - 1];
        for (const checkedArg of args) {
          if (checkedArg instanceof SpreadElement) {
            for (const arg of args) {
              arg.include(context, false);
            }
            break;
          }
        }
        for (let index = args.length - 1; index >= 0; index--) {
          const paramVars = this.parameters[index] || restParam;
          const arg = args[index];
          if (paramVars) {
            calledFromTryStatement = false;
            if (paramVars.length === 0) {
              argIncluded = true;
            } else {
              for (const variable of paramVars) {
                if (variable.included) {
                  argIncluded = true;
                }
                if (variable.calledFromTryStatement) {
                  calledFromTryStatement = true;
                }
              }
            }
          }
          if (!argIncluded && arg.shouldBeIncluded(context)) {
            argIncluded = true;
          }
          if (argIncluded) {
            arg.include(context, calledFromTryStatement);
          }
        }
      }
    };
    ReturnValueScope = class extends ParameterScope {
      constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.returnExpressions = [];
      }
      addReturnExpression(expression) {
        this.returnExpressions.push(expression);
      }
      getReturnExpression() {
        if (this.returnExpression === null)
          this.updateReturnExpression();
        return this.returnExpression;
      }
      updateReturnExpression() {
        if (this.returnExpressions.length === 1) {
          this.returnExpression = this.returnExpressions[0];
        } else {
          this.returnExpression = UNKNOWN_EXPRESSION;
          for (const expression of this.returnExpressions) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
    };
    NO_SEMICOLON = { isNoStatement: true };
    NON_WHITESPACE = /\S/g;
    BlockScope = class extends ChildScope {
      addDeclaration(identifier, context, init, isHoisted) {
        if (isHoisted) {
          const variable = this.parent.addDeclaration(identifier, context, init, isHoisted);
          variable.markInitializersForDeoptimization();
          return variable;
        } else {
          return super.addDeclaration(identifier, context, init, false);
        }
      }
    };
    ExpressionStatement = class extends NodeBase {
      initialise() {
        if (this.directive && this.directive !== "use strict" && this.parent.type === Program$1) {
          this.context.warn(
            {
              code: "MODULE_LEVEL_DIRECTIVE",
              message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
            },
            this.start
          );
        }
      }
      render(code, options) {
        super.render(code, options);
        if (this.included)
          this.insertSemicolon(code);
      }
      shouldBeIncluded(context) {
        if (this.directive && this.directive !== "use strict")
          return this.parent.type !== Program$1;
        return super.shouldBeIncluded(context);
      }
    };
    BlockStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.directlyIncluded = false;
      }
      addImplicitReturnExpressionToScope() {
        const lastStatement = this.body[this.body.length - 1];
        if (!lastStatement || lastStatement.type !== ReturnStatement$1) {
          this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
        }
      }
      createScope(parentScope) {
        this.scope = this.parent.preventChildBlockScope ? parentScope : new BlockScope(parentScope);
      }
      hasEffects(context) {
        if (this.deoptimizeBody)
          return true;
        for (const node of this.body) {
          if (context.brokenFlow)
            break;
          if (node.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        if (!(this.deoptimizeBody && this.directlyIncluded)) {
          this.included = true;
          this.directlyIncluded = true;
          if (this.deoptimizeBody)
            includeChildrenRecursively = true;
          for (const node of this.body) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context))
              node.include(context, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        const firstBodyStatement = this.body[0];
        this.deoptimizeBody = firstBodyStatement instanceof ExpressionStatement && firstBodyStatement.directive === "use asm";
      }
      render(code, options) {
        if (this.body.length) {
          renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        } else {
          super.render(code, options);
        }
      }
    };
    ValueProperties = Symbol("Value Properties");
    PURE = { pure: true };
    IMPURE = { pure: false };
    O = {
      __proto__: null,
      [ValueProperties]: IMPURE
    };
    PF = {
      __proto__: null,
      [ValueProperties]: PURE
    };
    C = {
      __proto__: null,
      [ValueProperties]: IMPURE,
      prototype: O
    };
    PC = {
      __proto__: null,
      [ValueProperties]: PURE,
      prototype: O
    };
    ARRAY_TYPE = {
      __proto__: null,
      [ValueProperties]: PURE,
      from: PF,
      of: PF,
      prototype: O
    };
    INTL_MEMBER = {
      __proto__: null,
      [ValueProperties]: PURE,
      supportedLocalesOf: PC
    };
    knownGlobals = {
      global: O,
      globalThis: O,
      self: O,
      window: O,
      __proto__: null,
      [ValueProperties]: IMPURE,
      Array: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        from: O,
        isArray: PF,
        of: PF,
        prototype: O
      },
      ArrayBuffer: {
        __proto__: null,
        [ValueProperties]: PURE,
        isView: PF,
        prototype: O
      },
      Atomics: O,
      BigInt: C,
      BigInt64Array: C,
      BigUint64Array: C,
      Boolean: PC,
      constructor: C,
      DataView: PC,
      Date: {
        __proto__: null,
        [ValueProperties]: PURE,
        now: PF,
        parse: PF,
        prototype: O,
        UTC: PF
      },
      decodeURI: PF,
      decodeURIComponent: PF,
      encodeURI: PF,
      encodeURIComponent: PF,
      Error: PC,
      escape: PF,
      eval: O,
      EvalError: PC,
      Float32Array: ARRAY_TYPE,
      Float64Array: ARRAY_TYPE,
      Function: C,
      hasOwnProperty: O,
      Infinity: O,
      Int16Array: ARRAY_TYPE,
      Int32Array: ARRAY_TYPE,
      Int8Array: ARRAY_TYPE,
      isFinite: PF,
      isNaN: PF,
      isPrototypeOf: O,
      JSON: O,
      Map: PC,
      Math: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        abs: PF,
        acos: PF,
        acosh: PF,
        asin: PF,
        asinh: PF,
        atan: PF,
        atan2: PF,
        atanh: PF,
        cbrt: PF,
        ceil: PF,
        clz32: PF,
        cos: PF,
        cosh: PF,
        exp: PF,
        expm1: PF,
        floor: PF,
        fround: PF,
        hypot: PF,
        imul: PF,
        log: PF,
        log10: PF,
        log1p: PF,
        log2: PF,
        max: PF,
        min: PF,
        pow: PF,
        random: PF,
        round: PF,
        sign: PF,
        sin: PF,
        sinh: PF,
        sqrt: PF,
        tan: PF,
        tanh: PF,
        trunc: PF
      },
      NaN: O,
      Number: {
        __proto__: null,
        [ValueProperties]: PURE,
        isFinite: PF,
        isInteger: PF,
        isNaN: PF,
        isSafeInteger: PF,
        parseFloat: PF,
        parseInt: PF,
        prototype: O
      },
      Object: {
        __proto__: null,
        [ValueProperties]: PURE,
        create: PF,
        getOwnPropertyDescriptor: PF,
        getOwnPropertyNames: PF,
        getOwnPropertySymbols: PF,
        getPrototypeOf: PF,
        is: PF,
        isExtensible: PF,
        isFrozen: PF,
        isSealed: PF,
        keys: PF,
        fromEntries: PF,
        entries: PF,
        prototype: O
      },
      parseFloat: PF,
      parseInt: PF,
      Promise: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        all: O,
        prototype: O,
        race: O,
        reject: O,
        resolve: O
      },
      propertyIsEnumerable: O,
      Proxy: O,
      RangeError: PC,
      ReferenceError: PC,
      Reflect: O,
      RegExp: PC,
      Set: PC,
      SharedArrayBuffer: C,
      String: {
        __proto__: null,
        [ValueProperties]: PURE,
        fromCharCode: PF,
        fromCodePoint: PF,
        prototype: O,
        raw: PF
      },
      Symbol: {
        __proto__: null,
        [ValueProperties]: PURE,
        for: PF,
        keyFor: PF,
        prototype: O
      },
      SyntaxError: PC,
      toLocaleString: O,
      toString: O,
      TypeError: PC,
      Uint16Array: ARRAY_TYPE,
      Uint32Array: ARRAY_TYPE,
      Uint8Array: ARRAY_TYPE,
      Uint8ClampedArray: ARRAY_TYPE,
      unescape: PF,
      URIError: PC,
      valueOf: O,
      WeakMap: PC,
      WeakSet: PC,
      clearInterval: C,
      clearTimeout: C,
      console: O,
      Intl: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        Collator: INTL_MEMBER,
        DateTimeFormat: INTL_MEMBER,
        ListFormat: INTL_MEMBER,
        NumberFormat: INTL_MEMBER,
        PluralRules: INTL_MEMBER,
        RelativeTimeFormat: INTL_MEMBER
      },
      setInterval: C,
      setTimeout: C,
      TextDecoder: C,
      TextEncoder: C,
      URL: C,
      URLSearchParams: C,
      AbortController: C,
      AbortSignal: C,
      addEventListener: O,
      alert: O,
      AnalyserNode: C,
      Animation: C,
      AnimationEvent: C,
      applicationCache: O,
      ApplicationCache: C,
      ApplicationCacheErrorEvent: C,
      atob: O,
      Attr: C,
      Audio: C,
      AudioBuffer: C,
      AudioBufferSourceNode: C,
      AudioContext: C,
      AudioDestinationNode: C,
      AudioListener: C,
      AudioNode: C,
      AudioParam: C,
      AudioProcessingEvent: C,
      AudioScheduledSourceNode: C,
      AudioWorkletNode: C,
      BarProp: C,
      BaseAudioContext: C,
      BatteryManager: C,
      BeforeUnloadEvent: C,
      BiquadFilterNode: C,
      Blob: C,
      BlobEvent: C,
      blur: O,
      BroadcastChannel: C,
      btoa: O,
      ByteLengthQueuingStrategy: C,
      Cache: C,
      caches: O,
      CacheStorage: C,
      cancelAnimationFrame: O,
      cancelIdleCallback: O,
      CanvasCaptureMediaStreamTrack: C,
      CanvasGradient: C,
      CanvasPattern: C,
      CanvasRenderingContext2D: C,
      ChannelMergerNode: C,
      ChannelSplitterNode: C,
      CharacterData: C,
      clientInformation: O,
      ClipboardEvent: C,
      close: O,
      closed: O,
      CloseEvent: C,
      Comment: C,
      CompositionEvent: C,
      confirm: O,
      ConstantSourceNode: C,
      ConvolverNode: C,
      CountQueuingStrategy: C,
      createImageBitmap: O,
      Credential: C,
      CredentialsContainer: C,
      crypto: O,
      Crypto: C,
      CryptoKey: C,
      CSS: C,
      CSSConditionRule: C,
      CSSFontFaceRule: C,
      CSSGroupingRule: C,
      CSSImportRule: C,
      CSSKeyframeRule: C,
      CSSKeyframesRule: C,
      CSSMediaRule: C,
      CSSNamespaceRule: C,
      CSSPageRule: C,
      CSSRule: C,
      CSSRuleList: C,
      CSSStyleDeclaration: C,
      CSSStyleRule: C,
      CSSStyleSheet: C,
      CSSSupportsRule: C,
      CustomElementRegistry: C,
      customElements: O,
      CustomEvent: C,
      DataTransfer: C,
      DataTransferItem: C,
      DataTransferItemList: C,
      defaultstatus: O,
      defaultStatus: O,
      DelayNode: C,
      DeviceMotionEvent: C,
      DeviceOrientationEvent: C,
      devicePixelRatio: O,
      dispatchEvent: O,
      document: O,
      Document: C,
      DocumentFragment: C,
      DocumentType: C,
      DOMError: C,
      DOMException: C,
      DOMImplementation: C,
      DOMMatrix: C,
      DOMMatrixReadOnly: C,
      DOMParser: C,
      DOMPoint: C,
      DOMPointReadOnly: C,
      DOMQuad: C,
      DOMRect: C,
      DOMRectReadOnly: C,
      DOMStringList: C,
      DOMStringMap: C,
      DOMTokenList: C,
      DragEvent: C,
      DynamicsCompressorNode: C,
      Element: C,
      ErrorEvent: C,
      Event: C,
      EventSource: C,
      EventTarget: C,
      external: O,
      fetch: O,
      File: C,
      FileList: C,
      FileReader: C,
      find: O,
      focus: O,
      FocusEvent: C,
      FontFace: C,
      FontFaceSetLoadEvent: C,
      FormData: C,
      frames: O,
      GainNode: C,
      Gamepad: C,
      GamepadButton: C,
      GamepadEvent: C,
      getComputedStyle: O,
      getSelection: O,
      HashChangeEvent: C,
      Headers: C,
      history: O,
      History: C,
      HTMLAllCollection: C,
      HTMLAnchorElement: C,
      HTMLAreaElement: C,
      HTMLAudioElement: C,
      HTMLBaseElement: C,
      HTMLBodyElement: C,
      HTMLBRElement: C,
      HTMLButtonElement: C,
      HTMLCanvasElement: C,
      HTMLCollection: C,
      HTMLContentElement: C,
      HTMLDataElement: C,
      HTMLDataListElement: C,
      HTMLDetailsElement: C,
      HTMLDialogElement: C,
      HTMLDirectoryElement: C,
      HTMLDivElement: C,
      HTMLDListElement: C,
      HTMLDocument: C,
      HTMLElement: C,
      HTMLEmbedElement: C,
      HTMLFieldSetElement: C,
      HTMLFontElement: C,
      HTMLFormControlsCollection: C,
      HTMLFormElement: C,
      HTMLFrameElement: C,
      HTMLFrameSetElement: C,
      HTMLHeadElement: C,
      HTMLHeadingElement: C,
      HTMLHRElement: C,
      HTMLHtmlElement: C,
      HTMLIFrameElement: C,
      HTMLImageElement: C,
      HTMLInputElement: C,
      HTMLLabelElement: C,
      HTMLLegendElement: C,
      HTMLLIElement: C,
      HTMLLinkElement: C,
      HTMLMapElement: C,
      HTMLMarqueeElement: C,
      HTMLMediaElement: C,
      HTMLMenuElement: C,
      HTMLMetaElement: C,
      HTMLMeterElement: C,
      HTMLModElement: C,
      HTMLObjectElement: C,
      HTMLOListElement: C,
      HTMLOptGroupElement: C,
      HTMLOptionElement: C,
      HTMLOptionsCollection: C,
      HTMLOutputElement: C,
      HTMLParagraphElement: C,
      HTMLParamElement: C,
      HTMLPictureElement: C,
      HTMLPreElement: C,
      HTMLProgressElement: C,
      HTMLQuoteElement: C,
      HTMLScriptElement: C,
      HTMLSelectElement: C,
      HTMLShadowElement: C,
      HTMLSlotElement: C,
      HTMLSourceElement: C,
      HTMLSpanElement: C,
      HTMLStyleElement: C,
      HTMLTableCaptionElement: C,
      HTMLTableCellElement: C,
      HTMLTableColElement: C,
      HTMLTableElement: C,
      HTMLTableRowElement: C,
      HTMLTableSectionElement: C,
      HTMLTemplateElement: C,
      HTMLTextAreaElement: C,
      HTMLTimeElement: C,
      HTMLTitleElement: C,
      HTMLTrackElement: C,
      HTMLUListElement: C,
      HTMLUnknownElement: C,
      HTMLVideoElement: C,
      IDBCursor: C,
      IDBCursorWithValue: C,
      IDBDatabase: C,
      IDBFactory: C,
      IDBIndex: C,
      IDBKeyRange: C,
      IDBObjectStore: C,
      IDBOpenDBRequest: C,
      IDBRequest: C,
      IDBTransaction: C,
      IDBVersionChangeEvent: C,
      IdleDeadline: C,
      IIRFilterNode: C,
      Image: C,
      ImageBitmap: C,
      ImageBitmapRenderingContext: C,
      ImageCapture: C,
      ImageData: C,
      indexedDB: O,
      innerHeight: O,
      innerWidth: O,
      InputEvent: C,
      IntersectionObserver: C,
      IntersectionObserverEntry: C,
      isSecureContext: O,
      KeyboardEvent: C,
      KeyframeEffect: C,
      length: O,
      localStorage: O,
      location: O,
      Location: C,
      locationbar: O,
      matchMedia: O,
      MediaDeviceInfo: C,
      MediaDevices: C,
      MediaElementAudioSourceNode: C,
      MediaEncryptedEvent: C,
      MediaError: C,
      MediaKeyMessageEvent: C,
      MediaKeySession: C,
      MediaKeyStatusMap: C,
      MediaKeySystemAccess: C,
      MediaList: C,
      MediaQueryList: C,
      MediaQueryListEvent: C,
      MediaRecorder: C,
      MediaSettingsRange: C,
      MediaSource: C,
      MediaStream: C,
      MediaStreamAudioDestinationNode: C,
      MediaStreamAudioSourceNode: C,
      MediaStreamEvent: C,
      MediaStreamTrack: C,
      MediaStreamTrackEvent: C,
      menubar: O,
      MessageChannel: C,
      MessageEvent: C,
      MessagePort: C,
      MIDIAccess: C,
      MIDIConnectionEvent: C,
      MIDIInput: C,
      MIDIInputMap: C,
      MIDIMessageEvent: C,
      MIDIOutput: C,
      MIDIOutputMap: C,
      MIDIPort: C,
      MimeType: C,
      MimeTypeArray: C,
      MouseEvent: C,
      moveBy: O,
      moveTo: O,
      MutationEvent: C,
      MutationObserver: C,
      MutationRecord: C,
      name: O,
      NamedNodeMap: C,
      NavigationPreloadManager: C,
      navigator: O,
      Navigator: C,
      NetworkInformation: C,
      Node: C,
      NodeFilter: O,
      NodeIterator: C,
      NodeList: C,
      Notification: C,
      OfflineAudioCompletionEvent: C,
      OfflineAudioContext: C,
      offscreenBuffering: O,
      OffscreenCanvas: C,
      open: O,
      openDatabase: O,
      Option: C,
      origin: O,
      OscillatorNode: C,
      outerHeight: O,
      outerWidth: O,
      PageTransitionEvent: C,
      pageXOffset: O,
      pageYOffset: O,
      PannerNode: C,
      parent: O,
      Path2D: C,
      PaymentAddress: C,
      PaymentRequest: C,
      PaymentRequestUpdateEvent: C,
      PaymentResponse: C,
      performance: O,
      Performance: C,
      PerformanceEntry: C,
      PerformanceLongTaskTiming: C,
      PerformanceMark: C,
      PerformanceMeasure: C,
      PerformanceNavigation: C,
      PerformanceNavigationTiming: C,
      PerformanceObserver: C,
      PerformanceObserverEntryList: C,
      PerformancePaintTiming: C,
      PerformanceResourceTiming: C,
      PerformanceTiming: C,
      PeriodicWave: C,
      Permissions: C,
      PermissionStatus: C,
      personalbar: O,
      PhotoCapabilities: C,
      Plugin: C,
      PluginArray: C,
      PointerEvent: C,
      PopStateEvent: C,
      postMessage: O,
      Presentation: C,
      PresentationAvailability: C,
      PresentationConnection: C,
      PresentationConnectionAvailableEvent: C,
      PresentationConnectionCloseEvent: C,
      PresentationConnectionList: C,
      PresentationReceiver: C,
      PresentationRequest: C,
      print: O,
      ProcessingInstruction: C,
      ProgressEvent: C,
      PromiseRejectionEvent: C,
      prompt: O,
      PushManager: C,
      PushSubscription: C,
      PushSubscriptionOptions: C,
      queueMicrotask: O,
      RadioNodeList: C,
      Range: C,
      ReadableStream: C,
      RemotePlayback: C,
      removeEventListener: O,
      Request: C,
      requestAnimationFrame: O,
      requestIdleCallback: O,
      resizeBy: O,
      ResizeObserver: C,
      ResizeObserverEntry: C,
      resizeTo: O,
      Response: C,
      RTCCertificate: C,
      RTCDataChannel: C,
      RTCDataChannelEvent: C,
      RTCDtlsTransport: C,
      RTCIceCandidate: C,
      RTCIceTransport: C,
      RTCPeerConnection: C,
      RTCPeerConnectionIceEvent: C,
      RTCRtpReceiver: C,
      RTCRtpSender: C,
      RTCSctpTransport: C,
      RTCSessionDescription: C,
      RTCStatsReport: C,
      RTCTrackEvent: C,
      screen: O,
      Screen: C,
      screenLeft: O,
      ScreenOrientation: C,
      screenTop: O,
      screenX: O,
      screenY: O,
      ScriptProcessorNode: C,
      scroll: O,
      scrollbars: O,
      scrollBy: O,
      scrollTo: O,
      scrollX: O,
      scrollY: O,
      SecurityPolicyViolationEvent: C,
      Selection: C,
      ServiceWorker: C,
      ServiceWorkerContainer: C,
      ServiceWorkerRegistration: C,
      sessionStorage: O,
      ShadowRoot: C,
      SharedWorker: C,
      SourceBuffer: C,
      SourceBufferList: C,
      speechSynthesis: O,
      SpeechSynthesisEvent: C,
      SpeechSynthesisUtterance: C,
      StaticRange: C,
      status: O,
      statusbar: O,
      StereoPannerNode: C,
      stop: O,
      Storage: C,
      StorageEvent: C,
      StorageManager: C,
      styleMedia: O,
      StyleSheet: C,
      StyleSheetList: C,
      SubtleCrypto: C,
      SVGAElement: C,
      SVGAngle: C,
      SVGAnimatedAngle: C,
      SVGAnimatedBoolean: C,
      SVGAnimatedEnumeration: C,
      SVGAnimatedInteger: C,
      SVGAnimatedLength: C,
      SVGAnimatedLengthList: C,
      SVGAnimatedNumber: C,
      SVGAnimatedNumberList: C,
      SVGAnimatedPreserveAspectRatio: C,
      SVGAnimatedRect: C,
      SVGAnimatedString: C,
      SVGAnimatedTransformList: C,
      SVGAnimateElement: C,
      SVGAnimateMotionElement: C,
      SVGAnimateTransformElement: C,
      SVGAnimationElement: C,
      SVGCircleElement: C,
      SVGClipPathElement: C,
      SVGComponentTransferFunctionElement: C,
      SVGDefsElement: C,
      SVGDescElement: C,
      SVGDiscardElement: C,
      SVGElement: C,
      SVGEllipseElement: C,
      SVGFEBlendElement: C,
      SVGFEColorMatrixElement: C,
      SVGFEComponentTransferElement: C,
      SVGFECompositeElement: C,
      SVGFEConvolveMatrixElement: C,
      SVGFEDiffuseLightingElement: C,
      SVGFEDisplacementMapElement: C,
      SVGFEDistantLightElement: C,
      SVGFEDropShadowElement: C,
      SVGFEFloodElement: C,
      SVGFEFuncAElement: C,
      SVGFEFuncBElement: C,
      SVGFEFuncGElement: C,
      SVGFEFuncRElement: C,
      SVGFEGaussianBlurElement: C,
      SVGFEImageElement: C,
      SVGFEMergeElement: C,
      SVGFEMergeNodeElement: C,
      SVGFEMorphologyElement: C,
      SVGFEOffsetElement: C,
      SVGFEPointLightElement: C,
      SVGFESpecularLightingElement: C,
      SVGFESpotLightElement: C,
      SVGFETileElement: C,
      SVGFETurbulenceElement: C,
      SVGFilterElement: C,
      SVGForeignObjectElement: C,
      SVGGElement: C,
      SVGGeometryElement: C,
      SVGGradientElement: C,
      SVGGraphicsElement: C,
      SVGImageElement: C,
      SVGLength: C,
      SVGLengthList: C,
      SVGLinearGradientElement: C,
      SVGLineElement: C,
      SVGMarkerElement: C,
      SVGMaskElement: C,
      SVGMatrix: C,
      SVGMetadataElement: C,
      SVGMPathElement: C,
      SVGNumber: C,
      SVGNumberList: C,
      SVGPathElement: C,
      SVGPatternElement: C,
      SVGPoint: C,
      SVGPointList: C,
      SVGPolygonElement: C,
      SVGPolylineElement: C,
      SVGPreserveAspectRatio: C,
      SVGRadialGradientElement: C,
      SVGRect: C,
      SVGRectElement: C,
      SVGScriptElement: C,
      SVGSetElement: C,
      SVGStopElement: C,
      SVGStringList: C,
      SVGStyleElement: C,
      SVGSVGElement: C,
      SVGSwitchElement: C,
      SVGSymbolElement: C,
      SVGTextContentElement: C,
      SVGTextElement: C,
      SVGTextPathElement: C,
      SVGTextPositioningElement: C,
      SVGTitleElement: C,
      SVGTransform: C,
      SVGTransformList: C,
      SVGTSpanElement: C,
      SVGUnitTypes: C,
      SVGUseElement: C,
      SVGViewElement: C,
      TaskAttributionTiming: C,
      Text: C,
      TextEvent: C,
      TextMetrics: C,
      TextTrack: C,
      TextTrackCue: C,
      TextTrackCueList: C,
      TextTrackList: C,
      TimeRanges: C,
      toolbar: O,
      top: O,
      Touch: C,
      TouchEvent: C,
      TouchList: C,
      TrackEvent: C,
      TransitionEvent: C,
      TreeWalker: C,
      UIEvent: C,
      ValidityState: C,
      visualViewport: O,
      VisualViewport: C,
      VTTCue: C,
      WaveShaperNode: C,
      WebAssembly: O,
      WebGL2RenderingContext: C,
      WebGLActiveInfo: C,
      WebGLBuffer: C,
      WebGLContextEvent: C,
      WebGLFramebuffer: C,
      WebGLProgram: C,
      WebGLQuery: C,
      WebGLRenderbuffer: C,
      WebGLRenderingContext: C,
      WebGLSampler: C,
      WebGLShader: C,
      WebGLShaderPrecisionFormat: C,
      WebGLSync: C,
      WebGLTexture: C,
      WebGLTransformFeedback: C,
      WebGLUniformLocation: C,
      WebGLVertexArrayObject: C,
      WebSocket: C,
      WheelEvent: C,
      Window: C,
      Worker: C,
      WritableStream: C,
      XMLDocument: C,
      XMLHttpRequest: C,
      XMLHttpRequestEventTarget: C,
      XMLHttpRequestUpload: C,
      XMLSerializer: C,
      XPathEvaluator: C,
      XPathExpression: C,
      XPathResult: C,
      XSLTProcessor: C
    };
    for (const global of ["window", "global", "self", "globalThis"]) {
      knownGlobals[global] = knownGlobals;
    }
    GlobalVariable = class extends Variable {
      constructor() {
        super(...arguments);
        this.isReassigned = true;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return !isGlobalMember([this.name, ...path4]);
      }
      hasEffectsWhenCalledAtPath(path4) {
        return !isPureGlobal([this.name, ...path4]);
      }
    };
    tdzVariableKinds = {
      __proto__: null,
      class: true,
      const: true,
      let: true,
      var: true
    };
    Identifier = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.variable = null;
        this.deoptimized = false;
        this.isTDZAccess = null;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        if (this.variable !== null && exportNamesByVariable.has(this.variable)) {
          variables.push(this.variable);
        }
      }
      bind() {
        if (this.variable === null && is_reference(this, this.parent)) {
          this.variable = this.scope.findVariable(this.name);
          this.variable.addReference(this);
        }
      }
      declare(kind, init) {
        let variable;
        const { treeshake } = this.context.options;
        switch (kind) {
          case "var":
            variable = this.scope.addDeclaration(this, this.context, init, true);
            if (treeshake && treeshake.correctVarValueBeforeDeclaration) {
              variable.markInitializersForDeoptimization();
            }
            break;
          case "function":
            variable = this.scope.addDeclaration(this, this.context, init, false);
            break;
          case "let":
          case "const":
          case "class":
            variable = this.scope.addDeclaration(this, this.context, init, false);
            break;
          case "parameter":
            variable = this.scope.addParameterDeclaration(this);
            break;
          default:
            throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
        }
        variable.kind = kind;
        return [this.variable = variable];
      }
      deoptimizePath(path4) {
        if (path4.length === 0 && !this.scope.contains(this.name)) {
          this.disallowImportReassignment();
        }
        this.variable.deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.variable.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffects() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.isPossibleTDZ() && this.variable.kind !== "var") {
          return true;
        }
        return this.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof GlobalVariable && this.variable.hasEffectsWhenAccessedAtPath(EMPTY_PATH);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return this.variable !== null && this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return !this.variable || (path4.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return !this.variable || this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (!this.included) {
          this.included = true;
          if (this.variable !== null) {
            this.context.includeVariableInModule(this.variable);
          }
        }
      }
      includeCallArguments(context, args) {
        this.getVariableRespectingTDZ().includeCallArguments(context, args);
      }
      isPossibleTDZ() {
        if (this.isTDZAccess !== null)
          return this.isTDZAccess;
        if (!(this.variable instanceof LocalVariable) || !this.variable.kind || !(this.variable.kind in tdzVariableKinds)) {
          return this.isTDZAccess = false;
        }
        let decl_id;
        if (this.variable.declarations && this.variable.declarations.length === 1 && (decl_id = this.variable.declarations[0]) && this.start < decl_id.start && closestParentFunctionOrProgram(this) === closestParentFunctionOrProgram(decl_id)) {
          return this.isTDZAccess = true;
        }
        if (!this.variable.initReached) {
          return this.isTDZAccess = true;
        }
        return this.isTDZAccess = false;
      }
      markDeclarationReached() {
        this.variable.initReached = true;
      }
      render(code, { snippets: { getPropertyAccess } }, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
        if (this.variable) {
          const name = this.variable.getName(getPropertyAccess);
          if (name !== this.name) {
            code.overwrite(this.start, this.end, name, {
              contentOnly: true,
              storeName: true
            });
            if (isShorthandProperty) {
              code.prependRight(this.start, `${this.name}: `);
            }
          }
          if (name === "eval" && renderedParentType === CallExpression$1 && isCalleeOfRenderedParent) {
            code.appendRight(this.start, "0, ");
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.variable !== null && this.variable instanceof LocalVariable) {
          this.variable.consolidateInitializers();
          this.context.requestTreeshakingPass();
        }
      }
      disallowImportReassignment() {
        return this.context.error({
          code: "ILLEGAL_REASSIGNMENT",
          message: `Illegal reassignment to import '${this.name}'`
        }, this.start);
      }
      getVariableRespectingTDZ() {
        if (this.isPossibleTDZ()) {
          return UNKNOWN_EXPRESSION;
        }
        return this.variable;
      }
    };
    RestElement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
        this.declarationInit = null;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        this.argument.addExportedVariables(variables, exportNamesByVariable);
      }
      declare(kind, init) {
        this.declarationInit = init;
        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
      }
      deoptimizePath(path4) {
        path4.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return path4.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
      }
      markDeclarationReached() {
        this.argument.markDeclarationReached();
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
          this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
          this.context.requestTreeshakingPass();
        }
      }
    };
    ArrowFunctionExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimizedReturn = false;
      }
      createScope(parentScope) {
        this.scope = new ReturnValueScope(parentScope, this.context);
      }
      deoptimizePath(path4) {
        if (path4.length === 1 && path4[0] === UnknownKey) {
          this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
        }
      }
      deoptimizeThisOnEventAtPath() {
      }
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length !== 0) {
          return UNKNOWN_EXPRESSION;
        }
        if (this.async) {
          if (!this.deoptimizedReturn) {
            this.deoptimizedReturn = true;
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
            this.context.requestTreeshakingPass();
          }
          return UNKNOWN_EXPRESSION;
        }
        return this.scope.getReturnExpression();
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenAssignedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenCalledAtPath(path4, _callOptions, context) {
        if (path4.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects } = this.context.options.treeshake;
          const returnExpression = this.scope.getReturnExpression();
          if (returnExpression.hasEffectsWhenCalledAtPath(["then"], { args: NO_ARGS, thisParam: null, withNew: false }, context) || propertyReadSideEffects && (propertyReadSideEffects === "always" || returnExpression.hasEffectsWhenAccessedAtPath(["then"], context))) {
            return true;
          }
        }
        for (const param of this.params) {
          if (param.hasEffects(context))
            return true;
        }
        const { ignore: ignore2, brokenFlow } = context;
        context.ignore = {
          breaks: false,
          continues: false,
          labels: /* @__PURE__ */ new Set(),
          returnYield: true
        };
        if (this.body.hasEffects(context))
          return true;
        context.ignore = ignore2;
        context.brokenFlow = brokenFlow;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        for (const param of this.params) {
          if (!(param instanceof Identifier)) {
            param.include(context, includeChildrenRecursively);
          }
        }
        const { brokenFlow } = context;
        context.brokenFlow = BROKEN_FLOW_NONE;
        this.body.include(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      includeCallArguments(context, args) {
        this.scope.includeCallArguments(context, args);
      }
      initialise() {
        this.scope.addParameterVariables(this.params.map((param) => param.declare("parameter", UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
        if (this.body instanceof BlockStatement) {
          this.body.addImplicitReturnExpressionToScope();
        } else {
          this.scope.addReturnExpression(this.body);
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.body.type === BlockStatement$1) {
          this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        }
        super.parseNode(esTreeNode);
      }
    };
    ArrowFunctionExpression.prototype.preventChildBlockScope = true;
    ObjectPattern = class extends NodeBase {
      addExportedVariables(variables, exportNamesByVariable) {
        for (const property of this.properties) {
          if (property.type === Property$1) {
            property.value.addExportedVariables(variables, exportNamesByVariable);
          } else {
            property.argument.addExportedVariables(variables, exportNamesByVariable);
          }
        }
      }
      declare(kind, init) {
        const variables = [];
        for (const property of this.properties) {
          variables.push(...property.declare(kind, init));
        }
        return variables;
      }
      deoptimizePath(path4) {
        if (path4.length === 0) {
          for (const property of this.properties) {
            property.deoptimizePath(path4);
          }
        }
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        if (path4.length > 0)
          return true;
        for (const property of this.properties) {
          if (property.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context))
            return true;
        }
        return false;
      }
      markDeclarationReached() {
        for (const property of this.properties) {
          property.markDeclarationReached();
        }
      }
    };
    AssignmentExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return this.right.hasEffects(context) || this.left.hasEffects(context) || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return path4.length > 0 && this.right.hasEffectsWhenAccessedAtPath(path4, context);
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        let hasEffectsContext;
        if (includeChildrenRecursively || this.operator !== "=" || this.left.included || (hasEffectsContext = createHasEffectsContext(), this.left.hasEffects(hasEffectsContext) || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, hasEffectsContext))) {
          this.left.include(context, includeChildrenRecursively);
        }
        this.right.include(context, includeChildrenRecursively);
      }
      render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        if (this.left.included) {
          this.left.render(code, options);
          this.right.render(code, options);
        } else {
          const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, "=", this.left.end) + 1);
          code.remove(this.start, inclusionStart);
          if (preventASI) {
            removeLineBreaks(code, inclusionStart, this.right.start);
          }
          this.right.render(code, options, {
            renderedParentType: renderedParentType || this.parent.type,
            renderedSurroundingElement: renderedSurroundingElement || this.parent.type
          });
        }
        if (options.format === "system") {
          if (this.left instanceof Identifier) {
            const variable = this.left.variable;
            const exportNames = options.exportNamesByVariable.get(variable);
            if (exportNames) {
              if (exportNames.length === 1) {
                renderSystemExportExpression(variable, this.start, this.end, code, options);
              } else {
                renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options);
              }
              return;
            }
          } else {
            const systemPatternExports = [];
            this.left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
            if (systemPatternExports.length > 0) {
              renderSystemExportFunction(systemPatternExports, this.start, this.end, renderedSurroundingElement === ExpressionStatement$1, code, options);
              return;
            }
          }
        }
        if (this.left.included && this.left instanceof ObjectPattern && (renderedSurroundingElement === ExpressionStatement$1 || renderedSurroundingElement === ArrowFunctionExpression$1)) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.context.requestTreeshakingPass();
      }
    };
    AssignmentPattern = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        this.left.addExportedVariables(variables, exportNamesByVariable);
      }
      declare(kind, init) {
        return this.left.declare(kind, init);
      }
      deoptimizePath(path4) {
        path4.length === 0 && this.left.deoptimizePath(path4);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return path4.length > 0 || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
      }
      markDeclarationReached() {
        this.left.markDeclarationReached();
      }
      render(code, options, { isShorthandProperty } = BLANK) {
        this.left.render(code, options, { isShorthandProperty });
        this.right.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.context.requestTreeshakingPass();
      }
    };
    ArgumentsVariable = class extends LocalVariable {
      constructor(context) {
        super("arguments", null, UNKNOWN_EXPRESSION, context);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      hasEffectsWhenAssignedAtPath() {
        return true;
      }
      hasEffectsWhenCalledAtPath() {
        return true;
      }
    };
    ThisVariable = class extends LocalVariable {
      constructor(context) {
        super("this", null, null, context);
        this.deoptimizedPaths = [];
        this.entitiesToBeDeoptimized = /* @__PURE__ */ new Set();
        this.thisDeoptimizationList = [];
        this.thisDeoptimizations = new DiscriminatedPathTracker();
      }
      addEntityToBeDeoptimized(entity) {
        for (const path4 of this.deoptimizedPaths) {
          entity.deoptimizePath(path4);
        }
        for (const thisDeoptimization of this.thisDeoptimizationList) {
          this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
        }
        this.entitiesToBeDeoptimized.add(entity);
      }
      deoptimizePath(path4) {
        if (path4.length === 0 || this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path4, this)) {
          return;
        }
        this.deoptimizedPaths.push(path4);
        for (const entity of this.entitiesToBeDeoptimized) {
          entity.deoptimizePath(path4);
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter) {
        const thisDeoptimization = {
          event,
          path: path4,
          thisParameter
        };
        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path4, event, thisParameter)) {
          for (const entity of this.entitiesToBeDeoptimized) {
            this.applyThisDeoptimizationEvent(entity, thisDeoptimization);
          }
          this.thisDeoptimizationList.push(thisDeoptimization);
        }
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return this.getInit(context).hasEffectsWhenAccessedAtPath(path4, context) || super.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.getInit(context).hasEffectsWhenAssignedAtPath(path4, context) || super.hasEffectsWhenAssignedAtPath(path4, context);
      }
      applyThisDeoptimizationEvent(entity, { event, path: path4, thisParameter }) {
        entity.deoptimizeThisOnEventAtPath(event, path4, thisParameter === this ? entity : thisParameter, SHARED_RECURSION_TRACKER);
      }
      getInit(context) {
        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
      }
    };
    FunctionScope = class extends ReturnValueScope {
      constructor(parent, context) {
        super(parent, context);
        this.variables.set("arguments", this.argumentsVariable = new ArgumentsVariable(context));
        this.variables.set("this", this.thisVariable = new ThisVariable(context));
      }
      findLexicalBoundary() {
        return this;
      }
      includeCallArguments(context, args) {
        super.includeCallArguments(context, args);
        if (this.argumentsVariable.included) {
          for (const arg of args) {
            if (!arg.included) {
              arg.include(context, false);
            }
          }
        }
      }
    };
    FunctionNode = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimizedReturn = false;
        this.isPrototypeDeoptimized = false;
      }
      createScope(parentScope) {
        this.scope = new FunctionScope(parentScope, this.context);
      }
      deoptimizePath(path4) {
        if (path4.length === 1) {
          if (path4[0] === "prototype") {
            this.isPrototypeDeoptimized = true;
          } else if (path4[0] === UnknownKey) {
            this.isPrototypeDeoptimized = true;
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter) {
        if (event === EVENT_CALLED) {
          if (path4.length > 0) {
            thisParameter.deoptimizePath(UNKNOWN_PATH);
          } else {
            this.scope.thisVariable.addEntityToBeDeoptimized(thisParameter);
          }
        }
      }
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length !== 0) {
          return UNKNOWN_EXPRESSION;
        }
        if (this.async) {
          if (!this.deoptimizedReturn) {
            this.deoptimizedReturn = true;
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
            this.context.requestTreeshakingPass();
          }
          return UNKNOWN_EXPRESSION;
        }
        return this.scope.getReturnExpression();
      }
      hasEffects() {
        return this.id !== null && this.id.hasEffects();
      }
      hasEffectsWhenAccessedAtPath(path4) {
        if (path4.length <= 1)
          return false;
        return path4.length > 2 || path4[0] !== "prototype" || this.isPrototypeDeoptimized;
      }
      hasEffectsWhenAssignedAtPath(path4) {
        if (path4.length <= 1) {
          return false;
        }
        return path4.length > 2 || path4[0] !== "prototype" || this.isPrototypeDeoptimized;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects } = this.context.options.treeshake;
          const returnExpression = this.scope.getReturnExpression();
          if (returnExpression.hasEffectsWhenCalledAtPath(["then"], { args: NO_ARGS, thisParam: null, withNew: false }, context) || propertyReadSideEffects && (propertyReadSideEffects === "always" || returnExpression.hasEffectsWhenAccessedAtPath(["then"], context))) {
            return true;
          }
        }
        for (const param of this.params) {
          if (param.hasEffects(context))
            return true;
        }
        const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
        context.replacedVariableInits.set(this.scope.thisVariable, callOptions.withNew ? new ObjectEntity(/* @__PURE__ */ Object.create(null), OBJECT_PROTOTYPE) : UNKNOWN_EXPRESSION);
        const { brokenFlow, ignore: ignore2 } = context;
        context.ignore = {
          breaks: false,
          continues: false,
          labels: /* @__PURE__ */ new Set(),
          returnYield: true
        };
        if (this.body.hasEffects(context))
          return true;
        context.brokenFlow = brokenFlow;
        if (thisInit) {
          context.replacedVariableInits.set(this.scope.thisVariable, thisInit);
        } else {
          context.replacedVariableInits.delete(this.scope.thisVariable);
        }
        context.ignore = ignore2;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.id)
          this.id.include();
        const hasArguments = this.scope.argumentsVariable.included;
        for (const param of this.params) {
          if (!(param instanceof Identifier) || hasArguments) {
            param.include(context, includeChildrenRecursively);
          }
        }
        const { brokenFlow } = context;
        context.brokenFlow = BROKEN_FLOW_NONE;
        this.body.include(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      includeCallArguments(context, args) {
        this.scope.includeCallArguments(context, args);
      }
      initialise() {
        if (this.id !== null) {
          this.id.declare("function", this);
        }
        this.scope.addParameterVariables(this.params.map((param) => param.declare("parameter", UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
        this.body.addImplicitReturnExpressionToScope();
      }
      parseNode(esTreeNode) {
        this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        super.parseNode(esTreeNode);
      }
    };
    FunctionNode.prototype.preventChildBlockScope = true;
    AwaitExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      hasEffects() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return true;
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (!this.included) {
          this.included = true;
          checkTopLevelAwait:
            if (!this.context.usesTopLevelAwait) {
              let parent = this.parent;
              do {
                if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)
                  break checkTopLevelAwait;
              } while (parent = parent.parent);
              this.context.usesTopLevelAwait = true;
            }
        }
        this.argument.include(context, includeChildrenRecursively);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath(UNKNOWN_PATH);
        this.context.requestTreeshakingPass();
      }
    };
    binaryOperators = {
      "!=": (left, right) => left != right,
      "!==": (left, right) => left !== right,
      "%": (left, right) => left % right,
      "&": (left, right) => left & right,
      "*": (left, right) => left * right,
      "**": (left, right) => left ** right,
      "+": (left, right) => left + right,
      "-": (left, right) => left - right,
      "/": (left, right) => left / right,
      "<": (left, right) => left < right,
      "<<": (left, right) => left << right,
      "<=": (left, right) => left <= right,
      "==": (left, right) => left == right,
      "===": (left, right) => left === right,
      ">": (left, right) => left > right,
      ">=": (left, right) => left >= right,
      ">>": (left, right) => left >> right,
      ">>>": (left, right) => left >>> right,
      "^": (left, right) => left ^ right,
      in: () => UnknownValue,
      instanceof: () => UnknownValue,
      "|": (left, right) => left | right
    };
    BinaryExpression = class extends NodeBase {
      deoptimizeCache() {
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (path4.length > 0)
          return UnknownValue;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (leftValue === UnknownValue)
          return UnknownValue;
        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (rightValue === UnknownValue)
          return UnknownValue;
        const operatorFn = binaryOperators[this.operator];
        if (!operatorFn)
          return UnknownValue;
        return operatorFn(leftValue, rightValue);
      }
      hasEffects(context) {
        if (this.operator === "+" && this.parent instanceof ExpressionStatement && this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === "")
          return true;
        return super.hasEffects(context);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        this.left.render(code, options, { renderedSurroundingElement });
        this.right.render(code, options);
      }
    };
    BreakStatement = class extends NodeBase {
      hasEffects(context) {
        if (this.label) {
          if (!context.ignore.labels.has(this.label.name))
            return true;
          context.includedLabels.add(this.label.name);
          context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        } else {
          if (!context.ignore.breaks)
            return true;
          context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
        }
        return false;
      }
      include(context) {
        this.included = true;
        if (this.label) {
          this.label.include();
          context.includedLabels.add(this.label.name);
        }
        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
      }
    };
    Literal = class extends NodeBase {
      deoptimizeThisOnEventAtPath() {
      }
      getLiteralValueAtPath(path4) {
        if (path4.length > 0 || this.value === null && this.context.code.charCodeAt(this.start) !== 110 || typeof this.value === "bigint" || this.context.code.charCodeAt(this.start) === 47) {
          return UnknownValue;
        }
        return this.value;
      }
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length !== 1)
          return UNKNOWN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(this.members, path4[0]);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        if (this.value === null) {
          return path4.length > 0;
        }
        return path4.length > 1;
      }
      hasEffectsWhenAssignedAtPath(path4) {
        return path4.length > 0;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length === 1) {
          return hasMemberEffectWhenCalled(this.members, path4[0], callOptions, context);
        }
        return true;
      }
      initialise() {
        this.members = getLiteralMembersForValue(this.value);
      }
      parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        this.regex = esTreeNode.regex;
        super.parseNode(esTreeNode);
      }
      render(code) {
        if (typeof this.value === "string") {
          code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
        }
      }
    };
    MAX_PATH_DEPTH = 7;
    MemberExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.variable = null;
        this.deoptimized = false;
        this.bound = false;
        this.expressionsToBeDeoptimized = [];
        this.replacement = null;
      }
      bind() {
        this.bound = true;
        const path4 = getPathIfNotComputed(this);
        const baseVariable = path4 && this.scope.findVariable(path4[0].key);
        if (baseVariable && baseVariable.isNamespace) {
          const resolvedVariable = this.resolveNamespaceVariables(baseVariable, path4.slice(1));
          if (!resolvedVariable) {
            super.bind();
          } else if (typeof resolvedVariable === "string") {
            this.replacement = resolvedVariable;
          } else {
            this.variable = resolvedVariable;
            this.scope.addNamespaceMemberAccess(getStringFromPath(path4), resolvedVariable);
          }
        } else {
          super.bind();
        }
      }
      deoptimizeCache() {
        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
        this.expressionsToBeDeoptimized = [];
        this.propertyKey = UnknownKey;
        this.object.deoptimizePath(UNKNOWN_PATH);
        for (const expression of expressionsToBeDeoptimized) {
          expression.deoptimizeCache();
        }
      }
      deoptimizePath(path4) {
        if (path4.length === 0)
          this.disallowNamespaceReassignment();
        if (this.variable) {
          this.variable.deoptimizePath(path4);
        } else if (!this.replacement) {
          if (path4.length < MAX_PATH_DEPTH) {
            this.object.deoptimizePath([this.getPropertyKey(), ...path4]);
          }
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        if (this.variable) {
          this.variable.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
        } else if (!this.replacement) {
          if (path4.length < MAX_PATH_DEPTH) {
            this.object.deoptimizeThisOnEventAtPath(event, [this.getPropertyKey(), ...path4], thisParameter, recursionTracker);
          } else {
            thisParameter.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (this.variable !== null) {
          return this.variable.getLiteralValueAtPath(path4, recursionTracker, origin);
        }
        if (this.replacement) {
          return UnknownValue;
        }
        this.expressionsToBeDeoptimized.push(origin);
        if (path4.length < MAX_PATH_DEPTH) {
          return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path4], recursionTracker, origin);
        }
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        if (this.variable !== null) {
          return this.variable.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
        }
        if (this.replacement) {
          return UNKNOWN_EXPRESSION;
        }
        this.expressionsToBeDeoptimized.push(origin);
        if (path4.length < MAX_PATH_DEPTH) {
          return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path4], callOptions, recursionTracker, origin);
        }
        return UNKNOWN_EXPRESSION;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const { propertyReadSideEffects } = this.context.options.treeshake;
        return this.property.hasEffects(context) || this.object.hasEffects(context) || !(this.variable || this.replacement || this.parent instanceof AssignmentExpression && this.parent.operator === "=") && propertyReadSideEffects && (propertyReadSideEffects === "always" || this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()], context));
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        if (this.variable !== null) {
          return this.variable.hasEffectsWhenAccessedAtPath(path4, context);
        }
        if (this.replacement) {
          return true;
        }
        if (path4.length < MAX_PATH_DEPTH) {
          return this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(), ...path4], context);
        }
        return true;
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        if (this.variable !== null) {
          return this.variable.hasEffectsWhenAssignedAtPath(path4, context);
        }
        if (this.replacement) {
          return true;
        }
        if (path4.length < MAX_PATH_DEPTH) {
          return this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(), ...path4], context);
        }
        return true;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (this.variable !== null) {
          return this.variable.hasEffectsWhenCalledAtPath(path4, callOptions, context);
        }
        if (this.replacement) {
          return true;
        }
        if (path4.length < MAX_PATH_DEPTH) {
          return this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(), ...path4], callOptions, context);
        }
        return true;
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (!this.included) {
          this.included = true;
          if (this.variable !== null) {
            this.context.includeVariableInModule(this.variable);
          }
        }
        this.object.include(context, includeChildrenRecursively);
        this.property.include(context, includeChildrenRecursively);
      }
      includeCallArguments(context, args) {
        if (this.variable) {
          this.variable.includeCallArguments(context, args);
        } else {
          super.includeCallArguments(context, args);
        }
      }
      initialise() {
        this.propertyKey = getResolvablePropertyKey(this);
      }
      render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = BLANK) {
        if (this.variable || this.replacement) {
          const { snippets: { getPropertyAccess } } = options;
          let replacement = this.variable ? this.variable.getName(getPropertyAccess) : this.replacement;
          if (renderedParentType && isCalleeOfRenderedParent)
            replacement = "0, " + replacement;
          code.overwrite(this.start, this.end, replacement, {
            contentOnly: true,
            storeName: true
          });
        } else {
          if (renderedParentType && isCalleeOfRenderedParent) {
            code.appendRight(this.start, "0, ");
          }
          this.object.render(code, options, { renderedSurroundingElement });
          this.property.render(code, options);
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { propertyReadSideEffects } = this.context.options.treeshake;
        if (this.bound && propertyReadSideEffects && !(this.variable || this.replacement)) {
          if (!(this.parent instanceof AssignmentExpression && this.parent.operator === "=")) {
            this.object.deoptimizeThisOnEventAtPath(EVENT_ACCESSED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
          }
          if (this.parent instanceof AssignmentExpression) {
            this.object.deoptimizeThisOnEventAtPath(EVENT_ASSIGNED, [this.propertyKey], this.object, SHARED_RECURSION_TRACKER);
          }
          this.context.requestTreeshakingPass();
        }
      }
      disallowNamespaceReassignment() {
        if (this.object instanceof Identifier) {
          const variable = this.scope.findVariable(this.object.name);
          if (variable.isNamespace) {
            if (this.variable) {
              this.context.includeVariableInModule(this.variable);
            }
            this.context.warn({
              code: "ILLEGAL_NAMESPACE_REASSIGNMENT",
              message: `Illegal reassignment to import '${this.object.name}'`
            }, this.start);
          }
        }
      }
      getPropertyKey() {
        if (this.propertyKey === null) {
          this.propertyKey = UnknownKey;
          const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
          return this.propertyKey = value === UnknownValue ? UnknownKey : String(value);
        }
        return this.propertyKey;
      }
      resolveNamespaceVariables(baseVariable, path4) {
        if (path4.length === 0)
          return baseVariable;
        if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
          return null;
        const exportName = path4[0].key;
        const variable = baseVariable.context.traceExport(exportName);
        if (!variable) {
          const fileName = baseVariable.context.fileName;
          this.context.warn({
            code: "MISSING_EXPORT",
            exporter: relativeId(fileName),
            importer: relativeId(this.context.fileName),
            message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
            missing: exportName,
            url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
          }, path4[0].pos);
          return "undefined";
        }
        return this.resolveNamespaceVariables(variable, path4.slice(1));
      }
    };
    CallExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
        this.deoptimizableDependentExpressions = [];
        this.expressionsToBeDeoptimized = /* @__PURE__ */ new Set();
        this.returnExpression = null;
      }
      bind() {
        super.bind();
        if (this.callee instanceof Identifier) {
          const variable = this.scope.findVariable(this.callee.name);
          if (variable.isNamespace) {
            this.context.warn({
              code: "CANNOT_CALL_NAMESPACE",
              message: `Cannot call a namespace ('${this.callee.name}')`
            }, this.start);
          }
          if (this.callee.name === "eval") {
            this.context.warn({
              code: "EVAL",
              message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
              url: "https://rollupjs.org/guide/en/#avoiding-eval"
            }, this.start);
          }
        }
        this.callOptions = {
          args: this.arguments,
          thisParam: this.callee instanceof MemberExpression && !this.callee.variable ? this.callee.object : null,
          withNew: false
        };
      }
      deoptimizeCache() {
        if (this.returnExpression !== UNKNOWN_EXPRESSION) {
          this.returnExpression = UNKNOWN_EXPRESSION;
          for (const expression of this.deoptimizableDependentExpressions) {
            expression.deoptimizeCache();
          }
          for (const expression of this.expressionsToBeDeoptimized) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
      deoptimizePath(path4) {
        if (path4.length === 0 || this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path4, this)) {
          return;
        }
        const returnExpression = this.getReturnExpression();
        if (returnExpression !== UNKNOWN_EXPRESSION) {
          returnExpression.deoptimizePath(path4);
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
          thisParameter.deoptimizePath(UNKNOWN_PATH);
        } else {
          recursionTracker.withTrackedEntityAtPath(path4, returnExpression, () => {
            this.expressionsToBeDeoptimized.add(thisParameter);
            returnExpression.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
          }, void 0);
        }
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
          return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, returnExpression, () => {
          this.deoptimizableDependentExpressions.push(origin);
          return returnExpression.getLiteralValueAtPath(path4, recursionTracker, origin);
        }, UnknownValue);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (this.returnExpression === UNKNOWN_EXPRESSION) {
          return UNKNOWN_EXPRESSION;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, returnExpression, () => {
          this.deoptimizableDependentExpressions.push(origin);
          return returnExpression.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
        }, UNKNOWN_EXPRESSION);
      }
      hasEffects(context) {
        try {
          for (const argument of this.arguments) {
            if (argument.hasEffects(context))
              return true;
          }
          if (this.context.options.treeshake.annotations && this.annotations)
            return false;
          return this.callee.hasEffects(context) || this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);
        } finally {
          if (!this.deoptimized)
            this.applyDeoptimizations();
        }
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return !context.accessed.trackEntityAtPathAndGetIfTracked(path4, this) && this.getReturnExpression().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return !context.assigned.trackEntityAtPathAndGetIfTracked(path4, this) && this.getReturnExpression().hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return !(callOptions.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path4, callOptions, this) && this.getReturnExpression().hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (includeChildrenRecursively) {
          super.include(context, includeChildrenRecursively);
          if (includeChildrenRecursively === INCLUDE_PARAMETERS && this.callee instanceof Identifier && this.callee.variable) {
            this.callee.variable.markCalledFromTryStatement();
          }
        } else {
          this.included = true;
          this.callee.include(context, false);
        }
        this.callee.includeCallArguments(context, this.arguments);
        const returnExpression = this.getReturnExpression();
        if (!returnExpression.included) {
          returnExpression.include(context, false);
        }
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        this.callee.render(code, options, {
          isCalleeOfRenderedParent: true,
          renderedSurroundingElement
        });
        if (this.arguments.length > 0) {
          if (this.arguments[this.arguments.length - 1].included) {
            for (const arg of this.arguments) {
              arg.render(code, options);
            }
          } else {
            let lastIncludedIndex = this.arguments.length - 2;
            while (lastIncludedIndex >= 0 && !this.arguments[lastIncludedIndex].included) {
              lastIncludedIndex--;
            }
            if (lastIncludedIndex >= 0) {
              for (let index = 0; index <= lastIncludedIndex; index++) {
                this.arguments[index].render(code, options);
              }
              code.remove(findFirstOccurrenceOutsideComment(code.original, ",", this.arguments[lastIncludedIndex].end), this.end - 1);
            } else {
              code.remove(findFirstOccurrenceOutsideComment(code.original, "(", this.callee.end) + 1, this.end - 1);
            }
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { thisParam } = this.callOptions;
        if (thisParam) {
          this.callee.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParam, SHARED_RECURSION_TRACKER);
        }
        for (const argument of this.arguments) {
          argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.context.requestTreeshakingPass();
      }
      getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
          this.returnExpression = UNKNOWN_EXPRESSION;
          return this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.callOptions, recursionTracker, this);
        }
        return this.returnExpression;
      }
    };
    CatchScope = class extends ParameterScope {
      addDeclaration(identifier, context, init, isHoisted) {
        const existingParameter = this.variables.get(identifier.name);
        if (existingParameter) {
          this.parent.addDeclaration(identifier, context, UNDEFINED_EXPRESSION, isHoisted);
          existingParameter.addDeclaration(identifier, init);
          return existingParameter;
        }
        return this.parent.addDeclaration(identifier, context, init, isHoisted);
      }
    };
    CatchClause = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new CatchScope(parentScope, this.context);
      }
      parseNode(esTreeNode) {
        const { param } = esTreeNode;
        if (param) {
          this.param = new (this.context.getNodeConstructor(param.type))(param, this, this.scope);
          this.param.declare("parameter", UNKNOWN_EXPRESSION);
        }
        super.parseNode(esTreeNode);
      }
    };
    ChainExpression = class extends NodeBase {
    };
    ClassBodyScope = class extends ChildScope {
      constructor(parent, classNode, context) {
        super(parent);
        this.variables.set("this", this.thisVariable = new LocalVariable("this", null, classNode, context));
        this.instanceScope = new ChildScope(this);
        this.instanceScope.variables.set("this", new ThisVariable(context));
      }
      findLexicalBoundary() {
        return this;
      }
    };
    ClassBody = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new ClassBodyScope(parentScope, this.parent, this.context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.context.includeVariableInModule(this.scope.thisVariable);
        for (const definition of this.body) {
          definition.include(context, includeChildrenRecursively);
        }
      }
      parseNode(esTreeNode) {
        const body = this.body = [];
        for (const definition of esTreeNode.body) {
          body.push(new (this.context.getNodeConstructor(definition.type))(definition, this, definition.static ? this.scope : this.scope.instanceScope));
        }
        super.parseNode(esTreeNode);
      }
    };
    MethodBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.accessedValue = null;
        this.accessorCallOptions = {
          args: NO_ARGS,
          thisParam: null,
          withNew: false
        };
      }
      deoptimizeCache() {
      }
      deoptimizePath(path4) {
        this.getAccessedValue().deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        if (event === EVENT_ACCESSED && this.kind === "get" && path4.length === 0) {
          return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
        }
        if (event === EVENT_ASSIGNED && this.kind === "set" && path4.length === 0) {
          return this.value.deoptimizeThisOnEventAtPath(EVENT_CALLED, EMPTY_PATH, thisParameter, recursionTracker);
        }
        this.getAccessedValue().deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getAccessedValue().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffects(context) {
        return this.key.hasEffects(context);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        if (this.kind === "get" && path4.length === 0) {
          return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
        }
        return this.getAccessedValue().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        if (this.kind === "set") {
          return this.value.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, context);
        }
        return this.getAccessedValue().hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return this.getAccessedValue().hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      getAccessedValue() {
        if (this.accessedValue === null) {
          if (this.kind === "get") {
            this.accessedValue = UNKNOWN_EXPRESSION;
            return this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.accessorCallOptions, SHARED_RECURSION_TRACKER, this);
          } else {
            return this.accessedValue = this.value;
          }
        }
        return this.accessedValue;
      }
    };
    MethodDefinition = class extends MethodBase {
    };
    ObjectMember = class extends ExpressionEntity {
      constructor(object, key) {
        super();
        this.object = object;
        this.key = key;
      }
      deoptimizePath(path4) {
        this.object.deoptimizePath([this.key, ...path4]);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.object.deoptimizeThisOnEventAtPath(event, [this.key, ...path4], thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.object.getLiteralValueAtPath([this.key, ...path4], recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path4], callOptions, recursionTracker, origin);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        if (path4.length === 0)
          return false;
        return this.object.hasEffectsWhenAccessedAtPath([this.key, ...path4], context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.object.hasEffectsWhenAssignedAtPath([this.key, ...path4], context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return this.object.hasEffectsWhenCalledAtPath([this.key, ...path4], callOptions, context);
      }
    };
    ClassNode = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      createScope(parentScope) {
        this.scope = new ChildScope(parentScope);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(path4) {
        this.getObjectEntity().deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffects(context) {
        var _a, _b;
        const initEffect = ((_a = this.superClass) === null || _a === void 0 ? void 0 : _a.hasEffects(context)) || this.body.hasEffects(context);
        (_b = this.id) === null || _b === void 0 ? void 0 : _b.markDeclarationReached();
        return initEffect || super.hasEffects(context);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        if (path4.length === 0) {
          return !callOptions.withNew || (this.classConstructor !== null ? this.classConstructor.hasEffectsWhenCalledAtPath(EMPTY_PATH, callOptions, context) : this.superClass !== null && this.superClass.hasEffectsWhenCalledAtPath(path4, callOptions, context));
        } else {
          return this.getObjectEntity().hasEffectsWhenCalledAtPath(path4, callOptions, context);
        }
      }
      include(context, includeChildrenRecursively) {
        var _a;
        this.included = true;
        (_a = this.superClass) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
        this.body.include(context, includeChildrenRecursively);
        if (this.id) {
          this.id.markDeclarationReached();
          this.id.include();
        }
      }
      initialise() {
        var _a;
        (_a = this.id) === null || _a === void 0 ? void 0 : _a.declare("class", this);
        for (const method of this.body.body) {
          if (method instanceof MethodDefinition && method.kind === "constructor") {
            this.classConstructor = method;
            return;
          }
        }
        this.classConstructor = null;
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        const staticProperties = [];
        const dynamicMethods = [];
        for (const definition of this.body.body) {
          const properties = definition.static ? staticProperties : dynamicMethods;
          const definitionKind = definition.kind;
          if (properties === dynamicMethods && !definitionKind)
            continue;
          const kind = definitionKind === "set" || definitionKind === "get" ? definitionKind : "init";
          let key;
          if (definition.computed) {
            const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (keyValue === UnknownValue) {
              properties.push({ key: UnknownKey, kind, property: definition });
              continue;
            } else {
              key = String(keyValue);
            }
          } else {
            key = definition.key instanceof Identifier ? definition.key.name : String(definition.key.value);
          }
          properties.push({ key, kind, property: definition });
        }
        staticProperties.unshift({
          key: "prototype",
          kind: "init",
          property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, "prototype") : OBJECT_PROTOTYPE)
        });
        return this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE);
      }
    };
    ClassDeclaration = class extends ClassNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
      }
      render(code, options) {
        const { exportNamesByVariable, format, snippets: { _ } } = options;
        if (format === "system" && this.id && exportNamesByVariable.has(this.id.variable)) {
          code.appendLeft(this.end, `${_}${getSystemExportStatement([this.id.variable], options)};`);
        }
        super.render(code, options);
      }
    };
    ClassExpression = class extends ClassNode {
      render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
    };
    MultiExpression = class extends ExpressionEntity {
      constructor(expressions) {
        super();
        this.expressions = expressions;
        this.included = false;
      }
      deoptimizePath(path4) {
        for (const expression of this.expressions) {
          expression.deoptimizePath(path4);
        }
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return new MultiExpression(this.expressions.map((expression) => expression.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin)));
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        for (const expression of this.expressions) {
          if (expression.hasEffectsWhenAccessedAtPath(path4, context))
            return true;
        }
        return false;
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        for (const expression of this.expressions) {
          if (expression.hasEffectsWhenAssignedAtPath(path4, context))
            return true;
        }
        return false;
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        for (const expression of this.expressions) {
          if (expression.hasEffectsWhenCalledAtPath(path4, callOptions, context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        for (const expression of this.expressions) {
          if (!expression.included) {
            expression.include(context, includeChildrenRecursively);
          }
        }
      }
    };
    ConditionalExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;
          this.usedBranch = null;
          unusedBranch.deoptimizePath(UNKNOWN_PATH);
          for (const expression of this.expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
      }
      deoptimizePath(path4) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          this.consequent.deoptimizePath(path4);
          this.alternate.deoptimizePath(path4);
        } else {
          usedBranch.deoptimizePath(path4);
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.consequent.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
        this.alternate.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null)
          return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null)
          return new MultiExpression([
            this.consequent.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin),
            this.alternate.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin)
          ]);
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffects(context) {
        if (this.test.hasEffects(context))
          return true;
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
        }
        return usedBranch.hasEffects(context);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.consequent.hasEffectsWhenAccessedAtPath(path4, context) || this.alternate.hasEffectsWhenAccessedAtPath(path4, context);
        }
        return usedBranch.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.consequent.hasEffectsWhenAssignedAtPath(path4, context) || this.alternate.hasEffectsWhenAssignedAtPath(path4, context);
        }
        return usedBranch.hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.consequent.hasEffectsWhenCalledAtPath(path4, callOptions, context) || this.alternate.hasEffectsWhenCalledAtPath(path4, callOptions, context);
        }
        return usedBranch.hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively || this.test.shouldBeIncluded(context) || usedBranch === null) {
          this.test.include(context, includeChildrenRecursively);
          this.consequent.include(context, includeChildrenRecursively);
          this.alternate.include(context, includeChildrenRecursively);
        } else {
          usedBranch.include(context, includeChildrenRecursively);
        }
      }
      includeCallArguments(context, args) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          this.consequent.includeCallArguments(context, args);
          this.alternate.includeCallArguments(context, args);
        } else {
          usedBranch.includeCallArguments(context, args);
        }
      }
      render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        const usedBranch = this.getUsedBranch();
        if (!this.test.included) {
          const colonPos = findFirstOccurrenceOutsideComment(code.original, ":", this.consequent.end);
          const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included ? findFirstOccurrenceOutsideComment(code.original, "?", this.test.end) : colonPos) + 1);
          if (preventASI) {
            removeLineBreaks(code, inclusionStart, usedBranch.start);
          }
          code.remove(this.start, inclusionStart);
          if (this.consequent.included) {
            code.remove(colonPos, this.end);
          }
          removeAnnotations(this, code);
          usedBranch.render(code, options, {
            isCalleeOfRenderedParent,
            preventASI: true,
            renderedParentType: renderedParentType || this.parent.type,
            renderedSurroundingElement: renderedSurroundingElement || this.parent.type
          });
        } else {
          this.test.render(code, options, { renderedSurroundingElement });
          this.consequent.render(code, options);
          this.alternate.render(code, options);
        }
      }
      getUsedBranch() {
        if (this.isBranchResolutionAnalysed) {
          return this.usedBranch;
        }
        this.isBranchResolutionAnalysed = true;
        const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
        return testValue === UnknownValue ? null : this.usedBranch = testValue ? this.consequent : this.alternate;
      }
    };
    ContinueStatement = class extends NodeBase {
      hasEffects(context) {
        if (this.label) {
          if (!context.ignore.labels.has(this.label.name))
            return true;
          context.includedLabels.add(this.label.name);
          context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        } else {
          if (!context.ignore.continues)
            return true;
          context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
        }
        return false;
      }
      include(context) {
        this.included = true;
        if (this.label) {
          this.label.include();
          context.includedLabels.add(this.label.name);
        }
        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
      }
    };
    DoWhileStatement = class extends NodeBase {
      hasEffects(context) {
        if (this.test.hasEffects(context))
          return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
          return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
    };
    EmptyStatement = class extends NodeBase {
      hasEffects() {
        return false;
      }
    };
    ExportAllDeclaration = class extends NodeBase {
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addExport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
    };
    ExportAllDeclaration.prototype.needsBoundaries = true;
    FunctionDeclaration = class extends FunctionNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
      }
    };
    ExportDefaultDeclaration = class extends NodeBase {
      include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively) {
          this.context.includeVariableInModule(this.variable);
        }
      }
      initialise() {
        const declaration = this.declaration;
        this.declarationName = declaration.id && declaration.id.name || this.declaration.name;
        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
        this.context.addExport(this);
      }
      render(code, options, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        const declarationStart = getDeclarationStart(code.original, this.start);
        if (this.declaration instanceof FunctionDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, "function", "(", this.declaration.id === null, options);
        } else if (this.declaration instanceof ClassDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, "class", "{", this.declaration.id === null, options);
        } else if (this.variable.getOriginalVariable() !== this.variable) {
          treeshakeNode(this, code, start, end);
          return;
        } else if (this.variable.included) {
          this.renderVariableDeclaration(code, declarationStart, options);
        } else {
          code.remove(this.start, declarationStart);
          this.declaration.render(code, options, {
            renderedSurroundingElement: ExpressionStatement$1
          });
          if (code.original[this.end - 1] !== ";") {
            code.appendLeft(this.end, ";");
          }
          return;
        }
        this.declaration.render(code, options);
      }
      renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
        const name = this.variable.getName(getPropertyAccess);
        code.remove(this.start, declarationStart);
        if (needsId) {
          code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
        }
        if (format === "system" && this.declaration instanceof ClassDeclaration && exportNamesByVariable.has(this.variable)) {
          code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
        }
      }
      renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59;
        const systemExportNames = format === "system" && exportNamesByVariable.get(this.variable);
        if (systemExportNames) {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
          code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ")" + (hasTrailingSemicolon ? "" : ";"));
        } else {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
          if (!hasTrailingSemicolon) {
            code.appendLeft(this.end, ";");
          }
        }
      }
    };
    ExportDefaultDeclaration.prototype.needsBoundaries = true;
    ExportNamedDeclaration = class extends NodeBase {
      bind() {
        if (this.declaration !== null)
          this.declaration.bind();
      }
      hasEffects(context) {
        return this.declaration !== null && this.declaration.hasEffects(context);
      }
      initialise() {
        this.context.addExport(this);
      }
      render(code, options, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        if (this.declaration === null) {
          code.remove(start, end);
        } else {
          code.remove(this.start, this.declaration.start);
          this.declaration.render(code, options, { end, start });
        }
      }
    };
    ExportNamedDeclaration.prototype.needsBoundaries = true;
    ExportSpecifier = class extends NodeBase {
    };
    ForInStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.left && (this.left.hasEffects(context) || this.left.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context)) || this.right && this.right.hasEffects(context))
          return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
          return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        this.left.include(context, includeChildrenRecursively || true);
        this.right.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        if (code.original.charCodeAt(this.right.start - 1) === 110) {
          code.prependLeft(this.right.start, " ");
        }
        this.body.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.context.requestTreeshakingPass();
      }
    };
    ForOfStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return true;
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        this.left.include(context, includeChildrenRecursively || true);
        this.right.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        if (code.original.charCodeAt(this.right.start - 1) === 102) {
          code.prependLeft(this.right.start, " ");
        }
        this.body.render(code, options);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.context.requestTreeshakingPass();
      }
    };
    ForStatement = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context) {
        if (this.init && this.init.hasEffects(context) || this.test && this.test.hasEffects(context) || this.update && this.update.hasEffects(context))
          return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
          return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.init)
          this.init.includeAsSingleStatement(context, includeChildrenRecursively);
        if (this.test)
          this.test.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        if (this.update)
          this.update.include(context, includeChildrenRecursively);
        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      render(code, options) {
        if (this.init)
          this.init.render(code, options, NO_SEMICOLON);
        if (this.test)
          this.test.render(code, options, NO_SEMICOLON);
        if (this.update)
          this.update.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
      }
    };
    FunctionExpression = class extends FunctionNode {
      render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
    };
    TrackingScope = class extends BlockScope {
      constructor() {
        super(...arguments);
        this.hoistedDeclarations = [];
      }
      addDeclaration(identifier, context, init, isHoisted) {
        this.hoistedDeclarations.push(identifier);
        return super.addDeclaration(identifier, context, init, isHoisted);
      }
    };
    unset = Symbol("unset");
    IfStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.testValue = unset;
      }
      deoptimizeCache() {
        this.testValue = UnknownValue;
      }
      hasEffects(context) {
        if (this.test.hasEffects(context)) {
          return true;
        }
        const testValue = this.getTestValue();
        if (testValue === UnknownValue) {
          const { brokenFlow } = context;
          if (this.consequent.hasEffects(context))
            return true;
          const consequentBrokenFlow = context.brokenFlow;
          context.brokenFlow = brokenFlow;
          if (this.alternate === null)
            return false;
          if (this.alternate.hasEffects(context))
            return true;
          context.brokenFlow = context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
          return false;
        }
        return testValue ? this.consequent.hasEffects(context) : this.alternate !== null && this.alternate.hasEffects(context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (includeChildrenRecursively) {
          this.includeRecursively(includeChildrenRecursively, context);
        } else {
          const testValue = this.getTestValue();
          if (testValue === UnknownValue) {
            this.includeUnknownTest(context);
          } else {
            this.includeKnownTest(context, testValue);
          }
        }
      }
      parseNode(esTreeNode) {
        this.consequentScope = new TrackingScope(this.scope);
        this.consequent = new (this.context.getNodeConstructor(esTreeNode.consequent.type))(esTreeNode.consequent, this, this.consequentScope);
        if (esTreeNode.alternate) {
          this.alternateScope = new TrackingScope(this.scope);
          this.alternate = new (this.context.getNodeConstructor(esTreeNode.alternate.type))(esTreeNode.alternate, this, this.alternateScope);
        }
        super.parseNode(esTreeNode);
      }
      render(code, options) {
        const { snippets: { getPropertyAccess } } = options;
        const testValue = this.getTestValue();
        const hoistedDeclarations = [];
        const includesIfElse = this.test.included;
        const noTreeshake = !this.context.options.treeshake;
        if (includesIfElse) {
          this.test.render(code, options);
        } else {
          code.remove(this.start, this.consequent.start);
        }
        if (this.consequent.included && (noTreeshake || testValue === UnknownValue || testValue)) {
          this.consequent.render(code, options);
        } else {
          code.overwrite(this.consequent.start, this.consequent.end, includesIfElse ? ";" : "");
          hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);
        }
        if (this.alternate) {
          if (this.alternate.included && (noTreeshake || testValue === UnknownValue || !testValue)) {
            if (includesIfElse) {
              if (code.original.charCodeAt(this.alternate.start - 1) === 101) {
                code.prependLeft(this.alternate.start, " ");
              }
            } else {
              code.remove(this.consequent.end, this.alternate.start);
            }
            this.alternate.render(code, options);
          } else {
            if (includesIfElse && this.shouldKeepAlternateBranch()) {
              code.overwrite(this.alternate.start, this.end, ";");
            } else {
              code.remove(this.consequent.end, this.end);
            }
            hoistedDeclarations.push(...this.alternateScope.hoistedDeclarations);
          }
        }
        this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);
      }
      getTestValue() {
        if (this.testValue === unset) {
          return this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
        }
        return this.testValue;
      }
      includeKnownTest(context, testValue) {
        if (this.test.shouldBeIncluded(context)) {
          this.test.include(context, false);
        }
        if (testValue && this.consequent.shouldBeIncluded(context)) {
          this.consequent.includeAsSingleStatement(context, false);
        }
        if (this.alternate !== null && !testValue && this.alternate.shouldBeIncluded(context)) {
          this.alternate.includeAsSingleStatement(context, false);
        }
      }
      includeRecursively(includeChildrenRecursively, context) {
        this.test.include(context, includeChildrenRecursively);
        this.consequent.include(context, includeChildrenRecursively);
        if (this.alternate !== null) {
          this.alternate.include(context, includeChildrenRecursively);
        }
      }
      includeUnknownTest(context) {
        this.test.include(context, false);
        const { brokenFlow } = context;
        let consequentBrokenFlow = BROKEN_FLOW_NONE;
        if (this.consequent.shouldBeIncluded(context)) {
          this.consequent.includeAsSingleStatement(context, false);
          consequentBrokenFlow = context.brokenFlow;
          context.brokenFlow = brokenFlow;
        }
        if (this.alternate !== null && this.alternate.shouldBeIncluded(context)) {
          this.alternate.includeAsSingleStatement(context, false);
          context.brokenFlow = context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
        }
      }
      renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {
        const hoistedVars = [
          ...new Set(hoistedDeclarations.map((identifier) => {
            const variable = identifier.variable;
            return variable.included ? variable.getName(getPropertyAccess) : "";
          }))
        ].filter(Boolean).join(", ");
        if (hoistedVars) {
          const parentType = this.parent.type;
          const needsBraces = parentType !== Program$1 && parentType !== BlockStatement$1;
          code.prependRight(this.start, `${needsBraces ? "{ " : ""}var ${hoistedVars}; `);
          if (needsBraces) {
            code.appendLeft(this.end, ` }`);
          }
        }
      }
      shouldKeepAlternateBranch() {
        let currentParent = this.parent;
        do {
          if (currentParent instanceof IfStatement && currentParent.alternate) {
            return true;
          }
          if (currentParent instanceof BlockStatement) {
            return false;
          }
          currentParent = currentParent.parent;
        } while (currentParent);
        return false;
      }
    };
    ImportDeclaration = class extends NodeBase {
      bind() {
      }
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addImport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
    };
    ImportDeclaration.prototype.needsBoundaries = true;
    ImportDefaultSpecifier = class extends NodeBase {
    };
    INTEROP_DEFAULT_VARIABLE = "_interopDefault";
    INTEROP_DEFAULT_LEGACY_VARIABLE = "_interopDefaultLegacy";
    INTEROP_NAMESPACE_VARIABLE = "_interopNamespace";
    INTEROP_NAMESPACE_DEFAULT_VARIABLE = "_interopNamespaceDefault";
    INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = "_interopNamespaceDefaultOnly";
    MERGE_NAMESPACES_VARIABLE = "_mergeNamespaces";
    defaultInteropHelpersByInteropType = {
      auto: INTEROP_DEFAULT_VARIABLE,
      default: null,
      defaultOnly: null,
      esModule: null,
      false: null,
      true: INTEROP_DEFAULT_LEGACY_VARIABLE
    };
    isDefaultAProperty = (interopType, externalLiveBindings) => interopType === "esModule" || externalLiveBindings && (interopType === "auto" || interopType === "true");
    namespaceInteropHelpersByInteropType = {
      auto: INTEROP_NAMESPACE_VARIABLE,
      default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,
      defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,
      esModule: null,
      false: null,
      true: INTEROP_NAMESPACE_VARIABLE
    };
    canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => isDefaultAProperty(interopType, externalLiveBindings) && defaultInteropHelpersByInteropType[interopType] === INTEROP_DEFAULT_VARIABLE;
    getHelpersBlock = (additionalHelpers, accessedGlobals, indent3, snippets, liveBindings, freeze, namespaceToStringTag) => {
      const usedHelpers = new Set(additionalHelpers);
      for (const variable of HELPER_NAMES) {
        if (accessedGlobals.has(variable)) {
          usedHelpers.add(variable);
        }
      }
      return HELPER_NAMES.map((variable) => usedHelpers.has(variable) ? HELPER_GENERATORS[variable](indent3, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) : "").join("");
    };
    HELPER_GENERATORS = {
      [INTEROP_DEFAULT_LEGACY_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_LEGACY_VARIABLE
        });
        return `${left}e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e${_}?${_}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n2}${n2}`;
      },
      [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_VARIABLE
        });
        return `${left}e${_}&&${_}e.__esModule${_}?${_}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, namespaceToStringTag) {
        const { getDirectReturnFunction, getObject, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
        });
        return `${left}${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, getObject([
          ["__proto__", "null"],
          ["default", "e"]
        ], { lineBreakIndent: null }), snippets))}${right}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, n: n2 } = snippets;
        return `function ${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${_}{${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) + `}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
          const [left, right] = getDirectReturnFunction(["e"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_VARIABLE
          });
          return `${left}e${_}&&${_}e.__esModule${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n2}${n2}`;
        }
        return `function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n2}${t}if${_}(e${_}&&${_}e.__esModule)${_}return e;${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) + `}${n2}${n2}`;
      },
      [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, cnst, n: n2 } = snippets;
        const useForEach = cnst === "var" && liveBindings;
        return `function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n2}${t}${loopOverNamespaces(`{${n2}${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n2}` + (liveBindings ? useForEach ? copyOwnPropertyLiveBinding : copyPropertyLiveBinding : copyPropertyStatic)(t, t + t + t + t, snippets) + `${t}${t}${t}}${n2}${t}${t}}`, useForEach, t, snippets)}${n2}${t}return ${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, "n", snippets))};${n2}}${n2}${n2}`;
      }
    };
    getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([["default", "e"]], { lineBreakIndent: null })}`;
    getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess("default")}${_}:${_}e`;
    createNamespaceObject = (t, i, snippets, liveBindings, freeze, namespaceToStringTag) => {
      const { _, cnst, getObject, getPropertyAccess, n: n2, s } = snippets;
      const copyProperty = `{${n2}` + (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, i + t + t, snippets) + `${i}${t}}`;
      return `${i}${cnst} n${_}=${_}Object.create(null${namespaceToStringTag ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}` : ""});${n2}${i}if${_}(e)${_}{${n2}${i}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n2}${i}}${n2}${i}n${getPropertyAccess("default")}${_}=${_}e;${n2}${i}return ${getFrozen(freeze, "n")}${s}${n2}`;
    };
    loopOverKeys = (body, allowVarLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== "var" || allowVarLoopVariable ? `for${_}(${cnst} k in e)${_}${body}` : `Object.keys(e).forEach(${getFunctionIntro(["k"], {
      isAsync: false,
      name: null
    })}${body})${s}`;
    loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n: n2 }) => {
      if (useForEach) {
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: false,
          lineBreakIndent: { base: t, t },
          name: null
        });
        return `m.forEach(${left}e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(["k"], {
          isAsync: false,
          name: null
        })}${body})${right});`;
      }
      return `for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n2}${t}${t}${cnst} e${_}=${_}m[i];${n2}${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n2}${t}}`;
    };
    copyNonDefaultOwnPropertyLiveBinding = (t, i, snippets) => {
      const { _, n: n2 } = snippets;
      return `${i}if${_}(k${_}!==${_}'default')${_}{${n2}` + copyOwnPropertyLiveBinding(t, i + t, snippets) + `${i}}${n2}`;
    };
    copyOwnPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n2}${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n2}${i}${t}enumerable:${_}true,${n2}${i}${t}get:${_}${left}e[k]${right}${n2}${i}});${n2}`;
    };
    copyPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n2}${i}if${_}(d)${_}{${n2}${i}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n2}${i}${t}${t}enumerable:${_}true,${n2}${i}${t}${t}get:${_}${left}e[k]${right}${n2}${i}${t}});${n2}${i}}${n2}`;
    };
    copyPropertyStatic = (_t, i, { _, n: n2 }) => `${i}n[k]${_}=${_}e[k];${n2}`;
    getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
    getWithToStringTag = (namespaceToStringTag, fragment, { _, getObject }) => namespaceToStringTag ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})` : fragment;
    HELPER_NAMES = Object.keys(HELPER_GENERATORS);
    ImportExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.inlineNamespace = null;
        this.mechanism = null;
        this.resolution = null;
      }
      hasEffects() {
        return true;
      }
      include(context, includeChildrenRecursively) {
        if (!this.included) {
          this.included = true;
          this.context.includeDynamicImport(this);
          this.scope.addAccessedDynamicImport(this);
        }
        this.source.include(context, includeChildrenRecursively);
      }
      initialise() {
        this.context.addDynamicImport(this);
      }
      render(code, options) {
        if (this.inlineNamespace) {
          const { snippets: { getDirectReturnFunction, getPropertyAccess } } = options;
          const [left, right] = getDirectReturnFunction([], {
            functionReturn: true,
            lineBreakIndent: null,
            name: null
          });
          code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`, { contentOnly: true });
          return;
        }
        if (this.mechanism) {
          code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, "(", this.start + 6) + 1, this.mechanism.left, { contentOnly: true });
          code.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true });
        }
        this.source.render(code, options);
      }
      renderFinalResolution(code, resolution, namespaceExportName, { getDirectReturnFunction }) {
        code.overwrite(this.source.start, this.source.end, resolution);
        if (namespaceExportName) {
          const [left, right] = getDirectReturnFunction(["n"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: null
          });
          code.prependLeft(this.end, `.then(${left}n.${namespaceExportName}${right})`);
        }
      }
      setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope) {
        const { format } = options;
        this.resolution = resolution;
        const accessedGlobals = [...accessedImportGlobals[format] || []];
        let helper;
        ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));
        if (helper) {
          accessedGlobals.push(helper);
        }
        if (accessedGlobals.length > 0) {
          this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
      }
      setInternalResolution(inlineNamespace) {
        this.inlineNamespace = inlineNamespace;
      }
      getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
        const mechanism = pluginDriver.hookFirstSync("renderDynamicImport", [
          {
            customResolution: typeof this.resolution === "string" ? this.resolution : null,
            format,
            moduleId: this.context.module.id,
            targetModuleId: this.resolution && typeof this.resolution !== "string" ? this.resolution.id : null
          }
        ]);
        if (mechanism) {
          return { helper: null, mechanism };
        }
        const hasDynamicTarget = !this.resolution || typeof this.resolution === "string";
        switch (format) {
          case "cjs": {
            const helper = getInteropHelper(resolution, exportMode, interop);
            let left = `require(`;
            let right = `)`;
            if (helper) {
              left = `/*#__PURE__*/${helper}(${left}`;
              right += ")";
            }
            const [functionLeft, functionRight] = getDirectReturnFunction([], {
              functionReturn: true,
              lineBreakIndent: null,
              name: null
            });
            left = `Promise.resolve().then(${functionLeft}${left}`;
            right += `${functionRight})`;
            if (!arrowFunctions && hasDynamicTarget) {
              left = getDirectReturnIifeLeft(["t"], `${left}t${right}`, {
                needsArrowReturnParens: false,
                needsWrappedFunction: true
              });
              right = ")";
            }
            return {
              helper,
              mechanism: { left, right }
            };
          }
          case "amd": {
            const resolve4 = compact ? "c" : "resolve";
            const reject = compact ? "e" : "reject";
            const helper = getInteropHelper(resolution, exportMode, interop);
            const [resolveLeft, resolveRight] = getDirectReturnFunction(["m"], {
              functionReturn: false,
              lineBreakIndent: null,
              name: null
            });
            const resolveNamespace = helper ? `${resolveLeft}${resolve4}(/*#__PURE__*/${helper}(m))${resolveRight}` : resolve4;
            const [handlerLeft, handlerRight] = getDirectReturnFunction([resolve4, reject], {
              functionReturn: false,
              lineBreakIndent: null,
              name: null
            });
            let left = `new Promise(${handlerLeft}require([`;
            let right = `],${_}${resolveNamespace},${_}${reject})${handlerRight})`;
            if (!arrowFunctions && hasDynamicTarget) {
              left = getDirectReturnIifeLeft(["t"], `${left}t${right}`, {
                needsArrowReturnParens: false,
                needsWrappedFunction: true
              });
              right = ")";
            }
            return {
              helper,
              mechanism: { left, right }
            };
          }
          case "system":
            return {
              helper: null,
              mechanism: {
                left: "module.import(",
                right: ")"
              }
            };
          case "es":
            if (dynamicImportFunction) {
              return {
                helper: null,
                mechanism: {
                  left: `${dynamicImportFunction}(`,
                  right: ")"
                }
              };
            }
        }
        return { helper: null, mechanism: null };
      }
    };
    accessedImportGlobals = {
      amd: ["require"],
      cjs: ["require"],
      system: ["module"]
    };
    ImportNamespaceSpecifier = class extends NodeBase {
    };
    ImportSpecifier = class extends NodeBase {
    };
    LabeledStatement = class extends NodeBase {
      hasEffects(context) {
        const brokenFlow = context.brokenFlow;
        context.ignore.labels.add(this.label.name);
        if (this.body.hasEffects(context))
          return true;
        context.ignore.labels.delete(this.label.name);
        if (context.includedLabels.has(this.label.name)) {
          context.includedLabels.delete(this.label.name);
          context.brokenFlow = brokenFlow;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        const brokenFlow = context.brokenFlow;
        this.body.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively || context.includedLabels.has(this.label.name)) {
          this.label.include();
          context.includedLabels.delete(this.label.name);
          context.brokenFlow = brokenFlow;
        }
      }
      render(code, options) {
        if (this.label.included) {
          this.label.render(code, options);
        } else {
          code.remove(this.start, findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, ":", this.label.end) + 1));
        }
        this.body.render(code, options);
      }
    };
    LogicalExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
          this.usedBranch = null;
          unusedBranch.deoptimizePath(UNKNOWN_PATH);
          for (const expression of this.expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
      }
      deoptimizePath(path4) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          this.left.deoptimizePath(path4);
          this.right.deoptimizePath(path4);
        } else {
          usedBranch.deoptimizePath(path4);
        }
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.left.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
        this.right.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null)
          return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null)
          return new MultiExpression([
            this.left.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin),
            this.right.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin)
          ]);
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffects(context) {
        if (this.left.hasEffects(context)) {
          return true;
        }
        if (this.getUsedBranch() !== this.left) {
          return this.right.hasEffects(context);
        }
        return false;
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.left.hasEffectsWhenAccessedAtPath(path4, context) || this.right.hasEffectsWhenAccessedAtPath(path4, context);
        }
        return usedBranch.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.left.hasEffectsWhenAssignedAtPath(path4, context) || this.right.hasEffectsWhenAssignedAtPath(path4, context);
        }
        return usedBranch.hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        const usedBranch = this.getUsedBranch();
        if (usedBranch === null) {
          return this.left.hasEffectsWhenCalledAtPath(path4, callOptions, context) || this.right.hasEffectsWhenCalledAtPath(path4, callOptions, context);
        }
        return usedBranch.hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively || usedBranch === this.right && this.left.shouldBeIncluded(context) || usedBranch === null) {
          this.left.include(context, includeChildrenRecursively);
          this.right.include(context, includeChildrenRecursively);
        } else {
          usedBranch.include(context, includeChildrenRecursively);
        }
      }
      render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        if (!this.left.included || !this.right.included) {
          const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
          if (this.right.included) {
            const removePos = findNonWhiteSpace(code.original, operatorPos + 2);
            code.remove(this.start, removePos);
            if (preventASI) {
              removeLineBreaks(code, removePos, this.right.start);
            }
          } else {
            code.remove(operatorPos, this.end);
          }
          removeAnnotations(this, code);
          this.getUsedBranch().render(code, options, {
            isCalleeOfRenderedParent,
            preventASI,
            renderedParentType: renderedParentType || this.parent.type,
            renderedSurroundingElement: renderedSurroundingElement || this.parent.type
          });
        } else {
          this.left.render(code, options, {
            preventASI,
            renderedSurroundingElement
          });
          this.right.render(code, options);
        }
      }
      getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
          this.isBranchResolutionAnalysed = true;
          const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
          if (leftValue === UnknownValue) {
            return null;
          } else {
            this.usedBranch = this.operator === "||" && leftValue || this.operator === "&&" && !leftValue || this.operator === "??" && leftValue != null ? this.left : this.right;
          }
        }
        return this.usedBranch;
      }
    };
    ASSET_PREFIX = "ROLLUP_ASSET_URL_";
    CHUNK_PREFIX = "ROLLUP_CHUNK_URL_";
    FILE_PREFIX = "ROLLUP_FILE_URL_";
    MetaProperty = class extends NodeBase {
      addAccessedGlobals(format, accessedGlobalsByScope) {
        const metaProperty = this.metaProperty;
        const accessedGlobals = (metaProperty && (metaProperty.startsWith(FILE_PREFIX) || metaProperty.startsWith(ASSET_PREFIX) || metaProperty.startsWith(CHUNK_PREFIX)) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format];
        if (accessedGlobals.length > 0) {
          this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
      }
      getReferencedFileName(outputPluginDriver) {
        const metaProperty = this.metaProperty;
        if (metaProperty && metaProperty.startsWith(FILE_PREFIX)) {
          return outputPluginDriver.getFileName(metaProperty.substring(FILE_PREFIX.length));
        }
        return null;
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      include() {
        if (!this.included) {
          this.included = true;
          if (this.meta.name === "import") {
            this.context.addImportMeta(this);
            const parent = this.parent;
            this.metaProperty = parent instanceof MemberExpression && typeof parent.propertyKey === "string" ? parent.propertyKey : null;
          }
        }
      }
      renderFinalMechanism(code, chunkId, format, snippets, outputPluginDriver) {
        var _a;
        const parent = this.parent;
        const metaProperty = this.metaProperty;
        if (metaProperty && (metaProperty.startsWith(FILE_PREFIX) || metaProperty.startsWith(ASSET_PREFIX) || metaProperty.startsWith(CHUNK_PREFIX))) {
          let referenceId = null;
          let assetReferenceId = null;
          let chunkReferenceId = null;
          let fileName;
          if (metaProperty.startsWith(FILE_PREFIX)) {
            referenceId = metaProperty.substring(FILE_PREFIX.length);
            fileName = outputPluginDriver.getFileName(referenceId);
          } else if (metaProperty.startsWith(ASSET_PREFIX)) {
            warnDeprecation(`Using the "${ASSET_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
            assetReferenceId = metaProperty.substring(ASSET_PREFIX.length);
            fileName = outputPluginDriver.getFileName(assetReferenceId);
          } else {
            warnDeprecation(`Using the "${CHUNK_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
            chunkReferenceId = metaProperty.substring(CHUNK_PREFIX.length);
            fileName = outputPluginDriver.getFileName(chunkReferenceId);
          }
          const relativePath = normalize((0, import_path.relative)((0, import_path.dirname)(chunkId), fileName));
          let replacement2;
          if (assetReferenceId !== null) {
            replacement2 = outputPluginDriver.hookFirstSync("resolveAssetUrl", [
              {
                assetFileName: fileName,
                chunkId,
                format,
                moduleId: this.context.module.id,
                relativeAssetPath: relativePath
              }
            ]);
          }
          if (!replacement2) {
            replacement2 = outputPluginDriver.hookFirstSync("resolveFileUrl", [
              {
                assetReferenceId,
                chunkId,
                chunkReferenceId,
                fileName,
                format,
                moduleId: this.context.module.id,
                referenceId: referenceId || assetReferenceId || chunkReferenceId,
                relativePath
              }
            ]) || relativeUrlMechanisms[format](relativePath);
          }
          code.overwrite(parent.start, parent.end, replacement2, { contentOnly: true });
          return;
        }
        const replacement = outputPluginDriver.hookFirstSync("resolveImportMeta", [
          metaProperty,
          {
            chunkId,
            format,
            moduleId: this.context.module.id
          }
        ]) || ((_a = importMetaMechanisms[format]) === null || _a === void 0 ? void 0 : _a.call(importMetaMechanisms, metaProperty, { chunkId, snippets }));
        if (typeof replacement === "string") {
          if (parent instanceof MemberExpression) {
            code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
          } else {
            code.overwrite(this.start, this.end, replacement, { contentOnly: true });
          }
        }
      }
    };
    accessedMetaUrlGlobals = {
      amd: ["document", "module", "URL"],
      cjs: ["document", "require", "URL"],
      es: [],
      iife: ["document", "URL"],
      system: ["module"],
      umd: ["document", "require", "URL"]
    };
    accessedFileUrlGlobals = {
      amd: ["document", "require", "URL"],
      cjs: ["document", "require", "URL"],
      es: [],
      iife: ["document", "URL"],
      system: ["module", "URL"],
      umd: ["document", "require", "URL"]
    };
    getResolveUrl = (path4, URL2 = "URL") => `new ${URL2}(${path4}).href`;
    getRelativeUrlFromDocument = (relativePath, umd2 = false) => getResolveUrl(`'${relativePath}', ${umd2 ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.src || document.baseURI`);
    getGenericImportMetaMechanism = (getUrl) => (prop, { chunkId }) => {
      const urlMechanism = getUrl(chunkId);
      return prop === null ? `({ url: ${urlMechanism} })` : prop === "url" ? urlMechanism : "undefined";
    };
    getUrlFromDocument = (chunkId, umd2 = false) => `${umd2 ? `typeof document === 'undefined' ? location.href : ` : ""}(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
    relativeUrlMechanisms = {
      amd: (relativePath) => {
        if (relativePath[0] !== ".")
          relativePath = "./" + relativePath;
        return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);
      },
      cjs: (relativePath) => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
      es: (relativePath) => getResolveUrl(`'${relativePath}', import.meta.url`),
      iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
      system: (relativePath) => getResolveUrl(`'${relativePath}', module.meta.url`),
      umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath, true)})`
    };
    importMetaMechanisms = {
      amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
      cjs: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
      iife: getGenericImportMetaMechanism((chunkId) => getUrlFromDocument(chunkId)),
      system: (prop, { snippets: { getPropertyAccess } }) => prop === null ? `module.meta` : `module.meta${getPropertyAccess(prop)}`,
      umd: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId, true)})`)
    };
    NewExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const argument of this.arguments) {
          if (argument.hasEffects(context))
            return true;
        }
        if (this.context.options.treeshake.annotations && this.annotations)
          return false;
        return this.callee.hasEffects(context) || this.callee.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 0;
      }
      initialise() {
        this.callOptions = {
          args: this.arguments,
          thisParam: null,
          withNew: true
        };
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const argument of this.arguments) {
          argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.context.requestTreeshakingPass();
      }
    };
    ObjectExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(path4) {
        this.getObjectEntity().deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1 || renderedSurroundingElement === ArrowFunctionExpression$1) {
          code.appendRight(this.start, "(");
          code.prependLeft(this.end, ")");
        }
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        let prototype = OBJECT_PROTOTYPE;
        const properties = [];
        for (const property of this.properties) {
          if (property instanceof SpreadElement) {
            properties.push({ key: UnknownKey, kind: "init", property });
            continue;
          }
          let key;
          if (property.computed) {
            const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (keyValue === UnknownValue) {
              properties.push({ key: UnknownKey, kind: property.kind, property });
              continue;
            } else {
              key = String(keyValue);
            }
          } else {
            key = property.key instanceof Identifier ? property.key.name : String(property.key.value);
            if (key === "__proto__" && property.kind === "init") {
              prototype = property.value instanceof Literal && property.value.value === null ? null : property.value;
              continue;
            }
          }
          properties.push({ key, kind: property.kind, property });
        }
        return this.objectEntity = new ObjectEntity(properties, prototype);
      }
    };
    PrivateIdentifier = class extends NodeBase {
    };
    Program = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.hasCachedEffect = false;
      }
      hasEffects(context) {
        if (this.hasCachedEffect)
          return true;
        for (const node of this.body) {
          if (node.hasEffects(context)) {
            return this.hasCachedEffect = true;
          }
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
            node.include(context, includeChildrenRecursively);
          }
        }
      }
      render(code, options) {
        if (this.body.length) {
          renderStatementList(this.body, code, this.start, this.end, options);
        } else {
          super.render(code, options);
        }
      }
    };
    Property = class extends MethodBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
        this.declarationInit = null;
      }
      declare(kind, init) {
        this.declarationInit = init;
        return this.value.declare(kind, UNKNOWN_EXPRESSION);
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const propertyReadSideEffects = this.context.options.treeshake.propertyReadSideEffects;
        return this.parent.type === "ObjectPattern" && propertyReadSideEffects === "always" || this.key.hasEffects(context) || this.value.hasEffects(context);
      }
      markDeclarationReached() {
        this.value.markDeclarationReached();
      }
      render(code, options) {
        if (!this.shorthand) {
          this.key.render(code, options);
        }
        this.value.render(code, options, { isShorthandProperty: this.shorthand });
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
          this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
          this.context.requestTreeshakingPass();
        }
      }
    };
    PropertyDefinition = class extends NodeBase {
      deoptimizePath(path4) {
        var _a;
        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        var _a;
        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.value ? this.value.getLiteralValueAtPath(path4, recursionTracker, origin) : UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) {
        return this.value ? this.value.getReturnExpressionWhenCalledAtPath(path4, callOptions, recursionTracker, origin) : UNKNOWN_EXPRESSION;
      }
      hasEffects(context) {
        return this.key.hasEffects(context) || this.static && this.value !== null && this.value.hasEffects(context);
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return !this.value || this.value.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return !this.value || this.value.hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return !this.value || this.value.hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
    };
    ReturnStatement = class extends NodeBase {
      hasEffects(context) {
        if (!context.ignore.returnYield || this.argument !== null && this.argument.hasEffects(context))
          return true;
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.argument) {
          this.argument.include(context, includeChildrenRecursively);
        }
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
      }
      initialise() {
        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
      }
      render(code, options) {
        if (this.argument) {
          this.argument.render(code, options, { preventASI: true });
          if (this.argument.start === this.start + 6) {
            code.prependLeft(this.start + 6, " ");
          }
        }
      }
    };
    SequenceExpression = class extends NodeBase {
      deoptimizePath(path4) {
        this.expressions[this.expressions.length - 1].deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.expressions[this.expressions.length - 1].deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      hasEffects(context) {
        for (const expression of this.expressions) {
          if (expression.hasEffects(context))
            return true;
        }
        return false;
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return path4.length > 0 && this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(path4, context);
      }
      hasEffectsWhenCalledAtPath(path4, callOptions, context) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(path4, callOptions, context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        const lastExpression = this.expressions[this.expressions.length - 1];
        for (const expression of this.expressions) {
          if (includeChildrenRecursively || expression === lastExpression && !(this.parent instanceof ExpressionStatement) || expression.shouldBeIncluded(context))
            expression.include(context, includeChildrenRecursively);
        }
      }
      render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
        let includedNodes = 0;
        let lastSeparatorPos = null;
        const lastNode = this.expressions[this.expressions.length - 1];
        for (const { node, separator, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
          if (!node.included) {
            treeshakeNode(node, code, start, end);
            continue;
          }
          includedNodes++;
          lastSeparatorPos = separator;
          if (includedNodes === 1 && preventASI) {
            removeLineBreaks(code, start, node.start);
          }
          if (includedNodes === 1) {
            const parentType = renderedParentType || this.parent.type;
            node.render(code, options, {
              isCalleeOfRenderedParent: isCalleeOfRenderedParent && node === lastNode,
              renderedParentType: parentType,
              renderedSurroundingElement: parentType
            });
          } else {
            node.render(code, options);
          }
        }
        if (lastSeparatorPos) {
          code.remove(lastSeparatorPos, this.end);
        }
      }
    };
    StaticBlock = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context) {
        for (const node of this.body) {
          if (node.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context))
            node.include(context, includeChildrenRecursively);
        }
      }
      render(code, options) {
        if (this.body.length) {
          renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        } else {
          super.render(code, options);
        }
      }
    };
    Super = class extends NodeBase {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(path4) {
        this.variable.deoptimizePath(path4);
      }
      include() {
        if (!this.included) {
          this.included = true;
          this.context.includeVariableInModule(this.variable);
        }
      }
    };
    SwitchCase = class extends NodeBase {
      hasEffects(context) {
        if (this.test && this.test.hasEffects(context))
          return true;
        for (const node of this.consequent) {
          if (context.brokenFlow)
            break;
          if (node.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.test)
          this.test.include(context, includeChildrenRecursively);
        for (const node of this.consequent) {
          if (includeChildrenRecursively || node.shouldBeIncluded(context))
            node.include(context, includeChildrenRecursively);
        }
      }
      render(code, options, nodeRenderOptions) {
        if (this.consequent.length) {
          this.test && this.test.render(code, options);
          const testEnd = this.test ? this.test.end : findFirstOccurrenceOutsideComment(code.original, "default", this.start) + 7;
          const consequentStart = findFirstOccurrenceOutsideComment(code.original, ":", testEnd) + 1;
          renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);
        } else {
          super.render(code, options);
        }
      }
    };
    SwitchCase.prototype.needsBoundaries = true;
    SwitchStatement = class extends NodeBase {
      createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
      }
      hasEffects(context) {
        if (this.discriminant.hasEffects(context))
          return true;
        const { brokenFlow, ignore: { breaks } } = context;
        let minBrokenFlow = Infinity;
        context.ignore.breaks = true;
        for (const switchCase of this.cases) {
          if (switchCase.hasEffects(context))
            return true;
          minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;
          context.brokenFlow = brokenFlow;
        }
        if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
          context.brokenFlow = minBrokenFlow;
        }
        context.ignore.breaks = breaks;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.discriminant.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        let minBrokenFlow = Infinity;
        let isCaseIncluded = includeChildrenRecursively || this.defaultCase !== null && this.defaultCase < this.cases.length - 1;
        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {
          const switchCase = this.cases[caseIndex];
          if (switchCase.included) {
            isCaseIncluded = true;
          }
          if (!isCaseIncluded) {
            const hasEffectsContext = createHasEffectsContext();
            hasEffectsContext.ignore.breaks = true;
            isCaseIncluded = switchCase.hasEffects(hasEffectsContext);
          }
          if (isCaseIncluded) {
            switchCase.include(context, includeChildrenRecursively);
            minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;
            context.brokenFlow = brokenFlow;
          } else {
            minBrokenFlow = brokenFlow;
          }
        }
        if (isCaseIncluded && this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
          context.brokenFlow = minBrokenFlow;
        }
      }
      initialise() {
        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {
          if (this.cases[caseIndex].test === null) {
            this.defaultCase = caseIndex;
            return;
          }
        }
        this.defaultCase = null;
      }
      render(code, options) {
        this.discriminant.render(code, options);
        if (this.cases.length > 0) {
          renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);
        }
      }
    };
    TaggedTemplateExpression = class extends NodeBase {
      bind() {
        super.bind();
        if (this.tag.type === Identifier$1) {
          const name = this.tag.name;
          const variable = this.scope.findVariable(name);
          if (variable.isNamespace) {
            this.context.warn({
              code: "CANNOT_CALL_NAMESPACE",
              message: `Cannot call a namespace ('${name}')`
            }, this.start);
          }
        }
      }
      hasEffects(context) {
        return super.hasEffects(context) || this.tag.hasEffectsWhenCalledAtPath(EMPTY_PATH, this.callOptions, context);
      }
      initialise() {
        this.callOptions = {
          args: NO_ARGS,
          thisParam: null,
          withNew: false
        };
      }
      render(code, options) {
        this.tag.render(code, options, { isCalleeOfRenderedParent: true });
        this.quasi.render(code, options);
      }
    };
    TemplateElement = class extends NodeBase {
      bind() {
      }
      hasEffects() {
        return false;
      }
      include() {
        this.included = true;
      }
      parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        super.parseNode(esTreeNode);
      }
      render() {
      }
    };
    TemplateLiteral = class extends NodeBase {
      getLiteralValueAtPath(path4) {
        if (path4.length > 0 || this.quasis.length !== 1) {
          return UnknownValue;
        }
        return this.quasis[0].value.cooked;
      }
      render(code, options) {
        code.indentExclusionRanges.push([this.start, this.end]);
        super.render(code, options);
      }
    };
    UndefinedVariable = class extends Variable {
      constructor() {
        super("undefined");
      }
      getLiteralValueAtPath() {
        return void 0;
      }
    };
    ExportDefaultVariable = class extends LocalVariable {
      constructor(name, exportDefaultDeclaration, context) {
        super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);
        this.hasId = false;
        this.originalId = null;
        this.originalVariable = null;
        const declaration = exportDefaultDeclaration.declaration;
        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) && declaration.id) {
          this.hasId = true;
          this.originalId = declaration.id;
        } else if (declaration instanceof Identifier) {
          this.originalId = declaration;
        }
      }
      addReference(identifier) {
        if (!this.hasId) {
          this.name = identifier.name;
        }
      }
      getAssignedVariableName() {
        return this.originalId && this.originalId.name || null;
      }
      getBaseVariableName() {
        const original = this.getOriginalVariable();
        if (original === this) {
          return super.getBaseVariableName();
        } else {
          return original.getBaseVariableName();
        }
      }
      getDirectOriginalVariable() {
        return this.originalId && (this.hasId || !(this.originalId.isPossibleTDZ() || this.originalId.variable.isReassigned || this.originalId.variable instanceof UndefinedVariable || "syntheticNamespace" in this.originalId.variable)) ? this.originalId.variable : null;
      }
      getName(getPropertyAccess) {
        const original = this.getOriginalVariable();
        if (original === this) {
          return super.getName(getPropertyAccess);
        } else {
          return original.getName(getPropertyAccess);
        }
      }
      getOriginalVariable() {
        if (this.originalVariable)
          return this.originalVariable;
        let original = this;
        let currentVariable;
        const checkedVariables = /* @__PURE__ */ new Set();
        do {
          checkedVariables.add(original);
          currentVariable = original;
          original = currentVariable.getDirectOriginalVariable();
        } while (original instanceof ExportDefaultVariable && !checkedVariables.has(original));
        return this.originalVariable = original || currentVariable;
      }
    };
    ModuleScope = class extends ChildScope {
      constructor(parent, context) {
        super(parent);
        this.context = context;
        this.variables.set("this", new LocalVariable("this", null, UNDEFINED_EXPRESSION, context));
      }
      addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {
        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);
        this.variables.set("default", variable);
        return variable;
      }
      addNamespaceMemberAccess() {
      }
      deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {
        for (const scope of this.children)
          scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
      }
      findLexicalBoundary() {
        return this;
      }
      findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
          return knownVariable;
        }
        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
        if (variable instanceof GlobalVariable) {
          this.accessedOutsideVariables.set(name, variable);
        }
        return variable;
      }
    };
    ThisExpression = class extends NodeBase {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(path4) {
        this.variable.deoptimizePath(path4);
      }
      deoptimizeThisOnEventAtPath(event, path4, thisParameter, recursionTracker) {
        this.variable.deoptimizeThisOnEventAtPath(
          event,
          path4,
          thisParameter === this ? this.variable : thisParameter,
          recursionTracker
        );
      }
      hasEffectsWhenAccessedAtPath(path4, context) {
        return path4.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(path4, context);
      }
      hasEffectsWhenAssignedAtPath(path4, context) {
        return this.variable.hasEffectsWhenAssignedAtPath(path4, context);
      }
      include() {
        if (!this.included) {
          this.included = true;
          this.context.includeVariableInModule(this.variable);
        }
      }
      initialise() {
        this.alias = this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
        if (this.alias === "undefined") {
          this.context.warn({
            code: "THIS_IS_UNDEFINED",
            message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
            url: `https://rollupjs.org/guide/en/#error-this-is-undefined`
          }, this.start);
        }
      }
      render(code) {
        if (this.alias !== null) {
          code.overwrite(this.start, this.end, this.alias, {
            contentOnly: false,
            storeName: true
          });
        }
      }
    };
    ThrowStatement = class extends NodeBase {
      hasEffects() {
        return true;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.argument.include(context, includeChildrenRecursively);
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
      }
      render(code, options) {
        this.argument.render(code, options, { preventASI: true });
        if (this.argument.start === this.start + 5) {
          code.prependLeft(this.start + 5, " ");
        }
      }
    };
    TryStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.directlyIncluded = false;
        this.includedLabelsAfterBlock = null;
      }
      hasEffects(context) {
        return (this.context.options.treeshake.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(context)) || this.finalizer !== null && this.finalizer.hasEffects(context);
      }
      include(context, includeChildrenRecursively) {
        var _a;
        const tryCatchDeoptimization = (_a = this.context.options.treeshake) === null || _a === void 0 ? void 0 : _a.tryCatchDeoptimization;
        const { brokenFlow } = context;
        if (!this.directlyIncluded || !tryCatchDeoptimization) {
          this.included = true;
          this.directlyIncluded = true;
          this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
          if (context.includedLabels.size > 0) {
            this.includedLabelsAfterBlock = [...context.includedLabels];
          }
          context.brokenFlow = brokenFlow;
        } else if (this.includedLabelsAfterBlock) {
          for (const label of this.includedLabelsAfterBlock) {
            context.includedLabels.add(label);
          }
        }
        if (this.handler !== null) {
          this.handler.include(context, includeChildrenRecursively);
          context.brokenFlow = brokenFlow;
        }
        if (this.finalizer !== null) {
          this.finalizer.include(context, includeChildrenRecursively);
        }
      }
    };
    unaryOperators = {
      "!": (value) => !value,
      "+": (value) => +value,
      "-": (value) => -value,
      delete: () => UnknownValue,
      typeof: (value) => typeof value,
      void: () => void 0,
      "~": (value) => ~value
    };
    UnaryExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (path4.length > 0)
          return UnknownValue;
        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (argumentValue === UnknownValue)
          return UnknownValue;
        return unaryOperators[this.operator](argumentValue);
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.operator === "typeof" && this.argument instanceof Identifier)
          return false;
        return this.argument.hasEffects(context) || this.operator === "delete" && this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        if (this.operator === "void") {
          return path4.length > 0;
        }
        return path4.length > 1;
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.operator === "delete") {
          this.argument.deoptimizePath(EMPTY_PATH);
          this.context.requestTreeshakingPass();
        }
      }
    };
    UnknownNode = class extends NodeBase {
      hasEffects() {
        return true;
      }
      include(context) {
        super.include(context, true);
      }
    };
    UpdateExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return this.argument.hasEffects(context) || this.argument.hasEffectsWhenAssignedAtPath(EMPTY_PATH, context);
      }
      hasEffectsWhenAccessedAtPath(path4) {
        return path4.length > 1;
      }
      render(code, options) {
        const { exportNamesByVariable, format, snippets: { _ } } = options;
        this.argument.render(code, options);
        if (format === "system") {
          const variable = this.argument.variable;
          const exportNames = exportNamesByVariable.get(variable);
          if (exportNames) {
            if (this.prefix) {
              if (exportNames.length === 1) {
                renderSystemExportExpression(variable, this.start, this.end, code, options);
              } else {
                renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options);
              }
            } else {
              const operator = this.operator[0];
              renderSystemExportSequenceBeforeExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options, `${_}${operator}${_}1`);
            }
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath(EMPTY_PATH);
        if (this.argument instanceof Identifier) {
          const variable = this.scope.findVariable(this.argument.name);
          variable.isReassigned = true;
        }
        this.context.requestTreeshakingPass();
      }
    };
    VariableDeclaration = class extends NodeBase {
      deoptimizePath() {
        for (const declarator of this.declarations) {
          declarator.deoptimizePath(EMPTY_PATH);
        }
      }
      hasEffectsWhenAssignedAtPath() {
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        for (const declarator of this.declarations) {
          if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
            declarator.include(context, includeChildrenRecursively);
        }
      }
      includeAsSingleStatement(context, includeChildrenRecursively) {
        this.included = true;
        for (const declarator of this.declarations) {
          if (includeChildrenRecursively || declarator.shouldBeIncluded(context)) {
            declarator.include(context, includeChildrenRecursively);
            declarator.id.include(context, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        for (const declarator of this.declarations) {
          declarator.declareDeclarator(this.kind);
        }
      }
      render(code, options, nodeRenderOptions = BLANK) {
        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
          for (const declarator of this.declarations) {
            declarator.render(code, options);
          }
          if (!nodeRenderOptions.isNoStatement && code.original.charCodeAt(this.end - 1) !== 59) {
            code.appendLeft(this.end, ";");
          }
        } else {
          this.renderReplacedDeclarations(code, options, nodeRenderOptions);
        }
      }
      renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options, isNoStatement) {
        if (code.original.charCodeAt(this.end - 1) === 59) {
          code.remove(this.end - 1, this.end);
        }
        if (!isNoStatement) {
          separatorString += ";";
        }
        if (lastSeparatorPos !== null) {
          if (code.original.charCodeAt(actualContentEnd - 1) === 10 && (code.original.charCodeAt(this.end) === 10 || code.original.charCodeAt(this.end) === 13)) {
            actualContentEnd--;
            if (code.original.charCodeAt(actualContentEnd) === 13) {
              actualContentEnd--;
            }
          }
          if (actualContentEnd === lastSeparatorPos + 1) {
            code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
          } else {
            code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
            code.remove(actualContentEnd, renderedContentEnd);
          }
        } else {
          code.appendLeft(renderedContentEnd, separatorString);
        }
        if (systemPatternExports.length > 0) {
          code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
        }
      }
      renderReplacedDeclarations(code, options, { isNoStatement }) {
        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 ? 1 : 0));
        let actualContentEnd, renderedContentEnd;
        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
        let lastSeparatorPos = renderedContentEnd - 1;
        code.remove(this.start, lastSeparatorPos);
        let isInDeclaration = false;
        let hasRenderedContent = false;
        let separatorString = "", leadingString, nextSeparatorString;
        const aggregatedSystemExports = [];
        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
          if (!node.included) {
            code.remove(start, end);
            continue;
          }
          node.render(code, options);
          leadingString = "";
          nextSeparatorString = "";
          if (!node.id.included || node.id instanceof Identifier && isReassignedExportsMember(node.id.variable, options.exportNamesByVariable)) {
            if (hasRenderedContent) {
              separatorString += ";";
            }
            isInDeclaration = false;
          } else {
            if (singleSystemExport && singleSystemExport === node.id.variable) {
              const operatorPos = findFirstOccurrenceOutsideComment(code.original, "=", node.id.end);
              renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
            }
            if (isInDeclaration) {
              separatorString += ",";
            } else {
              if (hasRenderedContent) {
                separatorString += ";";
              }
              leadingString += `${this.kind} `;
              isInDeclaration = true;
            }
          }
          if (renderedContentEnd === lastSeparatorPos + 1) {
            code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
          } else {
            code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
            code.appendLeft(renderedContentEnd, leadingString);
          }
          actualContentEnd = contentEnd;
          renderedContentEnd = end;
          hasRenderedContent = true;
          lastSeparatorPos = separator;
          separatorString = nextSeparatorString;
        }
        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options, isNoStatement);
      }
    };
    VariableDeclarator = class extends NodeBase {
      declareDeclarator(kind) {
        this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
      }
      deoptimizePath(path4) {
        this.id.deoptimizePath(path4);
      }
      hasEffects(context) {
        const initEffect = this.init !== null && this.init.hasEffects(context);
        this.id.markDeclarationReached();
        return initEffect || this.id.hasEffects(context);
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        if (this.init) {
          this.init.include(context, includeChildrenRecursively);
        }
        this.id.markDeclarationReached();
        if (includeChildrenRecursively || this.id.shouldBeIncluded(context)) {
          this.id.include(context, includeChildrenRecursively);
        }
      }
      render(code, options) {
        const { exportNamesByVariable, snippets: { _ } } = options;
        const renderId = this.id.included;
        if (renderId) {
          this.id.render(code, options);
        } else {
          const operatorPos = findFirstOccurrenceOutsideComment(code.original, "=", this.id.end);
          code.remove(this.start, findNonWhiteSpace(code.original, operatorPos + 1));
        }
        if (this.init) {
          this.init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
        } else if (this.id instanceof Identifier && isReassignedExportsMember(this.id.variable, exportNamesByVariable)) {
          code.appendLeft(this.end, `${_}=${_}void 0`);
        }
      }
    };
    WhileStatement = class extends NodeBase {
      hasEffects(context) {
        if (this.test.hasEffects(context))
          return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
          return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.includeAsSingleStatement(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
    };
    YieldExpression = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.deoptimized = false;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return !context.ignore.returnYield || this.argument !== null && this.argument.hasEffects(context);
      }
      render(code, options) {
        if (this.argument) {
          this.argument.render(code, options, { preventASI: true });
          if (this.argument.start === this.start + 5) {
            code.prependLeft(this.start + 5, " ");
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { argument } = this;
        if (argument) {
          argument.deoptimizePath(UNKNOWN_PATH);
          this.context.requestTreeshakingPass();
        }
      }
    };
    nodeConstructors = {
      ArrayExpression,
      ArrayPattern,
      ArrowFunctionExpression,
      AssignmentExpression,
      AssignmentPattern,
      AwaitExpression,
      BinaryExpression,
      BlockStatement,
      BreakStatement,
      CallExpression,
      CatchClause,
      ChainExpression,
      ClassBody,
      ClassDeclaration,
      ClassExpression,
      ConditionalExpression,
      ContinueStatement,
      DoWhileStatement,
      EmptyStatement,
      ExportAllDeclaration,
      ExportDefaultDeclaration,
      ExportNamedDeclaration,
      ExportSpecifier,
      ExpressionStatement,
      ForInStatement,
      ForOfStatement,
      ForStatement,
      FunctionDeclaration,
      FunctionExpression,
      Identifier,
      IfStatement,
      ImportDeclaration,
      ImportDefaultSpecifier,
      ImportExpression,
      ImportNamespaceSpecifier,
      ImportSpecifier,
      LabeledStatement,
      Literal,
      LogicalExpression,
      MemberExpression,
      MetaProperty,
      MethodDefinition,
      NewExpression,
      ObjectExpression,
      ObjectPattern,
      PrivateIdentifier,
      Program,
      Property,
      PropertyDefinition,
      RestElement,
      ReturnStatement,
      SequenceExpression,
      SpreadElement,
      StaticBlock,
      Super,
      SwitchCase,
      SwitchStatement,
      TaggedTemplateExpression,
      TemplateElement,
      TemplateLiteral,
      ThisExpression,
      ThrowStatement,
      TryStatement,
      UnaryExpression,
      UnknownNode,
      UpdateExpression,
      VariableDeclaration,
      VariableDeclarator,
      WhileStatement,
      YieldExpression
    };
    MISSING_EXPORT_SHIM_VARIABLE = "_missingExportShim";
    ExportShimVariable = class extends Variable {
      constructor(module2) {
        super(MISSING_EXPORT_SHIM_VARIABLE);
        this.module = module2;
      }
      include() {
        super.include();
        this.module.needsExportShim = true;
      }
    };
    NamespaceVariable = class extends Variable {
      constructor(context) {
        super(context.getModuleName());
        this.memberVariables = null;
        this.mergedNamespaces = [];
        this.referencedEarly = false;
        this.references = [];
        this.context = context;
        this.module = context.module;
      }
      addReference(identifier) {
        this.references.push(identifier);
        this.name = identifier.name;
      }
      getMemberVariables() {
        if (this.memberVariables) {
          return this.memberVariables;
        }
        const memberVariables = /* @__PURE__ */ Object.create(null);
        for (const name of this.context.getExports().concat(this.context.getReexports())) {
          if (name[0] !== "*" && name !== this.module.info.syntheticNamedExports) {
            const exportedVariable = this.context.traceExport(name);
            if (exportedVariable) {
              memberVariables[name] = exportedVariable;
            }
          }
        }
        return this.memberVariables = memberVariables;
      }
      include() {
        this.included = true;
        this.context.includeAllExports();
      }
      prepare(accessedGlobalsByScope) {
        if (this.mergedNamespaces.length > 0) {
          this.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE], accessedGlobalsByScope);
        }
      }
      renderBlock(options) {
        const { exportNamesByVariable, format, freeze, indent: t, namespaceToStringTag, snippets: { _, cnst, getObject, getPropertyAccess, n: n2, s } } = options;
        const memberVariables = this.getMemberVariables();
        const members = Object.entries(memberVariables).map(([name2, original]) => {
          if (this.referencedEarly || original.isReassigned) {
            return [
              null,
              `get ${name2}${_}()${_}{${_}return ${original.getName(getPropertyAccess)}${s}${_}}`
            ];
          }
          return [name2, original.getName(getPropertyAccess)];
        });
        members.unshift([null, `__proto__:${_}null`]);
        let output = getObject(members, { lineBreakIndent: { base: "", t } });
        if (this.mergedNamespaces.length > 0) {
          const assignmentArgs = this.mergedNamespaces.map((variable) => variable.getName(getPropertyAccess));
          output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArgs.join(`,${_}`)}])`;
        } else {
          if (namespaceToStringTag) {
            output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;
          }
          if (freeze) {
            output = `/*#__PURE__*/Object.freeze(${output})`;
          }
        }
        const name = this.getName(getPropertyAccess);
        output = `${cnst} ${name}${_}=${_}${output};`;
        if (format === "system" && exportNamesByVariable.has(this)) {
          output += `${n2}${getSystemExportStatement([this], options)};`;
        }
        return output;
      }
      renderFirst() {
        return this.referencedEarly;
      }
      setMergedNamespaces(mergedNamespaces) {
        this.mergedNamespaces = mergedNamespaces;
        const moduleExecIndex = this.context.getModuleExecIndex();
        for (const identifier of this.references) {
          if (identifier.context.getModuleExecIndex() <= moduleExecIndex) {
            this.referencedEarly = true;
            break;
          }
        }
      }
    };
    NamespaceVariable.prototype.isNamespace = true;
    SyntheticNamedExportVariable = class extends Variable {
      constructor(context, name, syntheticNamespace) {
        super(name);
        this.baseVariable = null;
        this.context = context;
        this.module = context.module;
        this.syntheticNamespace = syntheticNamespace;
      }
      getBaseVariable() {
        if (this.baseVariable)
          return this.baseVariable;
        let baseVariable = this.syntheticNamespace;
        while (baseVariable instanceof ExportDefaultVariable || baseVariable instanceof SyntheticNamedExportVariable) {
          if (baseVariable instanceof ExportDefaultVariable) {
            const original = baseVariable.getOriginalVariable();
            if (original === baseVariable)
              break;
            baseVariable = original;
          }
          if (baseVariable instanceof SyntheticNamedExportVariable) {
            baseVariable = baseVariable.syntheticNamespace;
          }
        }
        return this.baseVariable = baseVariable;
      }
      getBaseVariableName() {
        return this.syntheticNamespace.getBaseVariableName();
      }
      getName(getPropertyAccess) {
        return `${this.syntheticNamespace.getName(getPropertyAccess)}${getPropertyAccess(this.name)}`;
      }
      include() {
        this.included = true;
        this.context.includeVariableInModule(this.syntheticNamespace);
      }
      setRenderNames(baseName, name) {
        super.setRenderNames(baseName, name);
      }
    };
    (function(BuildPhase2) {
      BuildPhase2[BuildPhase2["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
      BuildPhase2[BuildPhase2["ANALYSE"] = 1] = "ANALYSE";
      BuildPhase2[BuildPhase2["GENERATE"] = 2] = "GENERATE";
    })(BuildPhase || (BuildPhase = {}));
    NOOP = () => {
    };
    timers = /* @__PURE__ */ new Map();
    timeStart = NOOP;
    timeEnd = NOOP;
    TIMED_PLUGIN_HOOKS = ["load", "resolveDynamicImport", "resolveId", "transform"];
    MISSING_EXPORT_SHIM_DESCRIPTION = {
      identifier: null,
      localName: MISSING_EXPORT_SHIM_VARIABLE
    };
    Module = class {
      constructor(graph, id, options, isEntry, moduleSideEffects, syntheticNamedExports, meta) {
        this.graph = graph;
        this.id = id;
        this.options = options;
        this.alternativeReexportModules = /* @__PURE__ */ new Map();
        this.chunkFileNames = /* @__PURE__ */ new Set();
        this.chunkNames = [];
        this.cycles = /* @__PURE__ */ new Set();
        this.dependencies = /* @__PURE__ */ new Set();
        this.dynamicDependencies = /* @__PURE__ */ new Set();
        this.dynamicImporters = [];
        this.dynamicImports = [];
        this.execIndex = Infinity;
        this.implicitlyLoadedAfter = /* @__PURE__ */ new Set();
        this.implicitlyLoadedBefore = /* @__PURE__ */ new Set();
        this.importDescriptions = /* @__PURE__ */ new Map();
        this.importMetas = [];
        this.importedFromNotTreeshaken = false;
        this.importers = [];
        this.imports = /* @__PURE__ */ new Set();
        this.includedDynamicImporters = [];
        this.isExecuted = false;
        this.isUserDefinedEntryPoint = false;
        this.needsExportShim = false;
        this.sideEffectDependenciesByVariable = /* @__PURE__ */ new Map();
        this.sources = /* @__PURE__ */ new Set();
        this.usesTopLevelAwait = false;
        this.allExportNames = null;
        this.ast = null;
        this.exportAllModules = [];
        this.exportAllSources = /* @__PURE__ */ new Set();
        this.exportNamesByVariable = null;
        this.exportShimVariable = new ExportShimVariable(this);
        this.exports = /* @__PURE__ */ new Map();
        this.namespaceReexportsByName = /* @__PURE__ */ new Map();
        this.reexportDescriptions = /* @__PURE__ */ new Map();
        this.relevantDependencies = null;
        this.syntheticExports = /* @__PURE__ */ new Map();
        this.syntheticNamespace = null;
        this.transformDependencies = [];
        this.transitiveReexports = null;
        this.excludeFromSourcemap = /\0/.test(id);
        this.context = options.moduleContext(id);
        this.preserveSignature = this.options.preserveEntrySignatures;
        const module2 = this;
        const { dynamicImports, dynamicImporters, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sources } = this;
        this.info = {
          ast: null,
          code: null,
          get dynamicallyImportedIdResolutions() {
            return dynamicImports.map(({ argument }) => typeof argument === "string" && module2.resolvedIds[argument]).filter(Boolean);
          },
          get dynamicallyImportedIds() {
            return dynamicImports.map(({ id: id2 }) => id2).filter((id2) => id2 != null);
          },
          get dynamicImporters() {
            return dynamicImporters.sort();
          },
          get hasDefaultExport() {
            if (!module2.ast) {
              return null;
            }
            return module2.exports.has("default") || reexportDescriptions.has("default");
          },
          get hasModuleSideEffects() {
            warnDeprecation("Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.", false, options);
            return this.moduleSideEffects;
          },
          id,
          get implicitlyLoadedAfterOneOf() {
            return Array.from(implicitlyLoadedAfter, getId).sort();
          },
          get implicitlyLoadedBefore() {
            return Array.from(implicitlyLoadedBefore, getId).sort();
          },
          get importedIdResolutions() {
            return Array.from(sources, (source) => module2.resolvedIds[source]).filter(Boolean);
          },
          get importedIds() {
            return Array.from(sources, (source) => {
              var _a;
              return (_a = module2.resolvedIds[source]) === null || _a === void 0 ? void 0 : _a.id;
            }).filter(Boolean);
          },
          get importers() {
            return importers.sort();
          },
          isEntry,
          isExternal: false,
          get isIncluded() {
            if (graph.phase !== BuildPhase.GENERATE) {
              return null;
            }
            return module2.isIncluded();
          },
          meta: { ...meta },
          moduleSideEffects,
          syntheticNamedExports
        };
        Object.defineProperty(this.info, "hasModuleSideEffects", {
          enumerable: false
        });
      }
      basename() {
        const base2 = (0, import_path.basename)(this.id);
        const ext = (0, import_path.extname)(this.id);
        return makeLegal(ext ? base2.slice(0, -ext.length) : base2);
      }
      bindReferences() {
        this.ast.bind();
      }
      error(props, pos) {
        this.addLocationToLogProps(props, pos);
        return error(props);
      }
      getAllExportNames() {
        if (this.allExportNames) {
          return this.allExportNames;
        }
        this.allExportNames = /* @__PURE__ */ new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
        for (const module2 of this.exportAllModules) {
          if (module2 instanceof ExternalModule) {
            this.allExportNames.add(`*${module2.id}`);
            continue;
          }
          for (const name of module2.getAllExportNames()) {
            if (name !== "default")
              this.allExportNames.add(name);
          }
        }
        if (typeof this.info.syntheticNamedExports === "string") {
          this.allExportNames.delete(this.info.syntheticNamedExports);
        }
        return this.allExportNames;
      }
      getDependenciesToBeIncluded() {
        if (this.relevantDependencies)
          return this.relevantDependencies;
        this.relevantDependencies = /* @__PURE__ */ new Set();
        const necessaryDependencies = /* @__PURE__ */ new Set();
        const alwaysCheckedDependencies = /* @__PURE__ */ new Set();
        const dependencyVariables = new Set(this.imports);
        if (this.info.isEntry || this.includedDynamicImporters.length > 0 || this.namespace.included || this.implicitlyLoadedAfter.size > 0) {
          for (const exportName of [...this.getReexports(), ...this.getExports()]) {
            const [exportedVariable] = this.getVariableForExportName(exportName);
            if (exportedVariable) {
              dependencyVariables.add(exportedVariable);
            }
          }
        }
        for (let variable of dependencyVariables) {
          const sideEffectDependencies = this.sideEffectDependenciesByVariable.get(variable);
          if (sideEffectDependencies) {
            for (const module2 of sideEffectDependencies) {
              alwaysCheckedDependencies.add(module2);
            }
          }
          if (variable instanceof SyntheticNamedExportVariable) {
            variable = variable.getBaseVariable();
          } else if (variable instanceof ExportDefaultVariable) {
            variable = variable.getOriginalVariable();
          }
          necessaryDependencies.add(variable.module);
        }
        if (!this.options.treeshake || this.info.moduleSideEffects === "no-treeshake") {
          for (const dependency of this.dependencies) {
            this.relevantDependencies.add(dependency);
          }
        } else {
          this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
        }
        for (const dependency of necessaryDependencies) {
          this.relevantDependencies.add(dependency);
        }
        return this.relevantDependencies;
      }
      getExportNamesByVariable() {
        if (this.exportNamesByVariable) {
          return this.exportNamesByVariable;
        }
        const exportNamesByVariable = /* @__PURE__ */ new Map();
        for (const exportName of this.getAllExportNames()) {
          let [tracedVariable] = this.getVariableForExportName(exportName);
          if (tracedVariable instanceof ExportDefaultVariable) {
            tracedVariable = tracedVariable.getOriginalVariable();
          }
          if (!tracedVariable || !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {
            continue;
          }
          const existingExportNames = exportNamesByVariable.get(tracedVariable);
          if (existingExportNames) {
            existingExportNames.push(exportName);
          } else {
            exportNamesByVariable.set(tracedVariable, [exportName]);
          }
        }
        return this.exportNamesByVariable = exportNamesByVariable;
      }
      getExports() {
        return Array.from(this.exports.keys());
      }
      getReexports() {
        if (this.transitiveReexports) {
          return this.transitiveReexports;
        }
        this.transitiveReexports = [];
        const reexports = new Set(this.reexportDescriptions.keys());
        for (const module2 of this.exportAllModules) {
          if (module2 instanceof ExternalModule) {
            reexports.add(`*${module2.id}`);
          } else {
            for (const name of [...module2.getReexports(), ...module2.getExports()]) {
              if (name !== "default")
                reexports.add(name);
            }
          }
        }
        return this.transitiveReexports = [...reexports];
      }
      getRenderedExports() {
        const renderedExports = [];
        const removedExports = [];
        for (const exportName of this.exports.keys()) {
          const [variable] = this.getVariableForExportName(exportName);
          (variable && variable.included ? renderedExports : removedExports).push(exportName);
        }
        return { removedExports, renderedExports };
      }
      getSyntheticNamespace() {
        if (this.syntheticNamespace === null) {
          this.syntheticNamespace = void 0;
          [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === "string" ? this.info.syntheticNamedExports : "default", { onlyExplicit: true });
        }
        if (!this.syntheticNamespace) {
          return error(errSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
        }
        return this.syntheticNamespace;
      }
      getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = EMPTY_OBJECT) {
        var _a;
        if (name[0] === "*") {
          if (name.length === 1) {
            return [this.namespace];
          }
          const module2 = this.graph.modulesById.get(name.slice(1));
          return module2.getVariableForExportName("*");
        }
        const reexportDeclaration = this.reexportDescriptions.get(name);
        if (reexportDeclaration) {
          const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);
          if (!variable) {
            return this.error(errMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
          }
          if (importerForSideEffects) {
            setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
          }
          return [variable];
        }
        const exportDeclaration = this.exports.get(name);
        if (exportDeclaration) {
          if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
            return [this.exportShimVariable];
          }
          const name2 = exportDeclaration.localName;
          const variable = this.traceVariable(name2, importerForSideEffects);
          if (importerForSideEffects) {
            getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, () => /* @__PURE__ */ new Set()).add(this);
            setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
          }
          return [variable];
        }
        if (onlyExplicit) {
          return [null];
        }
        if (name !== "default") {
          const foundNamespaceReexport = (_a = this.namespaceReexportsByName.get(name)) !== null && _a !== void 0 ? _a : this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);
          this.namespaceReexportsByName.set(name, foundNamespaceReexport);
          if (foundNamespaceReexport[0]) {
            return foundNamespaceReexport;
          }
        }
        if (this.info.syntheticNamedExports) {
          return [
            getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))
          ];
        }
        if (!isExportAllSearch) {
          if (this.options.shimMissingExports) {
            this.shimMissingExport(name);
            return [this.exportShimVariable];
          }
        }
        return [null];
      }
      hasEffects() {
        return this.info.moduleSideEffects === "no-treeshake" || this.ast.included && this.ast.hasEffects(createHasEffectsContext());
      }
      include() {
        const context = createInclusionContext();
        if (this.ast.shouldBeIncluded(context))
          this.ast.include(context, false);
      }
      includeAllExports(includeNamespaceMembers) {
        if (!this.isExecuted) {
          markModuleAndImpureDependenciesAsExecuted(this);
          this.graph.needsTreeshakingPass = true;
        }
        for (const exportName of this.exports.keys()) {
          if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {
            const variable = this.getVariableForExportName(exportName)[0];
            variable.deoptimizePath(UNKNOWN_PATH);
            if (!variable.included) {
              this.includeVariable(variable);
            }
          }
        }
        for (const name of this.getReexports()) {
          const [variable] = this.getVariableForExportName(name);
          if (variable) {
            variable.deoptimizePath(UNKNOWN_PATH);
            if (!variable.included) {
              this.includeVariable(variable);
            }
            if (variable instanceof ExternalVariable) {
              variable.module.reexported = true;
            }
          }
        }
        if (includeNamespaceMembers) {
          this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
        }
      }
      includeAllInBundle() {
        this.ast.include(createInclusionContext(), true);
        this.includeAllExports(false);
      }
      isIncluded() {
        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
      }
      linkImports() {
        this.addModulesToImportDescriptions(this.importDescriptions);
        this.addModulesToImportDescriptions(this.reexportDescriptions);
        const externalExportAllModules = [];
        for (const source of this.exportAllSources) {
          const module2 = this.graph.modulesById.get(this.resolvedIds[source].id);
          if (module2 instanceof ExternalModule) {
            externalExportAllModules.push(module2);
            continue;
          }
          this.exportAllModules.push(module2);
        }
        this.exportAllModules.push(...externalExportAllModules);
      }
      render(options) {
        const magicString = this.magicString.clone();
        this.ast.render(magicString, options);
        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
        return magicString;
      }
      setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {
        this.info.code = code;
        this.originalCode = originalCode;
        this.originalSourcemap = originalSourcemap;
        this.sourcemapChain = sourcemapChain;
        if (transformFiles) {
          this.transformFiles = transformFiles;
        }
        this.transformDependencies = transformDependencies;
        this.customTransformCache = customTransformCache;
        this.updateOptions(moduleOptions);
        timeStart("generate ast", 3);
        if (!ast) {
          ast = this.tryParse();
        }
        timeEnd("generate ast", 3);
        this.resolvedIds = resolvedIds || /* @__PURE__ */ Object.create(null);
        const fileName = this.id;
        this.magicString = new MagicString$1(code, {
          filename: this.excludeFromSourcemap ? null : fileName,
          indentExclusionRanges: []
        });
        timeStart("analyse ast", 3);
        this.astContext = {
          addDynamicImport: this.addDynamicImport.bind(this),
          addExport: this.addExport.bind(this),
          addImport: this.addImport.bind(this),
          addImportMeta: this.addImportMeta.bind(this),
          code,
          deoptimizationTracker: this.graph.deoptimizationTracker,
          error: this.error.bind(this),
          fileName,
          getExports: this.getExports.bind(this),
          getModuleExecIndex: () => this.execIndex,
          getModuleName: this.basename.bind(this),
          getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,
          getReexports: this.getReexports.bind(this),
          importDescriptions: this.importDescriptions,
          includeAllExports: () => this.includeAllExports(true),
          includeDynamicImport: this.includeDynamicImport.bind(this),
          includeVariableInModule: this.includeVariableInModule.bind(this),
          magicString: this.magicString,
          module: this,
          moduleContext: this.context,
          options: this.options,
          requestTreeshakingPass: () => this.graph.needsTreeshakingPass = true,
          traceExport: (name) => this.getVariableForExportName(name)[0],
          traceVariable: this.traceVariable.bind(this),
          usesTopLevelAwait: false,
          warn: this.warn.bind(this)
        };
        this.scope = new ModuleScope(this.graph.scope, this.astContext);
        this.namespace = new NamespaceVariable(this.astContext);
        this.ast = new Program(ast, { context: this.astContext, type: "Module" }, this.scope);
        this.info.ast = ast;
        timeEnd("analyse ast", 3);
      }
      toJSON() {
        return {
          ast: this.ast.esTreeNode,
          code: this.info.code,
          customTransformCache: this.customTransformCache,
          dependencies: Array.from(this.dependencies, getId),
          id: this.id,
          meta: this.info.meta,
          moduleSideEffects: this.info.moduleSideEffects,
          originalCode: this.originalCode,
          originalSourcemap: this.originalSourcemap,
          resolvedIds: this.resolvedIds,
          sourcemapChain: this.sourcemapChain,
          syntheticNamedExports: this.info.syntheticNamedExports,
          transformDependencies: this.transformDependencies,
          transformFiles: this.transformFiles
        };
      }
      traceVariable(name, importerForSideEffects) {
        const localVariable = this.scope.variables.get(name);
        if (localVariable) {
          return localVariable;
        }
        const importDeclaration = this.importDescriptions.get(name);
        if (importDeclaration) {
          const otherModule = importDeclaration.module;
          if (otherModule instanceof Module && importDeclaration.name === "*") {
            return otherModule.namespace;
          }
          const [declaration] = otherModule.getVariableForExportName(importDeclaration.name, {
            importerForSideEffects: importerForSideEffects || this
          });
          if (!declaration) {
            return this.error(errMissingExport(importDeclaration.name, this.id, otherModule.id), importDeclaration.start);
          }
          return declaration;
        }
        return null;
      }
      tryParse() {
        try {
          return this.graph.contextParse(this.info.code);
        } catch (err) {
          let message = err.message.replace(/ \(\d+:\d+\)$/, "");
          if (this.id.endsWith(".json")) {
            message += " (Note that you need @rollup/plugin-json to import JSON files)";
          } else if (!this.id.endsWith(".js")) {
            message += " (Note that you need plugins to import files that are not JavaScript)";
          }
          return this.error({
            code: "PARSE_ERROR",
            message,
            parserError: err
          }, err.pos);
        }
      }
      updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {
        if (moduleSideEffects != null) {
          this.info.moduleSideEffects = moduleSideEffects;
        }
        if (syntheticNamedExports != null) {
          this.info.syntheticNamedExports = syntheticNamedExports;
        }
        if (meta != null) {
          Object.assign(this.info.meta, meta);
        }
      }
      warn(props, pos) {
        this.addLocationToLogProps(props, pos);
        this.options.onwarn(props);
      }
      addDynamicImport(node) {
        let argument = node.source;
        if (argument instanceof TemplateLiteral) {
          if (argument.quasis.length === 1 && argument.quasis[0].value.cooked) {
            argument = argument.quasis[0].value.cooked;
          }
        } else if (argument instanceof Literal && typeof argument.value === "string") {
          argument = argument.value;
        }
        this.dynamicImports.push({ argument, id: null, node, resolution: null });
      }
      addExport(node) {
        if (node instanceof ExportDefaultDeclaration) {
          this.exports.set("default", {
            identifier: node.variable.getAssignedVariableName(),
            localName: "default"
          });
        } else if (node instanceof ExportAllDeclaration) {
          const source = node.source.value;
          this.sources.add(source);
          if (node.exported) {
            const name = node.exported.name;
            this.reexportDescriptions.set(name, {
              localName: "*",
              module: null,
              source,
              start: node.start
            });
          } else {
            this.exportAllSources.add(source);
          }
        } else if (node.source instanceof Literal) {
          const source = node.source.value;
          this.sources.add(source);
          for (const specifier of node.specifiers) {
            const name = specifier.exported.name;
            this.reexportDescriptions.set(name, {
              localName: specifier.local.name,
              module: null,
              source,
              start: specifier.start
            });
          }
        } else if (node.declaration) {
          const declaration = node.declaration;
          if (declaration instanceof VariableDeclaration) {
            for (const declarator of declaration.declarations) {
              for (const localName of extractAssignedNames(declarator.id)) {
                this.exports.set(localName, { identifier: null, localName });
              }
            }
          } else {
            const localName = declaration.id.name;
            this.exports.set(localName, { identifier: null, localName });
          }
        } else {
          for (const specifier of node.specifiers) {
            const localName = specifier.local.name;
            const exportedName = specifier.exported.name;
            this.exports.set(exportedName, { identifier: null, localName });
          }
        }
      }
      addImport(node) {
        const source = node.source.value;
        this.sources.add(source);
        for (const specifier of node.specifiers) {
          const isDefault = specifier.type === ImportDefaultSpecifier$1;
          const isNamespace = specifier.type === ImportNamespaceSpecifier$1;
          const name = isDefault ? "default" : isNamespace ? "*" : specifier.imported.name;
          this.importDescriptions.set(specifier.local.name, {
            module: null,
            name,
            source,
            start: specifier.start
          });
        }
      }
      addImportMeta(node) {
        this.importMetas.push(node);
      }
      addLocationToLogProps(props, pos) {
        props.id = this.id;
        props.pos = pos;
        let code = this.info.code;
        const location = locate(code, pos, { offsetLine: 1 });
        if (location) {
          let { column, line } = location;
          try {
            ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));
            code = this.originalCode;
          } catch (err) {
            this.options.onwarn({
              code: "SOURCEMAP_ERROR",
              id: this.id,
              loc: {
                column,
                file: this.id,
                line
              },
              message: `Error when using sourcemap for reporting an error: ${err.message}`,
              pos
            });
          }
          augmentCodeLocation(props, { column, line }, code, this.id);
        }
      }
      addModulesToImportDescriptions(importDescription) {
        for (const specifier of importDescription.values()) {
          const { id } = this.resolvedIds[specifier.source];
          specifier.module = this.graph.modulesById.get(id);
        }
      }
      addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies) {
        const handledDependencies = /* @__PURE__ */ new Set();
        const addSideEffectDependencies = (possibleDependencies) => {
          for (const dependency of possibleDependencies) {
            if (handledDependencies.has(dependency)) {
              continue;
            }
            handledDependencies.add(dependency);
            if (necessaryDependencies.has(dependency)) {
              relevantDependencies.add(dependency);
              continue;
            }
            if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {
              continue;
            }
            if (dependency instanceof ExternalModule || dependency.hasEffects()) {
              relevantDependencies.add(dependency);
              continue;
            }
            addSideEffectDependencies(dependency.dependencies);
          }
        };
        addSideEffectDependencies(this.dependencies);
        addSideEffectDependencies(alwaysCheckedDependencies);
      }
      getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {
        let foundSyntheticDeclaration = null;
        const foundInternalDeclarations = /* @__PURE__ */ new Map();
        const foundExternalDeclarations = /* @__PURE__ */ new Set();
        for (const module2 of this.exportAllModules) {
          if (module2.info.syntheticNamedExports === name) {
            continue;
          }
          const [variable, indirectExternal] = getVariableForExportNameRecursive(module2, name, importerForSideEffects, true, searchedNamesAndModules);
          if (module2 instanceof ExternalModule || indirectExternal) {
            foundExternalDeclarations.add(variable);
          } else if (variable instanceof SyntheticNamedExportVariable) {
            if (!foundSyntheticDeclaration) {
              foundSyntheticDeclaration = variable;
            }
          } else if (variable) {
            foundInternalDeclarations.set(variable, module2);
          }
        }
        if (foundInternalDeclarations.size > 0) {
          const foundDeclarationList = [...foundInternalDeclarations];
          const usedDeclaration = foundDeclarationList[0][0];
          if (foundDeclarationList.length === 1) {
            return [usedDeclaration];
          }
          this.options.onwarn(errNamespaceConflict(name, this.id, foundDeclarationList.map(([, module2]) => module2.id)));
          return [null];
        }
        if (foundExternalDeclarations.size > 0) {
          const foundDeclarationList = [...foundExternalDeclarations];
          const usedDeclaration = foundDeclarationList[0];
          if (foundDeclarationList.length > 1) {
            this.options.onwarn(errAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map((declaration) => declaration.module.id)));
          }
          return [usedDeclaration, true];
        }
        if (foundSyntheticDeclaration) {
          return [foundSyntheticDeclaration];
        }
        return [null];
      }
      includeAndGetAdditionalMergedNamespaces() {
        const externalNamespaces = /* @__PURE__ */ new Set();
        const syntheticNamespaces = /* @__PURE__ */ new Set();
        for (const module2 of [this, ...this.exportAllModules]) {
          if (module2 instanceof ExternalModule) {
            const [externalVariable] = module2.getVariableForExportName("*");
            externalVariable.include();
            this.imports.add(externalVariable);
            externalNamespaces.add(externalVariable);
          } else if (module2.info.syntheticNamedExports) {
            const syntheticNamespace = module2.getSyntheticNamespace();
            syntheticNamespace.include();
            this.imports.add(syntheticNamespace);
            syntheticNamespaces.add(syntheticNamespace);
          }
        }
        return [...syntheticNamespaces, ...externalNamespaces];
      }
      includeDynamicImport(node) {
        const resolution = this.dynamicImports.find((dynamicImport) => dynamicImport.node === node).resolution;
        if (resolution instanceof Module) {
          resolution.includedDynamicImporters.push(this);
          resolution.includeAllExports(true);
        }
      }
      includeVariable(variable) {
        if (!variable.included) {
          variable.include();
          this.graph.needsTreeshakingPass = true;
          const variableModule = variable.module;
          if (variableModule instanceof Module) {
            if (!variableModule.isExecuted) {
              markModuleAndImpureDependenciesAsExecuted(variableModule);
            }
            if (variableModule !== this) {
              const sideEffectModules = getAndExtendSideEffectModules(variable, this);
              for (const module2 of sideEffectModules) {
                if (!module2.isExecuted) {
                  markModuleAndImpureDependenciesAsExecuted(module2);
                }
              }
            }
          }
        }
      }
      includeVariableInModule(variable) {
        this.includeVariable(variable);
        const variableModule = variable.module;
        if (variableModule && variableModule !== this) {
          this.imports.add(variable);
        }
      }
      shimMissingExport(name) {
        this.options.onwarn({
          code: "SHIMMED_EXPORT",
          exporter: relativeId(this.id),
          exportName: name,
          message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
        });
        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);
      }
    };
    getDefineProperty = (name, needsLiveBinding, t, { _, getDirectReturnFunction, n: n2 }) => {
      if (needsLiveBinding) {
        const [left, right] = getDirectReturnFunction([], {
          functionReturn: true,
          lineBreakIndent: null,
          name: null
        });
        return `Object.defineProperty(exports,${_}k,${_}{${n2}${t}${t}enumerable:${_}true,${n2}${t}${t}get:${_}${left}${name}[k]${right}${n2}${t}})`;
      }
      return `exports[k]${_}=${_}${name}[k]`;
    };
    builtins = {
      assert: true,
      buffer: true,
      console: true,
      constants: true,
      domain: true,
      events: true,
      http: true,
      https: true,
      os: true,
      path: true,
      process: true,
      punycode: true,
      querystring: true,
      stream: true,
      string_decoder: true,
      timers: true,
      tty: true,
      url: true,
      util: true,
      vm: true,
      zlib: true
    };
    keypath = (keypath2, getPropertyAccess) => keypath2.split(".").map(getPropertyAccess).join("");
    getStarExcludes = ({ dependencies, exports }) => {
      const starExcludes = new Set(exports.map((expt) => expt.exported));
      starExcludes.add("default");
      for (const { reexports } of dependencies) {
        if (reexports) {
          for (const reexport of reexports) {
            if (reexport.reexported !== "*")
              starExcludes.add(reexport.reexported);
          }
        }
      }
      return starExcludes;
    };
    getStarExcludesBlock = (starExcludes, t, { _, cnst, getObject, n: n2 }) => starExcludes ? `${n2}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map((prop) => [prop, "1"]), { lineBreakIndent: { base: t, t } })};` : "";
    getImportBindingsBlock = (importBindings, t, { _, n: n2 }) => importBindings.length ? `${n2}${t}var ${importBindings.join(`,${_}`)};` : "";
    getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.hoisted).map((expt) => ({ name: expt.exported, value: expt.local })), t, snippets);
    getSyntheticExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.expression).map((expt) => ({ name: expt.exported, value: expt.local })), t, snippets);
    getMissingExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter((expt) => expt.local === MISSING_EXPORT_SHIM_VARIABLE).map((expt) => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);
    finalisers = { amd, cjs, es, iife, system, umd };
    Source = class {
      constructor(filename, content) {
        this.isOriginal = true;
        this.filename = filename;
        this.content = content;
      }
      traceSegment(line, column, name) {
        return { column, line, name, source: this };
      }
    };
    Link = class {
      constructor(map, sources) {
        this.sources = sources;
        this.names = map.names;
        this.mappings = map.mappings;
      }
      traceMappings() {
        const sources = [];
        const sourceIndexMap = /* @__PURE__ */ new Map();
        const sourcesContent = [];
        const names = [];
        const nameIndexMap = /* @__PURE__ */ new Map();
        const mappings = [];
        for (const line of this.mappings) {
          const tracedLine = [];
          for (const segment of line) {
            if (segment.length === 1)
              continue;
            const source = this.sources[segment[1]];
            if (!source)
              continue;
            const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : "");
            if (traced) {
              const { column, line: line2, name, source: { content, filename } } = traced;
              let sourceIndex = sourceIndexMap.get(filename);
              if (sourceIndex === void 0) {
                sourceIndex = sources.length;
                sources.push(filename);
                sourceIndexMap.set(filename, sourceIndex);
                sourcesContent[sourceIndex] = content;
              } else if (sourcesContent[sourceIndex] == null) {
                sourcesContent[sourceIndex] = content;
              } else if (content != null && sourcesContent[sourceIndex] !== content) {
                return error({
                  message: `Multiple conflicting contents for sourcemap source ${filename}`
                });
              }
              const tracedSegment = [segment[0], sourceIndex, line2, column];
              if (name) {
                let nameIndex = nameIndexMap.get(name);
                if (nameIndex === void 0) {
                  nameIndex = names.length;
                  names.push(name);
                  nameIndexMap.set(name, nameIndex);
                }
                tracedSegment[4] = nameIndex;
              }
              tracedLine.push(tracedSegment);
            }
          }
          mappings.push(tracedLine);
        }
        return { mappings, names, sources, sourcesContent };
      }
      traceSegment(line, column, name) {
        const segments = this.mappings[line];
        if (!segments)
          return null;
        let searchStart = 0;
        let searchEnd = segments.length - 1;
        while (searchStart <= searchEnd) {
          const m = searchStart + searchEnd >> 1;
          const segment = segments[m];
          if (segment[0] === column || searchStart === searchEnd) {
            if (segment.length == 1)
              return null;
            const source = this.sources[segment[1]];
            if (!source)
              return null;
            return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
          }
          if (segment[0] > column) {
            searchEnd = m - 1;
          } else {
            searchStart = m + 1;
          }
        }
        return null;
      }
    };
    createHash = () => (0, import_crypto.createHash)("sha256");
    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
      amd: deconflictImportsOther,
      cjs: deconflictImportsOther,
      es: deconflictImportsEsmOrSystem,
      iife: deconflictImportsOther,
      system: deconflictImportsEsmOrSystem,
      umd: deconflictImportsOther
    };
    needsEscapeRegEx = /[\\'\r\n\u2028\u2029]/;
    quoteNewlineRegEx = /(['\r\n\u2028\u2029])/g;
    backSlashRegEx = /\\/g;
    NON_ASSET_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx"];
    Chunk2 = class {
      constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias) {
        this.orderedModules = orderedModules;
        this.inputOptions = inputOptions;
        this.outputOptions = outputOptions;
        this.unsetOptions = unsetOptions;
        this.pluginDriver = pluginDriver;
        this.modulesById = modulesById;
        this.chunkByModule = chunkByModule;
        this.facadeChunkByModule = facadeChunkByModule;
        this.includedNamespaces = includedNamespaces;
        this.manualChunkAlias = manualChunkAlias;
        this.entryModules = [];
        this.exportMode = "named";
        this.facadeModule = null;
        this.id = null;
        this.namespaceVariableName = "";
        this.needsExportsShim = false;
        this.variableName = "";
        this.accessedGlobalsByScope = /* @__PURE__ */ new Map();
        this.dependencies = /* @__PURE__ */ new Set();
        this.dynamicDependencies = /* @__PURE__ */ new Set();
        this.dynamicEntryModules = [];
        this.dynamicName = null;
        this.exportNamesByVariable = /* @__PURE__ */ new Map();
        this.exports = /* @__PURE__ */ new Set();
        this.exportsByName = /* @__PURE__ */ new Map();
        this.fileName = null;
        this.implicitEntryModules = [];
        this.implicitlyLoadedBefore = /* @__PURE__ */ new Set();
        this.imports = /* @__PURE__ */ new Set();
        this.indentString = void 0;
        this.isEmpty = true;
        this.name = null;
        this.renderedDependencies = null;
        this.renderedExports = null;
        this.renderedHash = void 0;
        this.renderedModuleSources = /* @__PURE__ */ new Map();
        this.renderedModules = /* @__PURE__ */ Object.create(null);
        this.renderedSource = null;
        this.sortedExportNames = null;
        this.strictFacade = false;
        this.usedModules = void 0;
        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
        const chunkModules = new Set(orderedModules);
        for (const module2 of orderedModules) {
          if (module2.namespace.included) {
            includedNamespaces.add(module2);
          }
          if (this.isEmpty && module2.isIncluded()) {
            this.isEmpty = false;
          }
          if (module2.info.isEntry || outputOptions.preserveModules) {
            this.entryModules.push(module2);
          }
          for (const importer of module2.includedDynamicImporters) {
            if (!chunkModules.has(importer)) {
              this.dynamicEntryModules.push(module2);
              if (module2.info.syntheticNamedExports && !outputOptions.preserveModules) {
                includedNamespaces.add(module2);
                this.exports.add(module2.namespace);
              }
            }
          }
          if (module2.implicitlyLoadedAfter.size > 0) {
            this.implicitEntryModules.push(module2);
          }
        }
        this.suggestedVariableName = makeLegal(this.generateVariableName());
      }
      static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName) {
        const chunk = new Chunk2([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, null);
        chunk.assignFacadeName(facadeName, facadedModule);
        if (!facadeChunkByModule.has(facadedModule)) {
          facadeChunkByModule.set(facadedModule, chunk);
        }
        for (const dependency of facadedModule.getDependenciesToBeIncluded()) {
          chunk.dependencies.add(dependency instanceof Module ? chunkByModule.get(dependency) : dependency);
        }
        if (!chunk.dependencies.has(chunkByModule.get(facadedModule)) && facadedModule.info.moduleSideEffects && facadedModule.hasEffects()) {
          chunk.dependencies.add(chunkByModule.get(facadedModule));
        }
        chunk.ensureReexportsAreAvailableForModule(facadedModule);
        chunk.facadeModule = facadedModule;
        chunk.strictFacade = true;
        return chunk;
      }
      canModuleBeFacade(module2, exposedVariables) {
        const moduleExportNamesByVariable = module2.getExportNamesByVariable();
        for (const exposedVariable of this.exports) {
          if (!moduleExportNamesByVariable.has(exposedVariable)) {
            if (moduleExportNamesByVariable.size === 0 && module2.isUserDefinedEntryPoint && module2.preserveSignature === "strict" && this.unsetOptions.has("preserveEntrySignatures")) {
              this.inputOptions.onwarn({
                code: "EMPTY_FACADE",
                id: module2.id,
                message: `To preserve the export signature of the entry module "${relativeId(module2.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,
                url: "https://rollupjs.org/guide/en/#preserveentrysignatures"
              });
            }
            return false;
          }
        }
        for (const exposedVariable of exposedVariables) {
          if (!(moduleExportNamesByVariable.has(exposedVariable) || exposedVariable.module === module2)) {
            return false;
          }
        }
        return true;
      }
      generateExports() {
        this.sortedExportNames = null;
        const remainingExports = new Set(this.exports);
        if (this.facadeModule !== null && (this.facadeModule.preserveSignature !== false || this.strictFacade)) {
          const exportNamesByVariable = this.facadeModule.getExportNamesByVariable();
          for (const [variable, exportNames] of exportNamesByVariable) {
            this.exportNamesByVariable.set(variable, [...exportNames]);
            for (const exportName of exportNames) {
              this.exportsByName.set(exportName, variable);
            }
            remainingExports.delete(variable);
          }
        }
        if (this.outputOptions.minifyInternalExports) {
          assignExportsToMangledNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        } else {
          assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        }
        if (this.outputOptions.preserveModules || this.facadeModule && this.facadeModule.info.isEntry)
          this.exportMode = getExportMode(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn);
      }
      generateFacades() {
        var _a;
        const facades = [];
        const entryModules = /* @__PURE__ */ new Set([...this.entryModules, ...this.implicitEntryModules]);
        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));
        for (const module2 of entryModules) {
          if (module2.preserveSignature) {
            for (const exportedVariable of module2.getExportNamesByVariable().keys()) {
              exposedVariables.add(exportedVariable);
            }
          }
        }
        for (const module2 of entryModules) {
          const requiredFacades = Array.from(
            new Set(module2.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)),
            (name) => ({
              name
            })
          );
          if (requiredFacades.length === 0 && module2.isUserDefinedEntryPoint) {
            requiredFacades.push({});
          }
          requiredFacades.push(...Array.from(module2.chunkFileNames, (fileName) => ({ fileName })));
          if (requiredFacades.length === 0) {
            requiredFacades.push({});
          }
          if (!this.facadeModule) {
            const needsStrictFacade = module2.preserveSignature === "strict" || module2.preserveSignature === "exports-only" && module2.getExportNamesByVariable().size !== 0;
            if (!needsStrictFacade || this.outputOptions.preserveModules || this.canModuleBeFacade(module2, exposedVariables)) {
              this.facadeModule = module2;
              this.facadeChunkByModule.set(module2, this);
              if (module2.preserveSignature) {
                this.strictFacade = needsStrictFacade;
              }
              this.assignFacadeName(requiredFacades.shift(), module2);
            }
          }
          for (const facadeName of requiredFacades) {
            facades.push(Chunk2.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, module2, facadeName));
          }
        }
        for (const module2 of this.dynamicEntryModules) {
          if (module2.info.syntheticNamedExports)
            continue;
          if (!this.facadeModule && this.canModuleBeFacade(module2, exposedVariables)) {
            this.facadeModule = module2;
            this.facadeChunkByModule.set(module2, this);
            this.strictFacade = true;
            this.dynamicName = getChunkNameFromModule(module2);
          } else if (this.facadeModule === module2 && !this.strictFacade && this.canModuleBeFacade(module2, exposedVariables)) {
            this.strictFacade = true;
          } else if (!((_a = this.facadeChunkByModule.get(module2)) === null || _a === void 0 ? void 0 : _a.strictFacade)) {
            this.includedNamespaces.add(module2);
            this.exports.add(module2.namespace);
          }
        }
        return facades;
      }
      generateId(addons, options, existingNames, includeHash) {
        if (this.fileName !== null) {
          return this.fileName;
        }
        const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint ? [options.entryFileNames, "output.entryFileNames"] : [options.chunkFileNames, "output.chunkFileNames"];
        return makeUnique(renderNamePattern(typeof pattern === "function" ? pattern(this.getChunkInfo()) : pattern, patternName, {
          format: () => options.format,
          hash: () => includeHash ? this.computeContentHashWithDependencies(addons, options, existingNames) : "[hash]",
          name: () => this.getChunkName()
        }), existingNames);
      }
      generateIdPreserveModules(preserveModulesRelativeDir, options, existingNames, unsetOptions) {
        const [{ id }] = this.orderedModules;
        const sanitizedId = this.outputOptions.sanitizeFileName(id.split(QUERY_HASH_REGEX, 1)[0]);
        let path4;
        const patternOpt = unsetOptions.has("entryFileNames") ? "[name][assetExtname].js" : options.entryFileNames;
        const pattern = typeof patternOpt === "function" ? patternOpt(this.getChunkInfo()) : patternOpt;
        if (isAbsolute(sanitizedId)) {
          const currentDir = (0, import_path.dirname)(sanitizedId);
          const extension = (0, import_path.extname)(sanitizedId);
          const fileName = renderNamePattern(pattern, "output.entryFileNames", {
            assetExtname: () => NON_ASSET_EXTENSIONS.includes(extension) ? "" : extension,
            ext: () => extension.substring(1),
            extname: () => extension,
            format: () => options.format,
            name: () => this.getChunkName()
          });
          const currentPath = `${currentDir}/${fileName}`;
          const { preserveModulesRoot } = options;
          if (preserveModulesRoot && currentPath.startsWith(preserveModulesRoot)) {
            path4 = currentPath.slice(preserveModulesRoot.length).replace(/^[\\/]/, "");
          } else {
            path4 = relative(preserveModulesRelativeDir, currentPath);
          }
        } else {
          const extension = (0, import_path.extname)(sanitizedId);
          const fileName = renderNamePattern(pattern, "output.entryFileNames", {
            assetExtname: () => NON_ASSET_EXTENSIONS.includes(extension) ? "" : extension,
            ext: () => extension.substring(1),
            extname: () => extension,
            format: () => options.format,
            name: () => getAliasName(sanitizedId)
          });
          path4 = `_virtual/${fileName}`;
        }
        return makeUnique(normalize(path4), existingNames);
      }
      getChunkInfo() {
        const facadeModule = this.facadeModule;
        const getChunkName = this.getChunkName.bind(this);
        return {
          exports: this.getExportNames(),
          facadeModuleId: facadeModule && facadeModule.id,
          isDynamicEntry: this.dynamicEntryModules.length > 0,
          isEntry: facadeModule !== null && facadeModule.info.isEntry,
          isImplicitEntry: this.implicitEntryModules.length > 0,
          modules: this.renderedModules,
          get name() {
            return getChunkName();
          },
          type: "chunk"
        };
      }
      getChunkInfoWithFileNames() {
        return Object.assign(this.getChunkInfo(), {
          code: void 0,
          dynamicImports: Array.from(this.dynamicDependencies, getId),
          fileName: this.id,
          implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, getId),
          importedBindings: this.getImportedBindingsPerDependency(),
          imports: Array.from(this.dependencies, getId),
          map: void 0,
          referencedFiles: this.getReferencedFiles()
        });
      }
      getChunkName() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName());
      }
      getExportNames() {
        var _a;
        return (_a = this.sortedExportNames) !== null && _a !== void 0 ? _a : this.sortedExportNames = Array.from(this.exportsByName.keys()).sort();
      }
      getRenderedHash() {
        if (this.renderedHash)
          return this.renderedHash;
        const hash = createHash();
        const hashAugmentation = this.pluginDriver.hookReduceValueSync("augmentChunkHash", "", [this.getChunkInfo()], (augmentation, pluginHash) => {
          if (pluginHash) {
            augmentation += pluginHash;
          }
          return augmentation;
        });
        hash.update(hashAugmentation);
        hash.update(this.renderedSource.toString());
        hash.update(this.getExportNames().map((exportName) => {
          const variable = this.exportsByName.get(exportName);
          return `${relativeId(variable.module.id).replace(/\\/g, "/")}:${variable.name}:${exportName}`;
        }).join(","));
        return this.renderedHash = hash.digest("hex");
      }
      getVariableExportName(variable) {
        if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {
          return "*";
        }
        return this.exportNamesByVariable.get(variable)[0];
      }
      link() {
        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule);
        for (const module2 of this.orderedModules) {
          this.addDependenciesToChunk(module2.dynamicDependencies, this.dynamicDependencies);
          this.addDependenciesToChunk(module2.implicitlyLoadedBefore, this.implicitlyLoadedBefore);
          this.setUpChunkImportsAndExportsForModule(module2);
        }
      }
      preRender(options, inputBase, snippets) {
        const { _, getPropertyAccess, n: n2 } = snippets;
        const magicString = new Bundle$1({ separator: `${n2}${n2}` });
        this.usedModules = [];
        this.indentString = getIndentString3(this.orderedModules, options);
        const renderOptions = {
          dynamicImportFunction: options.dynamicImportFunction,
          exportNamesByVariable: this.exportNamesByVariable,
          format: options.format,
          freeze: options.freeze,
          indent: this.indentString,
          namespaceToStringTag: options.namespaceToStringTag,
          outputPluginDriver: this.pluginDriver,
          snippets
        };
        if (options.hoistTransitiveImports && !this.outputOptions.preserveModules && this.facadeModule !== null) {
          for (const dep of this.dependencies) {
            if (dep instanceof Chunk2)
              this.inlineChunkDependencies(dep);
          }
        }
        this.prepareModulesForRendering(snippets);
        this.setIdentifierRenderResolutions(options);
        let hoistedSource = "";
        const renderedModules = this.renderedModules;
        for (const module2 of this.orderedModules) {
          let renderedLength = 0;
          if (module2.isIncluded() || this.includedNamespaces.has(module2)) {
            const source = module2.render(renderOptions).trim();
            renderedLength = source.length();
            if (renderedLength) {
              if (options.compact && source.lastLine().includes("//"))
                source.append("\n");
              this.renderedModuleSources.set(module2, source);
              magicString.addSource(source);
              this.usedModules.push(module2);
            }
            const namespace = module2.namespace;
            if (this.includedNamespaces.has(module2) && !this.outputOptions.preserveModules) {
              const rendered = namespace.renderBlock(renderOptions);
              if (namespace.renderFirst())
                hoistedSource += n2 + rendered;
              else
                magicString.addSource(new MagicString$1(rendered));
            }
          }
          const { renderedExports, removedExports } = module2.getRenderedExports();
          const { renderedModuleSources } = this;
          renderedModules[module2.id] = {
            get code() {
              var _a, _b;
              return (_b = (_a = renderedModuleSources.get(module2)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
            },
            originalLength: module2.originalCode.length,
            removedExports,
            renderedExports,
            renderedLength
          };
        }
        if (hoistedSource)
          magicString.prepend(hoistedSource + n2 + n2);
        if (this.needsExportsShim) {
          magicString.prepend(`${n2}${snippets.cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n2}${n2}`);
        }
        if (options.compact) {
          this.renderedSource = magicString;
        } else {
          this.renderedSource = magicString.trim();
        }
        this.renderedHash = void 0;
        if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
          const chunkName = this.getChunkName();
          this.inputOptions.onwarn({
            chunkName,
            code: "EMPTY_BUNDLE",
            message: `Generated an empty chunk: "${chunkName}"`
          });
        }
        this.setExternalRenderPaths(options, inputBase);
        this.renderedDependencies = this.getChunkDependencyDeclarations(options, getPropertyAccess);
        this.renderedExports = this.exportMode === "none" ? [] : this.getChunkExportDeclarations(options.format, getPropertyAccess);
      }
      async render(options, addons, outputChunk, snippets) {
        timeStart("render format", 2);
        const format = options.format;
        const finalise = finalisers[format];
        if (options.dynamicImportFunction && format !== "es") {
          this.inputOptions.onwarn(errInvalidOption("output.dynamicImportFunction", "outputdynamicImportFunction", 'this option is ignored for formats other than "es"'));
        }
        for (const dependency of this.dependencies) {
          const renderedDependency = this.renderedDependencies.get(dependency);
          if (dependency instanceof ExternalModule) {
            const originalId = dependency.renderPath;
            renderedDependency.id = escapeId(dependency.renormalizeRenderPath ? getImportPath(this.id, originalId, false, false) : originalId);
          } else {
            renderedDependency.namedExportsMode = dependency.exportMode !== "default";
            renderedDependency.id = escapeId(getImportPath(this.id, dependency.id, false, true));
          }
        }
        this.finaliseDynamicImports(options, snippets);
        this.finaliseImportMetas(format, snippets);
        const hasExports = this.renderedExports.length !== 0 || [...this.renderedDependencies.values()].some((dep) => dep.reexports && dep.reexports.length !== 0);
        let topLevelAwaitModule = null;
        const accessedGlobals = /* @__PURE__ */ new Set();
        for (const module2 of this.orderedModules) {
          if (module2.usesTopLevelAwait) {
            topLevelAwaitModule = module2.id;
          }
          const accessedGlobalVariables = this.accessedGlobalsByScope.get(module2.scope);
          if (accessedGlobalVariables) {
            for (const name of accessedGlobalVariables) {
              accessedGlobals.add(name);
            }
          }
        }
        if (topLevelAwaitModule !== null && format !== "es" && format !== "system") {
          return error({
            code: "INVALID_TLA_FORMAT",
            id: topLevelAwaitModule,
            message: `Module format ${format} does not support top-level await. Use the "es" or "system" output formats rather.`
          });
        }
        if (!this.id) {
          throw new Error("Internal Error: expecting chunk id");
        }
        const magicString = finalise(this.renderedSource, {
          accessedGlobals,
          dependencies: [...this.renderedDependencies.values()],
          exports: this.renderedExports,
          hasExports,
          id: this.id,
          indent: this.indentString,
          intro: addons.intro,
          isEntryFacade: this.outputOptions.preserveModules || this.facadeModule !== null && this.facadeModule.info.isEntry,
          isModuleFacade: this.facadeModule !== null,
          namedExportsMode: this.exportMode !== "default",
          outro: addons.outro,
          snippets,
          usesTopLevelAwait: topLevelAwaitModule !== null,
          warn: this.inputOptions.onwarn
        }, options);
        if (addons.banner)
          magicString.prepend(addons.banner);
        if (addons.footer)
          magicString.append(addons.footer);
        const prevCode = magicString.toString();
        timeEnd("render format", 2);
        let map = null;
        const chunkSourcemapChain = [];
        let code = await renderChunk({
          code: prevCode,
          options,
          outputPluginDriver: this.pluginDriver,
          renderChunk: outputChunk,
          sourcemapChain: chunkSourcemapChain
        });
        if (options.sourcemap) {
          timeStart("sourcemap", 2);
          let file;
          if (options.file)
            file = (0, import_path.resolve)(options.sourcemapFile || options.file);
          else if (options.dir)
            file = (0, import_path.resolve)(options.dir, this.id);
          else
            file = (0, import_path.resolve)(this.id);
          const decodedMap = magicString.generateDecodedMap({});
          map = collapseSourcemaps(file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources, this.inputOptions.onwarn);
          map.sources = map.sources.map((sourcePath) => {
            const { sourcemapPathTransform } = options;
            if (sourcemapPathTransform) {
              const newSourcePath = sourcemapPathTransform(sourcePath, `${file}.map`);
              if (typeof newSourcePath !== "string") {
                error(errFailedValidation(`sourcemapPathTransform function must return a string.`));
              }
              return newSourcePath;
            }
            return sourcePath;
          }).map(normalize);
          timeEnd("sourcemap", 2);
        }
        if (!options.compact && code[code.length - 1] !== "\n")
          code += "\n";
        return { code, map };
      }
      addDependenciesToChunk(moduleDependencies, chunkDependencies) {
        for (const module2 of moduleDependencies) {
          if (module2 instanceof Module) {
            const chunk = this.chunkByModule.get(module2);
            if (chunk && chunk !== this) {
              chunkDependencies.add(chunk);
            }
          } else {
            chunkDependencies.add(module2);
          }
        }
      }
      assignFacadeName({ fileName, name }, facadedModule) {
        if (fileName) {
          this.fileName = fileName;
        } else {
          this.name = this.outputOptions.sanitizeFileName(name || getChunkNameFromModule(facadedModule));
        }
      }
      checkCircularDependencyImport(variable, importingModule) {
        const variableModule = variable.module;
        if (variableModule instanceof Module) {
          const exportChunk = this.chunkByModule.get(variableModule);
          let alternativeReexportModule;
          do {
            alternativeReexportModule = importingModule.alternativeReexportModules.get(variable);
            if (alternativeReexportModule) {
              const exportingChunk = this.chunkByModule.get(alternativeReexportModule);
              if (exportingChunk && exportingChunk !== exportChunk) {
                this.inputOptions.onwarn(errCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
              }
              importingModule = alternativeReexportModule;
            }
          } while (alternativeReexportModule);
        }
      }
      computeContentHashWithDependencies(addons, options, existingNames) {
        const hash = createHash();
        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].join(":"));
        hash.update(options.format);
        const dependenciesForHashing = /* @__PURE__ */ new Set([this]);
        for (const current2 of dependenciesForHashing) {
          if (current2 instanceof ExternalModule) {
            hash.update(`:${current2.renderPath}`);
          } else {
            hash.update(current2.getRenderedHash());
            hash.update(current2.generateId(addons, options, existingNames, false));
          }
          if (current2 instanceof ExternalModule)
            continue;
          for (const dependency of [...current2.dependencies, ...current2.dynamicDependencies]) {
            dependenciesForHashing.add(dependency);
          }
        }
        return hash.digest("hex").substr(0, 8);
      }
      ensureReexportsAreAvailableForModule(module2) {
        const map = module2.getExportNamesByVariable();
        for (const exportedVariable of map.keys()) {
          const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;
          const importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable;
          if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
            this.checkCircularDependencyImport(importedVariable, module2);
            const exportingModule = importedVariable.module;
            if (exportingModule instanceof Module) {
              const chunk = this.chunkByModule.get(exportingModule);
              if (chunk && chunk !== this) {
                chunk.exports.add(importedVariable);
                if (isSynthetic) {
                  this.imports.add(importedVariable);
                }
              }
            }
          }
        }
      }
      finaliseDynamicImports(options, snippets) {
        const stripKnownJsExtensions = options.format === "amd";
        for (const [module2, code] of this.renderedModuleSources) {
          for (const { node, resolution } of module2.dynamicImports) {
            const chunk = this.chunkByModule.get(resolution);
            const facadeChunk = this.facadeChunkByModule.get(resolution);
            if (!resolution || !node.included || chunk === this) {
              continue;
            }
            const renderedResolution = resolution instanceof Module ? `'${escapeId(getImportPath(this.id, (facadeChunk || chunk).id, stripKnownJsExtensions, true))}'` : resolution instanceof ExternalModule ? `'${escapeId(resolution.renormalizeRenderPath ? getImportPath(this.id, resolution.renderPath, stripKnownJsExtensions, false) : resolution.renderPath)}'` : resolution;
            node.renderFinalResolution(code, renderedResolution, resolution instanceof Module && !(facadeChunk === null || facadeChunk === void 0 ? void 0 : facadeChunk.strictFacade) && chunk.exportNamesByVariable.get(resolution.namespace)[0], snippets);
          }
        }
      }
      finaliseImportMetas(format, snippets) {
        for (const [module2, code] of this.renderedModuleSources) {
          for (const importMeta of module2.importMetas) {
            importMeta.renderFinalMechanism(code, this.id, format, snippets, this.pluginDriver);
          }
        }
      }
      generateVariableName() {
        if (this.manualChunkAlias) {
          return this.manualChunkAlias;
        }
        const moduleForNaming = this.entryModules[0] || this.implicitEntryModules[0] || this.dynamicEntryModules[0] || this.orderedModules[this.orderedModules.length - 1];
        if (moduleForNaming) {
          return getChunkNameFromModule(moduleForNaming);
        }
        return "chunk";
      }
      getChunkDependencyDeclarations(options, getPropertyAccess) {
        const importSpecifiers = this.getImportSpecifiers(getPropertyAccess);
        const reexportSpecifiers = this.getReexportSpecifiers();
        const dependencyDeclaration = /* @__PURE__ */ new Map();
        for (const dep of this.dependencies) {
          const imports = importSpecifiers.get(dep) || null;
          const reexports = reexportSpecifiers.get(dep) || null;
          const namedExportsMode = dep instanceof ExternalModule || dep.exportMode !== "default";
          dependencyDeclaration.set(dep, {
            defaultVariableName: dep.defaultVariableName,
            globalName: dep instanceof ExternalModule && (options.format === "umd" || options.format === "iife") && getGlobalName(dep, options.globals, (imports || reexports) !== null, this.inputOptions.onwarn),
            id: void 0,
            imports,
            isChunk: dep instanceof Chunk2,
            name: dep.variableName,
            namedExportsMode,
            namespaceVariableName: dep.namespaceVariableName,
            reexports
          });
        }
        return dependencyDeclaration;
      }
      getChunkExportDeclarations(format, getPropertyAccess) {
        const exports = [];
        for (const exportName of this.getExportNames()) {
          if (exportName[0] === "*")
            continue;
          const variable = this.exportsByName.get(exportName);
          if (!(variable instanceof SyntheticNamedExportVariable)) {
            const module2 = variable.module;
            if (module2 && this.chunkByModule.get(module2) !== this)
              continue;
          }
          let expression = null;
          let hoisted = false;
          let local = variable.getName(getPropertyAccess);
          if (variable instanceof LocalVariable) {
            for (const declaration of variable.declarations) {
              if (declaration.parent instanceof FunctionDeclaration || declaration instanceof ExportDefaultDeclaration && declaration.declaration instanceof FunctionDeclaration) {
                hoisted = true;
                break;
              }
            }
          } else if (variable instanceof SyntheticNamedExportVariable) {
            expression = local;
            if (format === "es") {
              local = variable.renderName;
            }
          }
          exports.push({
            exported: exportName,
            expression,
            hoisted,
            local
          });
        }
        return exports;
      }
      getDependenciesToBeDeconflicted(addNonNamespacesAndInteropHelpers, addDependenciesWithoutBindings, interop) {
        const dependencies = /* @__PURE__ */ new Set();
        const deconflictedDefault = /* @__PURE__ */ new Set();
        const deconflictedNamespace = /* @__PURE__ */ new Set();
        for (const variable of [...this.exportNamesByVariable.keys(), ...this.imports]) {
          if (addNonNamespacesAndInteropHelpers || variable.isNamespace) {
            const module2 = variable.module;
            if (module2 instanceof ExternalModule) {
              dependencies.add(module2);
              if (addNonNamespacesAndInteropHelpers) {
                if (variable.name === "default") {
                  if (defaultInteropHelpersByInteropType[String(interop(module2.id))]) {
                    deconflictedDefault.add(module2);
                  }
                } else if (variable.name === "*") {
                  if (namespaceInteropHelpersByInteropType[String(interop(module2.id))]) {
                    deconflictedNamespace.add(module2);
                  }
                }
              }
            } else {
              const chunk = this.chunkByModule.get(module2);
              if (chunk !== this) {
                dependencies.add(chunk);
                if (addNonNamespacesAndInteropHelpers && chunk.exportMode === "default" && variable.isNamespace) {
                  deconflictedNamespace.add(chunk);
                }
              }
            }
          }
        }
        if (addDependenciesWithoutBindings) {
          for (const dependency of this.dependencies) {
            dependencies.add(dependency);
          }
        }
        return { deconflictedDefault, deconflictedNamespace, dependencies };
      }
      getFallbackChunkName() {
        if (this.manualChunkAlias) {
          return this.manualChunkAlias;
        }
        if (this.dynamicName) {
          return this.dynamicName;
        }
        if (this.fileName) {
          return getAliasName(this.fileName);
        }
        return getAliasName(this.orderedModules[this.orderedModules.length - 1].id);
      }
      getImportSpecifiers(getPropertyAccess) {
        const { interop } = this.outputOptions;
        const importsByDependency = /* @__PURE__ */ new Map();
        for (const variable of this.imports) {
          const module2 = variable.module;
          let dependency;
          let imported;
          if (module2 instanceof ExternalModule) {
            dependency = module2;
            imported = variable.name;
            if (imported !== "default" && imported !== "*" && interop(module2.id) === "defaultOnly") {
              return error(errUnexpectedNamedImport(module2.id, imported, false));
            }
          } else {
            dependency = this.chunkByModule.get(module2);
            imported = dependency.getVariableExportName(variable);
          }
          getOrCreate(importsByDependency, dependency, () => []).push({
            imported,
            local: variable.getName(getPropertyAccess)
          });
        }
        return importsByDependency;
      }
      getImportedBindingsPerDependency() {
        const importSpecifiers = {};
        for (const [dependency, declaration] of this.renderedDependencies) {
          const specifiers = /* @__PURE__ */ new Set();
          if (declaration.imports) {
            for (const { imported } of declaration.imports) {
              specifiers.add(imported);
            }
          }
          if (declaration.reexports) {
            for (const { imported } of declaration.reexports) {
              specifiers.add(imported);
            }
          }
          importSpecifiers[dependency.id] = [...specifiers];
        }
        return importSpecifiers;
      }
      getReexportSpecifiers() {
        const { externalLiveBindings, interop } = this.outputOptions;
        const reexportSpecifiers = /* @__PURE__ */ new Map();
        for (let exportName of this.getExportNames()) {
          let dependency;
          let imported;
          let needsLiveBinding = false;
          if (exportName[0] === "*") {
            const id = exportName.substring(1);
            if (interop(id) === "defaultOnly") {
              this.inputOptions.onwarn(errUnexpectedNamespaceReexport(id));
            }
            needsLiveBinding = externalLiveBindings;
            dependency = this.modulesById.get(id);
            imported = exportName = "*";
          } else {
            const variable = this.exportsByName.get(exportName);
            if (variable instanceof SyntheticNamedExportVariable)
              continue;
            const module2 = variable.module;
            if (module2 instanceof Module) {
              dependency = this.chunkByModule.get(module2);
              if (dependency === this)
                continue;
              imported = dependency.getVariableExportName(variable);
              needsLiveBinding = variable.isReassigned;
            } else {
              dependency = module2;
              imported = variable.name;
              if (imported !== "default" && imported !== "*" && interop(module2.id) === "defaultOnly") {
                return error(errUnexpectedNamedImport(module2.id, imported, true));
              }
              needsLiveBinding = externalLiveBindings && (imported !== "default" || isDefaultAProperty(String(interop(module2.id)), true));
            }
          }
          getOrCreate(reexportSpecifiers, dependency, () => []).push({
            imported,
            needsLiveBinding,
            reexported: exportName
          });
        }
        return reexportSpecifiers;
      }
      getReferencedFiles() {
        const referencedFiles = [];
        for (const module2 of this.orderedModules) {
          for (const meta of module2.importMetas) {
            const fileName = meta.getReferencedFileName(this.pluginDriver);
            if (fileName) {
              referencedFiles.push(fileName);
            }
          }
        }
        return referencedFiles;
      }
      inlineChunkDependencies(chunk) {
        for (const dep of chunk.dependencies) {
          if (this.dependencies.has(dep))
            continue;
          this.dependencies.add(dep);
          if (dep instanceof Chunk2) {
            this.inlineChunkDependencies(dep);
          }
        }
      }
      prepareModulesForRendering(snippets) {
        var _a;
        const accessedGlobalsByScope = this.accessedGlobalsByScope;
        for (const module2 of this.orderedModules) {
          for (const { node, resolution } of module2.dynamicImports) {
            if (node.included) {
              if (resolution instanceof Module) {
                const chunk = this.chunkByModule.get(resolution);
                if (chunk === this) {
                  node.setInternalResolution(resolution.namespace);
                } else {
                  node.setExternalResolution(((_a = this.facadeChunkByModule.get(resolution)) === null || _a === void 0 ? void 0 : _a.exportMode) || chunk.exportMode, resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
                }
              } else {
                node.setExternalResolution("external", resolution, this.outputOptions, snippets, this.pluginDriver, accessedGlobalsByScope);
              }
            }
          }
          for (const importMeta of module2.importMetas) {
            importMeta.addAccessedGlobals(this.outputOptions.format, accessedGlobalsByScope);
          }
          if (this.includedNamespaces.has(module2) && !this.outputOptions.preserveModules) {
            module2.namespace.prepare(accessedGlobalsByScope);
          }
        }
      }
      setExternalRenderPaths(options, inputBase) {
        for (const dependency of [...this.dependencies, ...this.dynamicDependencies]) {
          if (dependency instanceof ExternalModule) {
            dependency.setRenderPath(options, inputBase);
          }
        }
      }
      setIdentifierRenderResolutions({ format, interop, namespaceToStringTag }) {
        const syntheticExports = /* @__PURE__ */ new Set();
        for (const exportName of this.getExportNames()) {
          const exportVariable = this.exportsByName.get(exportName);
          if (format !== "es" && format !== "system" && exportVariable.isReassigned && !exportVariable.isId) {
            exportVariable.setRenderNames("exports", exportName);
          } else if (exportVariable instanceof SyntheticNamedExportVariable) {
            syntheticExports.add(exportVariable);
          } else {
            exportVariable.setRenderNames(null, null);
          }
        }
        for (const module2 of this.orderedModules) {
          if (module2.needsExportShim) {
            this.needsExportsShim = true;
            break;
          }
        }
        const usedNames = /* @__PURE__ */ new Set(["Object", "Promise"]);
        if (this.needsExportsShim) {
          usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);
        }
        if (namespaceToStringTag) {
          usedNames.add("Symbol");
        }
        switch (format) {
          case "system":
            usedNames.add("module").add("exports");
            break;
          case "es":
            break;
          case "cjs":
            usedNames.add("module").add("require").add("__filename").add("__dirname");
          default:
            usedNames.add("exports");
            for (const helper of HELPER_NAMES) {
              usedNames.add(helper);
            }
        }
        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== "es" && format !== "system", format === "amd" || format === "umd" || format === "iife", interop), this.imports, usedNames, format, interop, this.outputOptions.preserveModules, this.outputOptions.externalLiveBindings, this.chunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
      }
      setUpChunkImportsAndExportsForModule(module2) {
        const moduleImports = new Set(module2.imports);
        if (!this.outputOptions.preserveModules) {
          if (this.includedNamespaces.has(module2)) {
            const memberVariables = module2.namespace.getMemberVariables();
            for (const variable of Object.values(memberVariables)) {
              moduleImports.add(variable);
            }
          }
        }
        for (let variable of moduleImports) {
          if (variable instanceof ExportDefaultVariable) {
            variable = variable.getOriginalVariable();
          }
          if (variable instanceof SyntheticNamedExportVariable) {
            variable = variable.getBaseVariable();
          }
          const chunk = this.chunkByModule.get(variable.module);
          if (chunk !== this) {
            this.imports.add(variable);
            if (!(variable instanceof NamespaceVariable && this.outputOptions.preserveModules) && variable.module instanceof Module) {
              chunk.exports.add(variable);
              this.checkCircularDependencyImport(variable, module2);
            }
          }
        }
        if (this.includedNamespaces.has(module2) || module2.info.isEntry && module2.preserveSignature !== false || module2.includedDynamicImporters.some((importer) => this.chunkByModule.get(importer) !== this)) {
          this.ensureReexportsAreAvailableForModule(module2);
        }
        for (const { node, resolution } of module2.dynamicImports) {
          if (node.included && resolution instanceof Module && this.chunkByModule.get(resolution) === this && !this.includedNamespaces.has(resolution)) {
            this.includedNamespaces.add(resolution);
            this.ensureReexportsAreAvailableForModule(resolution);
          }
        }
      }
    };
    QUERY_HASH_REGEX = /[?#]/;
    FILE_PLACEHOLDER = {
      type: "placeholder"
    };
    FileEmitter = class {
      constructor(graph, options, baseFileEmitter) {
        this.graph = graph;
        this.options = options;
        this.bundle = null;
        this.facadeChunkByModule = null;
        this.outputOptions = null;
        this.assertAssetsFinalized = () => {
          for (const [referenceId, emittedFile] of this.filesByReferenceId) {
            if (emittedFile.type === "asset" && typeof emittedFile.fileName !== "string")
              return error(errNoAssetSourceSet(emittedFile.name || referenceId));
          }
        };
        this.emitFile = (emittedFile) => {
          if (!hasValidType(emittedFile)) {
            return error(errFailedValidation(`Emitted files must be of type "asset" or "chunk", received "${emittedFile && emittedFile.type}".`));
          }
          if (!hasValidName(emittedFile)) {
            return error(errFailedValidation(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${emittedFile.fileName || emittedFile.name}".`));
          }
          if (emittedFile.type === "chunk") {
            return this.emitChunk(emittedFile);
          }
          return this.emitAsset(emittedFile);
        };
        this.getFileName = (fileReferenceId) => {
          const emittedFile = this.filesByReferenceId.get(fileReferenceId);
          if (!emittedFile)
            return error(errFileReferenceIdNotFoundForFilename(fileReferenceId));
          if (emittedFile.type === "chunk") {
            return getChunkFileName(emittedFile, this.facadeChunkByModule);
          }
          return getAssetFileName(emittedFile, fileReferenceId);
        };
        this.setAssetSource = (referenceId, requestedSource) => {
          const consumedFile = this.filesByReferenceId.get(referenceId);
          if (!consumedFile)
            return error(errAssetReferenceIdNotFoundForSetSource(referenceId));
          if (consumedFile.type !== "asset") {
            return error(errFailedValidation(`Asset sources can only be set for emitted assets but "${referenceId}" is an emitted chunk.`));
          }
          if (consumedFile.source !== void 0) {
            return error(errAssetSourceAlreadySet(consumedFile.name || referenceId));
          }
          const source = getValidSource(requestedSource, consumedFile, referenceId);
          if (this.bundle) {
            this.finalizeAsset(consumedFile, source, referenceId, this.bundle);
          } else {
            consumedFile.source = source;
          }
        };
        this.setOutputBundle = (outputBundle, outputOptions, facadeChunkByModule) => {
          this.outputOptions = outputOptions;
          this.bundle = outputBundle;
          this.facadeChunkByModule = facadeChunkByModule;
          for (const emittedFile of this.filesByReferenceId.values()) {
            if (emittedFile.fileName) {
              reserveFileNameInBundle(emittedFile.fileName, this.bundle, this.options.onwarn);
            }
          }
          for (const [referenceId, consumedFile] of this.filesByReferenceId) {
            if (consumedFile.type === "asset" && consumedFile.source !== void 0) {
              this.finalizeAsset(consumedFile, consumedFile.source, referenceId, this.bundle);
            }
          }
        };
        this.filesByReferenceId = baseFileEmitter ? new Map(baseFileEmitter.filesByReferenceId) : /* @__PURE__ */ new Map();
      }
      assignReferenceId(file, idBase) {
        let referenceId;
        do {
          referenceId = createHash().update(referenceId || idBase).digest("hex").substring(0, 8);
        } while (this.filesByReferenceId.has(referenceId));
        this.filesByReferenceId.set(referenceId, file);
        return referenceId;
      }
      emitAsset(emittedAsset) {
        const source = typeof emittedAsset.source !== "undefined" ? getValidSource(emittedAsset.source, emittedAsset, null) : void 0;
        const consumedAsset = {
          fileName: emittedAsset.fileName,
          name: emittedAsset.name,
          source,
          type: "asset"
        };
        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || emittedAsset.type);
        if (this.bundle) {
          if (emittedAsset.fileName) {
            reserveFileNameInBundle(emittedAsset.fileName, this.bundle, this.options.onwarn);
          }
          if (source !== void 0) {
            this.finalizeAsset(consumedAsset, source, referenceId, this.bundle);
          }
        }
        return referenceId;
      }
      emitChunk(emittedChunk) {
        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {
          return error(errInvalidRollupPhaseForChunkEmission());
        }
        if (typeof emittedChunk.id !== "string") {
          return error(errFailedValidation(`Emitted chunks need to have a valid string id, received "${emittedChunk.id}"`));
        }
        const consumedChunk = {
          fileName: emittedChunk.fileName,
          module: null,
          name: emittedChunk.name || emittedChunk.id,
          type: "chunk"
        };
        this.graph.moduleLoader.emitChunk(emittedChunk).then((module2) => consumedChunk.module = module2).catch(() => {
        });
        return this.assignReferenceId(consumedChunk, emittedChunk.id);
      }
      finalizeAsset(consumedFile, source, referenceId, bundle) {
        const fileName = consumedFile.fileName || findExistingAssetFileNameWithSource(bundle, source) || generateAssetFileName(consumedFile.name, source, this.outputOptions, bundle);
        const assetWithFileName = { ...consumedFile, fileName, source };
        this.filesByReferenceId.set(referenceId, assetWithFileName);
        const { options } = this;
        bundle[fileName] = {
          fileName,
          get isAsset() {
            warnDeprecation(`Accessing "isAsset" on files in the bundle is deprecated, please use "type === 'asset'" instead`, true, options);
            return true;
          },
          name: consumedFile.name,
          source,
          type: "asset"
        };
      }
    };
    concatSep = (out, next) => next ? `${out}
${next}` : out;
    concatDblSep = (out, next) => next ? `${out}

${next}` : out;
    compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;
    wrapIfNeeded = (code, needsParens) => needsParens ? `(${code})` : code;
    validPropName = /^(?!\d)[\w$]+$/;
    Bundle2 = class {
      constructor(outputOptions, unsetOptions, inputOptions, pluginDriver, graph) {
        this.outputOptions = outputOptions;
        this.unsetOptions = unsetOptions;
        this.inputOptions = inputOptions;
        this.pluginDriver = pluginDriver;
        this.graph = graph;
        this.facadeChunkByModule = /* @__PURE__ */ new Map();
        this.includedNamespaces = /* @__PURE__ */ new Set();
      }
      async generate(isWrite) {
        timeStart("GENERATE", 1);
        const outputBundle = /* @__PURE__ */ Object.create(null);
        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions, this.facadeChunkByModule);
        try {
          await this.pluginDriver.hookParallel("renderStart", [this.outputOptions, this.inputOptions]);
          timeStart("generate chunks", 2);
          const chunks = await this.generateChunks();
          if (chunks.length > 1) {
            validateOptionsForMultiChunkOutput(this.outputOptions, this.inputOptions.onwarn);
          }
          const inputBase = commondir(getAbsoluteEntryModulePaths(chunks));
          timeEnd("generate chunks", 2);
          timeStart("render modules", 2);
          const addons = await createAddons(this.outputOptions, this.pluginDriver);
          const snippets = getGenerateCodeSnippets(this.outputOptions);
          this.prerenderChunks(chunks, inputBase, snippets);
          timeEnd("render modules", 2);
          await this.addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets);
        } catch (err) {
          await this.pluginDriver.hookParallel("renderError", [err]);
          throw err;
        }
        await this.pluginDriver.hookSeq("generateBundle", [
          this.outputOptions,
          outputBundle,
          isWrite
        ]);
        this.finaliseAssets(outputBundle);
        timeEnd("GENERATE", 1);
        return outputBundle;
      }
      async addFinalizedChunksToBundle(chunks, inputBase, addons, outputBundle, snippets) {
        this.assignChunkIds(chunks, inputBase, addons, outputBundle);
        for (const chunk of chunks) {
          outputBundle[chunk.id] = chunk.getChunkInfoWithFileNames();
        }
        await Promise.all(chunks.map(async (chunk) => {
          const outputChunk = outputBundle[chunk.id];
          Object.assign(outputChunk, await chunk.render(this.outputOptions, addons, outputChunk, snippets));
        }));
      }
      async addManualChunks(manualChunks) {
        const manualChunkAliasByEntry = /* @__PURE__ */ new Map();
        const chunkEntries = await Promise.all(Object.entries(manualChunks).map(async ([alias, files]) => ({
          alias,
          entries: await this.graph.moduleLoader.addAdditionalModules(files)
        })));
        for (const { alias, entries } of chunkEntries) {
          for (const entry of entries) {
            addModuleToManualChunk(alias, entry, manualChunkAliasByEntry);
          }
        }
        return manualChunkAliasByEntry;
      }
      assignChunkIds(chunks, inputBase, addons, bundle) {
        const entryChunks = [];
        const otherChunks = [];
        for (const chunk of chunks) {
          (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint ? entryChunks : otherChunks).push(chunk);
        }
        const chunksForNaming = entryChunks.concat(otherChunks);
        for (const chunk of chunksForNaming) {
          if (this.outputOptions.file) {
            chunk.id = (0, import_path.basename)(this.outputOptions.file);
          } else if (this.outputOptions.preserveModules) {
            chunk.id = chunk.generateIdPreserveModules(inputBase, this.outputOptions, bundle, this.unsetOptions);
          } else {
            chunk.id = chunk.generateId(addons, this.outputOptions, bundle, true);
          }
          bundle[chunk.id] = FILE_PLACEHOLDER;
        }
      }
      assignManualChunks(getManualChunk) {
        const manualChunkAliasesWithEntry = [];
        const manualChunksApi = {
          getModuleIds: () => this.graph.modulesById.keys(),
          getModuleInfo: this.graph.getModuleInfo
        };
        for (const module2 of this.graph.modulesById.values()) {
          if (module2 instanceof Module) {
            const manualChunkAlias = getManualChunk(module2.id, manualChunksApi);
            if (typeof manualChunkAlias === "string") {
              manualChunkAliasesWithEntry.push([manualChunkAlias, module2]);
            }
          }
        }
        manualChunkAliasesWithEntry.sort(([aliasA], [aliasB]) => aliasA > aliasB ? 1 : aliasA < aliasB ? -1 : 0);
        const manualChunkAliasByEntry = /* @__PURE__ */ new Map();
        for (const [alias, module2] of manualChunkAliasesWithEntry) {
          addModuleToManualChunk(alias, module2, manualChunkAliasByEntry);
        }
        return manualChunkAliasByEntry;
      }
      finaliseAssets(outputBundle) {
        for (const file of Object.values(outputBundle)) {
          if (!file.type) {
            warnDeprecation('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', true, this.inputOptions);
            file.type = "asset";
          }
          if (this.outputOptions.validate && "code" in file) {
            try {
              this.graph.contextParse(file.code, {
                allowHashBang: true,
                ecmaVersion: "latest"
              });
            } catch (err) {
              this.inputOptions.onwarn(errChunkInvalid(file, err));
            }
          }
        }
        this.pluginDriver.finaliseAssets();
      }
      async generateChunks() {
        const { manualChunks } = this.outputOptions;
        const manualChunkAliasByEntry = typeof manualChunks === "object" ? await this.addManualChunks(manualChunks) : this.assignManualChunks(manualChunks);
        const chunks = [];
        const chunkByModule = /* @__PURE__ */ new Map();
        for (const { alias, modules } of this.outputOptions.inlineDynamicImports ? [{ alias: null, modules: getIncludedModules(this.graph.modulesById) }] : this.outputOptions.preserveModules ? getIncludedModules(this.graph.modulesById).map((module2) => ({
          alias: null,
          modules: [module2]
        })) : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry)) {
          sortByExecutionOrder(modules);
          const chunk = new Chunk2(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias);
          chunks.push(chunk);
          for (const module2 of modules) {
            chunkByModule.set(module2, chunk);
          }
        }
        for (const chunk of chunks) {
          chunk.link();
        }
        const facades = [];
        for (const chunk of chunks) {
          facades.push(...chunk.generateFacades());
        }
        return [...chunks, ...facades];
      }
      prerenderChunks(chunks, inputBase, snippets) {
        for (const chunk of chunks) {
          chunk.generateExports();
        }
        for (const chunk of chunks) {
          chunk.preRender(this.outputOptions, inputBase, snippets);
        }
      }
    };
    reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    keywordRelationalOperator = /^in(stanceof)?$/;
    nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    TokenType = function TokenType2(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    beforeExpr = { beforeExpr: true };
    startsExpr = { startsExpr: true };
    keywords = {};
    types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    lineBreak = /\r\n?|\n|\u2028|\u2029/;
    lineBreakG = new RegExp(lineBreak.source, "g");
    nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    ref = Object.prototype;
    hasOwnProperty = ref.hasOwnProperty;
    toString5 = ref.toString;
    hasOwn = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty.call(obj, propName);
    };
    isArray = Array.isArray || function(obj) {
      return toString5.call(obj) === "[object Array]";
    };
    loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    Position = function Position2(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset(n2) {
      return new Position(this.line, this.column + n2);
    };
    SourceLocation = function SourceLocation2(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) {
        this.source = p.sourceFile;
      }
    };
    defaultOptions = {
      ecmaVersion: null,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: null,
      allowSuperOutsideMethod: null,
      allowHashBang: false,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    warnedAboutEcmaVersion = false;
    SCOPE_TOP = 1;
    SCOPE_FUNCTION = 2;
    SCOPE_ASYNC = 4;
    SCOPE_GENERATOR = 8;
    SCOPE_ARROW = 16;
    SCOPE_SIMPLE_CATCH = 32;
    SCOPE_SUPER = 64;
    SCOPE_DIRECT_SUPER = 128;
    SCOPE_CLASS_STATIC_BLOCK = 256;
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    BIND_NONE = 0;
    BIND_VAR = 1;
    BIND_LEXICAL = 2;
    BIND_FUNCTION = 3;
    BIND_SIMPLE_CATCH = 4;
    BIND_OUTSIDE = 5;
    Parser = function Parser2(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
        if (options.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$1.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser.prototype.parse = function parse2() {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
      for (var i = this.scopeStack.length - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION) {
          return (scope.flags & SCOPE_ASYNC) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend() {
      var plugins = [], len = arguments.length;
      while (len--)
        plugins[len] = arguments[len];
      var cls = this;
      for (var i = 0; i < plugins.length; i++) {
        cls = plugins[i](cls);
      }
      return cls;
    };
    Parser.parse = function parse3(input, options) {
      return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
      return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    pp$9 = Parser.prototype;
    literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, "Parenthesized pattern");
      }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    pp$8 = Parser.prototype;
    pp$8.parseTopLevel = function(node) {
      var exports = /* @__PURE__ */ Object.create(null);
      if (!node.body) {
        node.body = [];
      }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule) {
        for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
          var name = list[i];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program");
    };
    loopLabel = { kind: "loop" };
    switchLabel = { kind: "switch" };
    pp$8.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$8.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node);
        case types$1._do:
          return this.parseDoStatement(node);
        case types$1._for:
          return this.parseForStatement(node);
        case types$1._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context);
        case types$1._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types$1._if:
          return this.parseIfStatement(node);
        case types$1._return:
          return this.parseReturnStatement(node);
        case types$1._switch:
          return this.parseSwitchStatement(node);
        case types$1._throw:
          return this.parseThrowStatement(node);
        case types$1._try:
          return this.parseTryStatement(node);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types$1._while:
          return this.parseWhileStatement(node);
        case types$1._with:
          return this.parseWithStatement(node);
        case types$1.braceL:
          return this.parseBlock(true, node);
        case types$1.semi:
          return this.parseEmptyStatement(node);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
      }
    };
    pp$8.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node.label = null;
      } else if (this.type !== types$1.name) {
        this.unexpected();
      } else {
        node.label = this.parseIdent();
        this.semicolon();
      }
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node.label && isBreak) {
            break;
          }
        }
      }
      if (i === this.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$1.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "DoWhileStatement");
    };
    pp$8.parseForStatement = function(node) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var refDestructuringErrors = new DestructuringErrors();
      var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node.await = awaitAt > -1;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLValPattern(init);
        return this.parseForIn(node, init);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR; ) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    empty$1 = [];
    pp$8.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types$1.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }
      return this.finishNode(node, "TryStatement");
    };
    pp$8.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node === void 0)
        node = this.startNode();
      node.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node, "BlockStatement");
    };
    pp$8.parseFor = function(node, init) {
      node.init = init;
      this.expect(types$1.semi);
      node.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    pp$8.parseForIn = function(node, init) {
      var isForIn = this.type === types$1._in;
      this.next();
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(
          init.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        );
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$8.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) {
          break;
        }
      }
      return node;
    };
    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    FUNC_STATEMENT = 1;
    FUNC_HANGING_STATEMENT = 2;
    FUNC_NULLABLE_ID = 4;
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node.id = this.type === types$1.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node) {
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$8.parseClass = function(node, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) {
        return null;
      }
      var ecmaVersion = this.options.ecmaVersion;
      var node = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node);
          return node;
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node.computed = false;
        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node.key.name = keyName;
        this.finishNode(node.key, "Identifier");
      } else {
        this.parseClassElementName(node);
      }
      if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node.static && checkKeyName(node, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node.key.start, "Constructor can't have get/set modifier");
        }
        node.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node);
      }
      return node;
    };
    pp$8.isClassElementNameStart = function() {
      return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value.params.length !== 0) {
        this.raiseRecoverable(value.start, "getter should have no params");
      }
      if (method.kind === "set" && value.params.length !== 1) {
        this.raiseRecoverable(value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value.params[0].type === "RestElement") {
        this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$1.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node) {
      node.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node, "StaticBlock");
    };
    pp$8.parseClassId = function(node, isStatement) {
      if (this.type === types$1.name) {
        node.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node.id = null;
      }
    };
    pp$8.parseClassSuper = function(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
    };
    pp$8.enterClassBody = function() {
      var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$8.exitClassBody = function() {
      var ref2 = this.privateNameStack.pop();
      var declared = ref2.declared;
      var used = ref2.used;
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i = 0; i < used.length; ++i) {
        var id = used[i];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    pp$8.parseExport = function(node, exports) {
      this.next();
      if (this.eat(types$1.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports, node.exported.name, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      if (this.eat(types$1._default)) {
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports, node.declaration.declarations);
        } else {
          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
        }
        node.specifiers = [];
        node.source = null;
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            var spec = list[i];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$8.checkExport = function(exports, name, pos) {
      if (!exports) {
        return;
      }
      if (hasOwn(exports, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports[name] = true;
    };
    pp$8.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports, pat.name, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i = 0, list = pat.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.checkPatternExport(exports, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports, pat.expression);
      }
    };
    pp$8.checkVariableExport = function(exports, decls) {
      if (!exports) {
        return;
      }
      for (var i = 0, list = decls; i < list.length; i += 1) {
        var decl = list[i];
        this.checkPatternExport(exports, decl.id);
      }
    };
    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$8.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports,
          node.exported[node.exported.type === "Identifier" ? "name" : "value"],
          node.exported.start
        );
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseImport = function(node) {
      this.next();
      if (this.type === types$1.string) {
        node.specifiers = empty$1;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types$1.name) {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types$1.comma)) {
          return nodes;
        }
      }
      if (this.type === types$1.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLValSimple(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLValSimple(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    pp$7 = Parser.prototype;
    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node;
    };
    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$7.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
        this.unexpected();
      }
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };
    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$1.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$7.parseBindingListItem = function(param) {
      return param;
    };
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
        return left;
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      var isBind = bindingType !== BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
      return [types.b_stat];
    };
    pp$6.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat) {
        return true;
      }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
        return true;
      }
      if (prevType === types$1.braceL) {
        return parent === types.b_stat;
      }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
        this.context.push(types.f_expr);
      } else {
        this.context.push(types.f_stat);
      }
      this.exprAllowed = false;
    };
    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types.f_expr) {
          this.context[index] = types.f_expr_gen;
        } else {
          this.context[index] = types.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    pp$5 = Parser.prototype;
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        if (this.type === types$1.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$1.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node.left = left;
        this.next();
        node.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types$1.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node.argument);
        } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
          this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
          this.raiseRecoverable(node.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if (forInit || this.privateNameStack.length === 0) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$1._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result;
    };
    pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base2 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base2 = element;
      }
    };
    pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$1.bracketL);
      if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base2;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base2.type !== "Super") {
          node.property = this.parsePrivateIdent();
        } else {
          node.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node.computed = !!computed;
        if (optionalSupported) {
          node.optional = optional;
        }
        base2 = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base2;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base2 = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base2;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base2 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base2;
    };
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
      if (this.type === types$1.slash) {
        this.readRegexp();
      }
      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node = this.startNode();
          node.value = this.type === types$1._null ? null : this.type === types$1._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$5.parseExprImport = function() {
      var node = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types$1.parenL:
          return this.parseDynamicImport(node);
        case types$1.dot:
          node.meta = meta;
          return this.parseImportMeta(node);
        default:
          this.unexpected();
      }
    };
    pp$5.parseDynamicImport = function(node) {
      this.next();
      node.source = this.parseMaybeAssign();
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node) {
      this.next();
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
        node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node, "Literal");
    };
    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$1.parenR) {
          first ? first = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$5.parseParenItem = function(item) {
      return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    empty = [];
    pp$5.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
      if (isImport && node.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types$1.parenL)) {
        node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node.arguments = empty;
      }
      return this.finishNode(node, "NewExpression");
    };
    pp$5.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        if (this.type === types$1.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon) {
        this.unexpected();
      }
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$5.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = node.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = false;
      }
    };
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression");
    };
    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node.body = this.parseMaybeAssign(forInit);
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        if (this.strict && node.id) {
          this.checkLValSimple(node.id, BIND_OUTSIDE);
        }
        node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1) {
        var param = list[i];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$5.checkParams = function(node, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i = 0, list = node.params; i < list.length; i += 1) {
        var param = list[i];
        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          }
        } else {
          first = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$1.comma) {
          elt = null;
        } else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$5.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
        this.raise(start, "Cannot use " + name + " in class static initialization block");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$5.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (this.type === types$1.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node.start;
        }
      }
      return node;
    };
    pp$5.parsePrivateIdent = function() {
      var node = this.startNode();
      if (this.type === types$1.privateId) {
        node.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "PrivateIdentifier");
      if (this.privateNameStack.length === 0) {
        this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
      }
      return node;
    };
    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types$1.star);
        node.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node, "AwaitExpression");
    };
    pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    pp$3 = Parser.prototype;
    Scope = function Scope2(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$3.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$3.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    Node = function Node2(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    pp$2 = Parser.prototype;
    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    pp$2.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$2.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc);
    };
    pp$2.copyNode = function(node) {
      var newNode = new Node(this, node.start, this.startLoc);
      for (var prop in node) {
        newNode[prop] = node[prop];
      }
      return newNode;
    };
    ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    ecma11BinaryProperties = ecma10BinaryProperties;
    ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    ecma13BinaryProperties = ecma12BinaryProperties;
    unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties
    };
    unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues
    };
    data = {};
    for (i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
      ecmaVersion = list[i];
      buildUnicodeData(ecmaVersion);
    }
    pp$1 = Parser.prototype;
    RegExpValidationState = function RegExpValidationState2(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1;
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
        return c;
      }
      var next = s.charCodeAt(i + 1);
      return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l;
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
        return i + 1;
      }
      return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance2(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];
        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$1.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(124)) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$1.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString$1(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString$1(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n2 = state.lastIntValue;
        if (state.switchU) {
          if (n2 > state.maxBackReference) {
            state.maxBackReference = n2;
          }
          return true;
        }
        if (n2 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$1.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString$1(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString$1(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        state.eat(94);
        this.regexp_classRanges(state);
        if (state.eat(93)) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$1.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    pp$1.regexp_eatFixedHexDigits = function(state, length3) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length3; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true;
    };
    Token = function Token2(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) {
        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
      }
      if (p.options.ranges) {
        this.range = [p.start, p.end];
      }
    };
    pp = Parser.prototype;
    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            };
          }
        };
      };
    }
    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$1.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$1.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot);
      }
    };
    pp.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$1.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(types$1.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$1.arrow);
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$1.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(types$1.coalesce, 2);
        }
      }
      return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92) {
          return this.finishToken(types$1.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped = ch === "\\";
        } else {
          escaped = false;
        }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
      }
      return this.finishToken(types$1.regexp, { pattern, flags, value });
    };
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val);
    };
    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val);
    };
    pp.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    pp.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 8232 || ch === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out);
    };
    INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            );
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );
            return null;
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n2 = this.readInt(16, len);
      if (n2 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n2;
    };
    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word);
    };
    version = "8.7.0";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext,
      tokContexts: types,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
    Queue = class {
      constructor(maxParallel) {
        this.maxParallel = maxParallel;
        this.queue = [];
        this.workerCount = 0;
      }
      run(task) {
        return new Promise((resolve4, reject) => {
          this.queue.push({ reject, resolve: resolve4, task });
          this.work();
        });
      }
      async work() {
        if (this.workerCount >= this.maxParallel)
          return;
        this.workerCount++;
        let entry;
        while (entry = this.queue.shift()) {
          const { reject, resolve: resolve4, task } = entry;
          try {
            const result = await task();
            resolve4(result);
          } catch (err) {
            reject(err);
          }
        }
        this.workerCount--;
      }
    };
    ANONYMOUS_PLUGIN_PREFIX = "at position ";
    ANONYMOUS_OUTPUT_PLUGIN_PREFIX = "at output position ";
    deprecatedHooks = [
      { active: true, deprecated: "resolveAssetUrl", replacement: "resolveFileUrl" }
    ];
    NO_CACHE = {
      delete() {
        return false;
      },
      get() {
        return void 0;
      },
      has() {
        return false;
      },
      set() {
      }
    };
    RESOLVE_DEPENDENCIES = "resolveDependencies";
    ModuleLoader = class {
      constructor(graph, modulesById, options, pluginDriver) {
        this.graph = graph;
        this.modulesById = modulesById;
        this.options = options;
        this.pluginDriver = pluginDriver;
        this.implicitEntryModules = /* @__PURE__ */ new Set();
        this.indexedEntryModules = [];
        this.latestLoadModulesPromise = Promise.resolve();
        this.moduleLoadPromises = /* @__PURE__ */ new Map();
        this.modulesWithLoadedDependencies = /* @__PURE__ */ new Set();
        this.nextChunkNamePriority = 0;
        this.nextEntryModuleIndex = 0;
        this.resolveId = async (source, importer, customOptions, isEntry, skip = null) => {
          return this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false) ? false : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === "boolean" ? isEntry : !importer), importer, source));
        };
        this.hasModuleSideEffects = options.treeshake ? options.treeshake.moduleSideEffects : () => true;
        this.readQueue = new Queue(options.maxParallelFileReads);
      }
      async addAdditionalModules(unresolvedModules) {
        const result = this.extendLoadModulesPromise(Promise.all(unresolvedModules.map((id) => this.loadEntryModule(id, false, void 0, null))));
        await this.awaitLoadModulesPromise();
        return result;
      }
      async addEntryModules(unresolvedEntryModules, isUserDefined) {
        const firstEntryModuleIndex = this.nextEntryModuleIndex;
        this.nextEntryModuleIndex += unresolvedEntryModules.length;
        const firstChunkNamePriority = this.nextChunkNamePriority;
        this.nextChunkNamePriority += unresolvedEntryModules.length;
        const newEntryModules = await this.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id, importer }) => this.loadEntryModule(id, true, importer, null))).then((entryModules) => {
          for (let index = 0; index < entryModules.length; index++) {
            const entryModule = entryModules[index];
            entryModule.isUserDefinedEntryPoint = entryModule.isUserDefinedEntryPoint || isUserDefined;
            addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined, firstChunkNamePriority + index);
            const existingIndexedModule = this.indexedEntryModules.find((indexedModule) => indexedModule.module === entryModule);
            if (!existingIndexedModule) {
              this.indexedEntryModules.push({
                index: firstEntryModuleIndex + index,
                module: entryModule
              });
            } else {
              existingIndexedModule.index = Math.min(existingIndexedModule.index, firstEntryModuleIndex + index);
            }
          }
          this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);
          return entryModules;
        }));
        await this.awaitLoadModulesPromise();
        return {
          entryModules: this.indexedEntryModules.map(({ module: module2 }) => module2),
          implicitEntryModules: [...this.implicitEntryModules],
          newEntryModules
        };
      }
      async emitChunk({ fileName, id, importer, name, implicitlyLoadedAfterOneOf, preserveSignature }) {
        const unresolvedModule = {
          fileName: fileName || null,
          id,
          importer,
          name: name || null
        };
        const module2 = implicitlyLoadedAfterOneOf ? await this.addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfterOneOf) : (await this.addEntryModules([unresolvedModule], false)).newEntryModules[0];
        if (preserveSignature != null) {
          module2.preserveSignature = preserveSignature;
        }
        return module2;
      }
      async preloadModule(resolvedId) {
        const module2 = await this.fetchModule(this.getResolvedIdWithDefaults(resolvedId), void 0, false, resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : true);
        return module2.info;
      }
      addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfter) {
        const chunkNamePriority = this.nextChunkNamePriority++;
        return this.extendLoadModulesPromise(this.loadEntryModule(unresolvedModule.id, false, unresolvedModule.importer, null).then(async (entryModule) => {
          addChunkNamesToModule(entryModule, unresolvedModule, false, chunkNamePriority);
          if (!entryModule.info.isEntry) {
            this.implicitEntryModules.add(entryModule);
            const implicitlyLoadedAfterModules = await Promise.all(implicitlyLoadedAfter.map((id) => this.loadEntryModule(id, false, unresolvedModule.importer, entryModule.id)));
            for (const module2 of implicitlyLoadedAfterModules) {
              entryModule.implicitlyLoadedAfter.add(module2);
            }
            for (const dependant of entryModule.implicitlyLoadedAfter) {
              dependant.implicitlyLoadedBefore.add(entryModule);
            }
          }
          return entryModule;
        }));
      }
      async addModuleSource(id, importer, module2) {
        timeStart("load modules", 3);
        let source;
        try {
          source = await this.readQueue.run(async () => {
            var _a;
            return (_a = await this.pluginDriver.hookFirst("load", [id])) !== null && _a !== void 0 ? _a : await import_fs.promises.readFile(id, "utf8");
          });
        } catch (err) {
          timeEnd("load modules", 3);
          let msg = `Could not load ${id}`;
          if (importer)
            msg += ` (imported by ${relativeId(importer)})`;
          msg += `: ${err.message}`;
          err.message = msg;
          throw err;
        }
        timeEnd("load modules", 3);
        const sourceDescription = typeof source === "string" ? { code: source } : source != null && typeof source === "object" && typeof source.code === "string" ? source : error(errBadLoader(id));
        const cachedModule = this.graph.cachedModules.get(id);
        if (cachedModule && !cachedModule.customTransformCache && cachedModule.originalCode === sourceDescription.code && !await this.pluginDriver.hookFirst("shouldTransformCachedModule", [
          {
            ast: cachedModule.ast,
            code: cachedModule.code,
            id: cachedModule.id,
            meta: cachedModule.meta,
            moduleSideEffects: cachedModule.moduleSideEffects,
            resolvedSources: cachedModule.resolvedIds,
            syntheticNamedExports: cachedModule.syntheticNamedExports
          }
        ])) {
          if (cachedModule.transformFiles) {
            for (const emittedFile of cachedModule.transformFiles)
              this.pluginDriver.emitFile(emittedFile);
          }
          module2.setSource(cachedModule);
        } else {
          module2.updateOptions(sourceDescription);
          module2.setSource(await transform(sourceDescription, module2, this.pluginDriver, this.options.onwarn));
        }
      }
      async awaitLoadModulesPromise() {
        let startingPromise;
        do {
          startingPromise = this.latestLoadModulesPromise;
          await startingPromise;
        } while (startingPromise !== this.latestLoadModulesPromise);
      }
      extendLoadModulesPromise(loadNewModulesPromise) {
        this.latestLoadModulesPromise = Promise.all([
          loadNewModulesPromise,
          this.latestLoadModulesPromise
        ]);
        this.latestLoadModulesPromise.catch(() => {
        });
        return loadNewModulesPromise;
      }
      async fetchDynamicDependencies(module2, resolveDynamicImportPromises) {
        const dependencies = await Promise.all(resolveDynamicImportPromises.map((resolveDynamicImportPromise) => resolveDynamicImportPromise.then(async ([dynamicImport, resolvedId]) => {
          if (resolvedId === null)
            return null;
          if (typeof resolvedId === "string") {
            dynamicImport.resolution = resolvedId;
            return null;
          }
          return dynamicImport.resolution = await this.fetchResolvedDependency(relativeId(resolvedId.id), module2.id, resolvedId);
        })));
        for (const dependency of dependencies) {
          if (dependency) {
            module2.dynamicDependencies.add(dependency);
            dependency.dynamicImporters.push(module2.id);
          }
        }
      }
      async fetchModule({ id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry, isPreload) {
        const existingModule = this.modulesById.get(id);
        if (existingModule instanceof Module) {
          await this.handleExistingModule(existingModule, isEntry, isPreload);
          return existingModule;
        }
        const module2 = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta);
        this.modulesById.set(id, module2);
        this.graph.watchFiles[id] = true;
        const loadPromise = this.addModuleSource(id, importer, module2).then(() => [
          this.getResolveStaticDependencyPromises(module2),
          this.getResolveDynamicImportPromises(module2),
          loadAndResolveDependenciesPromise
        ]);
        const loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() => this.pluginDriver.hookParallel("moduleParsed", [module2.info]));
        loadAndResolveDependenciesPromise.catch(() => {
        });
        this.moduleLoadPromises.set(module2, loadPromise);
        const resolveDependencyPromises = await loadPromise;
        if (!isPreload) {
          await this.fetchModuleDependencies(module2, ...resolveDependencyPromises);
        } else if (isPreload === RESOLVE_DEPENDENCIES) {
          await loadAndResolveDependenciesPromise;
        }
        return module2;
      }
      async fetchModuleDependencies(module2, resolveStaticDependencyPromises, resolveDynamicDependencyPromises, loadAndResolveDependenciesPromise) {
        if (this.modulesWithLoadedDependencies.has(module2)) {
          return;
        }
        this.modulesWithLoadedDependencies.add(module2);
        await Promise.all([
          this.fetchStaticDependencies(module2, resolveStaticDependencyPromises),
          this.fetchDynamicDependencies(module2, resolveDynamicDependencyPromises)
        ]);
        module2.linkImports();
        await loadAndResolveDependenciesPromise;
      }
      fetchResolvedDependency(source, importer, resolvedId) {
        if (resolvedId.external) {
          const { external, id, moduleSideEffects, meta } = resolvedId;
          if (!this.modulesById.has(id)) {
            this.modulesById.set(id, new ExternalModule(this.options, id, moduleSideEffects, meta, external !== "absolute" && isAbsolute(id)));
          }
          const externalModule = this.modulesById.get(id);
          if (!(externalModule instanceof ExternalModule)) {
            return error(errInternalIdCannotBeExternal(source, importer));
          }
          return Promise.resolve(externalModule);
        }
        return this.fetchModule(resolvedId, importer, false, false);
      }
      async fetchStaticDependencies(module2, resolveStaticDependencyPromises) {
        for (const dependency of await Promise.all(resolveStaticDependencyPromises.map((resolveStaticDependencyPromise) => resolveStaticDependencyPromise.then(([source, resolvedId]) => this.fetchResolvedDependency(source, module2.id, resolvedId))))) {
          module2.dependencies.add(dependency);
          dependency.importers.push(module2.id);
        }
        if (!this.options.treeshake || module2.info.moduleSideEffects === "no-treeshake") {
          for (const dependency of module2.dependencies) {
            if (dependency instanceof Module) {
              dependency.importedFromNotTreeshaken = true;
            }
          }
        }
      }
      getNormalizedResolvedIdWithoutDefaults(resolveIdResult, importer, source) {
        const { makeAbsoluteExternalsRelative } = this.options;
        if (resolveIdResult) {
          if (typeof resolveIdResult === "object") {
            const external2 = resolveIdResult.external || this.options.external(resolveIdResult.id, importer, true);
            return {
              ...resolveIdResult,
              external: external2 && (external2 === "relative" || !isAbsolute(resolveIdResult.id) || external2 === true && isNotAbsoluteExternal(resolveIdResult.id, source, makeAbsoluteExternalsRelative) || "absolute")
            };
          }
          const external = this.options.external(resolveIdResult, importer, true);
          return {
            external: external && (isNotAbsoluteExternal(resolveIdResult, source, makeAbsoluteExternalsRelative) || "absolute"),
            id: external && makeAbsoluteExternalsRelative ? normalizeRelativeExternalId(resolveIdResult, importer) : resolveIdResult
          };
        }
        const id = makeAbsoluteExternalsRelative ? normalizeRelativeExternalId(source, importer) : source;
        if (resolveIdResult !== false && !this.options.external(id, importer, true)) {
          return null;
        }
        return {
          external: isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) || "absolute",
          id
        };
      }
      getResolveDynamicImportPromises(module2) {
        return module2.dynamicImports.map(async (dynamicImport) => {
          const resolvedId = await this.resolveDynamicImport(module2, typeof dynamicImport.argument === "string" ? dynamicImport.argument : dynamicImport.argument.esTreeNode, module2.id);
          if (resolvedId && typeof resolvedId === "object") {
            dynamicImport.id = resolvedId.id;
          }
          return [dynamicImport, resolvedId];
        });
      }
      getResolveStaticDependencyPromises(module2) {
        return Array.from(module2.sources, async (source) => [
          source,
          module2.resolvedIds[source] = module2.resolvedIds[source] || this.handleResolveId(await this.resolveId(source, module2.id, EMPTY_OBJECT, false), source, module2.id)
        ]);
      }
      getResolvedIdWithDefaults(resolvedId) {
        var _a, _b;
        if (!resolvedId) {
          return null;
        }
        const external = resolvedId.external || false;
        return {
          external,
          id: resolvedId.id,
          meta: resolvedId.meta || {},
          moduleSideEffects: (_a = resolvedId.moduleSideEffects) !== null && _a !== void 0 ? _a : this.hasModuleSideEffects(resolvedId.id, !!external),
          syntheticNamedExports: (_b = resolvedId.syntheticNamedExports) !== null && _b !== void 0 ? _b : false
        };
      }
      async handleExistingModule(module2, isEntry, isPreload) {
        const loadPromise = this.moduleLoadPromises.get(module2);
        if (isPreload) {
          return isPreload === RESOLVE_DEPENDENCIES ? waitForDependencyResolution(loadPromise) : loadPromise;
        }
        if (isEntry) {
          module2.info.isEntry = true;
          this.implicitEntryModules.delete(module2);
          for (const dependant of module2.implicitlyLoadedAfter) {
            dependant.implicitlyLoadedBefore.delete(module2);
          }
          module2.implicitlyLoadedAfter.clear();
        }
        return this.fetchModuleDependencies(module2, ...await loadPromise);
      }
      handleResolveId(resolvedId, source, importer) {
        if (resolvedId === null) {
          if (isRelative(source)) {
            return error(errUnresolvedImport(source, importer));
          }
          this.options.onwarn(errUnresolvedImportTreatedAsExternal(source, importer));
          return {
            external: true,
            id: source,
            meta: {},
            moduleSideEffects: this.hasModuleSideEffects(source, true),
            syntheticNamedExports: false
          };
        } else if (resolvedId.external && resolvedId.syntheticNamedExports) {
          this.options.onwarn(errExternalSyntheticExports(source, importer));
        }
        return resolvedId;
      }
      async loadEntryModule(unresolvedId, isEntry, importer, implicitlyLoadedBefore) {
        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, EMPTY_OBJECT, true);
        if (resolveIdResult == null) {
          return error(implicitlyLoadedBefore === null ? errUnresolvedEntry(unresolvedId) : errUnresolvedImplicitDependant(unresolvedId, implicitlyLoadedBefore));
        }
        if (resolveIdResult === false || typeof resolveIdResult === "object" && resolveIdResult.external) {
          return error(implicitlyLoadedBefore === null ? errEntryCannotBeExternal(unresolvedId) : errImplicitDependantCannotBeExternal(unresolvedId, implicitlyLoadedBefore));
        }
        return this.fetchModule(this.getResolvedIdWithDefaults(typeof resolveIdResult === "object" ? resolveIdResult : { id: resolveIdResult }), void 0, isEntry, false);
      }
      async resolveDynamicImport(module2, specifier, importer) {
        var _a;
        var _b;
        const resolution = await this.pluginDriver.hookFirst("resolveDynamicImport", [
          specifier,
          importer
        ]);
        if (typeof specifier !== "string") {
          if (typeof resolution === "string") {
            return resolution;
          }
          if (!resolution) {
            return null;
          }
          return {
            external: false,
            moduleSideEffects: true,
            ...resolution
          };
        }
        if (resolution == null) {
          return (_a = (_b = module2.resolvedIds)[specifier]) !== null && _a !== void 0 ? _a : _b[specifier] = this.handleResolveId(await this.resolveId(specifier, module2.id, EMPTY_OBJECT, false), specifier, module2.id);
        }
        return this.handleResolveId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier)), specifier, importer);
      }
    };
    GlobalScope = class extends Scope$1 {
      constructor() {
        super();
        this.parent = null;
        this.variables.set("undefined", new UndefinedVariable());
      }
      findVariable(name) {
        let variable = this.variables.get(name);
        if (!variable) {
          variable = new GlobalVariable(name);
          this.variables.set(name, variable);
        }
        return variable;
      }
    };
    inputHookNames = {
      buildEnd: 1,
      buildStart: 1,
      closeBundle: 1,
      closeWatcher: 1,
      load: 1,
      moduleParsed: 1,
      options: 1,
      resolveDynamicImport: 1,
      resolveId: 1,
      shouldTransformCachedModule: 1,
      transform: 1,
      watchChange: 1
    };
    inputHooks = Object.keys(inputHookNames);
    PluginDriver = class {
      constructor(graph, options, userPlugins, pluginCache, basePluginDriver) {
        this.graph = graph;
        this.options = options;
        this.unfulfilledActions = /* @__PURE__ */ new Set();
        warnDeprecatedHooks(userPlugins, options);
        this.pluginCache = pluginCache;
        this.fileEmitter = new FileEmitter(graph, options, basePluginDriver && basePluginDriver.fileEmitter);
        this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter);
        this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter);
        this.finaliseAssets = this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter);
        this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter);
        this.plugins = userPlugins.concat(basePluginDriver ? basePluginDriver.plugins : []);
        const existingPluginNames = /* @__PURE__ */ new Set();
        this.pluginContexts = new Map(this.plugins.map((plugin) => [
          plugin,
          getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames)
        ]));
        if (basePluginDriver) {
          for (const plugin of userPlugins) {
            for (const hook of inputHooks) {
              if (hook in plugin) {
                options.onwarn(errInputHookInOutputPlugin(plugin.name, hook));
              }
            }
          }
        }
      }
      createOutputPluginDriver(plugins) {
        return new PluginDriver(this.graph, this.options, plugins, this.pluginCache, this);
      }
      getUnfulfilledHookActions() {
        return this.unfulfilledActions;
      }
      hookFirst(hookName, args, replaceContext, skipped) {
        let promise = Promise.resolve(void 0);
        for (const plugin of this.plugins) {
          if (skipped && skipped.has(plugin))
            continue;
          promise = promise.then((result) => {
            if (result != null)
              return result;
            return this.runHook(hookName, args, plugin, false, replaceContext);
          });
        }
        return promise;
      }
      hookFirstSync(hookName, args, replaceContext) {
        for (const plugin of this.plugins) {
          const result = this.runHookSync(hookName, args, plugin, replaceContext);
          if (result != null)
            return result;
        }
        return null;
      }
      hookParallel(hookName, args, replaceContext) {
        const promises2 = [];
        for (const plugin of this.plugins) {
          const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
          if (!hookPromise)
            continue;
          promises2.push(hookPromise);
        }
        return Promise.all(promises2).then(() => {
        });
      }
      hookReduceArg0(hookName, [arg0, ...rest], reduce, replaceContext) {
        let promise = Promise.resolve(arg0);
        for (const plugin of this.plugins) {
          promise = promise.then((arg02) => {
            const args = [arg02, ...rest];
            const hookPromise = this.runHook(hookName, args, plugin, false, replaceContext);
            if (!hookPromise)
              return arg02;
            return hookPromise.then((result) => reduce.call(this.pluginContexts.get(plugin), arg02, result, plugin));
          });
        }
        return promise;
      }
      hookReduceArg0Sync(hookName, [arg0, ...rest], reduce, replaceContext) {
        for (const plugin of this.plugins) {
          const args = [arg0, ...rest];
          const result = this.runHookSync(hookName, args, plugin, replaceContext);
          arg0 = reduce.call(this.pluginContexts.get(plugin), arg0, result, plugin);
        }
        return arg0;
      }
      hookReduceValue(hookName, initialValue, args, reduce, replaceContext) {
        let promise = Promise.resolve(initialValue);
        for (const plugin of this.plugins) {
          promise = promise.then((value) => {
            const hookPromise = this.runHook(hookName, args, plugin, true, replaceContext);
            if (!hookPromise)
              return value;
            return hookPromise.then((result) => reduce.call(this.pluginContexts.get(plugin), value, result, plugin));
          });
        }
        return promise;
      }
      hookReduceValueSync(hookName, initialValue, args, reduce, replaceContext) {
        let acc = initialValue;
        for (const plugin of this.plugins) {
          const result = this.runHookSync(hookName, args, plugin, replaceContext);
          acc = reduce.call(this.pluginContexts.get(plugin), acc, result, plugin);
        }
        return acc;
      }
      hookSeq(hookName, args, replaceContext) {
        let promise = Promise.resolve();
        for (const plugin of this.plugins) {
          promise = promise.then(() => this.runHook(hookName, args, plugin, false, replaceContext));
        }
        return promise;
      }
      runHook(hookName, args, plugin, permitValues, hookContext) {
        const hook = plugin[hookName];
        if (!hook)
          return void 0;
        let context = this.pluginContexts.get(plugin);
        if (hookContext) {
          context = hookContext(context, plugin);
        }
        let action = null;
        return Promise.resolve().then(() => {
          if (typeof hook !== "function") {
            if (permitValues)
              return hook;
            return throwInvalidHookError(hookName, plugin.name);
          }
          const hookResult = hook.apply(context, args);
          if (!hookResult || !hookResult.then) {
            return hookResult;
          }
          action = [plugin.name, hookName, args];
          this.unfulfilledActions.add(action);
          return Promise.resolve(hookResult).then((result) => {
            this.unfulfilledActions.delete(action);
            return result;
          });
        }).catch((err) => {
          if (action !== null) {
            this.unfulfilledActions.delete(action);
          }
          return throwPluginError(err, plugin.name, { hook: hookName });
        });
      }
      runHookSync(hookName, args, plugin, hookContext) {
        const hook = plugin[hookName];
        if (!hook)
          return void 0;
        let context = this.pluginContexts.get(plugin);
        if (hookContext) {
          context = hookContext(context, plugin);
        }
        try {
          if (typeof hook !== "function") {
            return throwInvalidHookError(hookName, plugin.name);
          }
          return hook.apply(context, args);
        } catch (err) {
          return throwPluginError(err, plugin.name, { hook: hookName });
        }
      }
    };
    Graph = class {
      constructor(options, watcher) {
        var _a, _b;
        this.options = options;
        this.cachedModules = /* @__PURE__ */ new Map();
        this.deoptimizationTracker = new PathTracker();
        this.entryModules = [];
        this.modulesById = /* @__PURE__ */ new Map();
        this.needsTreeshakingPass = false;
        this.phase = BuildPhase.LOAD_AND_PARSE;
        this.scope = new GlobalScope();
        this.watchFiles = /* @__PURE__ */ Object.create(null);
        this.watchMode = false;
        this.externalModules = [];
        this.implicitEntryModules = [];
        this.modules = [];
        this.getModuleInfo = (moduleId) => {
          const foundModule = this.modulesById.get(moduleId);
          if (!foundModule)
            return null;
          return foundModule.info;
        };
        if (options.cache !== false) {
          if ((_a = options.cache) === null || _a === void 0 ? void 0 : _a.modules) {
            for (const module2 of options.cache.modules)
              this.cachedModules.set(module2.id, module2);
          }
          this.pluginCache = ((_b = options.cache) === null || _b === void 0 ? void 0 : _b.plugins) || /* @__PURE__ */ Object.create(null);
          for (const name in this.pluginCache) {
            const cache = this.pluginCache[name];
            for (const value of Object.values(cache))
              value[0]++;
          }
        }
        if (watcher) {
          this.watchMode = true;
          const handleChange = (...args) => this.pluginDriver.hookParallel("watchChange", args);
          const handleClose = () => this.pluginDriver.hookParallel("closeWatcher", []);
          watcher.onCurrentAwaited("change", handleChange);
          watcher.onCurrentAwaited("close", handleClose);
        }
        this.pluginDriver = new PluginDriver(this, options, options.plugins, this.pluginCache);
        this.acornParser = Parser.extend(...options.acornInjectPlugins);
        this.moduleLoader = new ModuleLoader(this, this.modulesById, this.options, this.pluginDriver);
      }
      async build() {
        timeStart("generate module graph", 2);
        await this.generateModuleGraph();
        timeEnd("generate module graph", 2);
        timeStart("sort modules", 2);
        this.phase = BuildPhase.ANALYSE;
        this.sortModules();
        timeEnd("sort modules", 2);
        timeStart("mark included statements", 2);
        this.includeStatements();
        timeEnd("mark included statements", 2);
        this.phase = BuildPhase.GENERATE;
      }
      contextParse(code, options = {}) {
        const onCommentOrig = options.onComment;
        const comments = [];
        if (onCommentOrig && typeof onCommentOrig == "function") {
          options.onComment = (block, text, start, end, ...args) => {
            comments.push({ end, start, type: block ? "Block" : "Line", value: text });
            return onCommentOrig.call(options, block, text, start, end, ...args);
          };
        } else {
          options.onComment = comments;
        }
        const ast = this.acornParser.parse(code, {
          ...this.options.acorn,
          ...options
        });
        if (typeof onCommentOrig == "object") {
          onCommentOrig.push(...comments);
        }
        options.onComment = onCommentOrig;
        addAnnotations(comments, ast, code);
        return ast;
      }
      getCache() {
        for (const name in this.pluginCache) {
          const cache = this.pluginCache[name];
          let allDeleted = true;
          for (const [key, value] of Object.entries(cache)) {
            if (value[0] >= this.options.experimentalCacheExpiry)
              delete cache[key];
            else
              allDeleted = false;
          }
          if (allDeleted)
            delete this.pluginCache[name];
        }
        return {
          modules: this.modules.map((module2) => module2.toJSON()),
          plugins: this.pluginCache
        };
      }
      async generateModuleGraph() {
        ({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } = await this.moduleLoader.addEntryModules(normalizeEntryModules(this.options.input), true));
        if (this.entryModules.length === 0) {
          throw new Error("You must supply options.input to rollup");
        }
        for (const module2 of this.modulesById.values()) {
          if (module2 instanceof Module) {
            this.modules.push(module2);
          } else {
            this.externalModules.push(module2);
          }
        }
      }
      includeStatements() {
        for (const module2 of [...this.entryModules, ...this.implicitEntryModules]) {
          markModuleAndImpureDependenciesAsExecuted(module2);
        }
        if (this.options.treeshake) {
          let treeshakingPass = 1;
          do {
            timeStart(`treeshaking pass ${treeshakingPass}`, 3);
            this.needsTreeshakingPass = false;
            for (const module2 of this.modules) {
              if (module2.isExecuted) {
                if (module2.info.moduleSideEffects === "no-treeshake") {
                  module2.includeAllInBundle();
                } else {
                  module2.include();
                }
              }
            }
            if (treeshakingPass === 1) {
              for (const module2 of [...this.entryModules, ...this.implicitEntryModules]) {
                if (module2.preserveSignature !== false) {
                  module2.includeAllExports(false);
                  this.needsTreeshakingPass = true;
                }
              }
            }
            timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);
          } while (this.needsTreeshakingPass);
        } else {
          for (const module2 of this.modules)
            module2.includeAllInBundle();
        }
        for (const externalModule of this.externalModules)
          externalModule.warnUnusedImports();
        for (const module2 of this.implicitEntryModules) {
          for (const dependant of module2.implicitlyLoadedAfter) {
            if (!(dependant.info.isEntry || dependant.isIncluded())) {
              error(errImplicitDependantIsNotIncluded(dependant));
            }
          }
        }
      }
      sortModules() {
        const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);
        for (const cyclePath of cyclePaths) {
          this.options.onwarn({
            code: "CIRCULAR_DEPENDENCY",
            cycle: cyclePath,
            importer: cyclePath[0],
            message: `Circular dependency: ${cyclePath.join(" -> ")}`
          });
        }
        this.modules = orderedModules;
        for (const module2 of this.modules) {
          module2.bindReferences();
        }
        this.warnForMissingExports();
      }
      warnForMissingExports() {
        for (const module2 of this.modules) {
          for (const importDescription of module2.importDescriptions.values()) {
            if (importDescription.name !== "*" && !importDescription.module.getVariableForExportName(importDescription.name)[0]) {
              module2.warn({
                code: "NON_EXISTENT_EXPORT",
                message: `Non-existent export '${importDescription.name}' is imported from ${relativeId(importDescription.module.id)}`,
                name: importDescription.name,
                source: importDescription.module.id
              }, importDescription.start);
            }
          }
        }
      }
    };
    defaultOnWarn = (warning) => console.warn(warning.message || warning);
    treeshakePresets = {
      recommended: {
        annotations: true,
        correctVarValueBeforeDeclaration: false,
        moduleSideEffects: () => true,
        propertyReadSideEffects: true,
        tryCatchDeoptimization: true,
        unknownGlobalSideEffects: false
      },
      safest: {
        annotations: true,
        correctVarValueBeforeDeclaration: true,
        moduleSideEffects: () => true,
        propertyReadSideEffects: true,
        tryCatchDeoptimization: true,
        unknownGlobalSideEffects: true
      },
      smallest: {
        annotations: true,
        correctVarValueBeforeDeclaration: false,
        moduleSideEffects: () => false,
        propertyReadSideEffects: false,
        tryCatchDeoptimization: false,
        unknownGlobalSideEffects: false
      }
    };
    generatedCodePresets = {
      es2015: {
        arrowFunctions: true,
        constBindings: true,
        objectShorthand: true,
        reservedNamesAsProps: true,
        symbols: true
      },
      es5: {
        arrowFunctions: false,
        constBindings: false,
        objectShorthand: false,
        reservedNamesAsProps: true,
        symbols: false
      }
    };
    objectifyOption = (value) => value && typeof value === "object" ? value : {};
    objectifyOptionWithPresets = (presets, optionName, additionalValues) => (value) => {
      if (typeof value === "string") {
        const preset = presets[value];
        if (preset) {
          return preset;
        }
        error(errInvalidOption(optionName, getHashFromObjectOption(optionName), `valid values are ${additionalValues}${printQuotedStringList(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));
      }
      return objectifyOption(value);
    };
    getOptionWithPreset = (value, presets, optionName, additionalValues) => {
      var _a;
      const presetName = (_a = value) === null || _a === void 0 ? void 0 : _a.preset;
      if (presetName) {
        const preset = presets[presetName];
        if (preset) {
          return { ...preset, ...value };
        } else {
          error(errInvalidOption(`${optionName}.preset`, getHashFromObjectOption(optionName), `valid values are ${printQuotedStringList(Object.keys(presets))}`, presetName));
        }
      }
      return objectifyOptionWithPresets(presets, optionName, additionalValues)(value);
    };
    getHashFromObjectOption = (optionName) => optionName.split(".").join("").toLowerCase();
    getOnwarn = (config) => {
      const { onwarn } = config;
      return onwarn ? (warning) => {
        warning.toString = () => {
          let str = "";
          if (warning.plugin)
            str += `(${warning.plugin} plugin) `;
          if (warning.loc)
            str += `${relativeId(warning.loc.file)} (${warning.loc.line}:${warning.loc.column}) `;
          str += warning.message;
          return str;
        };
        onwarn(warning, defaultOnWarn);
      } : defaultOnWarn;
    };
    getAcorn = (config) => ({
      allowAwaitOutsideFunction: true,
      ecmaVersion: "latest",
      preserveParens: false,
      sourceType: "module",
      ...config.acorn
    });
    getAcornInjectPlugins = (config) => ensureArray(config.acornInjectPlugins);
    getCache = (config) => {
      var _a;
      return ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.cache) || config.cache;
    };
    getIdMatcher = (option) => {
      if (option === true) {
        return () => true;
      }
      if (typeof option === "function") {
        return (id, ...args) => !id.startsWith("\0") && option(id, ...args) || false;
      }
      if (option) {
        const ids = /* @__PURE__ */ new Set();
        const matchers = [];
        for (const value of ensureArray(option)) {
          if (value instanceof RegExp) {
            matchers.push(value);
          } else {
            ids.add(value);
          }
        }
        return (id, ..._args) => ids.has(id) || matchers.some((matcher) => matcher.test(id));
      }
      return () => false;
    };
    getInlineDynamicImports$1 = (config, warn, strictDeprecations) => {
      const configInlineDynamicImports = config.inlineDynamicImports;
      if (configInlineDynamicImports) {
        warnDeprecationWithOptions('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', false, warn, strictDeprecations);
      }
      return configInlineDynamicImports;
    };
    getInput = (config) => {
      const configInput = config.input;
      return configInput == null ? [] : typeof configInput === "string" ? [configInput] : configInput;
    };
    getManualChunks$1 = (config, warn, strictDeprecations) => {
      const configManualChunks = config.manualChunks;
      if (configManualChunks) {
        warnDeprecationWithOptions('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', false, warn, strictDeprecations);
      }
      return configManualChunks;
    };
    getMaxParallelFileReads = (config) => {
      const maxParallelFileReads = config.maxParallelFileReads;
      if (typeof maxParallelFileReads === "number") {
        if (maxParallelFileReads <= 0)
          return Infinity;
        return maxParallelFileReads;
      }
      return 20;
    };
    getModuleContext = (config, context) => {
      const configModuleContext = config.moduleContext;
      if (typeof configModuleContext === "function") {
        return (id) => {
          var _a;
          return (_a = configModuleContext(id)) !== null && _a !== void 0 ? _a : context;
        };
      }
      if (configModuleContext) {
        const contextByModuleId = /* @__PURE__ */ Object.create(null);
        for (const [key, moduleContext] of Object.entries(configModuleContext)) {
          contextByModuleId[(0, import_path.resolve)(key)] = moduleContext;
        }
        return (id) => contextByModuleId[id] || context;
      }
      return () => context;
    };
    getPreserveEntrySignatures = (config, unsetOptions) => {
      const configPreserveEntrySignatures = config.preserveEntrySignatures;
      if (configPreserveEntrySignatures == null) {
        unsetOptions.add("preserveEntrySignatures");
      }
      return configPreserveEntrySignatures !== null && configPreserveEntrySignatures !== void 0 ? configPreserveEntrySignatures : "strict";
    };
    getPreserveModules$1 = (config, warn, strictDeprecations) => {
      const configPreserveModules = config.preserveModules;
      if (configPreserveModules) {
        warnDeprecationWithOptions('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', false, warn, strictDeprecations);
      }
      return configPreserveModules;
    };
    getTreeshake = (config, warn, strictDeprecations) => {
      const configTreeshake = config.treeshake;
      if (configTreeshake === false) {
        return false;
      }
      const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, "treeshake", "false, true, ");
      if (typeof configWithPreset.pureExternalModules !== "undefined") {
        warnDeprecationWithOptions(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, true, warn, strictDeprecations);
      }
      return {
        annotations: configWithPreset.annotations !== false,
        correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === true,
        moduleSideEffects: typeof configTreeshake === "object" && configTreeshake.pureExternalModules ? getHasModuleSideEffects(configTreeshake.moduleSideEffects, configTreeshake.pureExternalModules) : getHasModuleSideEffects(configWithPreset.moduleSideEffects, void 0),
        propertyReadSideEffects: configWithPreset.propertyReadSideEffects === "always" ? "always" : configWithPreset.propertyReadSideEffects !== false,
        tryCatchDeoptimization: configWithPreset.tryCatchDeoptimization !== false,
        unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== false
      };
    };
    getHasModuleSideEffects = (moduleSideEffectsOption, pureExternalModules) => {
      if (typeof moduleSideEffectsOption === "boolean") {
        return () => moduleSideEffectsOption;
      }
      if (moduleSideEffectsOption === "no-external") {
        return (_id, external) => !external;
      }
      if (typeof moduleSideEffectsOption === "function") {
        return (id, external) => !id.startsWith("\0") ? moduleSideEffectsOption(id, external) !== false : true;
      }
      if (Array.isArray(moduleSideEffectsOption)) {
        const ids = new Set(moduleSideEffectsOption);
        return (id) => ids.has(id);
      }
      if (moduleSideEffectsOption) {
        error(errInvalidOption("treeshake.moduleSideEffects", "treeshake", 'please use one of false, "no-external", a function or an array'));
      }
      const isPureExternalModule = getIdMatcher(pureExternalModules);
      return (id, external) => !(external && isPureExternalModule(id));
    };
    INVALID_CHAR_REGEX = /[\x00-\x1F\x7F<>*#"{}|^[\]`;?:&=+$,]/g;
    DRIVE_LETTER_REGEX = /^[a-z]:/i;
    getFile = (config, preserveModules, inputOptions) => {
      const { file } = config;
      if (typeof file === "string") {
        if (preserveModules) {
          return error(errInvalidOption("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
        }
        if (!Array.isArray(inputOptions.input))
          return error(errInvalidOption("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when providing named inputs'));
      }
      return file;
    };
    getFormat = (config) => {
      const configFormat = config.format;
      switch (configFormat) {
        case void 0:
        case "es":
        case "esm":
        case "module":
          return "es";
        case "cjs":
        case "commonjs":
          return "cjs";
        case "system":
        case "systemjs":
          return "system";
        case "amd":
        case "iife":
        case "umd":
          return configFormat;
        default:
          return error({
            message: `You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".`,
            url: `https://rollupjs.org/guide/en/#outputformat`
          });
      }
    };
    getInlineDynamicImports = (config, inputOptions) => {
      var _a;
      const inlineDynamicImports = ((_a = config.inlineDynamicImports) !== null && _a !== void 0 ? _a : inputOptions.inlineDynamicImports) || false;
      const { input } = inputOptions;
      if (inlineDynamicImports && (Array.isArray(input) ? input : Object.keys(input)).length > 1) {
        return error(errInvalidOption("output.inlineDynamicImports", "outputinlinedynamicimports", 'multiple inputs are not supported when "output.inlineDynamicImports" is true'));
      }
      return inlineDynamicImports;
    };
    getPreserveModules = (config, inlineDynamicImports, inputOptions) => {
      var _a;
      const preserveModules = ((_a = config.preserveModules) !== null && _a !== void 0 ? _a : inputOptions.preserveModules) || false;
      if (preserveModules) {
        if (inlineDynamicImports) {
          return error(errInvalidOption("output.inlineDynamicImports", "outputinlinedynamicimports", `this option is not supported for "output.preserveModules"`));
        }
        if (inputOptions.preserveEntrySignatures === false) {
          return error(errInvalidOption("preserveEntrySignatures", "preserveentrysignatures", 'setting this option to false is not supported for "output.preserveModules"'));
        }
      }
      return preserveModules;
    };
    getPreferConst = (config, inputOptions) => {
      const configPreferConst = config.preferConst;
      if (configPreferConst != null) {
        warnDeprecation(`The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.`, false, inputOptions);
      }
      return !!configPreferConst;
    };
    getPreserveModulesRoot = (config) => {
      const { preserveModulesRoot } = config;
      if (preserveModulesRoot === null || preserveModulesRoot === void 0) {
        return void 0;
      }
      return (0, import_path.resolve)(preserveModulesRoot);
    };
    getAmd = (config) => {
      const mergedOption = {
        autoId: false,
        basePath: "",
        define: "define",
        ...config.amd
      };
      if ((mergedOption.autoId || mergedOption.basePath) && mergedOption.id) {
        return error(errInvalidOption("output.amd.id", "outputamd", 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
      }
      if (mergedOption.basePath && !mergedOption.autoId) {
        return error(errInvalidOption("output.amd.basePath", "outputamd", 'this option only works with "output.amd.autoId"'));
      }
      let normalized;
      if (mergedOption.autoId) {
        normalized = {
          autoId: true,
          basePath: mergedOption.basePath,
          define: mergedOption.define
        };
      } else {
        normalized = {
          autoId: false,
          define: mergedOption.define,
          id: mergedOption.id
        };
      }
      return normalized;
    };
    getAddon = (config, name) => {
      const configAddon = config[name];
      if (typeof configAddon === "function") {
        return configAddon;
      }
      return () => configAddon || "";
    };
    getDir = (config, file) => {
      const { dir } = config;
      if (typeof dir === "string" && typeof file === "string") {
        return error(errInvalidOption("output.dir", "outputdir", 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks'));
      }
      return dir;
    };
    getDynamicImportFunction = (config, inputOptions) => {
      const configDynamicImportFunction = config.dynamicImportFunction;
      if (configDynamicImportFunction) {
        warnDeprecation(`The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.`, false, inputOptions);
      }
      return configDynamicImportFunction;
    };
    getEntryFileNames = (config, unsetOptions) => {
      const configEntryFileNames = config.entryFileNames;
      if (configEntryFileNames == null) {
        unsetOptions.add("entryFileNames");
      }
      return configEntryFileNames !== null && configEntryFileNames !== void 0 ? configEntryFileNames : "[name].js";
    };
    getGeneratedCode = (config, preferConst) => {
      const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, "output.generatedCode", "");
      return {
        arrowFunctions: configWithPreset.arrowFunctions === true,
        constBindings: configWithPreset.constBindings === true || preferConst,
        objectShorthand: configWithPreset.objectShorthand === true,
        reservedNamesAsProps: configWithPreset.reservedNamesAsProps === true,
        symbols: configWithPreset.symbols === true
      };
    };
    getIndent = (config, compact) => {
      if (compact) {
        return "";
      }
      const configIndent = config.indent;
      return configIndent === false ? "" : configIndent !== null && configIndent !== void 0 ? configIndent : true;
    };
    ALLOWED_INTEROP_TYPES = /* @__PURE__ */ new Set([
      "auto",
      "esModule",
      "default",
      "defaultOnly",
      true,
      false
    ]);
    getInterop = (config, inputOptions) => {
      const configInterop = config.interop;
      const validatedInteropTypes = /* @__PURE__ */ new Set();
      const validateInterop = (interop) => {
        if (!validatedInteropTypes.has(interop)) {
          validatedInteropTypes.add(interop);
          if (!ALLOWED_INTEROP_TYPES.has(interop)) {
            return error(errInvalidOption("output.interop", "outputinterop", `use one of ${Array.from(ALLOWED_INTEROP_TYPES, (value) => JSON.stringify(value)).join(", ")}`, interop));
          }
          if (typeof interop === "boolean") {
            warnDeprecation({
              message: `The boolean value "${interop}" for the "output.interop" option is deprecated. Use ${interop ? '"auto"' : '"esModule", "default" or "defaultOnly"'} instead.`,
              url: "https://rollupjs.org/guide/en/#outputinterop"
            }, false, inputOptions);
          }
        }
        return interop;
      };
      if (typeof configInterop === "function") {
        const interopPerId = /* @__PURE__ */ Object.create(null);
        let defaultInterop = null;
        return (id) => id === null ? defaultInterop || validateInterop(defaultInterop = configInterop(id)) : id in interopPerId ? interopPerId[id] : validateInterop(interopPerId[id] = configInterop(id));
      }
      return configInterop === void 0 ? () => true : () => validateInterop(configInterop);
    };
    getManualChunks = (config, inlineDynamicImports, preserveModules, inputOptions) => {
      const configManualChunks = config.manualChunks || inputOptions.manualChunks;
      if (configManualChunks) {
        if (inlineDynamicImports) {
          return error(errInvalidOption("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.inlineDynamicImports"'));
        }
        if (preserveModules) {
          return error(errInvalidOption("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.preserveModules"'));
        }
      }
      return configManualChunks || {};
    };
    getMinifyInternalExports = (config, format, compact) => {
      var _a;
      return (_a = config.minifyInternalExports) !== null && _a !== void 0 ? _a : compact || format === "es" || format === "system";
    };
    getNamespaceToStringTag = (config, generatedCode, inputOptions) => {
      const configNamespaceToStringTag = config.namespaceToStringTag;
      if (configNamespaceToStringTag != null) {
        warnDeprecation(`The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.`, false, inputOptions);
        return configNamespaceToStringTag;
      }
      return generatedCode.symbols || false;
    };
    (function(SortingFileType2) {
      SortingFileType2[SortingFileType2["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
      SortingFileType2[SortingFileType2["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
      SortingFileType2[SortingFileType2["ASSET"] = 2] = "ASSET";
    })(SortingFileType || (SortingFileType = {}));
  }
});

// plugins/public/node_modules/builtin-modules/index.js
var require_builtin_modules = __commonJS({
  "plugins/public/node_modules/builtin-modules/index.js"(exports, module2) {
    "use strict";
    var { builtinModules } = require("module");
    var ignoreList = [
      "sys"
    ];
    module2.exports = (builtinModules || Object.keys(process.binding("natives"))).filter((x) => !/^_|^(internal|v8|node-inspect)\/|\//.test(x) && !ignoreList.includes(x)).sort();
  }
});

// plugins/public/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "plugins/public/node_modules/deepmerge/dist/cjs.js"(exports, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module2.exports = deepmerge_1;
  }
});

// plugins/public/node_modules/is-module/index.js
var require_is_module = __commonJS({
  "plugins/public/node_modules/is-module/index.js"(exports, module2) {
    var ES6ImportExportRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(import\s+['"]|(import|module)\s+[^"'\(\)\n;]+\s+from\s+['"]|export\s+(\*|\{|default|function|var|const|let|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*))/;
    var ES6AliasRegExp = /(?:^\s*|[}{\(\);,\n]\s*)(export\s*\*\s*from\s*(?:'([^']+)'|"([^"]+)"))/;
    module2.exports = function(sauce) {
      return ES6ImportExportRegExp.test(sauce) || ES6AliasRegExp.test(sauce);
    };
  }
});

// plugins/public/node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "plugins/public/node_modules/resolve/lib/homedir.js"(exports, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// plugins/public/node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "plugins/public/node_modules/resolve/lib/caller.js"(exports, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// plugins/public/node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "plugins/public/node_modules/path-parse/index.js"(exports, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win322 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win322.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix3 = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix3.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win322.parse;
    else
      module2.exports = posix3.parse;
    module2.exports.posix = posix3.parse;
    module2.exports.win32 = win322.parse;
  }
});

// plugins/public/node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "plugins/public/node_modules/resolve/lib/node-modules-paths.js"(exports, module2) {
    var path4 = require("path");
    var parse4 = path4.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse4(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse4(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path4.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// plugins/public/node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "plugins/public/node_modules/resolve/lib/normalize-options.js"(exports, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// plugins/public/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "plugins/public/node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice2.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice2.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// plugins/public/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "plugins/public/node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// plugins/public/node_modules/has/src/index.js
var require_src = __commonJS({
  "plugins/public/node_modules/has/src/index.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// plugins/public/node_modules/is-core-module/core.json
var require_core = __commonJS({
  "plugins/public/node_modules/is-core-module/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// plugins/public/node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "plugins/public/node_modules/is-core-module/index.js"(exports, module2) {
    "use strict";
    var has2 = require_src();
    function specifierIncluded(current2, specifier) {
      var nodeParts = current2.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current2, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current2, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current2 = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current2 !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current2, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current2, specifierValue);
    }
    var data2 = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return has2(data2, x) && versionIncluded(nodeVersion, data2[x]);
    };
  }
});

// plugins/public/node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "plugins/public/node_modules/resolve/lib/async.js"(exports, module2) {
    var fs2 = require("fs");
    var getHomedir = require_homedir();
    var path4 = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = fs2.realpath && typeof fs2.realpath.native === "function" ? fs2.realpath.native : fs2.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path4.join(homedir, ".node_modules"),
        path4.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs2.stat(file, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isFile() || stat2.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs2.stat(dir, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath2(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath2, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath2(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path4.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve4(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs2.readFile;
      var realpath2 = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path4.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path4.resolve(basedir);
      maybeRealpath(
        realpath2,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path4.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n2, pkg) {
            if (err2)
              cb(err2);
            else if (n2) {
              return maybeRealpath(realpath2, n2, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath2, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path4.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path4.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path4.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath2, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path4.dirname(dir), cb2);
          var pkgfile = path4.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path4.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath2, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path4.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path4.join(x2, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path4.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path4.join(x2, "index"), pkg2, cb2);
                  var dir = path4.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n2, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n2)
                      return cb2(null, n2, pkg3);
                    loadAsFile(path4.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path4.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path4.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n2, pkg) {
          if (err2)
            return cb2(err2);
          if (n2)
            return cb2(null, n2, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// plugins/public/node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "plugins/public/node_modules/resolve/lib/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// plugins/public/node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "plugins/public/node_modules/resolve/lib/core.js"(exports, module2) {
    var current2 = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current2[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data2 = require_core2();
    var core = {};
    for (mod in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, mod)) {
        core[mod] = versionIncluded(data2[mod]);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// plugins/public/node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "plugins/public/node_modules/resolve/lib/is-core.js"(exports, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// plugins/public/node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "plugins/public/node_modules/resolve/lib/sync.js"(exports, module2) {
    var isCore = require_is_core_module();
    var fs2 = require("fs");
    var path4 = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = fs2.realpathSync && typeof fs2.realpathSync.native === "function" ? fs2.realpathSync.native : fs2.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path4.join(homedir, ".node_modules"),
        path4.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat2 = fs2.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat2 && (stat2.isFile() || stat2.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat2 = fs2.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat2 && stat2.isDirectory();
    };
    var defaultRealpathSync = function realpathSync2(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync2, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync2(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path4.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs2.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync2 = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path4.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync2, path4.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path4.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync2, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n2 = loadNodeModulesSync(x, absoluteStart);
        if (n2)
          return maybeRealpathSync(realpathSync2, n2, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path4.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path4.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path4.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path4.join(maybeRealpathSync(realpathSync2, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path4.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path4.join(maybeRealpathSync(realpathSync2, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path4.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n3 = loadAsDirectorySync(path4.resolve(x2, pkg.main));
              if (n3)
                return n3;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path4.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path4.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n3 = loadAsDirectorySync(dir);
            if (n3)
              return n3;
          }
        }
      }
    };
  }
});

// plugins/public/node_modules/resolve/index.js
var require_resolve = __commonJS({
  "plugins/public/node_modules/resolve/index.js"(exports, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// plugins/public/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "plugins/public/node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var WIN_SLASH2 = "\\\\/";
    var WIN_NO_SLASH2 = `[^${WIN_SLASH2}]`;
    var DOT_LITERAL2 = "\\.";
    var PLUS_LITERAL2 = "\\+";
    var QMARK_LITERAL2 = "\\?";
    var SLASH_LITERAL2 = "\\/";
    var ONE_CHAR2 = "(?=.)";
    var QMARK2 = "[^/]";
    var END_ANCHOR2 = `(?:${SLASH_LITERAL2}|$)`;
    var START_ANCHOR2 = `(?:^|${SLASH_LITERAL2})`;
    var DOTS_SLASH2 = `${DOT_LITERAL2}{1,2}${END_ANCHOR2}`;
    var NO_DOT2 = `(?!${DOT_LITERAL2})`;
    var NO_DOTS2 = `(?!${START_ANCHOR2}${DOTS_SLASH2})`;
    var NO_DOT_SLASH2 = `(?!${DOT_LITERAL2}{0,1}${END_ANCHOR2})`;
    var NO_DOTS_SLASH2 = `(?!${DOTS_SLASH2})`;
    var QMARK_NO_DOT2 = `[^.${SLASH_LITERAL2}]`;
    var STAR2 = `${QMARK2}*?`;
    var POSIX_CHARS2 = {
      DOT_LITERAL: DOT_LITERAL2,
      PLUS_LITERAL: PLUS_LITERAL2,
      QMARK_LITERAL: QMARK_LITERAL2,
      SLASH_LITERAL: SLASH_LITERAL2,
      ONE_CHAR: ONE_CHAR2,
      QMARK: QMARK2,
      END_ANCHOR: END_ANCHOR2,
      DOTS_SLASH: DOTS_SLASH2,
      NO_DOT: NO_DOT2,
      NO_DOTS: NO_DOTS2,
      NO_DOT_SLASH: NO_DOT_SLASH2,
      NO_DOTS_SLASH: NO_DOTS_SLASH2,
      QMARK_NO_DOT: QMARK_NO_DOT2,
      STAR: STAR2,
      START_ANCHOR: START_ANCHOR2
    };
    var WINDOWS_CHARS2 = {
      ...POSIX_CHARS2,
      SLASH_LITERAL: `[${WIN_SLASH2}]`,
      QMARK: WIN_NO_SLASH2,
      STAR: `${WIN_NO_SLASH2}*?`,
      DOTS_SLASH: `${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL2})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH2}])${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL2}{0,1}(?:[${WIN_SLASH2}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH2}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH2}])`,
      END_ANCHOR: `(?:[${WIN_SLASH2}]|$)`
    };
    var POSIX_REGEX_SOURCE2 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE2,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path4.sep,
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS2 : POSIX_CHARS2;
      }
    };
  }
});

// plugins/public/node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "plugins/public/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path4 = require("path");
    var win322 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path4.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend3 = options.contains ? "" : "^";
      const append3 = options.contains ? "" : "$";
      let output = `${prepend3}(?:${input})${append3}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// plugins/public/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "plugins/public/node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils2 = require_utils();
    var {
      CHAR_ASTERISK: CHAR_ASTERISK2,
      CHAR_AT: CHAR_AT2,
      CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
      CHAR_COMMA: CHAR_COMMA2,
      CHAR_DOT: CHAR_DOT2,
      CHAR_EXCLAMATION_MARK: CHAR_EXCLAMATION_MARK2,
      CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE2,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES2,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET2,
      CHAR_PLUS: CHAR_PLUS2,
      CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE2,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES2,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET2
    } = require_constants2();
    var isPathSeparator2 = (code) => {
      return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
    };
    var depth2 = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan2 = (input, options) => {
      const opts = options || {};
      const length3 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length3;
      const peek = () => str.charCodeAt(index + 1);
      const advance3 = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length3) {
        code = advance3();
        let next;
        if (code === CHAR_BACKWARD_SLASH2) {
          backslashes = token.backslashes = true;
          code = advance3();
          if (code === CHAR_LEFT_CURLY_BRACE2) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE2) {
          braces++;
          while (eos() !== true && (code = advance3())) {
            if (code === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE2) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance3()) === CHAR_DOT2) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA2) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE2) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH2) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT2 && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS2 || code === CHAR_AT2 || code === CHAR_ASTERISK2 || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK2;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES2) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK2 && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance3())) {
                if (code === CHAR_BACKWARD_SLASH2) {
                  backslashes = token.backslashes = true;
                  code = advance3();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES2) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK2) {
          if (prev === CHAR_ASTERISK2)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK2) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET2) {
          while (eos() !== true && (next = advance3())) {
            if (next === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET2) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK2 && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES2) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance3())) {
              if (code === CHAR_LEFT_PARENTHESES2) {
                backslashes = token.backslashes = true;
                code = advance3();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES2) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base2 = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base2 = "";
        glob = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator2(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils2.removeBackslashes(glob);
        if (base2 && backslashes === true) {
          base2 = utils2.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator2(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth2(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth2(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan2;
  }
});

// plugins/public/node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "plugins/public/node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants2 = require_constants2();
    var utils2 = require_utils();
    var {
      MAX_LENGTH: MAX_LENGTH2,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE2,
      REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS2,
      REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF2,
      REPLACEMENTS: REPLACEMENTS2
    } = constants2;
    var expandRange2 = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils2.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError2 = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse4 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS2[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils2.isWindows(options);
      const PLATFORM_CHARS = constants2.globChars(win322);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils2.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance3 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append3 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance3();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append3(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR2 });
        push({ type: "paren", extglob: true, value: advance3(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse4(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF2, (m, esc, chars2, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils2.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance3();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance3();
          } else {
            value += advance3();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE2[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance3();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append3({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils2.escapeRegex(value);
          prev.value += value;
          append3({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError2("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append3({ value });
          if (opts.literalBrackets === false || utils2.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils2.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange2(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL2 });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL2 });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL2 });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils2.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT2 });
            continue;
          }
          push({ type: "qmark", value, output: QMARK2 });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS2.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance3());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance3());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "]"));
        state.output = utils2.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", ")"));
        state.output = utils2.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "}"));
        state.output = utils2.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse4.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS2[input] || input;
      const win322 = utils2.isWindows(options);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants2.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL2 + match[2];
          }
        }
      };
      const output = utils2.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL2}?`;
      }
      return source;
    };
    module2.exports = parse4;
  }
});

// plugins/public/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "plugins/public/node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var scan2 = require_scan();
    var parse4 = require_parse();
    var utils2 = require_utils();
    var constants2 = require_constants2();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = utils2.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix3 ? utils2.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix3);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix3 = utils2.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path4.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse4(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan2(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend3 = opts.contains ? "" : "^";
      const append3 = opts.contains ? "" : "$";
      let source = `${prepend3}(?:${state.output})${append3}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse4.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse4(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants2;
    module2.exports = picomatch;
  }
});

// plugins/public/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "plugins/public/node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// plugins/public/node_modules/@rollup/pluginutils/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "plugins/public/node_modules/@rollup/pluginutils/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var path4 = require("path");
    var pm2 = _interopDefault(require_picomatch2());
    var addExtension = function addExtension2(filename, ext = ".js") {
      let result = `${filename}`;
      if (!path4.extname(filename))
        result += ext;
      return result;
    };
    function walk(ast, { enter, leave }) {
      return visit(ast, null, enter, leave);
    }
    var should_skip = false;
    var should_remove = false;
    var replacement = null;
    var context = {
      skip: () => should_skip = true,
      remove: () => should_remove = true,
      replace: (node) => replacement = node
    };
    function replace(parent, prop, index2, node) {
      if (parent) {
        if (index2 !== null) {
          parent[prop][index2] = node;
        } else {
          parent[prop] = node;
        }
      }
    }
    function remove2(parent, prop, index2) {
      if (parent) {
        if (index2 !== null) {
          parent[prop].splice(index2, 1);
        } else {
          delete parent[prop];
        }
      }
    }
    function visit(node, parent, enter, leave, prop, index2) {
      if (node) {
        if (enter) {
          const _should_skip = should_skip;
          const _should_remove = should_remove;
          const _replacement = replacement;
          should_skip = false;
          should_remove = false;
          replacement = null;
          enter.call(context, node, parent, prop, index2);
          if (replacement) {
            node = replacement;
            replace(parent, prop, index2, node);
          }
          if (should_remove) {
            remove2(parent, prop, index2);
          }
          const skipped = should_skip;
          const removed = should_remove;
          should_skip = _should_skip;
          should_remove = _should_remove;
          replacement = _replacement;
          if (skipped)
            return node;
          if (removed)
            return null;
        }
        for (const key in node) {
          const value = node[key];
          if (typeof value !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (let j = 0, k = 0; j < value.length; j += 1, k += 1) {
              if (value[j] !== null && typeof value[j].type === "string") {
                if (!visit(value[j], node, enter, leave, key, k)) {
                  j--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            visit(value, node, enter, leave, key, null);
          }
        }
        if (leave) {
          const _replacement = replacement;
          const _should_remove = should_remove;
          replacement = null;
          should_remove = false;
          leave.call(context, node, parent, prop, index2);
          if (replacement) {
            node = replacement;
            replace(parent, prop, index2, node);
          }
          if (should_remove) {
            remove2(parent, prop, index2);
          }
          const removed = should_remove;
          replacement = _replacement;
          should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node;
    }
    var extractors2 = {
      ArrayPattern(names, param) {
        for (const element of param.elements) {
          if (element)
            extractors2[element.type](names, element);
        }
      },
      AssignmentPattern(names, param) {
        extractors2[param.left.type](names, param.left);
      },
      Identifier(names, param) {
        names.push(param.name);
      },
      MemberExpression() {
      },
      ObjectPattern(names, param) {
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractors2.RestElement(names, prop);
          } else {
            extractors2[prop.value.type](names, prop.value);
          }
        }
      },
      RestElement(names, param) {
        extractors2[param.argument.type](names, param.argument);
      }
    };
    var extractAssignedNames3 = function extractAssignedNames4(param) {
      const names = [];
      extractors2[param.type](names, param);
      return names;
    };
    var blockDeclarations = {
      const: true,
      let: true
    };
    var Scope3 = class {
      constructor(options = {}) {
        this.parent = options.parent;
        this.isBlockScope = !!options.block;
        this.declarations = /* @__PURE__ */ Object.create(null);
        if (options.params) {
          options.params.forEach((param) => {
            extractAssignedNames3(param).forEach((name) => {
              this.declarations[name] = true;
            });
          });
        }
      }
      addDeclaration(node, isBlockDeclaration, isVar) {
        if (!isBlockDeclaration && this.isBlockScope) {
          this.parent.addDeclaration(node, isBlockDeclaration, isVar);
        } else if (node.id) {
          extractAssignedNames3(node.id).forEach((name) => {
            this.declarations[name] = true;
          });
        }
      }
      contains(name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
      }
    };
    var attachScopes = function attachScopes2(ast, propertyName = "scope") {
      let scope = new Scope3();
      walk(ast, {
        enter(n2, parent) {
          const node = n2;
          if (/(Function|Class)Declaration/.test(node.type)) {
            scope.addDeclaration(node, false, false);
          }
          if (node.type === "VariableDeclaration") {
            const { kind } = node;
            const isBlockDeclaration = blockDeclarations[kind];
            const parentType = parent ? parent.type : "";
            if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {
              node.declarations.forEach((declaration) => {
                scope.addDeclaration(declaration, isBlockDeclaration, true);
              });
            }
          }
          let newScope;
          if (/Function/.test(node.type)) {
            const func = node;
            newScope = new Scope3({
              parent: scope,
              block: false,
              params: func.params
            });
            if (func.type === "FunctionExpression" && func.id) {
              newScope.addDeclaration(func, false, false);
            }
          }
          if (node.type === "BlockStatement" && !/Function/.test(parent.type)) {
            newScope = new Scope3({
              parent: scope,
              block: true
            });
          }
          if (node.type === "CatchClause") {
            newScope = new Scope3({
              parent: scope,
              params: node.param ? [node.param] : [],
              block: true
            });
          }
          if (newScope) {
            Object.defineProperty(node, propertyName, {
              value: newScope,
              configurable: true
            });
            scope = newScope;
          }
        },
        leave(n2) {
          const node = n2;
          if (node[propertyName])
            scope = scope.parent;
        }
      });
      return scope;
    };
    function isArray3(arg) {
      return Array.isArray(arg);
    }
    function ensureArray3(thing) {
      if (isArray3(thing))
        return thing;
      if (thing == null)
        return [];
      return [thing];
    }
    function getMatcherString2(id, resolutionBase) {
      if (resolutionBase === false) {
        return id;
      }
      const basePath = path4.resolve(resolutionBase || "").split(path4.sep).join("/").replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
      return path4.posix.join(basePath, id);
    }
    var createFilter3 = function createFilter4(include, exclude, options) {
      const resolutionBase = options && options.resolve;
      const getMatcher = (id) => id instanceof RegExp ? id : {
        test: (what) => {
          const pattern = getMatcherString2(id, resolutionBase);
          const fn = pm2(pattern, { dot: true });
          const result = fn(what);
          return result;
        }
      };
      const includeMatchers = ensureArray3(include).map(getMatcher);
      const excludeMatchers = ensureArray3(exclude).map(getMatcher);
      return function result(id) {
        if (typeof id !== "string")
          return false;
        if (/\0/.test(id))
          return false;
        const pathId = id.split(path4.sep).join("/");
        for (let i = 0; i < excludeMatchers.length; ++i) {
          const matcher = excludeMatchers[i];
          if (matcher.test(pathId))
            return false;
        }
        for (let i = 0; i < includeMatchers.length; ++i) {
          const matcher = includeMatchers[i];
          if (matcher.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    var reservedWords3 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    var builtins4 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    var forbiddenIdentifiers3 = new Set(`${reservedWords3} ${builtins4}`.split(" "));
    forbiddenIdentifiers3.add("");
    var makeLegalIdentifier = function makeLegalIdentifier2(str) {
      let identifier = str.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers3.has(identifier)) {
        identifier = `_${identifier}`;
      }
      return identifier || "_";
    };
    function stringify(obj) {
      return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
    }
    function serializeArray(arr, indent3, baseIndent) {
      let output = "[";
      const separator = indent3 ? `
${baseIndent}${indent3}` : "";
      for (let i = 0; i < arr.length; i++) {
        const key = arr[i];
        output += `${i > 0 ? "," : ""}${separator}${serialize(key, indent3, baseIndent + indent3)}`;
      }
      return `${output}${indent3 ? `
${baseIndent}` : ""}]`;
    }
    function serializeObject(obj, indent3, baseIndent) {
      let output = "{";
      const separator = indent3 ? `
${baseIndent}${indent3}` : "";
      const entries = Object.entries(obj);
      for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        const stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);
        output += `${i > 0 ? "," : ""}${separator}${stringKey}:${indent3 ? " " : ""}${serialize(value, indent3, baseIndent + indent3)}`;
      }
      return `${output}${indent3 ? `
${baseIndent}` : ""}}`;
    }
    function serialize(obj, indent3, baseIndent) {
      if (obj === Infinity)
        return "Infinity";
      if (obj === -Infinity)
        return "-Infinity";
      if (obj === 0 && 1 / obj === -Infinity)
        return "-0";
      if (obj instanceof Date)
        return `new Date(${obj.getTime()})`;
      if (obj instanceof RegExp)
        return obj.toString();
      if (obj !== obj)
        return "NaN";
      if (Array.isArray(obj))
        return serializeArray(obj, indent3, baseIndent);
      if (obj === null)
        return "null";
      if (typeof obj === "object")
        return serializeObject(obj, indent3, baseIndent);
      return stringify(obj);
    }
    var dataToEsm = function dataToEsm2(data2, options = {}) {
      const t = options.compact ? "" : "indent" in options ? options.indent : "	";
      const _ = options.compact ? "" : " ";
      const n2 = options.compact ? "" : "\n";
      const declarationType = options.preferConst ? "const" : "var";
      if (options.namedExports === false || typeof data2 !== "object" || Array.isArray(data2) || data2 instanceof Date || data2 instanceof RegExp || data2 === null) {
        const code = serialize(data2, options.compact ? null : t, "");
        const magic = _ || (/^[{[\-\/]/.test(code) ? "" : " ");
        return `export default${magic}${code};`;
      }
      let namedExportCode = "";
      const defaultExportRows = [];
      for (const [key, value] of Object.entries(data2)) {
        if (key === makeLegalIdentifier(key)) {
          if (options.objectShorthand)
            defaultExportRows.push(key);
          else
            defaultExportRows.push(`${key}:${_}${key}`);
          namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, "")};${n2}`;
        } else {
          defaultExportRows.push(`${stringify(key)}:${_}${serialize(value, options.compact ? null : t, "")}`);
        }
      }
      return `${namedExportCode}export default${_}{${n2}${t}${defaultExportRows.join(`,${n2}${t}`)}${n2}};${n2}`;
    };
    var index = {
      addExtension,
      attachScopes,
      createFilter: createFilter3,
      dataToEsm,
      extractAssignedNames: extractAssignedNames3,
      makeLegalIdentifier
    };
    exports.addExtension = addExtension;
    exports.attachScopes = attachScopes;
    exports.createFilter = createFilter3;
    exports.dataToEsm = dataToEsm;
    exports.default = index;
    exports.extractAssignedNames = extractAssignedNames3;
    exports.makeLegalIdentifier = makeLegalIdentifier;
  }
});

// plugins/public/node_modules/commondir/index.js
var require_commondir = __commonJS({
  "plugins/public/node_modules/commondir/index.js"(exports, module2) {
    var path4 = require("path");
    module2.exports = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r) {
          return path4.resolve(basedir, r);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs = file.split(/\/+|\\+/);
        for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
          ;
        return ps.slice(0, i);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
  }
});

// plugins/public/node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "plugins/public/node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs2 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize3 = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync2(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current2;
      var base2;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current2 = m[0];
        base2 = m[0];
        previous = "";
        if (isWindows && !knownHard[base2]) {
          fs2.lstatSync(base2);
          knownHard[base2] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current2;
        current2 += result[0];
        base2 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache && cache[base2] === base2) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
          resolvedLink = cache[base2];
        } else {
          var stat2 = fs2.lstatSync(base2);
          if (!stat2.isSymbolicLink()) {
            knownHard[base2] = true;
            if (cache)
              cache[base2] = base2;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs2.statSync(base2);
            linkTarget = fs2.readlinkSync(base2);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base2] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath2(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current2;
      var base2;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current2 = m[0];
        base2 = m[0];
        previous = "";
        if (isWindows && !knownHard[base2]) {
          fs2.lstat(base2, function(err) {
            if (err)
              return cb(err);
            knownHard[base2] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current2;
        current2 += result[0];
        base2 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache && cache[base2] === base2) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base2)) {
          return gotResolvedLink(cache[base2]);
        }
        return fs2.lstat(base2, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base2] = true;
          if (cache)
            cache[base2] = base2;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base2);
          }
        }
        fs2.stat(base2, function(err2) {
          if (err2)
            return cb(err2);
          fs2.readlink(base2, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base3) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base3] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// plugins/public/node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "plugins/public/node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath2;
    realpath2.realpath = realpath2;
    realpath2.sync = realpathSync2;
    realpath2.realpathSync = realpathSync2;
    realpath2.monkeypatch = monkeypatch;
    realpath2.unmonkeypatch = unmonkeypatch;
    var fs2 = require("fs");
    var origRealpath = fs2.realpath;
    var origRealpathSync = fs2.realpathSync;
    var version3 = process.version;
    var ok = /^v[0-5]\./.test(version3);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath2(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync2(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs2.realpath = realpath2;
      fs2.realpathSync = realpathSync2;
    }
    function unmonkeypatch() {
      fs2.realpath = origRealpath;
      fs2.realpathSync = origRealpathSync;
    }
  }
});

// plugins/public/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "plugins/public/node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray3(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray3 = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// plugins/public/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "plugins/public/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// plugins/public/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "plugins/public/node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n2;
      if (isSequence) {
        n2 = m.body.split(/\.\./);
      } else {
        n2 = parseCommaParts(m.body);
        if (n2.length === 1) {
          n2 = expand(n2[0], false).map(embrace);
          if (n2.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n2[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n2[0]);
        var y = numeric(n2[1]);
        var width = Math.max(n2[0].length, n2[1].length);
        var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n2.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n2, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// plugins/public/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "plugins/public/node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path4 = { sep: "/" };
    try {
      path4 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path4.sep !== "/") {
        pattern = pattern.split(path4.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse4;
    var SUBPARSE = {};
    function parse4(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
        var nl = negativeLists[n2];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path4.sep !== "/") {
        f = f.split(path4.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// plugins/public/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "plugins/public/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// plugins/public/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "plugins/public/node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// plugins/public/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "plugins/public/node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix3(path4) {
      return path4.charAt(0) === "/";
    }
    function win322(path4) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path4);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win322 : posix3;
    module2.exports.posix = posix3;
    module2.exports.win32 = win322;
  }
});

// plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/common.js
var require_common = __commonJS({
  "plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs2 = require("fs");
    var path4 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute2 = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs2;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path4.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path4.resolve(self2.cwd, "/");
      self2.root = path4.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal2 = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal2);
            else
              all[literal2] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path4.join(self2.root, f);
      } else if (isAbsolute2(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path4.resolve(self2.cwd, f);
      } else {
        abs = path4.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path5) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path5) || !!(item.gmatcher && item.gmatcher.match(path5));
      });
    }
    function childrenIgnored(self2, path5) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path5));
      });
    }
  }
});

// plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/sync.js
var require_sync2 = __commonJS({
  "plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path4 = require("path");
    var assert = require("assert");
    var isAbsolute2 = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n2 = this.minimatch.set.length;
      this.matches = new Array(n2);
      for (var i = 0; i < n2; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n2 = 0;
      while (typeof pattern[n2] === "string") {
        n2++;
      }
      var prefix;
      switch (n2) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n2).join("/");
          break;
      }
      var remain = pattern.slice(n2);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute2(prefix) || isAbsolute2(pattern.join("/"))) {
        if (!prefix || !isAbsolute2(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path4.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat2;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path4.join(this.root, prefix);
        } else {
          prefix = path4.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (!stat2) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat2 = this.fs.statSync(abs);
          } catch (er) {
            stat2 = lstat;
          }
        } else {
          stat2 = lstat;
        }
      }
      this.statCache[abs] = stat2;
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// plugins/public/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "plugins/public/node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// plugins/public/node_modules/once/once.js
var require_once = __commonJS({
  "plugins/public/node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// plugins/public/node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "plugins/public/node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice2(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice2(args) {
      var length3 = args.length;
      var array = [];
      for (var i = 0; i < length3; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/glob.js
var require_glob = __commonJS({
  "plugins/public/node_modules/@rollup/plugin-commonjs/node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path4 = require("path");
    var assert = require("assert");
    var isAbsolute2 = require_path_is_absolute();
    var globSync = require_sync2();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend2(origin, add2) {
      if (add2 === null || typeof add2 !== "object") {
        return origin;
      }
      var keys2 = Object.keys(add2);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add2[keys2[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend2({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n2 = this.minimatch.set.length;
      this.matches = new Array(n2);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n2 === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n2; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n2 = this.matches.length;
      if (n2 === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n2 === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n2 = found.length;
      if (n2 === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n2 === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n2 = 0;
      while (typeof pattern[n2] === "string") {
        n2++;
      }
      var prefix;
      switch (n2) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n2).join("/");
          break;
      }
      var remain = pattern.slice(n2);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute2(prefix) || isAbsolute2(pattern.join("/"))) {
        if (!prefix || !isAbsolute2(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path4.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute2(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute2(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path4.join(this.root, prefix);
        } else {
          prefix = path4.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat2 = this.statCache[abs];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat3) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat3, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat2, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat2;
      if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c = true;
      if (stat2)
        c = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat2);
    };
  }
});

// plugins/public/node_modules/estree-walker/dist/umd/estree-walker.js
var require_estree_walker = __commonJS({
  "plugins/public/node_modules/estree-walker/dist/umd/estree-walker.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.estreeWalker = {}));
    })(exports, function(exports2) {
      "use strict";
      class WalkerBase {
        constructor() {
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.context = {
            skip: () => this.should_skip = true,
            remove: () => this.should_remove = true,
            replace: (node) => this.replacement = node
          };
        }
        replace(parent, prop, index, node) {
          if (parent) {
            if (index !== null) {
              parent[prop][index] = node;
            } else {
              parent[prop] = node;
            }
          }
        }
        remove(parent, prop, index) {
          if (parent) {
            if (index !== null) {
              parent[prop].splice(index, 1);
            } else {
              delete parent[prop];
            }
          }
        }
      }
      class SyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      class AsyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        async visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              await this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!await this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                await this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              await this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      function walk(ast, { enter, leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
      }
      async function asyncWalk(ast, { enter, leave }) {
        const instance = new AsyncWalker(enter, leave);
        return await instance.visit(ast, null);
      }
      exports2.asyncWalk = asyncWalk;
      exports2.walk = walk;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// plugins/public/node_modules/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "plugins/public/node_modules/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      var charToInteger2 = {};
      var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      for (var i = 0; i < chars2.length; i++) {
        charToInteger2[chars2.charCodeAt(i)] = i;
      }
      function decode2(mappings) {
        var decoded = [];
        var line = [];
        var segment = [
          0,
          0,
          0,
          0,
          0
        ];
        var j = 0;
        for (var i2 = 0, shift = 0, value = 0; i2 < mappings.length; i2++) {
          var c = mappings.charCodeAt(i2);
          if (c === 44) {
            segmentify2(line, segment, j);
            j = 0;
          } else if (c === 59) {
            segmentify2(line, segment, j);
            j = 0;
            decoded.push(line);
            line = [];
            segment[0] = 0;
          } else {
            var integer = charToInteger2[c];
            if (integer === void 0) {
              throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value += integer << shift;
            if (hasContinuationBit) {
              shift += 5;
            } else {
              var shouldNegate = value & 1;
              value >>>= 1;
              if (shouldNegate) {
                value = value === 0 ? -2147483648 : -value;
              }
              segment[j] += value;
              j++;
              value = shift = 0;
            }
          }
        }
        segmentify2(line, segment, j);
        decoded.push(line);
        return decoded;
      }
      function segmentify2(line, segment, j) {
        if (j === 4)
          line.push([segment[0], segment[1], segment[2], segment[3]]);
        else if (j === 5)
          line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
        else if (j === 1)
          line.push([segment[0]]);
      }
      function encode2(decoded) {
        var sourceFileIndex = 0;
        var sourceCodeLine = 0;
        var sourceCodeColumn = 0;
        var nameIndex = 0;
        var mappings = "";
        for (var i2 = 0; i2 < decoded.length; i2++) {
          var line = decoded[i2];
          if (i2 > 0)
            mappings += ";";
          if (line.length === 0)
            continue;
          var generatedCodeColumn = 0;
          var lineMappings = [];
          for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger2(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
              segmentMappings += encodeInteger2(segment[1] - sourceFileIndex) + encodeInteger2(segment[2] - sourceCodeLine) + encodeInteger2(segment[3] - sourceCodeColumn);
              sourceFileIndex = segment[1];
              sourceCodeLine = segment[2];
              sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
              segmentMappings += encodeInteger2(segment[4] - nameIndex);
              nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
          }
          mappings += lineMappings.join(",");
        }
        return mappings;
      }
      function encodeInteger2(num) {
        var result = "";
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          var clamped = num & 31;
          num >>>= 5;
          if (num > 0) {
            clamped |= 32;
          }
          result += chars2[clamped];
        } while (num > 0);
        return result;
      }
      exports2.decode = decode2;
      exports2.encode = encode2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// plugins/public/node_modules/magic-string/dist/magic-string.cjs.js
var require_magic_string_cjs = __commonJS({
  "plugins/public/node_modules/magic-string/dist/magic-string.cjs.js"(exports, module2) {
    "use strict";
    var sourcemapCodec = require_sourcemap_codec_umd();
    var BitSet3 = function BitSet4(arg) {
      this.bits = arg instanceof BitSet4 ? arg.bits.slice() : [];
    };
    BitSet3.prototype.add = function add2(n3) {
      this.bits[n3 >> 5] |= 1 << (n3 & 31);
    };
    BitSet3.prototype.has = function has2(n3) {
      return !!(this.bits[n3 >> 5] & 1 << (n3 & 31));
    };
    var Chunk3 = function Chunk4(start, end, content) {
      this.start = start;
      this.end = end;
      this.original = content;
      this.intro = "";
      this.outro = "";
      this.content = content;
      this.storeName = false;
      this.edited = false;
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    };
    Chunk3.prototype.appendLeft = function appendLeft3(content) {
      this.outro += content;
    };
    Chunk3.prototype.appendRight = function appendRight3(content) {
      this.intro = this.intro + content;
    };
    Chunk3.prototype.clone = function clone4() {
      var chunk = new Chunk3(this.start, this.end, this.original);
      chunk.intro = this.intro;
      chunk.outro = this.outro;
      chunk.content = this.content;
      chunk.storeName = this.storeName;
      chunk.edited = this.edited;
      return chunk;
    };
    Chunk3.prototype.contains = function contains2(index) {
      return this.start < index && index < this.end;
    };
    Chunk3.prototype.eachNext = function eachNext2(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.next;
      }
    };
    Chunk3.prototype.eachPrevious = function eachPrevious2(fn) {
      var chunk = this;
      while (chunk) {
        fn(chunk);
        chunk = chunk.previous;
      }
    };
    Chunk3.prototype.edit = function edit2(content, storeName, contentOnly) {
      this.content = content;
      if (!contentOnly) {
        this.intro = "";
        this.outro = "";
      }
      this.storeName = storeName;
      this.edited = true;
      return this;
    };
    Chunk3.prototype.prependLeft = function prependLeft3(content) {
      this.outro = content + this.outro;
    };
    Chunk3.prototype.prependRight = function prependRight3(content) {
      this.intro = content + this.intro;
    };
    Chunk3.prototype.split = function split2(index) {
      var sliceIndex = index - this.start;
      var originalBefore = this.original.slice(0, sliceIndex);
      var originalAfter = this.original.slice(sliceIndex);
      this.original = originalBefore;
      var newChunk = new Chunk3(index, this.end, originalAfter);
      newChunk.outro = this.outro;
      this.outro = "";
      this.end = index;
      if (this.edited) {
        newChunk.edit("", false);
        this.content = "";
      } else {
        this.content = originalBefore;
      }
      newChunk.next = this.next;
      if (newChunk.next) {
        newChunk.next.previous = newChunk;
      }
      newChunk.previous = this;
      this.next = newChunk;
      return newChunk;
    };
    Chunk3.prototype.toString = function toString7() {
      return this.intro + this.content + this.outro;
    };
    Chunk3.prototype.trimEnd = function trimEnd4(rx) {
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.start + trimmed.length).edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
      }
    };
    Chunk3.prototype.trimStart = function trimStart4(rx) {
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.end - trimmed.length);
          this.edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
      }
    };
    var btoa2 = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa2 = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    } else if (typeof Buffer === "function") {
      btoa2 = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
      };
    }
    var SourceMap3 = function SourceMap4(properties) {
      this.version = 3;
      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = sourcemapCodec.encode(properties.mappings);
    };
    SourceMap3.prototype.toString = function toString7() {
      return JSON.stringify(this);
    };
    SourceMap3.prototype.toUrl = function toUrl2() {
      return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
    };
    function guessIndent2(code) {
      var lines = code.split("\n");
      var tabbed = lines.filter(function(line) {
        return /^\t+/.test(line);
      });
      var spaced = lines.filter(function(line) {
        return /^ {2,}/.test(line);
      });
      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }
      if (tabbed.length >= spaced.length) {
        return "	";
      }
      var min = spaced.reduce(function(previous, current2) {
        var numSpaces = /^ +/.exec(current2)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);
      return new Array(min + 1).join(" ");
    }
    function getRelativePath2(from, to) {
      var fromParts = from.split(/[/\\]/);
      var toParts = to.split(/[/\\]/);
      fromParts.pop();
      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }
      if (fromParts.length) {
        var i = fromParts.length;
        while (i--) {
          fromParts[i] = "..";
        }
      }
      return fromParts.concat(toParts).join("/");
    }
    var toString6 = Object.prototype.toString;
    function isObject2(thing) {
      return toString6.call(thing) === "[object Object]";
    }
    function getLocator2(source) {
      var originalLines = source.split("\n");
      var lineOffsets = [];
      for (var i = 0, pos = 0; i < originalLines.length; i++) {
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
      }
      return function locate2(index) {
        var i2 = 0;
        var j = lineOffsets.length;
        while (i2 < j) {
          var m = i2 + j >> 1;
          if (index < lineOffsets[m]) {
            j = m;
          } else {
            i2 = m + 1;
          }
        }
        var line = i2 - 1;
        var column = index - lineOffsets[line];
        return { line, column };
      };
    }
    var Mappings3 = function Mappings4(hires) {
      this.hires = hires;
      this.generatedCodeLine = 0;
      this.generatedCodeColumn = 0;
      this.raw = [];
      this.rawSegments = this.raw[this.generatedCodeLine] = [];
      this.pending = null;
    };
    Mappings3.prototype.addEdit = function addEdit2(sourceIndex, content, loc, nameIndex) {
      if (content.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
      } else if (this.pending) {
        this.rawSegments.push(this.pending);
      }
      this.advance(content);
      this.pending = null;
    };
    Mappings3.prototype.addUneditedChunk = function addUneditedChunk2(sourceIndex, chunk, original, loc, sourcemapLocations) {
      var originalCharIndex = chunk.start;
      var first = true;
      while (originalCharIndex < chunk.end) {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === "\n") {
          loc.line += 1;
          loc.column = 0;
          this.generatedCodeLine += 1;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
          first = true;
        } else {
          loc.column += 1;
          this.generatedCodeColumn += 1;
          first = false;
        }
        originalCharIndex += 1;
      }
      this.pending = null;
    };
    Mappings3.prototype.advance = function advance3(str) {
      if (!str) {
        return;
      }
      var lines = str.split("\n");
      if (lines.length > 1) {
        for (var i = 0; i < lines.length - 1; i++) {
          this.generatedCodeLine++;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    var n2 = "\n";
    var warned2 = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    var MagicString3 = function MagicString4(string, options) {
      if (options === void 0)
        options = {};
      var chunk = new Chunk3(0, string.length, string);
      Object.defineProperties(this, {
        original: { writable: true, value: string },
        outro: { writable: true, value: "" },
        intro: { writable: true, value: "" },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options.filename },
        indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: new BitSet3() },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent2(string) }
      });
      this.byStart[0] = chunk;
      this.byEnd[string.length] = chunk;
    };
    MagicString3.prototype.addSourcemapLocation = function addSourcemapLocation2(char) {
      this.sourcemapLocations.add(char);
    };
    MagicString3.prototype.append = function append3(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.outro += content;
      return this;
    };
    MagicString3.prototype.appendLeft = function appendLeft3(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.appendLeft(content);
      } else {
        this.intro += content;
      }
      return this;
    };
    MagicString3.prototype.appendRight = function appendRight3(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.appendRight(content);
      } else {
        this.outro += content;
      }
      return this;
    };
    MagicString3.prototype.clone = function clone4() {
      var cloned = new MagicString3(this.original, { filename: this.filename });
      var originalChunk = this.firstChunk;
      var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
      while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
          clonedChunk.next = nextClonedChunk;
          nextClonedChunk.previous = clonedChunk;
          clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
      }
      cloned.lastChunk = clonedChunk;
      if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
      }
      cloned.sourcemapLocations = new BitSet3(this.sourcemapLocations);
      cloned.intro = this.intro;
      cloned.outro = this.outro;
      return cloned;
    };
    MagicString3.prototype.generateDecodedMap = function generateDecodedMap3(options) {
      var this$1$1 = this;
      options = options || {};
      var sourceIndex = 0;
      var names = Object.keys(this.storedNames);
      var mappings = new Mappings3(options.hires);
      var locate2 = getLocator2(this.original);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.firstChunk.eachNext(function(chunk) {
        var loc = locate2(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
          mappings.addEdit(
            sourceIndex,
            chunk.content,
            loc,
            chunk.storeName ? names.indexOf(chunk.original) : -1
          );
        } else {
          mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: [options.source ? getRelativePath2(options.file || "", options.source) : null],
        sourcesContent: options.includeContent ? [this.original] : [null],
        names,
        mappings: mappings.raw
      };
    };
    MagicString3.prototype.generateMap = function generateMap3(options) {
      return new SourceMap3(this.generateDecodedMap(options));
    };
    MagicString3.prototype.getIndentString = function getIndentString4() {
      return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString3.prototype.indent = function indent3(indentStr, options) {
      var pattern = /^[^\r\n]/gm;
      if (isObject2(indentStr)) {
        options = indentStr;
        indentStr = void 0;
      }
      indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
      if (indentStr === "") {
        return this;
      }
      options = options || {};
      var isExcluded = {};
      if (options.exclude) {
        var exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
        exclusions.forEach(function(exclusion) {
          for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
            isExcluded[i] = true;
          }
        });
      }
      var shouldIndentNextCharacter = options.indentStart !== false;
      var replacer = function(match) {
        if (shouldIndentNextCharacter) {
          return "" + indentStr + match;
        }
        shouldIndentNextCharacter = true;
        return match;
      };
      this.intro = this.intro.replace(pattern, replacer);
      var charIndex = 0;
      var chunk = this.firstChunk;
      while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
          if (!isExcluded[charIndex]) {
            chunk.content = chunk.content.replace(pattern, replacer);
            if (chunk.content.length) {
              shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
            }
          }
        } else {
          charIndex = chunk.start;
          while (charIndex < end) {
            if (!isExcluded[charIndex]) {
              var char = this.original[charIndex];
              if (char === "\n") {
                shouldIndentNextCharacter = true;
              } else if (char !== "\r" && shouldIndentNextCharacter) {
                shouldIndentNextCharacter = false;
                if (charIndex === chunk.start) {
                  chunk.prependRight(indentStr);
                } else {
                  this._splitChunk(chunk, charIndex);
                  chunk = chunk.next;
                  chunk.prependRight(indentStr);
                }
              }
            }
            charIndex += 1;
          }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
      }
      this.outro = this.outro.replace(pattern, replacer);
      return this;
    };
    MagicString3.prototype.insert = function insert2() {
      throw new Error(
        "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
      );
    };
    MagicString3.prototype.insertLeft = function insertLeft2(index, content) {
      if (!warned2.insertLeft) {
        console.warn(
          "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
        );
        warned2.insertLeft = true;
      }
      return this.appendLeft(index, content);
    };
    MagicString3.prototype.insertRight = function insertRight2(index, content) {
      if (!warned2.insertRight) {
        console.warn(
          "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
        );
        warned2.insertRight = true;
      }
      return this.prependRight(index, content);
    };
    MagicString3.prototype.move = function move2(start, end, index) {
      if (index >= start && index <= end) {
        throw new Error("Cannot move a selection inside itself");
      }
      this._split(start);
      this._split(end);
      this._split(index);
      var first = this.byStart[start];
      var last = this.byEnd[end];
      var oldLeft = first.previous;
      var oldRight = last.next;
      var newRight = this.byStart[index];
      if (!newRight && last === this.lastChunk) {
        return this;
      }
      var newLeft = newRight ? newRight.previous : this.lastChunk;
      if (oldLeft) {
        oldLeft.next = oldRight;
      }
      if (oldRight) {
        oldRight.previous = oldLeft;
      }
      if (newLeft) {
        newLeft.next = first;
      }
      if (newRight) {
        newRight.previous = last;
      }
      if (!first.previous) {
        this.firstChunk = last.next;
      }
      if (!last.next) {
        this.lastChunk = first.previous;
        this.lastChunk.next = null;
      }
      first.previous = newLeft;
      last.next = newRight || null;
      if (!newLeft) {
        this.firstChunk = first;
      }
      if (!newRight) {
        this.lastChunk = last;
      }
      return this;
    };
    MagicString3.prototype.overwrite = function overwrite2(start, end, content, options) {
      if (typeof content !== "string") {
        throw new TypeError("replacement content must be a string");
      }
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (end > this.original.length) {
        throw new Error("end is out of bounds");
      }
      if (start === end) {
        throw new Error(
          "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
        );
      }
      this._split(start);
      this._split(end);
      if (options === true) {
        if (!warned2.storeName) {
          console.warn(
            "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
          );
          warned2.storeName = true;
        }
        options = { storeName: true };
      }
      var storeName = options !== void 0 ? options.storeName : false;
      var contentOnly = options !== void 0 ? options.contentOnly : false;
      if (storeName) {
        var original = this.original.slice(start, end);
        Object.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });
      }
      var first = this.byStart[start];
      var last = this.byEnd[end];
      if (first) {
        var chunk = first;
        while (chunk !== last) {
          if (chunk.next !== this.byStart[chunk.end]) {
            throw new Error("Cannot overwrite across a split point");
          }
          chunk = chunk.next;
          chunk.edit("", false);
        }
        first.edit(content, storeName, contentOnly);
      } else {
        var newChunk = new Chunk3(start, end, "").edit(content, storeName);
        last.next = newChunk;
        newChunk.previous = last;
      }
      return this;
    };
    MagicString3.prototype.prepend = function prepend3(content) {
      if (typeof content !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.intro = content + this.intro;
      return this;
    };
    MagicString3.prototype.prependLeft = function prependLeft3(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byEnd[index];
      if (chunk) {
        chunk.prependLeft(content);
      } else {
        this.intro = content + this.intro;
      }
      return this;
    };
    MagicString3.prototype.prependRight = function prependRight3(index, content) {
      if (typeof content !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index);
      var chunk = this.byStart[index];
      if (chunk) {
        chunk.prependRight(content);
      } else {
        this.outro = content + this.outro;
      }
      return this;
    };
    MagicString3.prototype.remove = function remove2(start, end) {
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (start === end) {
        return this;
      }
      if (start < 0 || end > this.original.length) {
        throw new Error("Character is out of bounds");
      }
      if (start > end) {
        throw new Error("end must be greater than start");
      }
      this._split(start);
      this._split(end);
      var chunk = this.byStart[start];
      while (chunk) {
        chunk.intro = "";
        chunk.outro = "";
        chunk.edit("");
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
      }
      return this;
    };
    MagicString3.prototype.lastChar = function lastChar2() {
      if (this.outro.length) {
        return this.outro[this.outro.length - 1];
      }
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length) {
          return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
          return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
          return chunk.intro[chunk.intro.length - 1];
        }
      } while (chunk = chunk.previous);
      if (this.intro.length) {
        return this.intro[this.intro.length - 1];
      }
      return "";
    };
    MagicString3.prototype.lastLine = function lastLine2() {
      var lineIndex = this.outro.lastIndexOf(n2);
      if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
      }
      var lineStr = this.outro;
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length > 0) {
          lineIndex = chunk.outro.lastIndexOf(n2);
          if (lineIndex !== -1) {
            return chunk.outro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
          lineIndex = chunk.content.lastIndexOf(n2);
          if (lineIndex !== -1) {
            return chunk.content.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
          lineIndex = chunk.intro.lastIndexOf(n2);
          if (lineIndex !== -1) {
            return chunk.intro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.intro + lineStr;
        }
      } while (chunk = chunk.previous);
      lineIndex = this.intro.lastIndexOf(n2);
      if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
      }
      return this.intro + lineStr;
    };
    MagicString3.prototype.slice = function slice2(start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = this.original.length;
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      var result = "";
      var chunk = this.firstChunk;
      while (chunk && (chunk.start > start || chunk.end <= start)) {
        if (chunk.start < end && chunk.end >= end) {
          return result;
        }
        chunk = chunk.next;
      }
      if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
      }
      var startChunk = chunk;
      while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
          result += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
          throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
          result += chunk.outro;
        }
        if (containsEnd) {
          break;
        }
        chunk = chunk.next;
      }
      return result;
    };
    MagicString3.prototype.snip = function snip2(start, end) {
      var clone4 = this.clone();
      clone4.remove(0, start);
      clone4.remove(end, clone4.original.length);
      return clone4;
    };
    MagicString3.prototype._split = function _split2(index) {
      if (this.byStart[index] || this.byEnd[index]) {
        return;
      }
      var chunk = this.lastSearchedChunk;
      var searchForward = index > chunk.end;
      while (chunk) {
        if (chunk.contains(index)) {
          return this._splitChunk(chunk, index);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      }
    };
    MagicString3.prototype._splitChunk = function _splitChunk2(chunk, index) {
      if (chunk.edited && chunk.content.length) {
        var loc = getLocator2(this.original)(index);
        throw new Error(
          "Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")'
        );
      }
      var newChunk = chunk.split(index);
      this.byEnd[index] = chunk;
      this.byStart[index] = newChunk;
      this.byEnd[newChunk.end] = newChunk;
      if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
      }
      this.lastSearchedChunk = chunk;
      return true;
    };
    MagicString3.prototype.toString = function toString7() {
      var str = this.intro;
      var chunk = this.firstChunk;
      while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
      }
      return str + this.outro;
    };
    MagicString3.prototype.isEmpty = function isEmpty3() {
      var chunk = this.firstChunk;
      do {
        if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
          return false;
        }
      } while (chunk = chunk.next);
      return true;
    };
    MagicString3.prototype.length = function length3() {
      var chunk = this.firstChunk;
      var length4 = 0;
      do {
        length4 += chunk.intro.length + chunk.content.length + chunk.outro.length;
      } while (chunk = chunk.next);
      return length4;
    };
    MagicString3.prototype.trimLines = function trimLines3() {
      return this.trim("[\\r\\n]");
    };
    MagicString3.prototype.trim = function trim3(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    MagicString3.prototype.trimEndAborted = function trimEndAborted2(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var chunk = this.lastChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        if (chunk.end !== end) {
          if (this.lastChunk === chunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.previous;
      } while (chunk);
      return false;
    };
    MagicString3.prototype.trimEnd = function trimEnd4(charType) {
      this.trimEndAborted(charType);
      return this;
    };
    MagicString3.prototype.trimStartAborted = function trimStartAborted2(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var chunk = this.firstChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
          if (chunk === this.lastChunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.next;
      } while (chunk);
      return false;
    };
    MagicString3.prototype.trimStart = function trimStart4(charType) {
      this.trimStartAborted(charType);
      return this;
    };
    var hasOwnProp2 = Object.prototype.hasOwnProperty;
    var Bundle3 = function Bundle4(options) {
      if (options === void 0)
        options = {};
      this.intro = options.intro || "";
      this.separator = options.separator !== void 0 ? options.separator : "\n";
      this.sources = [];
      this.uniqueSources = [];
      this.uniqueSourceIndexByFilename = {};
    };
    Bundle3.prototype.addSource = function addSource2(source) {
      if (source instanceof MagicString3) {
        return this.addSource({
          content: source,
          filename: source.filename,
          separator: this.separator
        });
      }
      if (!isObject2(source) || !source.content) {
        throw new Error(
          "bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`"
        );
      }
      ["filename", "indentExclusionRanges", "separator"].forEach(function(option) {
        if (!hasOwnProp2.call(source, option)) {
          source[option] = source.content[option];
        }
      });
      if (source.separator === void 0) {
        source.separator = this.separator;
      }
      if (source.filename) {
        if (!hasOwnProp2.call(this.uniqueSourceIndexByFilename, source.filename)) {
          this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
          this.uniqueSources.push({ filename: source.filename, content: source.content.original });
        } else {
          var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
          if (source.content.original !== uniqueSource.content) {
            throw new Error("Illegal source: same filename (" + source.filename + "), different contents");
          }
        }
      }
      this.sources.push(source);
      return this;
    };
    Bundle3.prototype.append = function append3(str, options) {
      this.addSource({
        content: new MagicString3(str),
        separator: options && options.separator || ""
      });
      return this;
    };
    Bundle3.prototype.clone = function clone4() {
      var bundle = new Bundle3({
        intro: this.intro,
        separator: this.separator
      });
      this.sources.forEach(function(source) {
        bundle.addSource({
          filename: source.filename,
          content: source.content.clone(),
          separator: source.separator
        });
      });
      return bundle;
    };
    Bundle3.prototype.generateDecodedMap = function generateDecodedMap3(options) {
      var this$1$1 = this;
      if (options === void 0)
        options = {};
      var names = [];
      this.sources.forEach(function(source) {
        Object.keys(source.content.storedNames).forEach(function(name) {
          if (!~names.indexOf(name)) {
            names.push(name);
          }
        });
      });
      var mappings = new Mappings3(options.hires);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.sources.forEach(function(source, i) {
        if (i > 0) {
          mappings.advance(this$1$1.separator);
        }
        var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
        var magicString = source.content;
        var locate2 = getLocator2(magicString.original);
        if (magicString.intro) {
          mappings.advance(magicString.intro);
        }
        magicString.firstChunk.eachNext(function(chunk) {
          var loc = locate2(chunk.start);
          if (chunk.intro.length) {
            mappings.advance(chunk.intro);
          }
          if (source.filename) {
            if (chunk.edited) {
              mappings.addEdit(
                sourceIndex,
                chunk.content,
                loc,
                chunk.storeName ? names.indexOf(chunk.original) : -1
              );
            } else {
              mappings.addUneditedChunk(
                sourceIndex,
                chunk,
                magicString.original,
                loc,
                magicString.sourcemapLocations
              );
            }
          } else {
            mappings.advance(chunk.content);
          }
          if (chunk.outro.length) {
            mappings.advance(chunk.outro);
          }
        });
        if (magicString.outro) {
          mappings.advance(magicString.outro);
        }
      });
      return {
        file: options.file ? options.file.split(/[/\\]/).pop() : null,
        sources: this.uniqueSources.map(function(source) {
          return options.file ? getRelativePath2(options.file, source.filename) : source.filename;
        }),
        sourcesContent: this.uniqueSources.map(function(source) {
          return options.includeContent ? source.content : null;
        }),
        names,
        mappings: mappings.raw
      };
    };
    Bundle3.prototype.generateMap = function generateMap3(options) {
      return new SourceMap3(this.generateDecodedMap(options));
    };
    Bundle3.prototype.getIndentString = function getIndentString4() {
      var indentStringCounts = {};
      this.sources.forEach(function(source) {
        var indentStr = source.content.indentStr;
        if (indentStr === null) {
          return;
        }
        if (!indentStringCounts[indentStr]) {
          indentStringCounts[indentStr] = 0;
        }
        indentStringCounts[indentStr] += 1;
      });
      return Object.keys(indentStringCounts).sort(function(a, b) {
        return indentStringCounts[a] - indentStringCounts[b];
      })[0] || "	";
    };
    Bundle3.prototype.indent = function indent3(indentStr) {
      var this$1$1 = this;
      if (!arguments.length) {
        indentStr = this.getIndentString();
      }
      if (indentStr === "") {
        return this;
      }
      var trailingNewline = !this.intro || this.intro.slice(-1) === "\n";
      this.sources.forEach(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
        var indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
        source.content.indent(indentStr, {
          exclude: source.indentExclusionRanges,
          indentStart
        });
        trailingNewline = source.content.lastChar() === "\n";
      });
      if (this.intro) {
        this.intro = indentStr + this.intro.replace(/^[^\n]/gm, function(match, index) {
          return index > 0 ? indentStr + match : match;
        });
      }
      return this;
    };
    Bundle3.prototype.prepend = function prepend3(str) {
      this.intro = str + this.intro;
      return this;
    };
    Bundle3.prototype.toString = function toString7() {
      var this$1$1 = this;
      var body = this.sources.map(function(source, i) {
        var separator = source.separator !== void 0 ? source.separator : this$1$1.separator;
        var str = (i > 0 ? separator : "") + source.content.toString();
        return str;
      }).join("");
      return this.intro + body;
    };
    Bundle3.prototype.isEmpty = function isEmpty3() {
      if (this.intro.length && this.intro.trim()) {
        return false;
      }
      if (this.sources.some(function(source) {
        return !source.content.isEmpty();
      })) {
        return false;
      }
      return true;
    };
    Bundle3.prototype.length = function length3() {
      return this.sources.reduce(
        function(length4, source) {
          return length4 + source.content.length();
        },
        this.intro.length
      );
    };
    Bundle3.prototype.trimLines = function trimLines3() {
      return this.trim("[\\r\\n]");
    };
    Bundle3.prototype.trim = function trim3(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    Bundle3.prototype.trimStart = function trimStart4(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (!this.intro) {
        var source;
        var i = 0;
        do {
          source = this.sources[i++];
          if (!source) {
            break;
          }
        } while (!source.content.trimStartAborted(charType));
      }
      return this;
    };
    Bundle3.prototype.trimEnd = function trimEnd4(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      var source;
      var i = this.sources.length - 1;
      do {
        source = this.sources[i--];
        if (!source) {
          this.intro = this.intro.replace(rx, "");
          break;
        }
      } while (!source.content.trimEndAborted(charType));
      return this;
    };
    MagicString3.Bundle = Bundle3;
    MagicString3.SourceMap = SourceMap3;
    MagicString3.default = MagicString3;
    module2.exports = MagicString3;
  }
});

// plugins/public/node_modules/is-reference/dist/is-reference.js
var require_is_reference = __commonJS({
  "plugins/public/node_modules/is-reference/dist/is-reference.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.isReference = factory());
    })(exports, function() {
      "use strict";
      function isReference(node, parent) {
        if (node.type === "MemberExpression") {
          return !node.computed && isReference(node.object, node);
        }
        if (node.type === "Identifier") {
          if (!parent)
            return true;
          switch (parent.type) {
            case "MemberExpression":
              return parent.computed || node === parent.object;
            case "MethodDefinition":
              return parent.computed;
            case "FieldDefinition":
              return parent.computed || node === parent.value;
            case "Property":
              return parent.computed || node === parent.value;
            case "ExportSpecifier":
            case "ImportSpecifier":
              return node === parent.local;
            case "LabeledStatement":
            case "BreakStatement":
            case "ContinueStatement":
              return false;
            default:
              return true;
          }
        }
        return false;
      }
      return isReference;
    });
  }
});

// plugins/public/node_modules/@rollup/plugin-commonjs/dist/index.js
var require_dist = __commonJS({
  "plugins/public/node_modules/@rollup/plugin-commonjs/dist/index.js"(exports, module2) {
    "use strict";
    var path4 = require("path");
    var pluginutils = require_cjs2();
    var getCommonDir = require_commondir();
    var fs2 = require("fs");
    var glob = require_glob();
    var estreeWalker = require_estree_walker();
    var MagicString3 = require_magic_string_cjs();
    var isReference = require_is_reference();
    var resolve4 = require_resolve();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var getCommonDir__default = /* @__PURE__ */ _interopDefaultLegacy(getCommonDir);
    var glob__default = /* @__PURE__ */ _interopDefaultLegacy(glob);
    var MagicString__default = /* @__PURE__ */ _interopDefaultLegacy(MagicString3);
    var isReference__default = /* @__PURE__ */ _interopDefaultLegacy(isReference);
    var peerDependencies = {
      rollup: "^2.38.3"
    };
    function tryParse(parse4, code, id) {
      try {
        return parse4(code, { allowReturnOutsideFunction: true });
      } catch (err) {
        err.message += ` in ${id}`;
        throw err;
      }
    }
    var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
    var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
    function hasCjsKeywords(code, ignoreGlobal) {
      const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
      return firstpass.test(code);
    }
    function analyzeTopLevelStatements(parse4, code, id) {
      const ast = tryParse(parse4, code, id);
      let isEsModule = false;
      let hasDefaultExport = false;
      let hasNamedExports = false;
      for (const node of ast.body) {
        switch (node.type) {
          case "ExportDefaultDeclaration":
            isEsModule = true;
            hasDefaultExport = true;
            break;
          case "ExportNamedDeclaration":
            isEsModule = true;
            if (node.declaration) {
              hasNamedExports = true;
            } else {
              for (const specifier of node.specifiers) {
                if (specifier.exported.name === "default") {
                  hasDefaultExport = true;
                } else {
                  hasNamedExports = true;
                }
              }
            }
            break;
          case "ExportAllDeclaration":
            isEsModule = true;
            if (node.exported && node.exported.name === "default") {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
            break;
          case "ImportDeclaration":
            isEsModule = true;
            break;
        }
      }
      return { isEsModule, hasDefaultExport, hasNamedExports, ast };
    }
    var isWrappedId = (id, suffix) => id.endsWith(suffix);
    var wrapId = (id, suffix) => `\0${id}${suffix}`;
    var unwrapId = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
    var PROXY_SUFFIX = "?commonjs-proxy";
    var REQUIRE_SUFFIX = "?commonjs-require";
    var EXTERNAL_SUFFIX = "?commonjs-external";
    var EXPORTS_SUFFIX = "?commonjs-exports";
    var MODULE_SUFFIX = "?commonjs-module";
    var DYNAMIC_REGISTER_SUFFIX = "?commonjs-dynamic-register";
    var DYNAMIC_JSON_PREFIX = "\0commonjs-dynamic-json:";
    var DYNAMIC_PACKAGES_ID = "\0commonjs-dynamic-packages";
    var HELPERS_ID = "\0commonjsHelpers.js";
    var HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
    var FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
    var HELPER_NON_DYNAMIC = `
export function commonjsRequire (path) {
	${FAILED_REQUIRE_ERROR}
}
`;
    var getDynamicHelpers = (ignoreDynamicRequires) => `
export function createModule(modulePath) {
	return {
		path: modulePath,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, base == null ? modulePath : base);
		}
	};
}

export function commonjsRegister (path, loader) {
	DYNAMIC_REQUIRE_LOADERS[path] = loader;
}

export function commonjsRegisterOrShort (path, to) {
	var resolvedPath = commonjsResolveImpl(path, null, true);
	if (resolvedPath !== null && DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
	  DYNAMIC_REQUIRE_CACHE[path] = DYNAMIC_REQUIRE_CACHE[resolvedPath];
	} else {
	  DYNAMIC_REQUIRE_SHORTS[path] = to;
	}
}

var DYNAMIC_REQUIRE_LOADERS = Object.create(null);
var DYNAMIC_REQUIRE_CACHE = Object.create(null);
var DYNAMIC_REQUIRE_SHORTS = Object.create(null);
var DEFAULT_PARENT_MODULE = {
	id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
};
var CHECKED_EXTENSIONS = ['', '.js', '.json'];

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/')
	  path = '/' + path;
	else if (path.length === 0)
	  path = '.';
	return path;
}

function join () {
	if (arguments.length === 0)
	  return '.';
	var joined;
	for (var i = 0; i < arguments.length; ++i) {
	  var arg = arguments[i];
	  if (arg.length > 0) {
		if (joined === undefined)
		  joined = arg;
		else
		  joined += '/' + arg;
	  }
	}
	if (joined === undefined)
	  return '.';

	return joined;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\'))
		return false;
	return true;
}

function dirname (path) {
  if (path.length === 0)
    return '.';

  var i = path.length - 1;
  while (i > 0) {
    var c = path.charCodeAt(i);
    if ((c === 47 || c === 92) && i !== path.length - 1)
      break;
    i--;
  }

  if (i > 0)
    return path.substr(0, i);

  if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
    return path.charAt(0);

  return '.';
}

export function commonjsResolveImpl (path, originalModuleDir, testCache) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '/';
	}
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = originalModuleDir ? normalize(originalModuleDir + '/' + path) : path;
		} else if (originalModuleDir) {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		} else {
			relPath = normalize(join('node_modules', path));
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
			var resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
			if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
				return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_SHORTS[resolvedPath]) {
			  return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

export function commonjsResolve (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir);
	if (resolvedPath !== null) {
		return resolvedPath;
	}
	return require.resolve(path);
}

export function commonjsRequire (path, originalModuleDir) {
	var resolvedPath = commonjsResolveImpl(path, originalModuleDir, true);
	if (resolvedPath !== null) {
    var cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
    if (cachedModule) return cachedModule.exports;
    var shortTo = DYNAMIC_REQUIRE_SHORTS[resolvedPath];
    if (shortTo) {
      cachedModule = DYNAMIC_REQUIRE_CACHE[shortTo];
      if (cachedModule)
        return cachedModule.exports;
      resolvedPath = commonjsResolveImpl(shortTo, null, true);
    }
    var loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
    if (loader) {
      DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
        id: resolvedPath,
        filename: resolvedPath,
        path: dirname(resolvedPath),
        exports: {},
        parent: DEFAULT_PARENT_MODULE,
        loaded: false,
        children: [],
        paths: [],
        require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
        }
      };
      try {
        loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
      } catch (error) {
        delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
        throw error;
      }
      cachedModule.loaded = true;
      return cachedModule.exports;
    };
	}
	${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
}

commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
commonjsRequire.resolve = commonjsResolve;
`;
    function getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires) {
      return `${HELPERS}${isDynamicRequireModulesEnabled ? getDynamicHelpers(ignoreDynamicRequires) : HELPER_NON_DYNAMIC}`;
    }
    function deconflict(scopes, globals, identifier) {
      let i = 1;
      let deconflicted = pluginutils.makeLegalIdentifier(identifier);
      const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
      while (hasConflicts()) {
        deconflicted = pluginutils.makeLegalIdentifier(`${identifier}_${i}`);
        i += 1;
      }
      for (const scope of scopes) {
        scope.declarations[deconflicted] = true;
      }
      return deconflicted;
    }
    function getName(id) {
      const name = pluginutils.makeLegalIdentifier(path4.basename(id, path4.extname(id)));
      if (name !== "index") {
        return name;
      }
      return pluginutils.makeLegalIdentifier(path4.basename(path4.dirname(id)));
    }
    function normalizePathSlashes(path5) {
      return path5.replace(/\\/g, "/");
    }
    var VIRTUAL_PATH_BASE = "/$$rollup_base$$";
    var getVirtualPathForDynamicRequirePath = (path5, commonDir) => {
      const normalizedPath = normalizePathSlashes(path5);
      return normalizedPath.startsWith(commonDir) ? VIRTUAL_PATH_BASE + normalizedPath.slice(commonDir.length) : normalizedPath;
    };
    function getPackageEntryPoint(dirPath) {
      let entryPoint = "index.js";
      try {
        if (fs2.existsSync(path4.join(dirPath, "package.json"))) {
          entryPoint = JSON.parse(fs2.readFileSync(path4.join(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
        }
      } catch (ignored) {
      }
      return entryPoint;
    }
    function getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir) {
      let code = `const commonjsRegisterOrShort = require('${HELPERS_ID}?commonjsRegisterOrShort');`;
      for (const dir of dynamicRequireModuleDirPaths) {
        const entryPoint = getPackageEntryPoint(dir);
        code += `
commonjsRegisterOrShort(${JSON.stringify(
          getVirtualPathForDynamicRequirePath(dir, commonDir)
        )}, ${JSON.stringify(getVirtualPathForDynamicRequirePath(path4.join(dir, entryPoint), commonDir))});`;
      }
      return code;
    }
    function getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) {
      let dynamicImports = Array.from(
        dynamicRequireModuleSet,
        (dynamicId) => `require(${JSON.stringify(wrapId(dynamicId, DYNAMIC_REGISTER_SUFFIX))});`
      ).join("\n");
      if (dynamicRequireModuleDirPaths.length) {
        dynamicImports += `require(${JSON.stringify(
          wrapId(DYNAMIC_PACKAGES_ID, DYNAMIC_REGISTER_SUFFIX)
        )});`;
      }
      return dynamicImports;
    }
    function isDynamicModuleImport(id, dynamicRequireModuleSet) {
      const normalizedPath = normalizePathSlashes(id);
      return dynamicRequireModuleSet.has(normalizedPath) && !normalizedPath.endsWith(".json");
    }
    function isDirectory(path5) {
      try {
        if (fs2.statSync(path5).isDirectory())
          return true;
      } catch (ignored) {
      }
      return false;
    }
    function getDynamicRequirePaths(patterns) {
      const dynamicRequireModuleSet = /* @__PURE__ */ new Set();
      for (const pattern of !patterns || Array.isArray(patterns) ? patterns || [] : [patterns]) {
        const isNegated = pattern.startsWith("!");
        const modifySet = Set.prototype[isNegated ? "delete" : "add"].bind(dynamicRequireModuleSet);
        for (const path$12 of glob__default["default"].sync(isNegated ? pattern.substr(1) : pattern)) {
          modifySet(normalizePathSlashes(path4.resolve(path$12)));
          if (isDirectory(path$12)) {
            modifySet(normalizePathSlashes(path4.resolve(path4.join(path$12, getPackageEntryPoint(path$12)))));
          }
        }
      }
      const dynamicRequireModuleDirPaths = Array.from(dynamicRequireModuleSet.values()).filter(
        (path5) => isDirectory(path5)
      );
      return { dynamicRequireModuleSet, dynamicRequireModuleDirPaths };
    }
    function getCommonJSMetaPromise(commonJSMetaPromises, id) {
      let commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise)
        return commonJSMetaPromise.promise;
      const promise = new Promise((resolve5) => {
        commonJSMetaPromise = {
          resolve: resolve5,
          promise: null
        };
        commonJSMetaPromises.set(id, commonJSMetaPromise);
      });
      commonJSMetaPromise.promise = promise;
      return promise;
    }
    function setCommonJSMetaPromise(commonJSMetaPromises, id, commonjsMeta) {
      const commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise) {
        if (commonJSMetaPromise.resolve) {
          commonJSMetaPromise.resolve(commonjsMeta);
          commonJSMetaPromise.resolve = null;
        }
      } else {
        commonJSMetaPromises.set(id, { promise: Promise.resolve(commonjsMeta), resolve: null });
      }
    }
    function getSpecificHelperProxy(id) {
      return `export {${id.split("?")[1]} as default} from "${HELPERS_ID}";`;
    }
    function getUnknownRequireProxy(id, requireReturnsDefault) {
      if (requireReturnsDefault === true || id.endsWith(".json")) {
        return `export {default} from ${JSON.stringify(id)};`;
      }
      const name = getName(id);
      const exported = requireReturnsDefault === "auto" ? `import {getDefaultExportFromNamespaceIfNotNamed} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});` : requireReturnsDefault === "preferred" ? `import {getDefaultExportFromNamespaceIfPresent} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});` : !requireReturnsDefault ? `import {getAugmentedNamespace} from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});` : `export default ${name};`;
      return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
    }
    function getDynamicJsonProxy(id, commonDir) {
      const normalizedPath = normalizePathSlashes(id.slice(DYNAMIC_JSON_PREFIX.length));
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(
        getVirtualPathForDynamicRequirePath(normalizedPath, commonDir)
      )}, function (module, exports) {
  module.exports = require(${JSON.stringify(normalizedPath)});
});`;
    }
    function getDynamicRequireProxy(normalizedPath, commonDir) {
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(
        getVirtualPathForDynamicRequirePath(normalizedPath, commonDir)
      )}, function (module, exports) {
  ${fs2.readFileSync(normalizedPath, { encoding: "utf8" })}
});`;
    }
    async function getStaticRequireProxy(id, requireReturnsDefault, esModulesWithDefaultExport, esModulesWithNamedExports, commonJsMetaPromises) {
      const name = getName(id);
      const commonjsMeta = await getCommonJSMetaPromise(commonJsMetaPromises, id);
      if (commonjsMeta && commonjsMeta.isCommonJS) {
        return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
      } else if (commonjsMeta === null) {
        return getUnknownRequireProxy(id, requireReturnsDefault);
      } else if (!requireReturnsDefault) {
        return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(
          id
        )}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
      } else if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !esModulesWithDefaultExport.has(id) || requireReturnsDefault === "auto" && esModulesWithNamedExports.has(id))) {
        return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
      }
      return `export { default } from ${JSON.stringify(id)};`;
    }
    function getCandidatesForExtension(resolved, extension) {
      return [resolved + extension, `${resolved}${path4.sep}index${extension}`];
    }
    function getCandidates(resolved, extensions) {
      return extensions.reduce(
        (paths, extension) => paths.concat(getCandidatesForExtension(resolved, extension)),
        [resolved]
      );
    }
    function getResolveId(extensions) {
      function resolveExtensions(importee, importer) {
        if (importee[0] !== "." || !importer)
          return void 0;
        const resolved = path4.resolve(path4.dirname(importer), importee);
        const candidates = getCandidates(resolved, extensions);
        for (let i = 0; i < candidates.length; i += 1) {
          try {
            const stats = fs2.statSync(candidates[i]);
            if (stats.isFile())
              return { id: candidates[i] };
          } catch (err) {
          }
        }
        return void 0;
      }
      return function resolveId2(importee, rawImporter, resolveOptions) {
        if (isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX)) {
          return importee;
        }
        const importer = rawImporter && isWrappedId(rawImporter, DYNAMIC_REGISTER_SUFFIX) ? unwrapId(rawImporter, DYNAMIC_REGISTER_SUFFIX) : rawImporter;
        if (importer && isWrappedId(importer, PROXY_SUFFIX)) {
          return importee;
        }
        const isProxyModule = isWrappedId(importee, PROXY_SUFFIX);
        const isRequiredModule = isWrappedId(importee, REQUIRE_SUFFIX);
        let isModuleRegistration = false;
        if (isProxyModule) {
          importee = unwrapId(importee, PROXY_SUFFIX);
        } else if (isRequiredModule) {
          importee = unwrapId(importee, REQUIRE_SUFFIX);
          isModuleRegistration = isWrappedId(importee, DYNAMIC_REGISTER_SUFFIX);
          if (isModuleRegistration) {
            importee = unwrapId(importee, DYNAMIC_REGISTER_SUFFIX);
          }
        }
        if (importee.startsWith(HELPERS_ID) || importee === DYNAMIC_PACKAGES_ID || importee.startsWith(DYNAMIC_JSON_PREFIX)) {
          return importee;
        }
        if (importee.startsWith("\0")) {
          return null;
        }
        return this.resolve(
          importee,
          importer,
          Object.assign({}, resolveOptions, {
            skipSelf: true,
            custom: Object.assign({}, resolveOptions.custom, {
              "node-resolve": { isRequire: isProxyModule || isRequiredModule }
            })
          })
        ).then((resolved) => {
          if (!resolved) {
            resolved = resolveExtensions(importee, importer);
          }
          if (resolved && isProxyModule) {
            resolved.id = wrapId(resolved.id, resolved.external ? EXTERNAL_SUFFIX : PROXY_SUFFIX);
            resolved.external = false;
          } else if (resolved && isModuleRegistration) {
            resolved.id = wrapId(resolved.id, DYNAMIC_REGISTER_SUFFIX);
          } else if (!resolved && (isProxyModule || isRequiredModule)) {
            return { id: wrapId(importee, EXTERNAL_SUFFIX), external: false };
          }
          return resolved;
        });
      };
    }
    function validateRollupVersion(rollupVersion, peerDependencyVersion) {
      const [major, minor] = rollupVersion.split(".").map(Number);
      const versionRegexp = /\^(\d+\.\d+)\.\d+/g;
      let minMajor = Infinity;
      let minMinor = Infinity;
      let foundVersion;
      while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
        const [foundMajor, foundMinor] = foundVersion[1].split(".").map(Number);
        if (foundMajor < minMajor) {
          minMajor = foundMajor;
          minMinor = foundMinor;
        }
      }
      if (major < minMajor || major === minMajor && minor < minMinor) {
        throw new Error(
          `Insufficient Rollup version: "@rollup/plugin-commonjs" requires at least rollup@${minMajor}.${minMinor} but found rollup@${rollupVersion}.`
        );
      }
    }
    var operators = {
      "==": (x) => equals(x.left, x.right, false),
      "!=": (x) => not(operators["=="](x)),
      "===": (x) => equals(x.left, x.right, true),
      "!==": (x) => not(operators["==="](x)),
      "!": (x) => isFalsy(x.argument),
      "&&": (x) => isTruthy(x.left) && isTruthy(x.right),
      "||": (x) => isTruthy(x.left) || isTruthy(x.right)
    };
    function not(value) {
      return value === null ? value : !value;
    }
    function equals(a, b, strict) {
      if (a.type !== b.type)
        return null;
      if (a.type === "Literal")
        return strict ? a.value === b.value : a.value == b.value;
      return null;
    }
    function isTruthy(node) {
      if (!node)
        return false;
      if (node.type === "Literal")
        return !!node.value;
      if (node.type === "ParenthesizedExpression")
        return isTruthy(node.expression);
      if (node.operator in operators)
        return operators[node.operator](node);
      return null;
    }
    function isFalsy(node) {
      return not(isTruthy(node));
    }
    function getKeypath(node) {
      const parts = [];
      while (node.type === "MemberExpression") {
        if (node.computed)
          return null;
        parts.unshift(node.property.name);
        node = node.object;
      }
      if (node.type !== "Identifier")
        return null;
      const { name } = node;
      parts.unshift(name);
      return { name, keypath: parts.join(".") };
    }
    var KEY_COMPILED_ESM = "__esModule";
    function isDefineCompiledEsm(node) {
      const definedProperty = getDefinePropertyCallName(node, "exports") || getDefinePropertyCallName(node, "module.exports");
      if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
        return isTruthy(definedProperty.value);
      }
      return false;
    }
    function getDefinePropertyCallName(node, targetName) {
      const {
        callee: { object, property }
      } = node;
      if (!object || object.type !== "Identifier" || object.name !== "Object")
        return;
      if (!property || property.type !== "Identifier" || property.name !== "defineProperty")
        return;
      if (node.arguments.length !== 3)
        return;
      const targetNames = targetName.split(".");
      const [target, key, value] = node.arguments;
      if (targetNames.length === 1) {
        if (target.type !== "Identifier" || target.name !== targetNames[0]) {
          return;
        }
      }
      if (targetNames.length === 2) {
        if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) {
          return;
        }
      }
      if (value.type !== "ObjectExpression" || !value.properties)
        return;
      const valueProperty = value.properties.find((p) => p.key && p.key.name === "value");
      if (!valueProperty || !valueProperty.value)
        return;
      return { key: key.value, value: valueProperty.value };
    }
    function isShorthandProperty(parent) {
      return parent && parent.type === "Property" && parent.shorthand;
    }
    function hasDefineEsmProperty(node) {
      return node.properties.some((property) => {
        if (property.type === "Property" && property.key.type === "Identifier" && property.key.name === "__esModule" && isTruthy(property.value)) {
          return true;
        }
        return false;
      });
    }
    function wrapCode(magicString, uses, moduleName, exportsName) {
      const args = [];
      const passedArgs = [];
      if (uses.module) {
        args.push("module");
        passedArgs.push(moduleName);
      }
      if (uses.exports) {
        args.push("exports");
        passedArgs.push(exportsName);
      }
      magicString.trim().prepend(`(function (${args.join(", ")}) {
`).append(`
}(${passedArgs.join(", ")}));`);
    }
    function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports) {
      const exports2 = [];
      const exportDeclarations = [];
      if (exportMode === "replace") {
        getExportsForReplacedModuleExports(
          magicString,
          exports2,
          exportDeclarations,
          moduleExportsAssignments,
          firstTopLevelModuleExportsAssignment,
          exportsName
        );
      } else {
        exports2.push(`${exportsName} as __moduleExports`);
        if (wrapped) {
          getExportsWhenWrapping(
            exportDeclarations,
            exportsName,
            detectWrappedDefault,
            HELPERS_NAME,
            defaultIsModuleExports
          );
        } else {
          getExports2(
            magicString,
            exports2,
            exportDeclarations,
            moduleExportsAssignments,
            exportsAssignmentsByName,
            deconflictedExportNames,
            topLevelAssignments,
            moduleName,
            exportsName,
            defineCompiledEsmExpressions,
            HELPERS_NAME,
            defaultIsModuleExports
          );
        }
      }
      if (exports2.length) {
        exportDeclarations.push(`export { ${exports2.join(", ")} };`);
      }
      return `

${exportDeclarations.join("\n")}`;
    }
    function getExportsForReplacedModuleExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName) {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, exportsName);
      }
      magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
      exports2.push(`${exportsName} as __moduleExports`);
      exportDeclarations.push(`export default ${exportsName};`);
    }
    function getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports) {
      exportDeclarations.push(
        `export default ${detectWrappedDefault && defaultIsModuleExports === "auto" ? `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName})` : defaultIsModuleExports === false ? `${exportsName}.default` : exportsName};`
      );
    }
    function getExports2(magicString, exports2, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports) {
      let deconflictedDefaultExportName;
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
      }
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        const deconflicted = deconflictedExportNames[exportName];
        let needsDeclaration = true;
        for (const node of nodes) {
          let replacement = `${deconflicted} = ${exportsName}.${exportName}`;
          if (needsDeclaration && topLevelAssignments.has(node)) {
            replacement = `var ${replacement}`;
            needsDeclaration = false;
          }
          magicString.overwrite(node.start, node.left.end, replacement);
        }
        if (needsDeclaration) {
          magicString.prepend(`var ${deconflicted};
`);
        }
        if (exportName === "default") {
          deconflictedDefaultExportName = deconflicted;
        } else {
          exports2.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
        }
      }
      let isRestorableCompiledEsm = false;
      for (const expression of defineCompiledEsmExpressions) {
        isRestorableCompiledEsm = true;
        const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
        magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportsName);
      }
      if (!isRestorableCompiledEsm || defaultIsModuleExports === true) {
        exportDeclarations.push(`export default ${exportsName};`);
      } else if (moduleExportsAssignments.length === 0 || defaultIsModuleExports === false) {
        exports2.push(`${deconflictedDefaultExportName || exportsName} as default`);
      } else {
        exportDeclarations.push(
          `export default /*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName});`
        );
      }
    }
    function isRequireStatement(node, scope) {
      if (!node)
        return false;
      if (node.type !== "CallExpression")
        return false;
      if (node.arguments.length === 0)
        return false;
      return isRequire(node.callee, scope);
    }
    function isRequire(node, scope) {
      return node.type === "Identifier" && node.name === "require" && !scope.contains("require") || node.type === "MemberExpression" && isModuleRequire(node, scope);
    }
    function isModuleRequire({ object, property }, scope) {
      return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
    }
    function isStaticRequireStatement(node, scope) {
      if (!isRequireStatement(node, scope))
        return false;
      return !hasDynamicArguments(node);
    }
    function hasDynamicArguments(node) {
      return node.arguments.length > 1 || node.arguments[0].type !== "Literal" && (node.arguments[0].type !== "TemplateLiteral" || node.arguments[0].expressions.length > 0);
    }
    var reservedMethod = { resolve: true, cache: true, main: true };
    function isNodeRequirePropertyAccess(parent) {
      return parent && parent.property && reservedMethod[parent.property.name];
    }
    function isIgnoredRequireStatement(requiredNode, ignoreRequire) {
      return ignoreRequire(requiredNode.arguments[0].value);
    }
    function getRequireStringArg(node) {
      return node.arguments[0].type === "Literal" ? node.arguments[0].value : node.arguments[0].quasis[0].value.cooked;
    }
    function hasDynamicModuleForPath(source, id, dynamicRequireModuleSet) {
      if (!/^(?:\.{0,2}[/\\]|[A-Za-z]:[/\\])/.test(source)) {
        try {
          const resolvedPath = normalizePathSlashes(resolve4.sync(source, { basedir: path4.dirname(id) }));
          if (dynamicRequireModuleSet.has(resolvedPath)) {
            return true;
          }
        } catch (ex) {
          return false;
        }
        return false;
      }
      for (const attemptExt of ["", ".js", ".json"]) {
        const resolvedPath = normalizePathSlashes(path4.resolve(path4.dirname(id), source + attemptExt));
        if (dynamicRequireModuleSet.has(resolvedPath)) {
          return true;
        }
      }
      return false;
    }
    function getRequireHandlers() {
      const requiredSources = [];
      const requiredBySource = /* @__PURE__ */ Object.create(null);
      const requiredByNode = /* @__PURE__ */ new Map();
      const requireExpressionsWithUsedReturnValue = [];
      function addRequireStatement(sourceId, node, scope, usesReturnValue) {
        const required = getRequired(sourceId);
        requiredByNode.set(node, { scope, required });
        if (usesReturnValue) {
          required.nodesUsingRequired.push(node);
          requireExpressionsWithUsedReturnValue.push(node);
        }
      }
      function getRequired(sourceId) {
        if (!requiredBySource[sourceId]) {
          requiredSources.push(sourceId);
          requiredBySource[sourceId] = {
            source: sourceId,
            name: null,
            nodesUsingRequired: []
          };
        }
        return requiredBySource[sourceId];
      }
      function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, topLevelRequireDeclarators, reassignedNames, helpersName, dynamicRegisterSources, moduleName, exportsName, id, exportMode) {
        setRemainingImportNamesAndRewriteRequires(
          requireExpressionsWithUsedReturnValue,
          requiredByNode,
          magicString
        );
        const imports = [];
        imports.push(`import * as ${helpersName} from "${HELPERS_ID}";`);
        if (exportMode === "module") {
          imports.push(
            `import { __module as ${moduleName}, exports as ${exportsName} } from ${JSON.stringify(
              wrapId(id, MODULE_SUFFIX)
            )}`
          );
        } else if (exportMode === "exports") {
          imports.push(
            `import { __exports as ${exportsName} } from ${JSON.stringify(wrapId(id, EXPORTS_SUFFIX))}`
          );
        }
        for (const source of dynamicRegisterSources) {
          imports.push(`import ${JSON.stringify(wrapId(source, REQUIRE_SUFFIX))};`);
        }
        for (const source of requiredSources) {
          if (!source.startsWith("\0")) {
            imports.push(`import ${JSON.stringify(wrapId(source, REQUIRE_SUFFIX))};`);
          }
          const { name, nodesUsingRequired } = requiredBySource[source];
          imports.push(
            `import ${nodesUsingRequired.length ? `${name} from ` : ""}${JSON.stringify(
              source.startsWith("\0") ? source : wrapId(source, PROXY_SUFFIX)
            )};`
          );
        }
        return imports.length ? `${imports.join("\n")}

` : "";
      }
      return {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      };
    }
    function setRemainingImportNamesAndRewriteRequires(requireExpressionsWithUsedReturnValue, requiredByNode, magicString) {
      let uid = 0;
      for (const requireExpression of requireExpressionsWithUsedReturnValue) {
        const { required } = requiredByNode.get(requireExpression);
        if (!required.name) {
          let potentialName;
          const isUsedName = (node) => requiredByNode.get(node).scope.contains(potentialName);
          do {
            potentialName = `require$$${uid}`;
            uid += 1;
          } while (required.nodesUsingRequired.some(isUsedName));
          required.name = potentialName;
        }
        magicString.overwrite(requireExpression.start, requireExpression.end, required.name);
      }
    }
    var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
    var functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
    function transformCommonjs(parse4, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModuleSet, disableWrap, commonDir, astCache, defaultIsModuleExports) {
      const ast = astCache || tryParse(parse4, code, id);
      const magicString = new MagicString__default["default"](code);
      const uses = {
        module: false,
        exports: false,
        global: false,
        require: false
      };
      let usesDynamicRequire = false;
      const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(path4.dirname(id), commonDir);
      let scope = pluginutils.attachScopes(ast, "scope");
      let lexicalDepth = 0;
      let programDepth = 0;
      let currentTryBlockEnd = null;
      let shouldWrap = false;
      const globals = /* @__PURE__ */ new Set();
      const HELPERS_NAME = deconflict([scope], globals, "commonjsHelpers");
      const dynamicRegisterSources = /* @__PURE__ */ new Set();
      let hasRemovedRequire = false;
      const {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      } = getRequireHandlers();
      const reassignedNames = /* @__PURE__ */ new Set();
      const topLevelDeclarations = [];
      const topLevelRequireDeclarators = /* @__PURE__ */ new Set();
      const skippedNodes = /* @__PURE__ */ new Set();
      const moduleAccessScopes = /* @__PURE__ */ new Set([scope]);
      const exportsAccessScopes = /* @__PURE__ */ new Set([scope]);
      const moduleExportsAssignments = [];
      let firstTopLevelModuleExportsAssignment = null;
      const exportsAssignmentsByName = /* @__PURE__ */ new Map();
      const topLevelAssignments = /* @__PURE__ */ new Set();
      const topLevelDefineCompiledEsmExpressions = [];
      estreeWalker.walk(ast, {
        enter(node, parent) {
          if (skippedNodes.has(node)) {
            this.skip();
            return;
          }
          if (currentTryBlockEnd !== null && node.start > currentTryBlockEnd) {
            currentTryBlockEnd = null;
          }
          programDepth += 1;
          if (node.scope)
            ({ scope } = node);
          if (functionType.test(node.type))
            lexicalDepth += 1;
          if (sourceMap) {
            magicString.addSourcemapLocation(node.start);
            magicString.addSourcemapLocation(node.end);
          }
          switch (node.type) {
            case "TryStatement":
              if (currentTryBlockEnd === null) {
                currentTryBlockEnd = node.block.end;
              }
              return;
            case "AssignmentExpression":
              if (node.left.type === "MemberExpression") {
                const flattened = getKeypath(node.left);
                if (!flattened || scope.contains(flattened.name))
                  return;
                const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
                if (!exportsPatternMatch || flattened.keypath === "exports")
                  return;
                const [, exportName] = exportsPatternMatch;
                uses[flattened.name] = true;
                if (flattened.keypath === "module.exports") {
                  moduleExportsAssignments.push(node);
                  if (programDepth > 3) {
                    moduleAccessScopes.add(scope);
                  } else if (!firstTopLevelModuleExportsAssignment) {
                    firstTopLevelModuleExportsAssignment = node;
                  }
                  if (defaultIsModuleExports === false) {
                    shouldWrap = true;
                  } else if (defaultIsModuleExports === "auto") {
                    if (node.right.type === "ObjectExpression") {
                      if (hasDefineEsmProperty(node.right)) {
                        shouldWrap = true;
                      }
                    } else if (defaultIsModuleExports === false) {
                      shouldWrap = true;
                    }
                  }
                } else if (exportName === KEY_COMPILED_ESM) {
                  if (programDepth > 3) {
                    shouldWrap = true;
                  } else {
                    topLevelDefineCompiledEsmExpressions.push(node);
                  }
                } else {
                  const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                    nodes: [],
                    scopes: /* @__PURE__ */ new Set()
                  };
                  exportsAssignments.nodes.push(node);
                  exportsAssignments.scopes.add(scope);
                  exportsAccessScopes.add(scope);
                  exportsAssignmentsByName.set(exportName, exportsAssignments);
                  if (programDepth <= 3) {
                    topLevelAssignments.add(node);
                  }
                }
                skippedNodes.add(node.left);
              } else {
                for (const name of pluginutils.extractAssignedNames(node.left)) {
                  reassignedNames.add(name);
                }
              }
              return;
            case "CallExpression": {
              if (isDefineCompiledEsm(node)) {
                if (programDepth === 3 && parent.type === "ExpressionStatement") {
                  skippedNodes.add(node.arguments[0]);
                  topLevelDefineCompiledEsmExpressions.push(node);
                } else {
                  shouldWrap = true;
                }
                return;
              }
              if (node.callee.object && node.callee.object.name === "require" && node.callee.property.name === "resolve" && hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                const requireNode = node.callee.object;
                magicString.appendLeft(
                  node.end - 1,
                  `,${JSON.stringify(
                    path4.dirname(id) === "." ? null : virtualDynamicRequirePath
                  )}`
                );
                magicString.overwrite(
                  requireNode.start,
                  requireNode.end,
                  `${HELPERS_NAME}.commonjsRequire`,
                  {
                    storeName: true
                  }
                );
                return;
              }
              if (!isStaticRequireStatement(node, scope))
                return;
              if (!isDynamicRequireModulesEnabled) {
                skippedNodes.add(node.callee);
              }
              if (!isIgnoredRequireStatement(node, ignoreRequire)) {
                skippedNodes.add(node.callee);
                const usesReturnValue = parent.type !== "ExpressionStatement";
                let canConvertRequire = true;
                let shouldRemoveRequireStatement = false;
                if (currentTryBlockEnd !== null) {
                  ({
                    canConvertRequire,
                    shouldRemoveRequireStatement
                  } = getIgnoreTryCatchRequireStatementMode(node.arguments[0].value));
                  if (shouldRemoveRequireStatement) {
                    hasRemovedRequire = true;
                  }
                }
                let sourceId = getRequireStringArg(node);
                const isDynamicRegister = isWrappedId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                if (isDynamicRegister) {
                  sourceId = unwrapId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                  if (sourceId.endsWith(".json")) {
                    sourceId = DYNAMIC_JSON_PREFIX + sourceId;
                  }
                  dynamicRegisterSources.add(wrapId(sourceId, DYNAMIC_REGISTER_SUFFIX));
                } else {
                  if (!sourceId.endsWith(".json") && hasDynamicModuleForPath(sourceId, id, dynamicRequireModuleSet)) {
                    if (shouldRemoveRequireStatement) {
                      magicString.overwrite(node.start, node.end, `undefined`);
                    } else if (canConvertRequire) {
                      magicString.overwrite(
                        node.start,
                        node.end,
                        `${HELPERS_NAME}.commonjsRequire(${JSON.stringify(
                          getVirtualPathForDynamicRequirePath(sourceId, commonDir)
                        )}, ${JSON.stringify(
                          path4.dirname(id) === "." ? null : virtualDynamicRequirePath
                        )})`
                      );
                      usesDynamicRequire = true;
                    }
                    return;
                  }
                  if (canConvertRequire) {
                    addRequireStatement(sourceId, node, scope, usesReturnValue);
                  }
                }
                if (usesReturnValue) {
                  if (shouldRemoveRequireStatement) {
                    magicString.overwrite(node.start, node.end, `undefined`);
                    return;
                  }
                  if (parent.type === "VariableDeclarator" && !scope.parent && parent.id.type === "Identifier") {
                    topLevelRequireDeclarators.add(parent);
                  }
                } else {
                  if (!canConvertRequire && !shouldRemoveRequireStatement) {
                    return;
                  }
                  magicString.remove(parent.start, parent.end);
                }
              }
              return;
            }
            case "ConditionalExpression":
            case "IfStatement":
              if (isFalsy(node.test)) {
                skippedNodes.add(node.consequent);
              } else if (node.alternate && isTruthy(node.test)) {
                skippedNodes.add(node.alternate);
              }
              return;
            case "Identifier": {
              const { name } = node;
              if (!(isReference__default["default"](node, parent) && !scope.contains(name)))
                return;
              switch (name) {
                case "require":
                  if (isNodeRequirePropertyAccess(parent)) {
                    if (hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                      if (parent.property.name === "cache") {
                        magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsRequire`, {
                          storeName: true
                        });
                      }
                    }
                    return;
                  }
                  if (isDynamicRequireModulesEnabled && isRequireStatement(parent, scope)) {
                    magicString.appendLeft(
                      parent.end - 1,
                      `,${JSON.stringify(
                        path4.dirname(id) === "." ? null : virtualDynamicRequirePath
                      )}`
                    );
                  }
                  if (!ignoreDynamicRequires) {
                    if (isShorthandProperty(parent)) {
                      magicString.appendRight(node.end, `: ${HELPERS_NAME}.commonjsRequire`);
                    } else {
                      magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsRequire`, {
                        storeName: true
                      });
                    }
                  }
                  usesDynamicRequire = true;
                  return;
                case "module":
                case "exports":
                  shouldWrap = true;
                  uses[name] = true;
                  return;
                case "global":
                  uses.global = true;
                  if (!ignoreGlobal) {
                    magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsGlobal`, {
                      storeName: true
                    });
                  }
                  return;
                case "define":
                  magicString.overwrite(node.start, node.end, "undefined", {
                    storeName: true
                  });
                  return;
                default:
                  globals.add(name);
                  return;
              }
            }
            case "MemberExpression":
              if (!isDynamicRequireModulesEnabled && isModuleRequire(node, scope)) {
                magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsRequire`, {
                  storeName: true
                });
                skippedNodes.add(node.object);
                skippedNodes.add(node.property);
              }
              return;
            case "ReturnStatement":
              if (lexicalDepth === 0) {
                shouldWrap = true;
              }
              return;
            case "ThisExpression":
              if (lexicalDepth === 0) {
                uses.global = true;
                if (!ignoreGlobal) {
                  magicString.overwrite(node.start, node.end, `${HELPERS_NAME}.commonjsGlobal`, {
                    storeName: true
                  });
                }
              }
              return;
            case "UnaryExpression":
              if (node.operator === "typeof") {
                const flattened = getKeypath(node.argument);
                if (!flattened)
                  return;
                if (scope.contains(flattened.name))
                  return;
                if (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports") {
                  magicString.overwrite(node.start, node.end, `'object'`, {
                    storeName: false
                  });
                }
              }
              return;
            case "VariableDeclaration":
              if (!scope.parent) {
                topLevelDeclarations.push(node);
              }
          }
        },
        leave(node) {
          programDepth -= 1;
          if (node.scope)
            scope = scope.parent;
          if (functionType.test(node.type))
            lexicalDepth -= 1;
        }
      });
      const nameBase = getName(id);
      const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
      const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
      const deconflictedExportNames = /* @__PURE__ */ Object.create(null);
      for (const [exportName, { scopes }] of exportsAssignmentsByName) {
        deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
      }
      shouldWrap = !isEsModule && !disableWrap && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
      const detectWrappedDefault = shouldWrap && (topLevelDefineCompiledEsmExpressions.length > 0 || code.indexOf("__esModule") >= 0);
      if (!(requiredSources.length || dynamicRegisterSources.size || uses.module || uses.exports || uses.require || usesDynamicRequire || hasRemovedRequire || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) {
        return { meta: { commonjs: { isCommonJS: false } } };
      }
      let leadingComment = "";
      if (code.startsWith("/*")) {
        const commentEnd = code.indexOf("*/", 2) + 2;
        leadingComment = `${code.slice(0, commentEnd)}
`;
        magicString.remove(0, commentEnd).trim();
      }
      const exportMode = shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
      const importBlock = rewriteRequireExpressionsAndGetImportBlock(
        magicString,
        topLevelDeclarations,
        topLevelRequireDeclarators,
        reassignedNames,
        HELPERS_NAME,
        dynamicRegisterSources,
        moduleName,
        exportsName,
        id,
        exportMode
      );
      const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(
        magicString,
        moduleName,
        exportsName,
        shouldWrap,
        moduleExportsAssignments,
        firstTopLevelModuleExportsAssignment,
        exportsAssignmentsByName,
        topLevelAssignments,
        topLevelDefineCompiledEsmExpressions,
        deconflictedExportNames,
        code,
        HELPERS_NAME,
        exportMode,
        detectWrappedDefault,
        defaultIsModuleExports
      );
      if (shouldWrap) {
        wrapCode(magicString, uses, moduleName, exportsName);
      }
      magicString.trim().prepend(leadingComment + importBlock).append(exportBlock);
      return {
        code: magicString.toString(),
        map: sourceMap ? magicString.generateMap() : null,
        syntheticNamedExports: isEsModule ? false : "__moduleExports",
        meta: { commonjs: { isCommonJS: !isEsModule } }
      };
    }
    function commonjs2(options = {}) {
      const extensions = options.extensions || [".js"];
      const filter = pluginutils.createFilter(options.include, options.exclude);
      const {
        ignoreGlobal,
        ignoreDynamicRequires,
        requireReturnsDefault: requireReturnsDefaultOption,
        esmExternals
      } = options;
      const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
      let esmExternalIds;
      const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
      const defaultIsModuleExports = typeof options.defaultIsModuleExports === "boolean" ? options.defaultIsModuleExports : "auto";
      const { dynamicRequireModuleSet, dynamicRequireModuleDirPaths } = getDynamicRequirePaths(
        options.dynamicRequireTargets
      );
      const isDynamicRequireModulesEnabled = dynamicRequireModuleSet.size > 0;
      const commonDir = isDynamicRequireModulesEnabled ? getCommonDir__default["default"](null, Array.from(dynamicRequireModuleSet).concat(process.cwd())) : null;
      const esModulesWithDefaultExport = /* @__PURE__ */ new Set();
      const esModulesWithNamedExports = /* @__PURE__ */ new Set();
      const commonJsMetaPromises = /* @__PURE__ */ new Map();
      const ignoreRequire = typeof options.ignore === "function" ? options.ignore : Array.isArray(options.ignore) ? (id) => options.ignore.includes(id) : () => false;
      const getIgnoreTryCatchRequireStatementMode = (id) => {
        const mode = typeof options.ignoreTryCatch === "function" ? options.ignoreTryCatch(id) : Array.isArray(options.ignoreTryCatch) ? options.ignoreTryCatch.includes(id) : typeof options.ignoreTryCatch !== "undefined" ? options.ignoreTryCatch : true;
        return {
          canConvertRequire: mode !== "remove" && mode !== true,
          shouldRemoveRequireStatement: mode === "remove"
        };
      };
      const resolveId2 = getResolveId(extensions);
      const sourceMap = options.sourceMap !== false;
      function transformAndCheckExports(code, id) {
        if (isDynamicRequireModulesEnabled && this.getModuleInfo(id).isEntry) {
          code = getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) + code;
        }
        const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(
          this.parse,
          code,
          id
        );
        if (hasDefaultExport) {
          esModulesWithDefaultExport.add(id);
        }
        if (hasNamedExports) {
          esModulesWithNamedExports.add(id);
        }
        if (!dynamicRequireModuleSet.has(normalizePathSlashes(id)) && (!hasCjsKeywords(code, ignoreGlobal) || isEsModule && !options.transformMixedEsModules)) {
          return { meta: { commonjs: { isCommonJS: false } } };
        }
        const disableWrap = isWrappedId(id, DYNAMIC_REGISTER_SUFFIX);
        if (disableWrap) {
          id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
        }
        return transformCommonjs(
          this.parse,
          code,
          id,
          isEsModule,
          ignoreGlobal || isEsModule,
          ignoreRequire,
          ignoreDynamicRequires && !isDynamicRequireModulesEnabled,
          getIgnoreTryCatchRequireStatementMode,
          sourceMap,
          isDynamicRequireModulesEnabled,
          dynamicRequireModuleSet,
          disableWrap,
          commonDir,
          ast,
          defaultIsModuleExports
        );
      }
      return {
        name: "commonjs",
        buildStart() {
          validateRollupVersion(this.meta.rollupVersion, peerDependencies.rollup);
          if (options.namedExports != null) {
            this.warn(
              'The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.'
            );
          }
        },
        resolveId: resolveId2,
        load(id) {
          if (id === HELPERS_ID) {
            return getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires);
          }
          if (id.startsWith(HELPERS_ID)) {
            return getSpecificHelperProxy(id);
          }
          if (isWrappedId(id, MODULE_SUFFIX)) {
            const actualId = unwrapId(id, MODULE_SUFFIX);
            let name = getName(actualId);
            let code;
            if (isDynamicRequireModulesEnabled) {
              if (["modulePath", "commonjsRequire", "createModule"].includes(name)) {
                name = `${name}_`;
              }
              code = `import {commonjsRequire, createModule} from "${HELPERS_ID}";
var ${name} = createModule(${JSON.stringify(
                getVirtualPathForDynamicRequirePath(path4.dirname(actualId), commonDir)
              )});
export {${name} as __module}`;
            } else {
              code = `var ${name} = {exports: {}}; export {${name} as __module}`;
            }
            return {
              code,
              syntheticNamedExports: "__module",
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXPORTS_SUFFIX)) {
            const actualId = unwrapId(id, EXPORTS_SUFFIX);
            const name = getName(actualId);
            return {
              code: `var ${name} = {}; export {${name} as __exports}`,
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXTERNAL_SUFFIX)) {
            const actualId = unwrapId(id, EXTERNAL_SUFFIX);
            return getUnknownRequireProxy(
              actualId,
              isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true
            );
          }
          if (id === DYNAMIC_PACKAGES_ID) {
            return getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir);
          }
          if (id.startsWith(DYNAMIC_JSON_PREFIX)) {
            return getDynamicJsonProxy(id, commonDir);
          }
          if (isDynamicModuleImport(id, dynamicRequireModuleSet)) {
            return `export default require(${JSON.stringify(normalizePathSlashes(id))});`;
          }
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            return getDynamicRequireProxy(
              normalizePathSlashes(unwrapId(id, DYNAMIC_REGISTER_SUFFIX)),
              commonDir
            );
          }
          if (isWrappedId(id, PROXY_SUFFIX)) {
            const actualId = unwrapId(id, PROXY_SUFFIX);
            return getStaticRequireProxy(
              actualId,
              getRequireReturnsDefault(actualId),
              esModulesWithDefaultExport,
              esModulesWithNamedExports,
              commonJsMetaPromises
            );
          }
          return null;
        },
        transform(code, rawId) {
          let id = rawId;
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
          }
          const extName = path4.extname(id);
          if (extName !== ".cjs" && id !== DYNAMIC_PACKAGES_ID && !id.startsWith(DYNAMIC_JSON_PREFIX) && (!filter(id) || !extensions.includes(extName))) {
            return null;
          }
          try {
            return transformAndCheckExports.call(this, code, rawId);
          } catch (err) {
            return this.error(err, err.loc);
          }
        },
        moduleParsed({ id, meta: { commonjs: commonjsMeta } }) {
          if (commonjsMeta && commonjsMeta.isCommonJS != null) {
            setCommonJSMetaPromise(commonJsMetaPromises, id, commonjsMeta);
            return;
          }
          setCommonJSMetaPromise(commonJsMetaPromises, id, null);
        }
      };
    }
    module2.exports = commonjs2;
  }
});

// plugins/public/reactdevtools/serverAddOn.tsx
var serverAddOn_exports = {};
__export(serverAddOn_exports, {
  default: () => serverAddOn_default
});
module.exports = __toCommonJS(serverAddOn_exports);
var import_flipper_plugin = require("flipper-plugin");
var import_path4 = __toESM(require("path"));

// plugins/public/node_modules/ws/wrapper.mjs
var import_stream = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// plugins/public/node_modules/rollup/dist/es/rollup.js
init_rollup();

// plugins/public/node_modules/@rollup/plugin-node-resolve/dist/es/index.js
var import_path3 = __toESM(require("path"), 1);
var import_builtin_modules = __toESM(require_builtin_modules(), 1);
var import_deepmerge = __toESM(require_cjs(), 1);
var import_is_module = __toESM(require_is_module(), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_util = require("util");
var import_url = require("url");
var import_resolve = __toESM(require_resolve(), 1);

// plugins/public/node_modules/@rollup/pluginutils/dist/es/index.js
var import_path2 = require("path");
var import_picomatch = __toESM(require_picomatch2(), 1);
function isArray2(arg) {
  return Array.isArray(arg);
}
function ensureArray2(thing) {
  if (isArray2(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false) {
    return id;
  }
  const basePath = (0, import_path2.resolve)(resolutionBase || "").split(import_path2.sep).join("/").replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return import_path2.posix.join(basePath, id);
}
var createFilter = function createFilter2(include, exclude, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern = getMatcherString(id, resolutionBase);
      const fn = (0, import_picomatch.default)(pattern, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray2(include).map(getMatcher);
  const excludeMatchers = ensureArray2(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = id.split(import_path2.sep).join("/");
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins2 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers2 = new Set(`${reservedWords2} ${builtins2}`.split(" "));
forbiddenIdentifiers2.add("");

// plugins/public/node_modules/@rollup/plugin-node-resolve/dist/es/index.js
var version2 = "13.1.3";
(0, import_util.promisify)(import_fs2.default.access);
var readFile$1 = (0, import_util.promisify)(import_fs2.default.readFile);
var realpath = (0, import_util.promisify)(import_fs2.default.realpath);
var stat = (0, import_util.promisify)(import_fs2.default.stat);
async function fileExists(filePath) {
  try {
    const res = await stat(filePath);
    return res.isFile();
  } catch {
    return false;
  }
}
async function resolveSymlink(path4) {
  return await fileExists(path4) ? realpath(path4) : path4;
}
var onError = (error2) => {
  if (error2.code === "ENOENT") {
    return false;
  }
  throw error2;
};
var makeCache = (fn) => {
  const cache = /* @__PURE__ */ new Map();
  const wrapped = async (param, done) => {
    if (cache.has(param) === false) {
      cache.set(
        param,
        fn(param).catch((err) => {
          cache.delete(param);
          throw err;
        })
      );
    }
    try {
      const result = cache.get(param);
      const value = await result;
      return done(null, value);
    } catch (error2) {
      return done(error2);
    }
  };
  wrapped.clear = () => cache.clear();
  return wrapped;
};
var isDirCached = makeCache(async (file) => {
  try {
    const stats = await stat(file);
    return stats.isDirectory();
  } catch (error2) {
    return onError(error2);
  }
});
var isFileCached = makeCache(async (file) => {
  try {
    const stats = await stat(file);
    return stats.isFile();
  } catch (error2) {
    return onError(error2);
  }
});
var readCachedFile = makeCache(readFile$1);
function handleDeprecatedOptions(opts) {
  const warnings = [];
  if (opts.customResolveOptions) {
    const { customResolveOptions } = opts;
    if (customResolveOptions.moduleDirectory) {
      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];
      warnings.push(
        "node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array."
      );
    }
    if (customResolveOptions.preserveSymlinks) {
      throw new Error(
        "node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option."
      );
    }
    [
      "basedir",
      "package",
      "extensions",
      "includeCoreModules",
      "readFile",
      "isFile",
      "isDirectory",
      "realpath",
      "packageFilter",
      "pathFilter",
      "paths",
      "packageIterator"
    ].forEach((resolveOption) => {
      if (customResolveOptions[resolveOption]) {
        throw new Error(
          `node-resolve: \`customResolveOptions.${resolveOption}\` is no longer an option. If you need this, please open an issue.`
        );
      }
    });
  }
  return { warnings };
}
function getPackageName(id) {
  if (id.startsWith(".") || id.startsWith("/")) {
    return null;
  }
  const split2 = id.split("/");
  if (split2[0][0] === "@") {
    return `${split2[0]}/${split2[1]}`;
  }
  return split2[0];
}
function getMainFields(options) {
  let mainFields;
  if (options.mainFields) {
    ({ mainFields } = options);
  } else {
    mainFields = ["module", "main"];
  }
  if (options.browser && mainFields.indexOf("browser") === -1) {
    return ["browser"].concat(mainFields);
  }
  if (!mainFields.length) {
    throw new Error("Please ensure at least one `mainFields` value is specified");
  }
  return mainFields;
}
function getPackageInfo(options) {
  const {
    cache,
    extensions,
    pkg,
    mainFields,
    preserveSymlinks,
    useBrowserOverrides,
    rootDir,
    ignoreSideEffectsForRoot
  } = options;
  let { pkgPath } = options;
  if (cache.has(pkgPath)) {
    return cache.get(pkgPath);
  }
  if (!preserveSymlinks) {
    pkgPath = (0, import_fs2.realpathSync)(pkgPath);
  }
  const pkgRoot = (0, import_path3.dirname)(pkgPath);
  const packageInfo = {
    packageJson: { ...pkg },
    packageJsonPath: pkgPath,
    root: pkgRoot,
    resolvedMainField: "main",
    browserMappedMain: false,
    resolvedEntryPoint: ""
  };
  let overriddenMain = false;
  for (let i = 0; i < mainFields.length; i++) {
    const field = mainFields[i];
    if (typeof pkg[field] === "string") {
      pkg.main = pkg[field];
      packageInfo.resolvedMainField = field;
      overriddenMain = true;
      break;
    }
  }
  const internalPackageInfo = {
    cachedPkg: pkg,
    hasModuleSideEffects: () => null,
    hasPackageEntry: overriddenMain !== false || mainFields.indexOf("main") !== -1,
    packageBrowserField: useBrowserOverrides && typeof pkg.browser === "object" && Object.keys(pkg.browser).reduce((browser, key) => {
      let resolved = pkg.browser[key];
      if (resolved && resolved[0] === ".") {
        resolved = (0, import_path3.resolve)(pkgRoot, resolved);
      }
      browser[key] = resolved;
      if (key[0] === ".") {
        const absoluteKey = (0, import_path3.resolve)(pkgRoot, key);
        browser[absoluteKey] = resolved;
        if (!(0, import_path3.extname)(key)) {
          extensions.reduce((subBrowser, ext) => {
            subBrowser[absoluteKey + ext] = subBrowser[key];
            return subBrowser;
          }, browser);
        }
      }
      return browser;
    }, {}),
    packageInfo
  };
  const browserMap = internalPackageInfo.packageBrowserField;
  if (useBrowserOverrides && typeof pkg.browser === "object" && browserMap.hasOwnProperty(pkg.main)) {
    packageInfo.resolvedEntryPoint = browserMap[pkg.main];
    packageInfo.browserMappedMain = true;
  } else {
    packageInfo.resolvedEntryPoint = (0, import_path3.resolve)(pkgRoot, pkg.main || "index.js");
    packageInfo.browserMappedMain = false;
  }
  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {
    const packageSideEffects = pkg.sideEffects;
    if (typeof packageSideEffects === "boolean") {
      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;
    } else if (Array.isArray(packageSideEffects)) {
      internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {
        resolve: pkgRoot
      });
    }
  }
  cache.set(pkgPath, internalPackageInfo);
  return internalPackageInfo;
}
function normalizeInput(input) {
  if (Array.isArray(input)) {
    return input;
  } else if (typeof input === "object") {
    return Object.values(input);
  }
  return [input];
}
function isModuleDir(current2, moduleDirs) {
  return moduleDirs.some((dir) => current2.endsWith(dir));
}
async function findPackageJson(base2, moduleDirs) {
  const { root } = import_path3.default.parse(base2);
  let current2 = base2;
  while (current2 !== root && !isModuleDir(current2, moduleDirs)) {
    const pkgJsonPath = import_path3.default.join(current2, "package.json");
    if (await fileExists(pkgJsonPath)) {
      const pkgJsonString = import_fs2.default.readFileSync(pkgJsonPath, "utf-8");
      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current2, pkgJsonPath };
    }
    current2 = import_path3.default.resolve(current2, "..");
  }
  return null;
}
function isUrl(str) {
  try {
    return !!new URL(str);
  } catch (_) {
    return false;
  }
}
function isConditions(exports) {
  return typeof exports === "object" && Object.keys(exports).every((k) => !k.startsWith("."));
}
function isMappings(exports) {
  return typeof exports === "object" && !isConditions(exports);
}
function isMixedExports(exports) {
  const keys2 = Object.keys(exports);
  return keys2.some((k) => k.startsWith(".")) && keys2.some((k) => !k.startsWith("."));
}
function createBaseErrorMsg(importSpecifier, importer) {
  return `Could not resolve import "${importSpecifier}" in ${importer}`;
}
function createErrorMsg(context, reason, internal) {
  const { importSpecifier, importer, pkgJsonPath } = context;
  const base2 = createBaseErrorMsg(importSpecifier, importer);
  const field = internal ? "imports" : "exports";
  return `${base2} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ""}`;
}
var ResolveError = class extends Error {
};
var InvalidConfigurationError = class extends ResolveError {
  constructor(context, reason) {
    super(createErrorMsg(context, `Invalid "exports" field. ${reason}`));
  }
};
var InvalidModuleSpecifierError = class extends ResolveError {
  constructor(context, internal, reason) {
    super(createErrorMsg(context, reason, internal));
  }
};
var InvalidPackageTargetError = class extends ResolveError {
  constructor(context, reason) {
    super(createErrorMsg(context, reason));
  }
};
function includesInvalidSegments(pathSegments, moduleDirs) {
  return pathSegments.split("/").slice(1).some((t) => [".", "..", ...moduleDirs].includes(t));
}
async function resolvePackageTarget(context, { target, subpath, pattern, internal }) {
  if (typeof target === "string") {
    if (!pattern && subpath.length > 0 && !target.endsWith("/")) {
      throw new InvalidModuleSpecifierError(context);
    }
    if (!target.startsWith("./")) {
      if (internal && !["/", "../"].some((p) => target.startsWith(p)) && !isUrl(target)) {
        if (pattern) {
          const result2 = await context.resolveId(
            target.replace(/\*/g, subpath),
            context.pkgURL.href
          );
          return result2 ? (0, import_url.pathToFileURL)(result2.location).href : null;
        }
        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);
        return result ? (0, import_url.pathToFileURL)(result.location).href : null;
      }
      throw new InvalidPackageTargetError(context, `Invalid mapping: "${target}".`);
    }
    if (includesInvalidSegments(target, context.moduleDirs)) {
      throw new InvalidPackageTargetError(context, `Invalid mapping: "${target}".`);
    }
    const resolvedTarget = new URL(target, context.pkgURL);
    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {
      throw new InvalidPackageTargetError(
        context,
        `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`
      );
    }
    if (includesInvalidSegments(subpath, context.moduleDirs)) {
      throw new InvalidModuleSpecifierError(context);
    }
    if (pattern) {
      return resolvedTarget.href.replace(/\*/g, subpath);
    }
    return new URL(subpath, resolvedTarget).href;
  }
  if (Array.isArray(target)) {
    let lastError;
    for (const item of target) {
      try {
        const resolved = await resolvePackageTarget(context, {
          target: item,
          subpath,
          pattern,
          internal
        });
        if (resolved !== void 0) {
          return resolved;
        }
      } catch (error2) {
        if (!(error2 instanceof InvalidPackageTargetError)) {
          throw error2;
        } else {
          lastError = error2;
        }
      }
    }
    if (lastError) {
      throw lastError;
    }
    return null;
  }
  if (target && typeof target === "object") {
    for (const [key, value] of Object.entries(target)) {
      if (key === "default" || context.conditions.includes(key)) {
        const resolved = await resolvePackageTarget(context, {
          target: value,
          subpath,
          pattern,
          internal
        });
        if (resolved !== void 0) {
          return resolved;
        }
      }
    }
    return void 0;
  }
  if (target === null) {
    return null;
  }
  throw new InvalidPackageTargetError(context, `Invalid exports field.`);
}
async function resolvePackageImportsExports(context, { matchKey, matchObj, internal }) {
  if (!matchKey.endsWith("*") && matchKey in matchObj) {
    const target = matchObj[matchKey];
    const resolved = await resolvePackageTarget(context, { target, subpath: "", internal });
    return resolved;
  }
  const expansionKeys = Object.keys(matchObj).filter((k) => k.endsWith("/") || k.endsWith("*")).sort((a, b) => b.length - a.length);
  for (const expansionKey of expansionKeys) {
    const prefix = expansionKey.substring(0, expansionKey.length - 1);
    if (expansionKey.endsWith("*") && matchKey.startsWith(prefix)) {
      const target = matchObj[expansionKey];
      const subpath = matchKey.substring(expansionKey.length - 1);
      const resolved = await resolvePackageTarget(context, {
        target,
        subpath,
        pattern: true,
        internal
      });
      return resolved;
    }
    if (matchKey.startsWith(expansionKey)) {
      const target = matchObj[expansionKey];
      const subpath = matchKey.substring(expansionKey.length);
      const resolved = await resolvePackageTarget(context, { target, subpath, internal });
      return resolved;
    }
  }
  throw new InvalidModuleSpecifierError(context, internal);
}
async function resolvePackageExports(context, subpath, exports) {
  if (isMixedExports(exports)) {
    throw new InvalidConfigurationError(
      context,
      "All keys must either start with ./, or without one."
    );
  }
  if (subpath === ".") {
    let mainExport;
    if (typeof exports === "string" || Array.isArray(exports) || isConditions(exports)) {
      mainExport = exports;
    } else if (isMappings(exports)) {
      mainExport = exports["."];
    }
    if (mainExport) {
      const resolved = await resolvePackageTarget(context, { target: mainExport, subpath: "" });
      if (resolved) {
        return resolved;
      }
    }
  } else if (isMappings(exports)) {
    const resolvedMatch = await resolvePackageImportsExports(context, {
      matchKey: subpath,
      matchObj: exports
    });
    if (resolvedMatch) {
      return resolvedMatch;
    }
  }
  throw new InvalidModuleSpecifierError(context);
}
async function resolvePackageImports({
  importSpecifier,
  importer,
  moduleDirs,
  conditions,
  resolveId: resolveId2
}) {
  const result = await findPackageJson(importer, moduleDirs);
  if (!result) {
    throw new Error(createBaseErrorMsg(". Could not find a parent package.json."));
  }
  const { pkgPath, pkgJsonPath, pkgJson } = result;
  const pkgURL = (0, import_url.pathToFileURL)(`${pkgPath}/`);
  const context = {
    importer,
    importSpecifier,
    moduleDirs,
    pkgURL,
    pkgJsonPath,
    conditions,
    resolveId: resolveId2
  };
  const { imports } = pkgJson;
  if (!imports) {
    throw new InvalidModuleSpecifierError(context, true);
  }
  if (importSpecifier === "#" || importSpecifier.startsWith("#/")) {
    throw new InvalidModuleSpecifierError(context, true, "Invalid import specifier.");
  }
  return resolvePackageImportsExports(context, {
    matchKey: importSpecifier,
    matchObj: imports,
    internal: true
  });
}
var resolveImportPath = (0, import_util.promisify)(import_resolve.default);
var readFile = (0, import_util.promisify)(import_fs2.default.readFile);
async function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {
  if (importer) {
    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);
    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {
      return selfPackageJsonResult;
    }
  }
  try {
    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);
    const pkgJson = JSON.parse(await readFile(pkgJsonPath, "utf-8"));
    return { pkgJsonPath, pkgJson, pkgPath: (0, import_path3.dirname)(pkgJsonPath) };
  } catch (_) {
    return null;
  }
}
async function resolveIdClassic({
  importSpecifier,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  let hasModuleSideEffects = () => null;
  let hasPackageEntry = true;
  let packageBrowserField = false;
  let packageInfo;
  const filter = (pkg, pkgPath) => {
    const info = getPackageInfo({
      cache: packageInfoCache,
      extensions,
      pkg,
      pkgPath,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      rootDir,
      ignoreSideEffectsForRoot
    });
    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);
    return info.cachedPkg;
  };
  const resolveOptions = {
    basedir: baseDir,
    readFile: readCachedFile,
    isFile: isFileCached,
    isDirectory: isDirCached,
    extensions,
    includeCoreModules: false,
    moduleDirectory: moduleDirectories,
    preserveSymlinks,
    packageFilter: filter
  };
  let location;
  try {
    location = await resolveImportPath(importSpecifier, resolveOptions);
  } catch (error2) {
    if (error2.code !== "MODULE_NOT_FOUND") {
      throw error2;
    }
    return null;
  }
  return {
    location: preserveSymlinks ? location : await resolveSymlink(location),
    hasModuleSideEffects,
    hasPackageEntry,
    packageBrowserField,
    packageInfo
  };
}
async function resolveWithExportMap({
  importer,
  importSpecifier,
  exportConditions,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  if (importSpecifier.startsWith("#")) {
    const resolveResult = await resolvePackageImports({
      importSpecifier,
      importer,
      moduleDirs: moduleDirectories,
      conditions: exportConditions,
      resolveId(id) {
        return resolveIdClassic({
          importSpecifier: id,
          packageInfoCache,
          extensions,
          mainFields,
          preserveSymlinks,
          useBrowserOverrides,
          baseDir,
          moduleDirectories
        });
      }
    });
    const location = (0, import_url.fileURLToPath)(resolveResult);
    return {
      location: preserveSymlinks ? location : await resolveSymlink(location),
      hasModuleSideEffects: () => null,
      hasPackageEntry: true,
      packageBrowserField: false,
      packageInfo: void 0
    };
  }
  const pkgName = getPackageName(importSpecifier);
  if (pkgName) {
    let hasModuleSideEffects = () => null;
    let hasPackageEntry = true;
    let packageBrowserField = false;
    let packageInfo;
    const filter = (pkg, pkgPath) => {
      const info = getPackageInfo({
        cache: packageInfoCache,
        extensions,
        pkg,
        pkgPath,
        mainFields,
        preserveSymlinks,
        useBrowserOverrides,
        rootDir,
        ignoreSideEffectsForRoot
      });
      ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);
      return info.cachedPkg;
    };
    const resolveOptions = {
      basedir: baseDir,
      readFile: readCachedFile,
      isFile: isFileCached,
      isDirectory: isDirCached,
      extensions,
      includeCoreModules: false,
      moduleDirectory: moduleDirectories,
      preserveSymlinks,
      packageFilter: filter
    };
    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);
    if (result && result.pkgJson.exports) {
      const { pkgJson, pkgJsonPath } = result;
      const subpath = pkgName === importSpecifier ? "." : `.${importSpecifier.substring(pkgName.length)}`;
      const pkgDr = pkgJsonPath.replace("package.json", "");
      const pkgURL = (0, import_url.pathToFileURL)(pkgDr);
      const context = {
        importer,
        importSpecifier,
        moduleDirs: moduleDirectories,
        pkgURL,
        pkgJsonPath,
        conditions: exportConditions
      };
      const resolvedPackageExport = await resolvePackageExports(context, subpath, pkgJson.exports);
      const location = (0, import_url.fileURLToPath)(resolvedPackageExport);
      if (location) {
        return {
          location: preserveSymlinks ? location : await resolveSymlink(location),
          hasModuleSideEffects,
          hasPackageEntry,
          packageBrowserField,
          packageInfo
        };
      }
    }
  }
  return null;
}
async function resolveWithClassic({
  importer,
  importSpecifierList,
  exportConditions,
  warn,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  for (let i = 0; i < importSpecifierList.length; i++) {
    const result = await resolveIdClassic({
      importer,
      importSpecifier: importSpecifierList[i],
      exportConditions,
      warn,
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      rootDir,
      ignoreSideEffectsForRoot
    });
    if (result) {
      return result;
    }
  }
  return null;
}
async function resolveImportSpecifiers({
  importer,
  importSpecifierList,
  exportConditions,
  warn,
  packageInfoCache,
  extensions,
  mainFields,
  preserveSymlinks,
  useBrowserOverrides,
  baseDir,
  moduleDirectories,
  rootDir,
  ignoreSideEffectsForRoot
}) {
  try {
    const exportMapRes = await resolveWithExportMap({
      importer,
      importSpecifier: importSpecifierList[0],
      exportConditions,
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      rootDir,
      ignoreSideEffectsForRoot
    });
    if (exportMapRes)
      return exportMapRes;
  } catch (error2) {
    if (error2 instanceof ResolveError) {
      warn(error2);
      return null;
    }
    throw error2;
  }
  return resolveWithClassic({
    importer,
    importSpecifierList,
    exportConditions,
    warn,
    packageInfoCache,
    extensions,
    mainFields,
    preserveSymlinks,
    useBrowserOverrides,
    baseDir,
    moduleDirectories,
    rootDir,
    ignoreSideEffectsForRoot
  });
}
var builtins3 = new Set(import_builtin_modules.default);
var ES6_BROWSER_EMPTY = "\0node-resolve:empty.js";
var deepFreeze = (object) => {
  Object.freeze(object);
  for (const value of Object.values(object)) {
    if (typeof value === "object" && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  }
  return object;
};
var baseConditions = ["default", "module"];
var baseConditionsEsm = [...baseConditions, "import"];
var baseConditionsCjs = [...baseConditions, "require"];
var defaults = {
  dedupe: [],
  extensions: [".mjs", ".js", ".json", ".node"],
  resolveOnly: [],
  moduleDirectories: ["node_modules"],
  ignoreSideEffectsForRoot: false
};
var DEFAULTS = deepFreeze((0, import_deepmerge.default)({}, defaults));
function nodeResolve(opts = {}) {
  const { warnings } = handleDeprecatedOptions(opts);
  const options = { ...defaults, ...opts };
  const { extensions, jail, moduleDirectories, ignoreSideEffectsForRoot } = options;
  const conditionsEsm = [...baseConditionsEsm, ...options.exportConditions || []];
  const conditionsCjs = [...baseConditionsCjs, ...options.exportConditions || []];
  const packageInfoCache = /* @__PURE__ */ new Map();
  const idToPackageInfo = /* @__PURE__ */ new Map();
  const mainFields = getMainFields(options);
  const useBrowserOverrides = mainFields.indexOf("browser") !== -1;
  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;
  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;
  const rootDir = (0, import_path3.resolve)(options.rootDir || process.cwd());
  let { dedupe } = options;
  let rollupOptions;
  if (typeof dedupe !== "function") {
    dedupe = (importee) => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));
  }
  const resolveOnly = options.resolveOnly.map((pattern) => {
    if (pattern instanceof RegExp) {
      return pattern;
    }
    const normalized = pattern.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
    return new RegExp(`^${normalized}$`);
  });
  const browserMapCache = /* @__PURE__ */ new Map();
  let preserveSymlinks;
  const doResolveId = async (context, importee, importer, custom) => {
    const [importPath, params] = importee.split("?");
    const importSuffix = `${params ? `?${params}` : ""}`;
    importee = importPath;
    const baseDir = !importer || dedupe(importee) ? rootDir : (0, import_path3.dirname)(importer);
    const browser = browserMapCache.get(importer);
    if (useBrowserOverrides && browser) {
      const resolvedImportee = (0, import_path3.resolve)(baseDir, importee);
      if (browser[importee] === false || browser[resolvedImportee] === false) {
        return { id: ES6_BROWSER_EMPTY };
      }
      const browserImportee = importee[0] !== "." && browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];
      if (browserImportee) {
        importee = browserImportee;
      }
    }
    const parts = importee.split(/[/\\]/);
    let id = parts.shift();
    let isRelativeImport = false;
    if (id[0] === "@" && parts.length > 0) {
      id += `/${parts.shift()}`;
    } else if (id[0] === ".") {
      id = (0, import_path3.resolve)(baseDir, importee);
      isRelativeImport = true;
    }
    if (!isRelativeImport && resolveOnly.length && !resolveOnly.some((pattern) => pattern.test(id))) {
      if (normalizeInput(rollupOptions.input).includes(importee)) {
        return null;
      }
      return false;
    }
    const importSpecifierList = [importee];
    if (importer === void 0 && !importee[0].match(/^\.?\.?\//)) {
      importSpecifierList.push(`./${importee}`);
    }
    if (importer && importee.endsWith(".js")) {
      for (const ext of [".ts", ".tsx"]) {
        if (importer.endsWith(ext) && extensions.includes(ext)) {
          importSpecifierList.push(importee.replace(/.js$/, ext));
        }
      }
    }
    const warn = (...args) => context.warn(...args);
    const isRequire = custom && custom["node-resolve"] && custom["node-resolve"].isRequire;
    const exportConditions = isRequire ? conditionsCjs : conditionsEsm;
    if (useBrowserOverrides && !exportConditions.includes("browser"))
      exportConditions.push("browser");
    const resolvedWithoutBuiltins = await resolveImportSpecifiers({
      importer,
      importSpecifierList,
      exportConditions,
      warn,
      packageInfoCache,
      extensions,
      mainFields,
      preserveSymlinks,
      useBrowserOverrides,
      baseDir,
      moduleDirectories,
      rootDir,
      ignoreSideEffectsForRoot
    });
    const importeeIsBuiltin = builtins3.has(importee);
    const resolved = importeeIsBuiltin && preferBuiltins ? {
      packageInfo: void 0,
      hasModuleSideEffects: () => null,
      hasPackageEntry: true,
      packageBrowserField: false
    } : resolvedWithoutBuiltins;
    if (!resolved) {
      return null;
    }
    const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;
    let { location } = resolved;
    if (packageBrowserField) {
      if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {
        if (!packageBrowserField[location]) {
          browserMapCache.set(location, packageBrowserField);
          return { id: ES6_BROWSER_EMPTY };
        }
        location = packageBrowserField[location];
      }
      browserMapCache.set(location, packageBrowserField);
    }
    if (hasPackageEntry && !preserveSymlinks) {
      const exists = await fileExists(location);
      if (exists) {
        location = await realpath(location);
      }
    }
    idToPackageInfo.set(location, packageInfo);
    if (hasPackageEntry) {
      if (importeeIsBuiltin && preferBuiltins) {
        if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {
          context.warn(
            `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`
          );
        }
        return false;
      } else if (jail && location.indexOf((0, import_path3.normalize)(jail.trim(import_path3.sep))) !== 0) {
        return null;
      }
    }
    if (options.modulesOnly && await fileExists(location)) {
      const code = await readFile$1(location, "utf-8");
      if ((0, import_is_module.default)(code)) {
        return {
          id: `${location}${importSuffix}`,
          moduleSideEffects: hasModuleSideEffects(location)
        };
      }
      return null;
    }
    return {
      id: `${location}${importSuffix}`,
      moduleSideEffects: hasModuleSideEffects(location)
    };
  };
  return {
    name: "node-resolve",
    version: version2,
    buildStart(options2) {
      rollupOptions = options2;
      for (const warning of warnings) {
        this.warn(warning);
      }
      ({ preserveSymlinks } = options2);
    },
    generateBundle() {
      readCachedFile.clear();
      isFileCached.clear();
      isDirCached.clear();
    },
    async resolveId(importee, importer, resolveOptions) {
      if (importee === ES6_BROWSER_EMPTY) {
        return importee;
      }
      if (/\0/.test(importee))
        return null;
      if (/\0/.test(importer)) {
        importer = void 0;
      }
      const resolved = await doResolveId(this, importee, importer, resolveOptions.custom);
      if (resolved) {
        const resolvedResolved = await this.resolve(
          resolved.id,
          importer,
          Object.assign({ skipSelf: true }, resolveOptions)
        );
        if (resolvedResolved) {
          if (resolvedResolved.external) {
            return false;
          }
          return { ...resolved, meta: resolvedResolved.meta };
        }
      }
      return resolved;
    },
    load(importee) {
      if (importee === ES6_BROWSER_EMPTY) {
        return "export default {};";
      }
      return null;
    },
    getPackageInfoForId(id) {
      return idToPackageInfo.get(id);
    }
  };
}

// plugins/public/reactdevtools/serverAddOn.tsx
var import_plugin_commonjs = __toESM(require_dist());
var DEV_TOOLS_PORT = 8097;
async function findGlobalDevTools(flipperServer) {
  try {
    const { stdout: basePath } = await flipperServer.exec(
      "node-api-exec",
      "npm root -g"
    );
    console.debug(
      "flipper-plugin-react-devtools.findGlobalDevTools -> npm root",
      basePath
    );
    const devToolsPath = import_path4.default.join(
      basePath.trim(),
      "react-devtools-inline",
      "frontend.js"
    );
    await flipperServer.exec("node-api-fs-stat", devToolsPath);
    return devToolsPath;
  } catch (error2) {
    console.warn(`Failed to find globally installed React DevTools: ${error2}`);
    return void 0;
  }
}
var serverAddOn = async (connection, { flipperServer }) => {
  console.debug("flipper-plugin-react-devtools.serverAddOn -> starting");
  const startServer = async () => {
    console.debug("flipper-plugin-react-devtools.serverAddOn -> startServer");
    const wss2 = new import_websocket_server.default({ port: DEV_TOOLS_PORT });
    const startedPromise = (0, import_flipper_plugin.createControlledPromise)();
    wss2.on("listening", () => startedPromise.resolve());
    wss2.on("error", (err) => {
      if (startedPromise.state === "pending") {
        startedPromise.reject(err);
        return;
      }
      console.error("flipper-plugin-react-devtools.serverAddOn -> error", err);
    });
    await startedPromise.promise;
    console.debug(
      "flipper-plugin-react-devtools.serverAddOn -> started server"
    );
    wss2.on("connection", (ws) => {
      connection.send("connected");
      console.debug(
        "flipper-plugin-react-devtools.serverAddOn -> connected a client"
      );
      ws.on("message", (data2) => {
        connection.send("message", JSON.parse(data2.toString()));
        console.debug(
          "flipper-plugin-react-devtools.serverAddOn -> client sent a message",
          data2.toString()
        );
      });
      ws.on("error", (err) => {
        console.error(
          "flipper-plugin-react-devtools.serverAddOn -> client error",
          err
        );
      });
      ws.on("close", () => {
        connection.send("disconnected");
        console.debug(
          "flipper-plugin-react-devtools.serverAddOn -> client left"
        );
      });
    });
    connection.receive("message", (data2) => {
      console.debug(
        "flipper-plugin-react-devtools.serverAddOn -> desktop sent a message",
        data2
      );
      wss2.clients.forEach((ws) => {
        if (ws.readyState === import_websocket.default.OPEN) {
          ws.send(JSON.stringify(data2));
        }
      });
    });
    return wss2;
  };
  const wss = await startServer();
  connection.receive("globalDevTools", async () => {
    const globalDevToolsPath = await findGlobalDevTools(flipperServer);
    if (!globalDevToolsPath) {
      console.info(
        "flipper-plugin-react-devtools.serverAddOn -> not found global React DevTools"
      );
      return;
    }
    console.info(
      "flipper-plugin-react-devtools.serverAddOn -> found global React DevTools: ",
      globalDevToolsPath
    );
    const bundle = await rollup({
      input: globalDevToolsPath,
      plugins: [nodeResolve(), (0, import_plugin_commonjs.default)()],
      external: ["react", "react-is", "react-dom/client", "react-dom"]
    });
    try {
      const { output } = await bundle.generate({
        format: "iife",
        globals: {
          react: "global.React",
          "react-is": "global.ReactIs",
          "react-dom/client": "global.ReactDOMClient",
          "react-dom": "global.ReactDOM"
        }
      });
      return output[0].code;
    } finally {
      await bundle.close();
    }
  });
  return async () => {
    console.debug("flipper-plugin-react-devtools.serverAddOn -> stopping");
    if (wss) {
      console.debug(
        "flipper-plugin-react-devtools.serverAddOn -> stopping wss"
      );
      await new Promise(
        (resolve4, reject) => wss.close((err) => err ? reject(err) : resolve4())
      );
      console.debug("flipper-plugin-react-devtools.serverAddOn -> stopped wss");
    }
  };
};
var serverAddOn_default = serverAddOn;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*
  @license
	Rollup.js v2.70.1
	Mon, 14 Mar 2022 05:50:08 GMT - commit b8315e03f9790d610a413316fbf6d565f9340cab

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC9kaXN0L2VzL3NoYXJlZC9yb2xsdXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2J1aWx0aW4tbW9kdWxlcy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pcy1tb2R1bGUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2hvbWVkaXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2NhbGxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcGF0aC1wYXJzZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS9saWIvbm9kZS1tb2R1bGVzLXBhdGhzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9ub3JtYWxpemUtb3B0aW9ucy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaXMtY29yZS1tb2R1bGUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc29sdmUvbGliL2FzeW5jLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9jb3JlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9pcy1jb3JlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlL2xpYi9zeW5jLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yZXNvbHZlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL2NvbnN0YW50cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi91dGlscy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9zY2FuLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BhcnNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9waWNvbWF0Y2gvbGliL3BpY29tYXRjaC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcGljb21hdGNoL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbnV0aWxzL2Rpc3QvY2pzL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb21tb25kaXIvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLnJlYWxwYXRoL29sZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvZnMucmVhbHBhdGgvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmNhdC1tYXAvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2JhbGFuY2VkLW1hdGNoL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9taW5pbWF0Y2guanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wYXRoLWlzLWFic29sdXRlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbi1jb21tb25qcy9ub2RlX21vZHVsZXMvZ2xvYi9jb21tb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL25vZGVfbW9kdWxlcy9nbG9iL3N5bmMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvaW5mbGlnaHQvaW5mbGlnaHQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL25vZGVfbW9kdWxlcy9nbG9iL2dsb2IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2VzdHJlZS13YWxrZXIvZGlzdC91bWQvZXN0cmVlLXdhbGtlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc291cmNlbWFwLWNvZGVjL3NyYy9zb3VyY2VtYXAtY29kZWMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvQml0U2V0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tYWdpYy1zdHJpbmcvc3JjL0NodW5rLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9tYWdpYy1zdHJpbmcvc3JjL1NvdXJjZU1hcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9ndWVzc0luZGVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9nZXRSZWxhdGl2ZVBhdGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvdXRpbHMvaXNPYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvdXRpbHMvZ2V0TG9jYXRvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy91dGlscy9NYXBwaW5ncy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy9NYWdpY1N0cmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbWFnaWMtc3RyaW5nL3NyYy9CdW5kbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL21hZ2ljLXN0cmluZy9zcmMvaW5kZXgtbGVnYWN5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9pcy1yZWZlcmVuY2UvZGlzdC9pcy1yZWZlcmVuY2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9wYXJzZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHJvbGx1cC9wbHVnaW4tY29tbW9uanMvc3JjL2FuYWx5emUtdG9wLWxldmVsLXN0YXRlbWVudHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9oZWxwZXJzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbi1jb21tb25qcy9zcmMvdXRpbHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9keW5hbWljLXBhY2thZ2VzLW1hbmFnZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9keW5hbWljLXJlcXVpcmUtcGF0aHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9pcy1janMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9wcm94aWVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbi1jb21tb25qcy9zcmMvcmVzb2x2ZS1pZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHJvbGx1cC9wbHVnaW4tY29tbW9uanMvc3JjL3JvbGx1cC12ZXJzaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbi1jb21tb25qcy9zcmMvYXN0LXV0aWxzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbi1jb21tb25qcy9zcmMvZ2VuZXJhdGUtZXhwb3J0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHJvbGx1cC9wbHVnaW4tY29tbW9uanMvc3JjL2dlbmVyYXRlLWltcG9ydHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy90cmFuc2Zvcm0tY29tbW9uanMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLWNvbW1vbmpzL3NyYy9pbmRleC5qcyIsICIuLi9zZXJ2ZXJBZGRPbi50c3giLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9yb2xsdXAvZGlzdC9lcy9yb2xsdXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Byb2xsdXAvcGx1Z2luLW5vZGUtcmVzb2x2ZS9kaXN0L2VzL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9Acm9sbHVwL3BsdWdpbnV0aWxzL2Rpc3QvZXMvaW5kZXguanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG5cbiAgICBpZiAoIWR1cGxleC5wdXNoKGRhdGEpKSB3cy5wYXVzZSgpO1xuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IGB3cy50ZXJtaW5hdGUoKWAgZnJvbSBiZWluZyBjYWxsZWQgYnkgYGR1cGxleC5fZGVzdHJveSgpYC5cbiAgICAvL1xuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cbiAgICAvLyAgIGB3cy50ZXJtaW5hdGUoKWAgaXMgYSBub29wIGFzIG5vIHNvY2tldCBpcyBhc3NpZ25lZC5cbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxuICAgIC8vICAgY29ubmVjdGlvbiBieSBjYWxsaW5nIGB3cy5jbG9zZSgpYC4gVGhpcyBhbGxvd3MgYSBjbG9zZSBmcmFtZSB0byBiZVxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcblxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgYnVmZmVycyBpbnRvIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBhcnJheSBvZiBidWZmZXJzIHRvIGNvbmNhdFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoIFRoZSB0b3RhbCBsZW5ndGggb2YgYnVmZmVycyBpbiB0aGUgbGlzdFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgcmVzdWx0aW5nIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25jYXQobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldHVybiBsaXN0WzBdO1xuXG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ1ZiA9IGxpc3RbaV07XG4gICAgdGFyZ2V0LnNldChidWYsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHJldHVybiB0YXJnZXQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzb3VyY2UgVGhlIGJ1ZmZlciB0byBtYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdXRwdXQgVGhlIGJ1ZmZlciB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIG1hc2suXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBVbm1hc2tzIGEgYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBtYXNrLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byB1bm1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG50cnkge1xuICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLm1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9LFxuICAgIHRvQXJyYXlCdWZmZXIsXG4gICAgdG9CdWZmZXIsXG4gICAgdW5tYXNrKGJ1ZmZlciwgbWFzaykge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMikgX3VubWFzayhidWZmZXIsIG1hc2spO1xuICAgICAgZWxzZSBidWZmZXJVdGlsLnVubWFzayhidWZmZXIsIG1hc2spO1xuICAgIH1cbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2s6IF9tYXNrLFxuICAgIHRvQXJyYXlCdWZmZXIsXG4gICAgdG9CdWZmZXIsXG4gICAgdW5tYXNrOiBfdW5tYXNrXG4gIH07XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSBkYXRhID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIDQpO1xuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudHJ5IHtcbiAgY29uc3QgaXNWYWxpZFVURjggPSByZXF1aXJlKCd1dGYtOC12YWxpZGF0ZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4KGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAxNTAgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfSxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59IGNhdGNoIChlKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gICAgdG9rZW5DaGFyc1xuICB9O1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIGxldCBlcnI7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBgSU5GTEFUSU5HYFxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBjYihlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiIsICIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFzaztcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgc2tpcE1hc2tpbmcgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLm1hc2spIHtcbiAgICAgIG1hc2sgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcblxuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKG1hc2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZG9tRmlsbFN5bmMobWFzaywgMCwgNCk7XG4gICAgICB9XG5cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xuICAgICAgb2Zmc2V0ID0gNjtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICByZWFkT25seSxcbiAgICAgICAgcnN2MVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICAgICAgb3Bjb2RlLFxuICAgICAgICAgIHJlYWRPbmx5LFxuICAgICAgICAgIHJzdjE6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICBjYlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWVbaV07XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGtGb3JPbkV2ZW50QXR0cmlidXRlLCBrTGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtDb2RlID0gU3ltYm9sKCdrQ29kZScpO1xuY29uc3Qga0RhdGEgPSBTeW1ib2woJ2tEYXRhJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2tFcnJvcicpO1xuY29uc3Qga01lc3NhZ2UgPSBTeW1ib2woJ2tNZXNzYWdlJyk7XG5jb25zdCBrUmVhc29uID0gU3ltYm9sKCdrUmVhc29uJyk7XG5jb25zdCBrVGFyZ2V0ID0gU3ltYm9sKCdrVGFyZ2V0Jyk7XG5jb25zdCBrVHlwZSA9IFN5bWJvbCgna1R5cGUnKTtcbmNvbnN0IGtXYXNDbGVhbiA9IFN5bWJvbCgna1dhc0NsZWFuJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICovXG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGB0eXBlYCBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpc1trVGFyZ2V0XSA9IG51bGw7XG4gICAgdGhpc1trVHlwZV0gPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba1R5cGVdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0YXJnZXQnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndHlwZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29kZT0wXSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbj0nJ10gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHlcbiAgICogICAgIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trQ29kZV0gPSBvcHRpb25zLmNvZGUgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmNvZGU7XG4gICAgdGhpc1trUmVhc29uXSA9IG9wdGlvbnMucmVhc29uID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMucmVhc29uO1xuICAgIHRoaXNba1dhc0NsZWFuXSA9IG9wdGlvbnMud2FzQ2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy53YXNDbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NvZGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzW2tSZWFzb25dO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHdhc0NsZWFuKCkge1xuICAgIHJldHVybiB0aGlzW2tXYXNDbGVhbl07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnY29kZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3JlYXNvbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3dhc0NsZWFuJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBlcnJvciBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmVycm9yPW51bGxdIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlPScnXSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzW2tNZXNzYWdlXSA9IG9wdGlvbnMubWVzc2FnZSA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXNba01lc3NhZ2VdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ2Vycm9yJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnbWVzc2FnZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtZXNzYWdlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmRhdGE9bnVsbF0gVGhlIG1lc3NhZ2UgY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tEYXRhXSA9IG9wdGlvbnMuZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzW2tEYXRhXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgJ2RhdGEnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGxpc3RlbmVyO1xuXG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgdGhpcy5vbmNlKHR5cGUsIHdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG4gICAgICBpZiAobGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBFdmVudCxcbiAgRXZlbnRUYXJnZXQsXG4gIE1lc3NhZ2VFdmVudFxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeUmVhZGFibGUkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAqIHJlcXVpcmVkIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCJcbiAgICogdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbltcbiAgJ2JpbmFyeVR5cGUnLFxuICAnYnVmZmVyZWRBbW91bnQnLFxuICAnZXh0ZW5zaW9ucycsXG4gICdpc1BhdXNlZCcsXG4gICdwcm90b2NvbCcsXG4gICdyZWFkeVN0YXRlJyxcbiAgJ3VybCdcbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcblxuLy9cbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cbi8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4vL1xuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcy5ocmVmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuX3VybCA9IGFkZHJlc3M7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xuICBjb25zdCBpc1VuaXhTb2NrZXQgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG4gIGxldCBpbnZhbGlkVVJMTWVzc2FnZTtcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzVW5peFNvY2tldCkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgb3IgXCJ3cyt1bml4OlwiJztcbiAgfSBlbHNlIGlmIChpc1VuaXhTb2NrZXQgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVVJMTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVVJMTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgZ2V0ID0gaXNTZWN1cmUgPyBodHRwcy5nZXQgOiBodHRwLmdldDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0O1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnLFxuICAgIC4uLm9wdHMuaGVhZGVyc1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0ID0gcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaG9zdCAhPT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3QpIHtcbiAgICAgIC8vXG4gICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cbiAgICAgIC8vXG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcbiAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVxID0gKHdlYnNvY2tldC5fcmVxID0gZ2V0KG9wdHMpKTtcblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxLmFib3J0ZWQpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuXG4gICAgaWYgKHN0cmVhbS5zb2NrZXQgJiYgIXN0cmVhbS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAvL1xuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgY29tcGxldGVkLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxuICAgICAgLy9cbiAgICAgIHN0cmVhbS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdhYm9ydCcsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5wb25nKGRhdGEsICF3ZWJzb2NrZXQuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgbGV0IGNodW5rO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cbiAgLy9cbiAgaWYgKFxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXG4gICkge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG5cbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcblxuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzLmVuZCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cbiAgaWYgKHdlYnNvY2tldCkge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJebmV0fHRsc3xodHRwcyRcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qgc3VicHJvdG9jb2wgPSByZXF1aXJlKCcuL3N1YnByb3RvY29sJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG5jb25zdCBSVU5OSU5HID0gMDtcbmNvbnN0IENMT1NJTkcgPSAxO1xuY29uc3QgQ0xPU0VEID0gMjtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcbiAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnRUcmFja2luZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXSBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaG9zdF0gVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICAgKiAgICAgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vU2VydmVyPWZhbHNlXSBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxuICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPWZhbHNlXSBFbmFibGUvZGlzYWJsZVxuICAgKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3J0XSBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHsoaHR0cC5TZXJ2ZXJ8aHR0cHMuU2VydmVyKX0gW29wdGlvbnMuc2VydmVyXSBBIHByZS1jcmVhdGVkIEhUVFAvU1xuICAgKiAgICAgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZlcmlmeUNsaWVudF0gQSBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5XZWJTb2NrZXQ9V2ViU29ja2V0XSBTcGVjaWZpZXMgdGhlIGBXZWJTb2NrZXRgXG4gICAqICAgICBjbGFzcyB0byB1c2UuIEl0IG11c3QgYmUgdGhlIGBXZWJTb2NrZXRgIGNsYXNzIG9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBmYWxzZSxcbiAgICAgIGhhbmRsZVByb3RvY29sczogbnVsbCxcbiAgICAgIGNsaWVudFRyYWNraW5nOiB0cnVlLFxuICAgICAgdmVyaWZ5Q2xpZW50OiBudWxsLFxuICAgICAgbm9TZXJ2ZXI6IGZhbHNlLFxuICAgICAgYmFja2xvZzogbnVsbCwgLy8gdXNlIGRlZmF1bHQgKDUxMSBhcyBpbXBsZW1lbnRlZCBpbiBuZXQuanMpXG4gICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICBob3N0OiBudWxsLFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIHBvcnQ6IG51bGwsXG4gICAgICBXZWJTb2NrZXQsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmIChcbiAgICAgIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIpIHx8XG4gICAgICAob3B0aW9ucy5wb3J0ICE9IG51bGwgJiYgKG9wdGlvbnMuc2VydmVyIHx8IG9wdGlvbnMubm9TZXJ2ZXIpKSB8fFxuICAgICAgKG9wdGlvbnMuc2VydmVyICYmIG9wdGlvbnMubm9TZXJ2ZXIpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnT25lIGFuZCBvbmx5IG9uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zICcgK1xuICAgICAgICAgICdtdXN0IGJlIHNwZWNpZmllZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XG5cbiAgICAgICAgcmVzLndyaXRlSGVhZCg0MjYsIHtcbiAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXMuZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXJ2ZXIubGlzdGVuKFxuICAgICAgICBvcHRpb25zLnBvcnQsXG4gICAgICAgIG9wdGlvbnMuaG9zdCxcbiAgICAgICAgb3B0aW9ucy5iYWNrbG9nLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VydmVyKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VydmVyKSB7XG4gICAgICBjb25zdCBlbWl0Q29ubmVjdGlvbiA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdjb25uZWN0aW9uJyk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IGFkZExpc3RlbmVycyh0aGlzLl9zZXJ2ZXIsIHtcbiAgICAgICAgbGlzdGVuaW5nOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnbGlzdGVuaW5nJyksXG4gICAgICAgIGVycm9yOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSxcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKSBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50VHJhY2tpbmcpIHtcbiAgICAgIHRoaXMuY2xpZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fc3RhdGUgPSBSVU5OSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kIGFkZHJlc3MsIHRoZSBhZGRyZXNzIGZhbWlseSBuYW1lLCBhbmQgcG9ydCBvZiB0aGUgc2VydmVyXG4gICAqIGFzIHJlcG9ydGVkIGJ5IHRoZSBvcGVyYXRpbmcgc3lzdGVtIGlmIGxpc3RlbmluZyBvbiBhbiBJUCBzb2NrZXQuXG4gICAqIElmIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIGEgcGlwZSBvciBVTklYIGRvbWFpbiBzb2NrZXQsIHRoZSBuYW1lIGlzXG4gICAqIHJldHVybmVkIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gVGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBvcGVyYXRpbmcgaW4gXCJub1NlcnZlclwiIG1vZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCB0aGUgc2VydmVyIGZyb20gYWNjZXB0aW5nIG5ldyBjb25uZWN0aW9ucyBhbmQgZW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIHdoZW4gYWxsIGV4aXN0aW5nIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjYikge1xuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0VEKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TSU5HKSByZXR1cm47XG4gICAgdGhpcy5fc3RhdGUgPSBDTE9TSU5HO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlciB8fCB0aGlzLm9wdGlvbnMuc2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5fc2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXI7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcblxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBIVFRQL1Mgc2VydmVyIHdhcyBjcmVhdGVkIGludGVybmFsbHkuIENsb3NlIGl0LCBhbmQgcmVseSBvbiBpdHNcbiAgICAgIC8vIGAnY2xvc2UnYCBldmVudC5cbiAgICAgIC8vXG4gICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4ge1xuICAgICAgICBlbWl0Q2xvc2UodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoJz8nKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuXG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgY29uc3Qga2V5ID1cbiAgICAgIHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXVxuICAgICAgICA6IGZhbHNlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcgfHxcbiAgICAgICFrZXkgfHxcbiAgICAgICFrZXlSZWdleC50ZXN0KGtleSkgfHxcbiAgICAgICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB8fFxuICAgICAgIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSlcbiAgICApIHtcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnXTtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgIHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9mZmVycyA9IGV4dGVuc2lvbi5wYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcblxuICAgICAgICBpZiAob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBjbGllbnQgdmVyaWZpY2F0aW9uIGhhbmRsZXIuXG4gICAgLy9cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOlxuICAgICAgICAgIHJlcS5oZWFkZXJzW2Ake3ZlcnNpb24gPT09IDggPyAnc2VjLXdlYnNvY2tldC1vcmlnaW4nIDogJ29yaWdpbid9YF0sXG4gICAgICAgIHNlY3VyZTogISEocmVxLnNvY2tldC5hdXRob3JpemVkIHx8IHJlcS5zb2NrZXQuZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoXG4gICAgICAgICAgICBleHRlbnNpb25zLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcHJvdG9jb2xzLFxuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIGNiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgYWNjZXB0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcbiAgICogQHBhcmFtIHtTZXR9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSBzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgLy9cbiAgICAvLyBEZXN0cm95IHRoZSBzb2NrZXQgaWYgdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBzZW50IGEgRklOIHBhY2tldC5cbiAgICAvL1xuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgaWYgKHNvY2tldFtrV2ViU29ja2V0XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnc2VydmVyLmhhbmRsZVVwZ3JhZGUoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgJyArXG4gICAgICAgICAgJ3NvY2tldCwgcG9zc2libHkgZHVlIHRvIGEgbWlzY29uZmlndXJhdGlvbidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID4gUlVOTklORykgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNTAzKTtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXQnLFxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXG4gICAgXTtcblxuICAgIGNvbnN0IHdzID0gbmV3IHRoaXMub3B0aW9ucy5XZWJTb2NrZXQobnVsbCk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IHRoaXMub3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudHMuZGVsZXRlKHdzKTtcblxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkRW1pdENsb3NlICYmICF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2Iod3MsIHJlcSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTZXJ2ZXI7XG5cbi8qKlxuICogQWRkIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBgRXZlbnRFbWl0dGVyYCB1c2luZyBhIG1hcCBvZiA8ZXZlbnQsIGxpc3RlbmVyPlxuICogcGFpcnMuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHBhcmFtIHtPYmplY3QuPFN0cmluZywgRnVuY3Rpb24+fSBtYXAgVGhlIGxpc3RlbmVycyB0byBhZGRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFkZGVkIGxpc3RlbmVycyB3aGVuXG4gKiAgICAgY2FsbGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcbiAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSBzZXJ2ZXIub24oZXZlbnQsIG1hcFtldmVudF0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCdjbG9zZSdgIGV2ZW50IG9uIGFuIGBFdmVudEVtaXR0ZXJgLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzZXJ2ZXIpIHtcbiAgc2VydmVyLl9zdGF0ZSA9IENMT1NFRDtcbiAgc2VydmVyLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogSGFuZGxlIHByZW1hdHVyZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBUaGUgSFRUUCByZXNwb25zZSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW2hlYWRlcnNdIEFkZGl0aW9uYWwgSFRUUCByZXNwb25zZSBoZWFkZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcbiAgaWYgKHNvY2tldC53cml0YWJsZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICAgIGhlYWRlcnMgPSB7XG4gICAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfTtcblxuICAgIHNvY2tldC53cml0ZShcbiAgICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgICAgLm1hcCgoaCkgPT4gYCR7aH06ICR7aGVhZGVyc1toXX1gKVxuICAgICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgICAgbWVzc2FnZVxuICAgICk7XG4gIH1cblxuICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHNvY2tldC5kZXN0cm95KCk7XG59XG4iLCAiLypcbiAgQGxpY2Vuc2Vcblx0Um9sbHVwLmpzIHYyLjcwLjFcblx0TW9uLCAxNCBNYXIgMjAyMiAwNTo1MDowOCBHTVQgLSBjb21taXQgYjgzMTVlMDNmOTc5MGQ2MTBhNDEzMzE2ZmJmNmQ1NjVmOTM0MGNhYlxuXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmltcG9ydCByZXF1aXJlJCQwLCB7IHJlc29sdmUsIGV4dG5hbWUsIGJhc2VuYW1lLCBkaXJuYW1lLCByZWxhdGl2ZSBhcyByZWxhdGl2ZSQxLCB3aW4zMiwgcG9zaXgsIGlzQWJzb2x1dGUgYXMgaXNBYnNvbHV0ZSQxIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgcHJvY2VzcyQxIGZyb20gJ3Byb2Nlc3MnO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2UgfSBmcm9tICdwZXJmX2hvb2tzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2ggYXMgY3JlYXRlSGFzaCQxIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IHByb21pc2VzIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxudmFyIHZlcnNpb24kMSA9IFwiMi43MC4xXCI7XG5cbnZhciBjaGFyVG9JbnRlZ2VyID0ge307XG52YXIgY2hhcnMkMSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5mb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGFycyQxLmxlbmd0aDsgaSQxKyspIHtcbiAgICBjaGFyVG9JbnRlZ2VyW2NoYXJzJDEuY2hhckNvZGVBdChpJDEpXSA9IGkkMTtcbn1cbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICAgIHZhciBkZWNvZGVkID0gW107XG4gICAgdmFyIGxpbmUgPSBbXTtcbiAgICB2YXIgc2VnbWVudCA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICBdO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwLCB2YWx1ZSA9IDA7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1hcHBpbmdzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjID09PSA0NCkgeyAvLyBcIixcIlxuICAgICAgICAgICAgc2VnbWVudGlmeShsaW5lLCBzZWdtZW50LCBqKTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IDU5KSB7IC8vIFwiO1wiXG4gICAgICAgICAgICBzZWdtZW50aWZ5KGxpbmUsIHNlZ21lbnQsIGopO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2gobGluZSk7XG4gICAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgICBzZWdtZW50WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnRlZ2VyID0gY2hhclRvSW50ZWdlcltjXTtcbiAgICAgICAgICAgIGlmIChpbnRlZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICgnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFzQ29udGludWF0aW9uQml0ID0gaW50ZWdlciAmIDMyO1xuICAgICAgICAgICAgaW50ZWdlciAmPSAzMTtcbiAgICAgICAgICAgIHZhbHVlICs9IGludGVnZXIgPDwgc2hpZnQ7XG4gICAgICAgICAgICBpZiAoaGFzQ29udGludWF0aW9uQml0KSB7XG4gICAgICAgICAgICAgICAgc2hpZnQgKz0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGROZWdhdGUgPSB2YWx1ZSAmIDE7XG4gICAgICAgICAgICAgICAgdmFsdWUgPj4+PSAxO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGROZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IC0weDgwMDAwMDAwIDogLXZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50W2pdICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNoaWZ0ID0gMDsgLy8gcmVzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWdtZW50aWZ5KGxpbmUsIHNlZ21lbnQsIGopO1xuICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRpZnkobGluZSwgc2VnbWVudCwgaikge1xuICAgIC8vIFRoaXMgbG9va3MgdWdseSwgYnV0IHdlJ3JlIGNyZWF0aW5nIHNwZWNpYWxpemVkIGFycmF5cyB3aXRoIGEgc3BlY2lmaWNcbiAgICAvLyBsZW5ndGguIFRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBhcnJheSAod2hpY2ggdjggZXhwYW5kcyB0b1xuICAgIC8vIGEgY2FwYWNpdHkgb2YgMTcgYWZ0ZXIgcHVzaGluZyB0aGUgZmlyc3QgaXRlbSksIG9yIHNsaWNpbmcgb3V0IGEgc3ViYXJyYXlcbiAgICAvLyAod2hpY2ggaXMgc2xvdykuIExlbmd0aCA0IGlzIGFzc3VtZWQgdG8gYmUgdGhlIG1vc3QgZnJlcXVlbnQsIGZvbGxvd2VkIGJ5XG4gICAgLy8gbGVuZ3RoIDUgKHNpbmNlIG5vdCBldmVyeXRoaW5nIHdpbGwgaGF2ZSBhbiBhc3NvY2lhdGVkIG5hbWUpLCBmb2xsb3dlZCBieVxuICAgIC8vIGxlbmd0aCAxIChpdCdzIHByb2JhYmx5IHJhcmUgZm9yIGEgc291cmNlIHN1YnN0cmluZyB0byBub3QgaGF2ZSBhblxuICAgIC8vIGFzc29jaWF0ZWQgc2VnbWVudCBkYXRhKS5cbiAgICBpZiAoaiA9PT0gNClcbiAgICAgICAgbGluZS5wdXNoKFtzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCBzZWdtZW50WzNdXSk7XG4gICAgZWxzZSBpZiAoaiA9PT0gNSlcbiAgICAgICAgbGluZS5wdXNoKFtzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCBzZWdtZW50WzNdLCBzZWdtZW50WzRdXSk7XG4gICAgZWxzZSBpZiAoaiA9PT0gMSlcbiAgICAgICAgbGluZS5wdXNoKFtzZWdtZW50WzBdXSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoZGVjb2RlZCkge1xuICAgIHZhciBzb3VyY2VGaWxlSW5kZXggPSAwOyAvLyBzZWNvbmQgZmllbGRcbiAgICB2YXIgc291cmNlQ29kZUxpbmUgPSAwOyAvLyB0aGlyZCBmaWVsZFxuICAgIHZhciBzb3VyY2VDb2RlQ29sdW1uID0gMDsgLy8gZm91cnRoIGZpZWxkXG4gICAgdmFyIG5hbWVJbmRleCA9IDA7IC8vIGZpZnRoIGZpZWxkXG4gICAgdmFyIG1hcHBpbmdzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgbWFwcGluZ3MgKz0gJzsnO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwOyAvLyBmaXJzdCBmaWVsZFxuICAgICAgICB2YXIgbGluZU1hcHBpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbGluZV8xID0gbGluZTsgX2kgPCBsaW5lXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IGxpbmVfMVtfaV07XG4gICAgICAgICAgICB2YXIgc2VnbWVudE1hcHBpbmdzID0gZW5jb2RlSW50ZWdlcihzZWdtZW50WzBdIC0gZ2VuZXJhdGVkQ29kZUNvbHVtbik7XG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gc2VnbWVudFswXTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50TWFwcGluZ3MgKz1cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlSW50ZWdlcihzZWdtZW50WzFdIC0gc291cmNlRmlsZUluZGV4KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMl0gLSBzb3VyY2VDb2RlTGluZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlSW50ZWdlcihzZWdtZW50WzNdIC0gc291cmNlQ29kZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgc291cmNlRmlsZUluZGV4ID0gc2VnbWVudFsxXTtcbiAgICAgICAgICAgICAgICBzb3VyY2VDb2RlTGluZSA9IHNlZ21lbnRbMl07XG4gICAgICAgICAgICAgICAgc291cmNlQ29kZUNvbHVtbiA9IHNlZ21lbnRbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50TWFwcGluZ3MgKz0gZW5jb2RlSW50ZWdlcihzZWdtZW50WzRdIC0gbmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBuYW1lSW5kZXggPSBzZWdtZW50WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU1hcHBpbmdzLnB1c2goc2VnbWVudE1hcHBpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwaW5ncyArPSBsaW5lTWFwcGluZ3Muam9pbignLCcpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZ3M7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRlZ2VyKG51bSkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBudW0gPSBudW0gPCAwID8gKC1udW0gPDwgMSkgfCAxIDogbnVtIDw8IDE7XG4gICAgZG8ge1xuICAgICAgICB2YXIgY2xhbXBlZCA9IG51bSAmIDMxO1xuICAgICAgICBudW0gPj4+PSA1O1xuICAgICAgICBpZiAobnVtID4gMCkge1xuICAgICAgICAgICAgY2xhbXBlZCB8PSAzMjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2hhcnMkMVtjbGFtcGVkXTtcbiAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgQml0U2V0ID0gZnVuY3Rpb24gQml0U2V0KGFyZykge1xuXHR0aGlzLmJpdHMgPSBhcmcgaW5zdGFuY2VvZiBCaXRTZXQgPyBhcmcuYml0cy5zbGljZSgpIDogW107XG59O1xuXG5CaXRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobikge1xuXHR0aGlzLmJpdHNbbiA+PiA1XSB8PSAxIDw8IChuICYgMzEpO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKG4pIHtcblx0cmV0dXJuICEhKHRoaXMuYml0c1tuID4+IDVdICYgKDEgPDwgKG4gJiAzMSkpKTtcbn07XG5cbnZhciBDaHVuayQxID0gZnVuY3Rpb24gQ2h1bmsoc3RhcnQsIGVuZCwgY29udGVudCkge1xuXHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdHRoaXMuZW5kID0gZW5kO1xuXHR0aGlzLm9yaWdpbmFsID0gY29udGVudDtcblxuXHR0aGlzLmludHJvID0gJyc7XG5cdHRoaXMub3V0cm8gPSAnJztcblxuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHR0aGlzLnN0b3JlTmFtZSA9IGZhbHNlO1xuXHR0aGlzLmVkaXRlZCA9IGZhbHNlO1xuXG5cdC8vIHdlIG1ha2UgdGhlc2Ugbm9uLWVudW1lcmFibGUsIGZvciBzYW5pdHkgd2hpbGUgZGVidWdnaW5nXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRwcmV2aW91czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSxcblx0XHRuZXh0OiAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuXHR9KTtcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmFwcGVuZExlZnQgPSBmdW5jdGlvbiBhcHBlbmRMZWZ0IChjb250ZW50KSB7XG5cdHRoaXMub3V0cm8gKz0gY29udGVudDtcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmFwcGVuZFJpZ2h0ID0gZnVuY3Rpb24gYXBwZW5kUmlnaHQgKGNvbnRlbnQpIHtcblx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8gKyBjb250ZW50O1xufTtcblxuQ2h1bmskMS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG5cdHZhciBjaHVuayA9IG5ldyBDaHVuayQxKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLm9yaWdpbmFsKTtcblxuXHRjaHVuay5pbnRybyA9IHRoaXMuaW50cm87XG5cdGNodW5rLm91dHJvID0gdGhpcy5vdXRybztcblx0Y2h1bmsuY29udGVudCA9IHRoaXMuY29udGVudDtcblx0Y2h1bmsuc3RvcmVOYW1lID0gdGhpcy5zdG9yZU5hbWU7XG5cdGNodW5rLmVkaXRlZCA9IHRoaXMuZWRpdGVkO1xuXG5cdHJldHVybiBjaHVuaztcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnN0YXJ0IDwgaW5kZXggJiYgaW5kZXggPCB0aGlzLmVuZDtcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmVhY2hOZXh0ID0gZnVuY3Rpb24gZWFjaE5leHQgKGZuKSB7XG5cdHZhciBjaHVuayA9IHRoaXM7XG5cdHdoaWxlIChjaHVuaykge1xuXHRcdGZuKGNodW5rKTtcblx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdH1cbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmVhY2hQcmV2aW91cyA9IGZ1bmN0aW9uIGVhY2hQcmV2aW91cyAoZm4pIHtcblx0dmFyIGNodW5rID0gdGhpcztcblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0Zm4oY2h1bmspO1xuXHRcdGNodW5rID0gY2h1bmsucHJldmlvdXM7XG5cdH1cbn07XG5cbkNodW5rJDEucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChjb250ZW50LCBzdG9yZU5hbWUsIGNvbnRlbnRPbmx5KSB7XG5cdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdGlmICghY29udGVudE9ubHkpIHtcblx0XHR0aGlzLmludHJvID0gJyc7XG5cdFx0dGhpcy5vdXRybyA9ICcnO1xuXHR9XG5cdHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuXG5cdHRoaXMuZWRpdGVkID0gdHJ1ZTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLnByZXBlbmRMZWZ0ID0gZnVuY3Rpb24gcHJlcGVuZExlZnQgKGNvbnRlbnQpIHtcblx0dGhpcy5vdXRybyA9IGNvbnRlbnQgKyB0aGlzLm91dHJvO1xufTtcblxuQ2h1bmskMS5wcm90b3R5cGUucHJlcGVuZFJpZ2h0ID0gZnVuY3Rpb24gcHJlcGVuZFJpZ2h0IChjb250ZW50KSB7XG5cdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGluZGV4KSB7XG5cdHZhciBzbGljZUluZGV4ID0gaW5kZXggLSB0aGlzLnN0YXJ0O1xuXG5cdHZhciBvcmlnaW5hbEJlZm9yZSA9IHRoaXMub3JpZ2luYWwuc2xpY2UoMCwgc2xpY2VJbmRleCk7XG5cdHZhciBvcmlnaW5hbEFmdGVyID0gdGhpcy5vcmlnaW5hbC5zbGljZShzbGljZUluZGV4KTtcblxuXHR0aGlzLm9yaWdpbmFsID0gb3JpZ2luYWxCZWZvcmU7XG5cblx0dmFyIG5ld0NodW5rID0gbmV3IENodW5rJDEoaW5kZXgsIHRoaXMuZW5kLCBvcmlnaW5hbEFmdGVyKTtcblx0bmV3Q2h1bmsub3V0cm8gPSB0aGlzLm91dHJvO1xuXHR0aGlzLm91dHJvID0gJyc7XG5cblx0dGhpcy5lbmQgPSBpbmRleDtcblxuXHRpZiAodGhpcy5lZGl0ZWQpIHtcblx0XHQvLyBUT0RPIGlzIHRoaXMgYmxvY2sgbmVjZXNzYXJ5Py4uLlxuXHRcdG5ld0NodW5rLmVkaXQoJycsIGZhbHNlKTtcblx0XHR0aGlzLmNvbnRlbnQgPSAnJztcblx0fSBlbHNlIHtcblx0XHR0aGlzLmNvbnRlbnQgPSBvcmlnaW5hbEJlZm9yZTtcblx0fVxuXG5cdG5ld0NodW5rLm5leHQgPSB0aGlzLm5leHQ7XG5cdGlmIChuZXdDaHVuay5uZXh0KSB7IG5ld0NodW5rLm5leHQucHJldmlvdXMgPSBuZXdDaHVuazsgfVxuXHRuZXdDaHVuay5wcmV2aW91cyA9IHRoaXM7XG5cdHRoaXMubmV4dCA9IG5ld0NodW5rO1xuXG5cdHJldHVybiBuZXdDaHVuaztcbn07XG5cbkNodW5rJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuXHRyZXR1cm4gdGhpcy5pbnRybyArIHRoaXMuY29udGVudCArIHRoaXMub3V0cm87XG59O1xuXG5DaHVuayQxLnByb3RvdHlwZS50cmltRW5kID0gZnVuY3Rpb24gdHJpbUVuZCAocngpIHtcblx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRpZiAodGhpcy5vdXRyby5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgdHJpbW1lZCA9IHRoaXMuY29udGVudC5yZXBsYWNlKHJ4LCAnJyk7XG5cblx0aWYgKHRyaW1tZWQubGVuZ3RoKSB7XG5cdFx0aWYgKHRyaW1tZWQgIT09IHRoaXMuY29udGVudCkge1xuXHRcdFx0dGhpcy5zcGxpdCh0aGlzLnN0YXJ0ICsgdHJpbW1lZC5sZW5ndGgpLmVkaXQoJycsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHR9XG59O1xuXG5DaHVuayQxLnByb3RvdHlwZS50cmltU3RhcnQgPSBmdW5jdGlvbiB0cmltU3RhcnQgKHJ4KSB7XG5cdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0aWYgKHRoaXMuaW50cm8ubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIHRyaW1tZWQgPSB0aGlzLmNvbnRlbnQucmVwbGFjZShyeCwgJycpO1xuXG5cdGlmICh0cmltbWVkLmxlbmd0aCkge1xuXHRcdGlmICh0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQpIHtcblx0XHRcdHRoaXMuc3BsaXQodGhpcy5lbmQgLSB0cmltbWVkLmxlbmd0aCk7XG5cdFx0XHR0aGlzLmVkaXQoJycsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdGlmICh0aGlzLm91dHJvLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHR9XG59O1xuXG52YXIgYnRvYSA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbnZpcm9ubWVudDogYHdpbmRvdy5idG9hYCBvciBgQnVmZmVyYCBzaG91bGQgYmUgc3VwcG9ydGVkLicpO1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0YnRvYSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7IH07XG59IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcblx0YnRvYSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9O1xufVxuXG52YXIgU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTWFwKHByb3BlcnRpZXMpIHtcblx0dGhpcy52ZXJzaW9uID0gMztcblx0dGhpcy5maWxlID0gcHJvcGVydGllcy5maWxlO1xuXHR0aGlzLnNvdXJjZXMgPSBwcm9wZXJ0aWVzLnNvdXJjZXM7XG5cdHRoaXMuc291cmNlc0NvbnRlbnQgPSBwcm9wZXJ0aWVzLnNvdXJjZXNDb250ZW50O1xuXHR0aGlzLm5hbWVzID0gcHJvcGVydGllcy5uYW1lcztcblx0dGhpcy5tYXBwaW5ncyA9IGVuY29kZShwcm9wZXJ0aWVzLm1hcHBpbmdzKTtcbn07XG5cblNvdXJjZU1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG5cdHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbn07XG5cblNvdXJjZU1hcC5wcm90b3R5cGUudG9VcmwgPSBmdW5jdGlvbiB0b1VybCAoKSB7XG5cdHJldHVybiAnZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBidG9hKHRoaXMudG9TdHJpbmcoKSk7XG59O1xuXG5mdW5jdGlvbiBndWVzc0luZGVudChjb2RlKSB7XG5cdHZhciBsaW5lcyA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuXG5cdHZhciB0YWJiZWQgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIC9eXFx0Ky8udGVzdChsaW5lKTsgfSk7XG5cdHZhciBzcGFjZWQgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIC9eIHsyLH0vLnRlc3QobGluZSk7IH0pO1xuXG5cdGlmICh0YWJiZWQubGVuZ3RoID09PSAwICYmIHNwYWNlZC5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE1vcmUgbGluZXMgdGFiYmVkIHRoYW4gc3BhY2VkPyBBc3N1bWUgdGFicywgYW5kXG5cdC8vIGRlZmF1bHQgdG8gdGFicyBpbiB0aGUgY2FzZSBvZiBhIHRpZSAob3Igbm90aGluZ1xuXHQvLyB0byBnbyBvbilcblx0aWYgKHRhYmJlZC5sZW5ndGggPj0gc3BhY2VkLmxlbmd0aCkge1xuXHRcdHJldHVybiAnXFx0Jztcblx0fVxuXG5cdC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBndWVzcyB0aGUgbXVsdGlwbGVcblx0dmFyIG1pbiA9IHNwYWNlZC5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG5cdFx0dmFyIG51bVNwYWNlcyA9IC9eICsvLmV4ZWMoY3VycmVudClbMF0ubGVuZ3RoO1xuXHRcdHJldHVybiBNYXRoLm1pbihudW1TcGFjZXMsIHByZXZpb3VzKTtcblx0fSwgSW5maW5pdHkpO1xuXG5cdHJldHVybiBuZXcgQXJyYXkobWluICsgMSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGgoZnJvbSwgdG8pIHtcblx0dmFyIGZyb21QYXJ0cyA9IGZyb20uc3BsaXQoL1svXFxcXF0vKTtcblx0dmFyIHRvUGFydHMgPSB0by5zcGxpdCgvWy9cXFxcXS8pO1xuXG5cdGZyb21QYXJ0cy5wb3AoKTsgLy8gZ2V0IGRpcm5hbWVcblxuXHR3aGlsZSAoZnJvbVBhcnRzWzBdID09PSB0b1BhcnRzWzBdKSB7XG5cdFx0ZnJvbVBhcnRzLnNoaWZ0KCk7XG5cdFx0dG9QYXJ0cy5zaGlmdCgpO1xuXHR9XG5cblx0aWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcblx0XHR2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkgeyBmcm9tUGFydHNbaV0gPSAnLi4nOyB9XG5cdH1cblxuXHRyZXR1cm4gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKS5qb2luKCcvJyk7XG59XG5cbnZhciB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNPYmplY3QkMSh0aGluZykge1xuXHRyZXR1cm4gdG9TdHJpbmckMS5jYWxsKHRoaW5nKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGdldExvY2F0b3IkMShzb3VyY2UpIHtcblx0dmFyIG9yaWdpbmFsTGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuXHR2YXIgbGluZU9mZnNldHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IG9yaWdpbmFsTGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRsaW5lT2Zmc2V0cy5wdXNoKHBvcyk7XG5cdFx0cG9zICs9IG9yaWdpbmFsTGluZXNbaV0ubGVuZ3RoICsgMTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiBsb2NhdGUoaW5kZXgpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGogPSBsaW5lT2Zmc2V0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGkgPCBqKSB7XG5cdFx0XHR2YXIgbSA9IChpICsgaikgPj4gMTtcblx0XHRcdGlmIChpbmRleCA8IGxpbmVPZmZzZXRzW21dKSB7XG5cdFx0XHRcdGogPSBtO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IG0gKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgbGluZSA9IGkgLSAxO1xuXHRcdHZhciBjb2x1bW4gPSBpbmRleCAtIGxpbmVPZmZzZXRzW2xpbmVdO1xuXHRcdHJldHVybiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uIH07XG5cdH07XG59XG5cbnZhciBNYXBwaW5ncyA9IGZ1bmN0aW9uIE1hcHBpbmdzKGhpcmVzKSB7XG5cdHRoaXMuaGlyZXMgPSBoaXJlcztcblx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSA9IDA7XG5cdHRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7XG5cdHRoaXMucmF3ID0gW107XG5cdHRoaXMucmF3U2VnbWVudHMgPSB0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXSA9IFtdO1xuXHR0aGlzLnBlbmRpbmcgPSBudWxsO1xufTtcblxuTWFwcGluZ3MucHJvdG90eXBlLmFkZEVkaXQgPSBmdW5jdGlvbiBhZGRFZGl0IChzb3VyY2VJbmRleCwgY29udGVudCwgbG9jLCBuYW1lSW5kZXgpIHtcblx0aWYgKGNvbnRlbnQubGVuZ3RoKSB7XG5cdFx0dmFyIHNlZ21lbnQgPSBbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dO1xuXHRcdGlmIChuYW1lSW5kZXggPj0gMCkge1xuXHRcdFx0c2VnbWVudC5wdXNoKG5hbWVJbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0fSBlbHNlIGlmICh0aGlzLnBlbmRpbmcpIHtcblx0XHR0aGlzLnJhd1NlZ21lbnRzLnB1c2godGhpcy5wZW5kaW5nKTtcblx0fVxuXG5cdHRoaXMuYWR2YW5jZShjb250ZW50KTtcblx0dGhpcy5wZW5kaW5nID0gbnVsbDtcbn07XG5cbk1hcHBpbmdzLnByb3RvdHlwZS5hZGRVbmVkaXRlZENodW5rID0gZnVuY3Rpb24gYWRkVW5lZGl0ZWRDaHVuayAoc291cmNlSW5kZXgsIGNodW5rLCBvcmlnaW5hbCwgbG9jLCBzb3VyY2VtYXBMb2NhdGlvbnMpIHtcblx0dmFyIG9yaWdpbmFsQ2hhckluZGV4ID0gY2h1bmsuc3RhcnQ7XG5cdHZhciBmaXJzdCA9IHRydWU7XG5cblx0d2hpbGUgKG9yaWdpbmFsQ2hhckluZGV4IDwgY2h1bmsuZW5kKSB7XG5cdFx0aWYgKHRoaXMuaGlyZXMgfHwgZmlyc3QgfHwgc291cmNlbWFwTG9jYXRpb25zLmhhcyhvcmlnaW5hbENoYXJJbmRleCkpIHtcblx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dKTtcblx0XHR9XG5cblx0XHRpZiAob3JpZ2luYWxbb3JpZ2luYWxDaGFySW5kZXhdID09PSAnXFxuJykge1xuXHRcdFx0bG9jLmxpbmUgKz0gMTtcblx0XHRcdGxvYy5jb2x1bW4gPSAwO1xuXHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSArPSAxO1xuXHRcdFx0dGhpcy5yYXdbdGhpcy5nZW5lcmF0ZWRDb2RlTGluZV0gPSB0aGlzLnJhd1NlZ21lbnRzID0gW107XG5cdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXHRcdFx0Zmlyc3QgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2MuY29sdW1uICs9IDE7XG5cdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gKz0gMTtcblx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0b3JpZ2luYWxDaGFySW5kZXggKz0gMTtcblx0fVxuXG5cdHRoaXMucGVuZGluZyA9IG51bGw7XG59O1xuXG5NYXBwaW5ncy5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKHN0cikge1xuXHRpZiAoIXN0cikgeyByZXR1cm47IH1cblxuXHR2YXIgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuXG5cdGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdHRoaXMuZ2VuZXJhdGVkQ29kZUxpbmUrKztcblx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdH1cblx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXHR9XG5cblx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uICs9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbn07XG5cbnZhciBuID0gJ1xcbic7XG5cbnZhciB3YXJuZWQgPSB7XG5cdGluc2VydExlZnQ6IGZhbHNlLFxuXHRpbnNlcnRSaWdodDogZmFsc2UsXG5cdHN0b3JlTmFtZTogZmFsc2Vcbn07XG5cbnZhciBNYWdpY1N0cmluZyA9IGZ1bmN0aW9uIE1hZ2ljU3RyaW5nKHN0cmluZywgb3B0aW9ucykge1xuXHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHR2YXIgY2h1bmsgPSBuZXcgQ2h1bmskMSgwLCBzdHJpbmcubGVuZ3RoLCBzdHJpbmcpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRvcmlnaW5hbDogICAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdHJpbmcgfSxcblx0XHRvdXRybzogICAgICAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiAnJyB9LFxuXHRcdGludHJvOiAgICAgICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0Zmlyc3RDaHVuazogICAgICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRsYXN0Q2h1bms6ICAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBjaHVuayB9LFxuXHRcdGxhc3RTZWFyY2hlZENodW5rOiAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0YnlTdGFydDogICAgICAgICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRieUVuZDogICAgICAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdGZpbGVuYW1lOiAgICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG9wdGlvbnMuZmlsZW5hbWUgfSxcblx0XHRpbmRlbnRFeGNsdXNpb25SYW5nZXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvcHRpb25zLmluZGVudEV4Y2x1c2lvblJhbmdlcyB9LFxuXHRcdHNvdXJjZW1hcExvY2F0aW9uczogICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBCaXRTZXQoKSB9LFxuXHRcdHN0b3JlZE5hbWVzOiAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG5cdFx0aW5kZW50U3RyOiAgICAgICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZ3Vlc3NJbmRlbnQoc3RyaW5nKSB9XG5cdH0pO1xuXG5cdHRoaXMuYnlTdGFydFswXSA9IGNodW5rO1xuXHR0aGlzLmJ5RW5kW3N0cmluZy5sZW5ndGhdID0gY2h1bms7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuYWRkU291cmNlbWFwTG9jYXRpb24gPSBmdW5jdGlvbiBhZGRTb3VyY2VtYXBMb2NhdGlvbiAoY2hhcikge1xuXHR0aGlzLnNvdXJjZW1hcExvY2F0aW9ucy5hZGQoY2hhcik7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChjb250ZW50KSB7XG5cdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignb3V0cm8gY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7IH1cblxuXHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdHJldHVybiB0aGlzO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmFwcGVuZExlZnQgPSBmdW5jdGlvbiBhcHBlbmRMZWZ0IChpbmRleCwgY29udGVudCkge1xuXHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpOyB9XG5cblx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdHZhciBjaHVuayA9IHRoaXMuYnlFbmRbaW5kZXhdO1xuXG5cdGlmIChjaHVuaykge1xuXHRcdGNodW5rLmFwcGVuZExlZnQoY29udGVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5pbnRybyArPSBjb250ZW50O1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmFwcGVuZFJpZ2h0ID0gZnVuY3Rpb24gYXBwZW5kUmlnaHQgKGluZGV4LCBjb250ZW50KSB7XG5cdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7IH1cblxuXHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0dmFyIGNodW5rID0gdGhpcy5ieVN0YXJ0W2luZGV4XTtcblxuXHRpZiAoY2h1bmspIHtcblx0XHRjaHVuay5hcHBlbmRSaWdodChjb250ZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG5cdHZhciBjbG9uZWQgPSBuZXcgTWFnaWNTdHJpbmcodGhpcy5vcmlnaW5hbCwgeyBmaWxlbmFtZTogdGhpcy5maWxlbmFtZSB9KTtcblxuXHR2YXIgb3JpZ2luYWxDaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0dmFyIGNsb25lZENodW5rID0gKGNsb25lZC5maXJzdENodW5rID0gY2xvbmVkLmxhc3RTZWFyY2hlZENodW5rID0gb3JpZ2luYWxDaHVuay5jbG9uZSgpKTtcblxuXHR3aGlsZSAob3JpZ2luYWxDaHVuaykge1xuXHRcdGNsb25lZC5ieVN0YXJ0W2Nsb25lZENodW5rLnN0YXJ0XSA9IGNsb25lZENodW5rO1xuXHRcdGNsb25lZC5ieUVuZFtjbG9uZWRDaHVuay5lbmRdID0gY2xvbmVkQ2h1bms7XG5cblx0XHR2YXIgbmV4dE9yaWdpbmFsQ2h1bmsgPSBvcmlnaW5hbENodW5rLm5leHQ7XG5cdFx0dmFyIG5leHRDbG9uZWRDaHVuayA9IG5leHRPcmlnaW5hbENodW5rICYmIG5leHRPcmlnaW5hbENodW5rLmNsb25lKCk7XG5cblx0XHRpZiAobmV4dENsb25lZENodW5rKSB7XG5cdFx0XHRjbG9uZWRDaHVuay5uZXh0ID0gbmV4dENsb25lZENodW5rO1xuXHRcdFx0bmV4dENsb25lZENodW5rLnByZXZpb3VzID0gY2xvbmVkQ2h1bms7XG5cblx0XHRcdGNsb25lZENodW5rID0gbmV4dENsb25lZENodW5rO1xuXHRcdH1cblxuXHRcdG9yaWdpbmFsQ2h1bmsgPSBuZXh0T3JpZ2luYWxDaHVuaztcblx0fVxuXG5cdGNsb25lZC5sYXN0Q2h1bmsgPSBjbG9uZWRDaHVuaztcblxuXHRpZiAodGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMpIHtcblx0XHRjbG9uZWQuaW5kZW50RXhjbHVzaW9uUmFuZ2VzID0gdGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMuc2xpY2UoKTtcblx0fVxuXG5cdGNsb25lZC5zb3VyY2VtYXBMb2NhdGlvbnMgPSBuZXcgQml0U2V0KHRoaXMuc291cmNlbWFwTG9jYXRpb25zKTtcblxuXHRjbG9uZWQuaW50cm8gPSB0aGlzLmludHJvO1xuXHRjbG9uZWQub3V0cm8gPSB0aGlzLm91dHJvO1xuXG5cdHJldHVybiBjbG9uZWQ7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuZ2VuZXJhdGVEZWNvZGVkTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVEZWNvZGVkTWFwIChvcHRpb25zKSB7XG5cdFx0dmFyIHRoaXMkMSQxID0gdGhpcztcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHR2YXIgc291cmNlSW5kZXggPSAwO1xuXHR2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JlZE5hbWVzKTtcblx0dmFyIG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMpO1xuXG5cdHZhciBsb2NhdGUgPSBnZXRMb2NhdG9yJDEodGhpcy5vcmlnaW5hbCk7XG5cblx0aWYgKHRoaXMuaW50cm8pIHtcblx0XHRtYXBwaW5ncy5hZHZhbmNlKHRoaXMuaW50cm8pO1xuXHR9XG5cblx0dGhpcy5maXJzdENodW5rLmVhY2hOZXh0KGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdHZhciBsb2MgPSBsb2NhdGUoY2h1bmsuc3RhcnQpO1xuXG5cdFx0aWYgKGNodW5rLmludHJvLmxlbmd0aCkgeyBtYXBwaW5ncy5hZHZhbmNlKGNodW5rLmludHJvKTsgfVxuXG5cdFx0aWYgKGNodW5rLmVkaXRlZCkge1xuXHRcdFx0bWFwcGluZ3MuYWRkRWRpdChcblx0XHRcdFx0c291cmNlSW5kZXgsXG5cdFx0XHRcdGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdGxvYyxcblx0XHRcdFx0Y2h1bmsuc3RvcmVOYW1lID8gbmFtZXMuaW5kZXhPZihjaHVuay5vcmlnaW5hbCkgOiAtMVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwcGluZ3MuYWRkVW5lZGl0ZWRDaHVuayhzb3VyY2VJbmRleCwgY2h1bmssIHRoaXMkMSQxLm9yaWdpbmFsLCBsb2MsIHRoaXMkMSQxLnNvdXJjZW1hcExvY2F0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKGNodW5rLm91dHJvLmxlbmd0aCkgeyBtYXBwaW5ncy5hZHZhbmNlKGNodW5rLm91dHJvKTsgfVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdGZpbGU6IG9wdGlvbnMuZmlsZSA/IG9wdGlvbnMuZmlsZS5zcGxpdCgvWy9cXFxcXS8pLnBvcCgpIDogbnVsbCxcblx0XHRzb3VyY2VzOiBbb3B0aW9ucy5zb3VyY2UgPyBnZXRSZWxhdGl2ZVBhdGgob3B0aW9ucy5maWxlIHx8ICcnLCBvcHRpb25zLnNvdXJjZSkgOiBudWxsXSxcblx0XHRzb3VyY2VzQ29udGVudDogb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IFt0aGlzLm9yaWdpbmFsXSA6IFtudWxsXSxcblx0XHRuYW1lczogbmFtZXMsXG5cdFx0bWFwcGluZ3M6IG1hcHBpbmdzLnJhd1xuXHR9O1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmdlbmVyYXRlTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVNYXAgKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTb3VyY2VNYXAodGhpcy5nZW5lcmF0ZURlY29kZWRNYXAob3B0aW9ucykpO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmdldEluZGVudFN0cmluZyA9IGZ1bmN0aW9uIGdldEluZGVudFN0cmluZyAoKSB7XG5cdHJldHVybiB0aGlzLmluZGVudFN0ciA9PT0gbnVsbCA/ICdcXHQnIDogdGhpcy5pbmRlbnRTdHI7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gaW5kZW50IChpbmRlbnRTdHIsIG9wdGlvbnMpIHtcblx0dmFyIHBhdHRlcm4gPSAvXlteXFxyXFxuXS9nbTtcblxuXHRpZiAoaXNPYmplY3QkMShpbmRlbnRTdHIpKSB7XG5cdFx0b3B0aW9ucyA9IGluZGVudFN0cjtcblx0XHRpbmRlbnRTdHIgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpbmRlbnRTdHIgPSBpbmRlbnRTdHIgIT09IHVuZGVmaW5lZCA/IGluZGVudFN0ciA6IHRoaXMuaW5kZW50U3RyIHx8ICdcXHQnO1xuXG5cdGlmIChpbmRlbnRTdHIgPT09ICcnKSB7IHJldHVybiB0aGlzOyB9IC8vIG5vb3BcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQvLyBQcm9jZXNzIGV4Y2x1c2lvbiByYW5nZXNcblx0dmFyIGlzRXhjbHVkZWQgPSB7fTtcblxuXHRpZiAob3B0aW9ucy5leGNsdWRlKSB7XG5cdFx0dmFyIGV4Y2x1c2lvbnMgPVxuXHRcdFx0dHlwZW9mIG9wdGlvbnMuZXhjbHVkZVswXSA9PT0gJ251bWJlcicgPyBbb3B0aW9ucy5leGNsdWRlXSA6IG9wdGlvbnMuZXhjbHVkZTtcblx0XHRleGNsdXNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4Y2x1c2lvbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGV4Y2x1c2lvblswXTsgaSA8IGV4Y2x1c2lvblsxXTsgaSArPSAxKSB7XG5cdFx0XHRcdGlzRXhjbHVkZWRbaV0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0dmFyIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBvcHRpb25zLmluZGVudFN0YXJ0ICE9PSBmYWxzZTtcblx0dmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG5cdFx0aWYgKHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIpIHsgcmV0dXJuIChcIlwiICsgaW5kZW50U3RyICsgbWF0Y2gpOyB9XG5cdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IHRydWU7XG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9O1xuXG5cdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG5cdHZhciBjaGFySW5kZXggPSAwO1xuXHR2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0dmFyIGVuZCA9IGNodW5rLmVuZDtcblxuXHRcdGlmIChjaHVuay5lZGl0ZWQpIHtcblx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdGNodW5rLmNvbnRlbnQgPSBjaHVuay5jb250ZW50LnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG5cdFx0XHRcdGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBjaHVuay5jb250ZW50W2NodW5rLmNvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXG5cdFx0XHR3aGlsZSAoY2hhckluZGV4IDwgZW5kKSB7XG5cdFx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdFx0dmFyIGNoYXIgPSB0aGlzLm9yaWdpbmFsW2NoYXJJbmRleF07XG5cblx0XHRcdFx0XHRpZiAoY2hhciA9PT0gJ1xcbicpIHtcblx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2hhciAhPT0gJ1xccicgJiYgc2hvdWxkSW5kZW50TmV4dENoYXJhY3Rlcikge1xuXHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2hhckluZGV4ID09PSBjaHVuay5zdGFydCkge1xuXHRcdFx0XHRcdFx0XHRjaHVuay5wcmVwZW5kUmlnaHQoaW5kZW50U3RyKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NwbGl0Q2h1bmsoY2h1bmssIGNoYXJJbmRleCk7XG5cdFx0XHRcdFx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGluZGVudFN0cik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2hhckluZGV4ICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2hhckluZGV4ID0gY2h1bmsuZW5kO1xuXHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0fVxuXG5cdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignbWFnaWNTdHJpbmcuaW5zZXJ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIHByZXBlbmRSaWdodCguLi4pIG9yIGFwcGVuZExlZnQoLi4uKScpO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmluc2VydExlZnQgPSBmdW5jdGlvbiBpbnNlcnRMZWZ0IChpbmRleCwgY29udGVudCkge1xuXHRpZiAoIXdhcm5lZC5pbnNlcnRMZWZ0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdtYWdpY1N0cmluZy5pbnNlcnRMZWZ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIG1hZ2ljU3RyaW5nLmFwcGVuZExlZnQoLi4uKSBpbnN0ZWFkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRcdHdhcm5lZC5pbnNlcnRMZWZ0ID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmFwcGVuZExlZnQoaW5kZXgsIGNvbnRlbnQpO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmluc2VydFJpZ2h0ID0gZnVuY3Rpb24gaW5zZXJ0UmlnaHQgKGluZGV4LCBjb250ZW50KSB7XG5cdGlmICghd2FybmVkLmluc2VydFJpZ2h0KSB7XG5cdFx0Y29uc29sZS53YXJuKCdtYWdpY1N0cmluZy5pbnNlcnRSaWdodCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBtYWdpY1N0cmluZy5wcmVwZW5kUmlnaHQoLi4uKSBpbnN0ZWFkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXHRcdHdhcm5lZC5pbnNlcnRSaWdodCA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5wcmVwZW5kUmlnaHQoaW5kZXgsIGNvbnRlbnQpO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiBtb3ZlIChzdGFydCwgZW5kLCBpbmRleCkge1xuXHRpZiAoaW5kZXggPj0gc3RhcnQgJiYgaW5kZXggPD0gZW5kKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgYSBzZWxlY3Rpb24gaW5zaWRlIGl0c2VsZicpOyB9XG5cblx0dGhpcy5fc3BsaXQoc3RhcnQpO1xuXHR0aGlzLl9zcGxpdChlbmQpO1xuXHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0dmFyIGZpcnN0ID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblx0dmFyIGxhc3QgPSB0aGlzLmJ5RW5kW2VuZF07XG5cblx0dmFyIG9sZExlZnQgPSBmaXJzdC5wcmV2aW91cztcblx0dmFyIG9sZFJpZ2h0ID0gbGFzdC5uZXh0O1xuXG5cdHZhciBuZXdSaWdodCA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cdGlmICghbmV3UmlnaHQgJiYgbGFzdCA9PT0gdGhpcy5sYXN0Q2h1bmspIHsgcmV0dXJuIHRoaXM7IH1cblx0dmFyIG5ld0xlZnQgPSBuZXdSaWdodCA/IG5ld1JpZ2h0LnByZXZpb3VzIDogdGhpcy5sYXN0Q2h1bms7XG5cblx0aWYgKG9sZExlZnQpIHsgb2xkTGVmdC5uZXh0ID0gb2xkUmlnaHQ7IH1cblx0aWYgKG9sZFJpZ2h0KSB7IG9sZFJpZ2h0LnByZXZpb3VzID0gb2xkTGVmdDsgfVxuXG5cdGlmIChuZXdMZWZ0KSB7IG5ld0xlZnQubmV4dCA9IGZpcnN0OyB9XG5cdGlmIChuZXdSaWdodCkgeyBuZXdSaWdodC5wcmV2aW91cyA9IGxhc3Q7IH1cblxuXHRpZiAoIWZpcnN0LnByZXZpb3VzKSB7IHRoaXMuZmlyc3RDaHVuayA9IGxhc3QubmV4dDsgfVxuXHRpZiAoIWxhc3QubmV4dCkge1xuXHRcdHRoaXMubGFzdENodW5rID0gZmlyc3QucHJldmlvdXM7XG5cdFx0dGhpcy5sYXN0Q2h1bmsubmV4dCA9IG51bGw7XG5cdH1cblxuXHRmaXJzdC5wcmV2aW91cyA9IG5ld0xlZnQ7XG5cdGxhc3QubmV4dCA9IG5ld1JpZ2h0IHx8IG51bGw7XG5cblx0aWYgKCFuZXdMZWZ0KSB7IHRoaXMuZmlyc3RDaHVuayA9IGZpcnN0OyB9XG5cdGlmICghbmV3UmlnaHQpIHsgdGhpcy5sYXN0Q2h1bmsgPSBsYXN0OyB9XG5cdHJldHVybiB0aGlzO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLm92ZXJ3cml0ZSA9IGZ1bmN0aW9uIG92ZXJ3cml0ZSAoc3RhcnQsIGVuZCwgY29udGVudCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcGxhY2VtZW50IGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpOyB9XG5cblx0d2hpbGUgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDsgfVxuXHR3aGlsZSAoZW5kIDwgMCkgeyBlbmQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7IH1cblxuXHRpZiAoZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKCdlbmQgaXMgb3V0IG9mIGJvdW5kcycpOyB9XG5cdGlmIChzdGFydCA9PT0gZW5kKVxuXHRcdHsgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcndyaXRlIGEgemVyby1sZW5ndGggcmFuZ2UgXHUyMDEzIHVzZSBhcHBlbmRMZWZ0IG9yIHByZXBlbmRSaWdodCBpbnN0ZWFkJyk7IH1cblxuXHR0aGlzLl9zcGxpdChzdGFydCk7XG5cdHRoaXMuX3NwbGl0KGVuZCk7XG5cblx0aWYgKG9wdGlvbnMgPT09IHRydWUpIHtcblx0XHRpZiAoIXdhcm5lZC5zdG9yZU5hbWUpIHtcblx0XHRcdGNvbnNvbGUud2FybignVGhlIGZpbmFsIGFyZ3VtZW50IHRvIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZSguLi4pIHNob3VsZCBiZSBhbiBvcHRpb25zIG9iamVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yaWNoLWhhcnJpcy9tYWdpYy1zdHJpbmcnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHR3YXJuZWQuc3RvcmVOYW1lID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0geyBzdG9yZU5hbWU6IHRydWUgfTtcblx0fVxuXHR2YXIgc3RvcmVOYW1lID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdG9yZU5hbWUgOiBmYWxzZTtcblx0dmFyIGNvbnRlbnRPbmx5ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb250ZW50T25seSA6IGZhbHNlO1xuXG5cdGlmIChzdG9yZU5hbWUpIHtcblx0XHR2YXIgb3JpZ2luYWwgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHRcdHRoaXMuc3RvcmVkTmFtZXNbb3JpZ2luYWxdID0gdHJ1ZTtcblx0fVxuXG5cdHZhciBmaXJzdCA9IHRoaXMuYnlTdGFydFtzdGFydF07XG5cdHZhciBsYXN0ID0gdGhpcy5ieUVuZFtlbmRdO1xuXG5cdGlmIChmaXJzdCkge1xuXHRcdGlmIChlbmQgPiBmaXJzdC5lbmQgJiYgZmlyc3QubmV4dCAhPT0gdGhpcy5ieVN0YXJ0W2ZpcnN0LmVuZF0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJ3cml0ZSBhY3Jvc3MgYSBzcGxpdCBwb2ludCcpO1xuXHRcdH1cblxuXHRcdGZpcnN0LmVkaXQoY29udGVudCwgc3RvcmVOYW1lLCBjb250ZW50T25seSk7XG5cblx0XHRpZiAoZmlyc3QgIT09IGxhc3QpIHtcblx0XHRcdHZhciBjaHVuayA9IGZpcnN0Lm5leHQ7XG5cdFx0XHR3aGlsZSAoY2h1bmsgIT09IGxhc3QpIHtcblx0XHRcdFx0Y2h1bmsuZWRpdCgnJywgZmFsc2UpO1xuXHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rLmVkaXQoJycsIGZhbHNlKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gbXVzdCBiZSBpbnNlcnRpbmcgYXQgdGhlIGVuZFxuXHRcdHZhciBuZXdDaHVuayA9IG5ldyBDaHVuayQxKHN0YXJ0LCBlbmQsICcnKS5lZGl0KGNvbnRlbnQsIHN0b3JlTmFtZSk7XG5cblx0XHQvLyBUT0RPIGxhc3QgY2h1bmsgaW4gdGhlIGFycmF5IG1heSBub3QgYmUgdGhlIGxhc3QgY2h1bmssIGlmIGl0J3MgbW92ZWQuLi5cblx0XHRsYXN0Lm5leHQgPSBuZXdDaHVuaztcblx0XHRuZXdDaHVuay5wcmV2aW91cyA9IGxhc3Q7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKGNvbnRlbnQpIHtcblx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTsgfVxuXG5cdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUucHJlcGVuZExlZnQgPSBmdW5jdGlvbiBwcmVwZW5kTGVmdCAoaW5kZXgsIGNvbnRlbnQpIHtcblx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTsgfVxuXG5cdHRoaXMuX3NwbGl0KGluZGV4KTtcblxuXHR2YXIgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuXHRpZiAoY2h1bmspIHtcblx0XHRjaHVuay5wcmVwZW5kTGVmdChjb250ZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUucHJlcGVuZFJpZ2h0ID0gZnVuY3Rpb24gcHJlcGVuZFJpZ2h0IChpbmRleCwgY29udGVudCkge1xuXHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpOyB9XG5cblx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdHZhciBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cblx0aWYgKGNodW5rKSB7XG5cdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGNvbnRlbnQpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMub3V0cm8gPSBjb250ZW50ICsgdGhpcy5vdXRybztcblx0fVxuXHRyZXR1cm4gdGhpcztcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKHN0YXJ0LCBlbmQpIHtcblx0d2hpbGUgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDsgfVxuXHR3aGlsZSAoZW5kIDwgMCkgeyBlbmQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7IH1cblxuXHRpZiAoc3RhcnQgPT09IGVuZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHsgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaXMgb3V0IG9mIGJvdW5kcycpOyB9XG5cdGlmIChzdGFydCA+IGVuZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydCcpOyB9XG5cblx0dGhpcy5fc3BsaXQoc3RhcnQpO1xuXHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdHZhciBjaHVuayA9IHRoaXMuYnlTdGFydFtzdGFydF07XG5cblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0Y2h1bmsuaW50cm8gPSAnJztcblx0XHRjaHVuay5vdXRybyA9ICcnO1xuXHRcdGNodW5rLmVkaXQoJycpO1xuXG5cdFx0Y2h1bmsgPSBlbmQgPiBjaHVuay5lbmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUubGFzdENoYXIgPSBmdW5jdGlvbiBsYXN0Q2hhciAoKSB7XG5cdGlmICh0aGlzLm91dHJvLmxlbmd0aClcblx0XHR7IHJldHVybiB0aGlzLm91dHJvW3RoaXMub3V0cm8ubGVuZ3RoIC0gMV07IH1cblx0dmFyIGNodW5rID0gdGhpcy5sYXN0Q2h1bms7XG5cdGRvIHtcblx0XHRpZiAoY2h1bmsub3V0cm8ubGVuZ3RoKVxuXHRcdFx0eyByZXR1cm4gY2h1bmsub3V0cm9bY2h1bmsub3V0cm8ubGVuZ3RoIC0gMV07IH1cblx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGgpXG5cdFx0XHR7IHJldHVybiBjaHVuay5jb250ZW50W2NodW5rLmNvbnRlbnQubGVuZ3RoIC0gMV07IH1cblx0XHRpZiAoY2h1bmsuaW50cm8ubGVuZ3RoKVxuXHRcdFx0eyByZXR1cm4gY2h1bmsuaW50cm9bY2h1bmsuaW50cm8ubGVuZ3RoIC0gMV07IH1cblx0fSB3aGlsZSAoY2h1bmsgPSBjaHVuay5wcmV2aW91cyk7XG5cdGlmICh0aGlzLmludHJvLmxlbmd0aClcblx0XHR7IHJldHVybiB0aGlzLmludHJvW3RoaXMuaW50cm8ubGVuZ3RoIC0gMV07IH1cblx0cmV0dXJuICcnO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLmxhc3RMaW5lID0gZnVuY3Rpb24gbGFzdExpbmUgKCkge1xuXHR2YXIgbGluZUluZGV4ID0gdGhpcy5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0aWYgKGxpbmVJbmRleCAhPT0gLTEpXG5cdFx0eyByZXR1cm4gdGhpcy5vdXRyby5zdWJzdHIobGluZUluZGV4ICsgMSk7IH1cblx0dmFyIGxpbmVTdHIgPSB0aGlzLm91dHJvO1xuXHR2YXIgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblx0ZG8ge1xuXHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGggPiAwKSB7XG5cdFx0XHRsaW5lSW5kZXggPSBjaHVuay5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRcdGlmIChsaW5lSW5kZXggIT09IC0xKVxuXHRcdFx0XHR7IHJldHVybiBjaHVuay5vdXRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyOyB9XG5cdFx0XHRsaW5lU3RyID0gY2h1bmsub3V0cm8gKyBsaW5lU3RyO1xuXHRcdH1cblxuXHRcdGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmNvbnRlbnQubGFzdEluZGV4T2Yobik7XG5cdFx0XHRpZiAobGluZUluZGV4ICE9PSAtMSlcblx0XHRcdFx0eyByZXR1cm4gY2h1bmsuY29udGVudC5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyOyB9XG5cdFx0XHRsaW5lU3RyID0gY2h1bmsuY29udGVudCArIGxpbmVTdHI7XG5cdFx0fVxuXG5cdFx0aWYgKGNodW5rLmludHJvLmxlbmd0aCA+IDApIHtcblx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdFx0aWYgKGxpbmVJbmRleCAhPT0gLTEpXG5cdFx0XHRcdHsgcmV0dXJuIGNodW5rLmludHJvLnN1YnN0cihsaW5lSW5kZXggKyAxKSArIGxpbmVTdHI7IH1cblx0XHRcdGxpbmVTdHIgPSBjaHVuay5pbnRybyArIGxpbmVTdHI7XG5cdFx0fVxuXHR9IHdoaWxlIChjaHVuayA9IGNodW5rLnByZXZpb3VzKTtcblx0bGluZUluZGV4ID0gdGhpcy5pbnRyby5sYXN0SW5kZXhPZihuKTtcblx0aWYgKGxpbmVJbmRleCAhPT0gLTEpXG5cdFx0eyByZXR1cm4gdGhpcy5pbnRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyOyB9XG5cdHJldHVybiB0aGlzLmludHJvICsgbGluZVN0cjtcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG5cdFx0aWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuXHRcdGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblxuXHR3aGlsZSAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoOyB9XG5cdHdoaWxlIChlbmQgPCAwKSB7IGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDsgfVxuXG5cdHZhciByZXN1bHQgPSAnJztcblxuXHQvLyBmaW5kIHN0YXJ0IGNodW5rXG5cdHZhciBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0d2hpbGUgKGNodW5rICYmIChjaHVuay5zdGFydCA+IHN0YXJ0IHx8IGNodW5rLmVuZCA8PSBzdGFydCkpIHtcblx0XHQvLyBmb3VuZCBlbmQgY2h1bmsgYmVmb3JlIHN0YXJ0XG5cdFx0aWYgKGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHR9XG5cblx0aWYgKGNodW5rICYmIGNodW5rLmVkaXRlZCAmJiBjaHVuay5zdGFydCAhPT0gc3RhcnQpXG5cdFx0eyB0aHJvdyBuZXcgRXJyb3IoKFwiQ2Fubm90IHVzZSByZXBsYWNlZCBjaGFyYWN0ZXIgXCIgKyBzdGFydCArIFwiIGFzIHNsaWNlIHN0YXJ0IGFuY2hvci5cIikpOyB9XG5cblx0dmFyIHN0YXJ0Q2h1bmsgPSBjaHVuaztcblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0aWYgKGNodW5rLmludHJvICYmIChzdGFydENodW5rICE9PSBjaHVuayB8fCBjaHVuay5zdGFydCA9PT0gc3RhcnQpKSB7XG5cdFx0XHRyZXN1bHQgKz0gY2h1bmsuaW50cm87XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRhaW5zRW5kID0gY2h1bmsuc3RhcnQgPCBlbmQgJiYgY2h1bmsuZW5kID49IGVuZDtcblx0XHRpZiAoY29udGFpbnNFbmQgJiYgY2h1bmsuZWRpdGVkICYmIGNodW5rLmVuZCAhPT0gZW5kKVxuXHRcdFx0eyB0aHJvdyBuZXcgRXJyb3IoKFwiQ2Fubm90IHVzZSByZXBsYWNlZCBjaGFyYWN0ZXIgXCIgKyBlbmQgKyBcIiBhcyBzbGljZSBlbmQgYW5jaG9yLlwiKSk7IH1cblxuXHRcdHZhciBzbGljZVN0YXJ0ID0gc3RhcnRDaHVuayA9PT0gY2h1bmsgPyBzdGFydCAtIGNodW5rLnN0YXJ0IDogMDtcblx0XHR2YXIgc2xpY2VFbmQgPSBjb250YWluc0VuZCA/IGNodW5rLmNvbnRlbnQubGVuZ3RoICsgZW5kIC0gY2h1bmsuZW5kIDogY2h1bmsuY29udGVudC5sZW5ndGg7XG5cblx0XHRyZXN1bHQgKz0gY2h1bmsuY29udGVudC5zbGljZShzbGljZVN0YXJ0LCBzbGljZUVuZCk7XG5cblx0XHRpZiAoY2h1bmsub3V0cm8gJiYgKCFjb250YWluc0VuZCB8fCBjaHVuay5lbmQgPT09IGVuZCkpIHtcblx0XHRcdHJlc3VsdCArPSBjaHVuay5vdXRybztcblx0XHR9XG5cblx0XHRpZiAoY29udGFpbnNFbmQpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUT0RPIGRlcHJlY2F0ZSB0aGlzPyBub3QgcmVhbGx5IHZlcnkgdXNlZnVsXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuc25pcCA9IGZ1bmN0aW9uIHNuaXAgKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXHRjbG9uZS5yZW1vdmUoMCwgc3RhcnQpO1xuXHRjbG9uZS5yZW1vdmUoZW5kLCBjbG9uZS5vcmlnaW5hbC5sZW5ndGgpO1xuXG5cdHJldHVybiBjbG9uZTtcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS5fc3BsaXQgPSBmdW5jdGlvbiBfc3BsaXQgKGluZGV4KSB7XG5cdGlmICh0aGlzLmJ5U3RhcnRbaW5kZXhdIHx8IHRoaXMuYnlFbmRbaW5kZXhdKSB7IHJldHVybjsgfVxuXG5cdHZhciBjaHVuayA9IHRoaXMubGFzdFNlYXJjaGVkQ2h1bms7XG5cdHZhciBzZWFyY2hGb3J3YXJkID0gaW5kZXggPiBjaHVuay5lbmQ7XG5cblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0aWYgKGNodW5rLmNvbnRhaW5zKGluZGV4KSkgeyByZXR1cm4gdGhpcy5fc3BsaXRDaHVuayhjaHVuaywgaW5kZXgpOyB9XG5cblx0XHRjaHVuayA9IHNlYXJjaEZvcndhcmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IHRoaXMuYnlFbmRbY2h1bmsuc3RhcnRdO1xuXHR9XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuX3NwbGl0Q2h1bmsgPSBmdW5jdGlvbiBfc3BsaXRDaHVuayAoY2h1bmssIGluZGV4KSB7XG5cdGlmIChjaHVuay5lZGl0ZWQgJiYgY2h1bmsuY29udGVudC5sZW5ndGgpIHtcblx0XHQvLyB6ZXJvLWxlbmd0aCBlZGl0ZWQgY2h1bmtzIGFyZSBhIHNwZWNpYWwgY2FzZSAob3ZlcmxhcHBpbmcgcmVwbGFjZW1lbnRzKVxuXHRcdHZhciBsb2MgPSBnZXRMb2NhdG9yJDEodGhpcy5vcmlnaW5hbCkoaW5kZXgpO1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdChcIkNhbm5vdCBzcGxpdCBhIGNodW5rIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBlZGl0ZWQgKFwiICsgKGxvYy5saW5lKSArIFwiOlwiICsgKGxvYy5jb2x1bW4pICsgXCIgXHUyMDEzIFxcXCJcIiArIChjaHVuay5vcmlnaW5hbCkgKyBcIlxcXCIpXCIpXG5cdFx0KTtcblx0fVxuXG5cdHZhciBuZXdDaHVuayA9IGNodW5rLnNwbGl0KGluZGV4KTtcblxuXHR0aGlzLmJ5RW5kW2luZGV4XSA9IGNodW5rO1xuXHR0aGlzLmJ5U3RhcnRbaW5kZXhdID0gbmV3Q2h1bms7XG5cdHRoaXMuYnlFbmRbbmV3Q2h1bmsuZW5kXSA9IG5ld0NodW5rO1xuXG5cdGlmIChjaHVuayA9PT0gdGhpcy5sYXN0Q2h1bmspIHsgdGhpcy5sYXN0Q2h1bmsgPSBuZXdDaHVuazsgfVxuXG5cdHRoaXMubGFzdFNlYXJjaGVkQ2h1bmsgPSBjaHVuaztcblx0cmV0dXJuIHRydWU7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG5cdHZhciBzdHIgPSB0aGlzLmludHJvO1xuXG5cdHZhciBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0d2hpbGUgKGNodW5rKSB7XG5cdFx0c3RyICs9IGNodW5rLnRvU3RyaW5nKCk7XG5cdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHR9XG5cblx0cmV0dXJuIHN0ciArIHRoaXMub3V0cm87XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuXHR2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdGRvIHtcblx0XHRpZiAoY2h1bmsuaW50cm8ubGVuZ3RoICYmIGNodW5rLmludHJvLnRyaW0oKSB8fFxuXHRcdFx0XHRjaHVuay5jb250ZW50Lmxlbmd0aCAmJiBjaHVuay5jb250ZW50LnRyaW0oKSB8fFxuXHRcdFx0XHRjaHVuay5vdXRyby5sZW5ndGggJiYgY2h1bmsub3V0cm8udHJpbSgpKVxuXHRcdFx0eyByZXR1cm4gZmFsc2U7IH1cblx0fSB3aGlsZSAoY2h1bmsgPSBjaHVuay5uZXh0KTtcblx0cmV0dXJuIHRydWU7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoICgpIHtcblx0dmFyIGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuXHR2YXIgbGVuZ3RoID0gMDtcblx0ZG8ge1xuXHRcdGxlbmd0aCArPSBjaHVuay5pbnRyby5sZW5ndGggKyBjaHVuay5jb250ZW50Lmxlbmd0aCArIGNodW5rLm91dHJvLmxlbmd0aDtcblx0fSB3aGlsZSAoY2h1bmsgPSBjaHVuay5uZXh0KTtcblx0cmV0dXJuIGxlbmd0aDtcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS50cmltTGluZXMgPSBmdW5jdGlvbiB0cmltTGluZXMgKCkge1xuXHRyZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gdHJpbSAoY2hhclR5cGUpIHtcblx0cmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcbn07XG5cbk1hZ2ljU3RyaW5nLnByb3RvdHlwZS50cmltRW5kQWJvcnRlZCA9IGZ1bmN0aW9uIHRyaW1FbmRBYm9ydGVkIChjaGFyVHlwZSkge1xuXHR2YXIgcnggPSBuZXcgUmVnRXhwKChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJCcpO1xuXG5cdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcblx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIGNodW5rID0gdGhpcy5sYXN0Q2h1bms7XG5cblx0ZG8ge1xuXHRcdHZhciBlbmQgPSBjaHVuay5lbmQ7XG5cdFx0dmFyIGFib3J0ZWQgPSBjaHVuay50cmltRW5kKHJ4KTtcblxuXHRcdC8vIGlmIGNodW5rIHdhcyB0cmltbWVkLCB3ZSBoYXZlIGEgbmV3IGxhc3RDaHVua1xuXHRcdGlmIChjaHVuay5lbmQgIT09IGVuZCkge1xuXHRcdFx0aWYgKHRoaXMubGFzdENodW5rID09PSBjaHVuaykge1xuXHRcdFx0XHR0aGlzLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYnlFbmRbY2h1bmsuZW5kXSA9IGNodW5rO1xuXHRcdFx0dGhpcy5ieVN0YXJ0W2NodW5rLm5leHQuc3RhcnRdID0gY2h1bmsubmV4dDtcblx0XHRcdHRoaXMuYnlFbmRbY2h1bmsubmV4dC5lbmRdID0gY2h1bmsubmV4dDtcblx0XHR9XG5cblx0XHRpZiAoYWJvcnRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGNodW5rID0gY2h1bmsucHJldmlvdXM7XG5cdH0gd2hpbGUgKGNodW5rKTtcblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5NYWdpY1N0cmluZy5wcm90b3R5cGUudHJpbUVuZCA9IGZ1bmN0aW9uIHRyaW1FbmQgKGNoYXJUeXBlKSB7XG5cdHRoaXMudHJpbUVuZEFib3J0ZWQoY2hhclR5cGUpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5NYWdpY1N0cmluZy5wcm90b3R5cGUudHJpbVN0YXJ0QWJvcnRlZCA9IGZ1bmN0aW9uIHRyaW1TdGFydEFib3J0ZWQgKGNoYXJUeXBlKSB7XG5cdHZhciByeCA9IG5ldyBSZWdFeHAoJ14nICsgKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJysnKTtcblxuXHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdGlmICh0aGlzLmludHJvLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRkbyB7XG5cdFx0dmFyIGVuZCA9IGNodW5rLmVuZDtcblx0XHR2YXIgYWJvcnRlZCA9IGNodW5rLnRyaW1TdGFydChyeCk7XG5cblx0XHRpZiAoY2h1bmsuZW5kICE9PSBlbmQpIHtcblx0XHRcdC8vIHNwZWNpYWwgY2FzZS4uLlxuXHRcdFx0aWYgKGNodW5rID09PSB0aGlzLmxhc3RDaHVuaykgeyB0aGlzLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7IH1cblxuXHRcdFx0dGhpcy5ieUVuZFtjaHVuay5lbmRdID0gY2h1bms7XG5cdFx0XHR0aGlzLmJ5U3RhcnRbY2h1bmsubmV4dC5zdGFydF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0dGhpcy5ieUVuZFtjaHVuay5uZXh0LmVuZF0gPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdGlmIChhYm9ydGVkKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHR9IHdoaWxlIChjaHVuayk7XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuTWFnaWNTdHJpbmcucHJvdG90eXBlLnRyaW1TdGFydCA9IGZ1bmN0aW9uIHRyaW1TdGFydCAoY2hhclR5cGUpIHtcblx0dGhpcy50cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG52YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBCdW5kbGUkMSA9IGZ1bmN0aW9uIEJ1bmRsZShvcHRpb25zKSB7XG5cdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdHRoaXMuaW50cm8gPSBvcHRpb25zLmludHJvIHx8ICcnO1xuXHR0aGlzLnNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNlcGFyYXRvciA6ICdcXG4nO1xuXHR0aGlzLnNvdXJjZXMgPSBbXTtcblx0dGhpcy51bmlxdWVTb3VyY2VzID0gW107XG5cdHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lID0ge307XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUuYWRkU291cmNlID0gZnVuY3Rpb24gYWRkU291cmNlIChzb3VyY2UpIHtcblx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIE1hZ2ljU3RyaW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkU291cmNlKHtcblx0XHRcdGNvbnRlbnQ6IHNvdXJjZSxcblx0XHRcdGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsXG5cdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yXG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIWlzT2JqZWN0JDEoc291cmNlKSB8fCAhc291cmNlLmNvbnRlbnQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2J1bmRsZS5hZGRTb3VyY2UoKSB0YWtlcyBhbiBvYmplY3Qgd2l0aCBhIGBjb250ZW50YCBwcm9wZXJ0eSwgd2hpY2ggc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIE1hZ2ljU3RyaW5nLCBhbmQgYW4gb3B0aW9uYWwgYGZpbGVuYW1lYCcpO1xuXHR9XG5cblx0WydmaWxlbmFtZScsICdpbmRlbnRFeGNsdXNpb25SYW5nZXMnLCAnc2VwYXJhdG9yJ10uZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG5cdFx0aWYgKCFoYXNPd25Qcm9wLmNhbGwoc291cmNlLCBvcHRpb24pKSB7IHNvdXJjZVtvcHRpb25dID0gc291cmNlLmNvbnRlbnRbb3B0aW9uXTsgfVxuXHR9KTtcblxuXHRpZiAoc291cmNlLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gVE9ETyB0aGVyZSdzIGEgYnVuY2ggb2YgdGhpcyBzb3J0IG9mIHRoaW5nLCBuZWVkcyBjbGVhbmluZyB1cFxuXHRcdHNvdXJjZS5zZXBhcmF0b3IgPSB0aGlzLnNlcGFyYXRvcjtcblx0fVxuXG5cdGlmIChzb3VyY2UuZmlsZW5hbWUpIHtcblx0XHRpZiAoIWhhc093blByb3AuY2FsbCh0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSwgc291cmNlLmZpbGVuYW1lKSkge1xuXHRcdFx0dGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWVbc291cmNlLmZpbGVuYW1lXSA9IHRoaXMudW5pcXVlU291cmNlcy5sZW5ndGg7XG5cdFx0XHR0aGlzLnVuaXF1ZVNvdXJjZXMucHVzaCh7IGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsIGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50Lm9yaWdpbmFsIH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdW5pcXVlU291cmNlID0gdGhpcy51bmlxdWVTb3VyY2VzW3RoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV1dO1xuXHRcdFx0aWYgKHNvdXJjZS5jb250ZW50Lm9yaWdpbmFsICE9PSB1bmlxdWVTb3VyY2UuY29udGVudCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKFwiSWxsZWdhbCBzb3VyY2U6IHNhbWUgZmlsZW5hbWUgKFwiICsgKHNvdXJjZS5maWxlbmFtZSkgKyBcIiksIGRpZmZlcmVudCBjb250ZW50c1wiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5zb3VyY2VzLnB1c2goc291cmNlKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChzdHIsIG9wdGlvbnMpIHtcblx0dGhpcy5hZGRTb3VyY2Uoe1xuXHRcdGNvbnRlbnQ6IG5ldyBNYWdpY1N0cmluZyhzdHIpLFxuXHRcdHNlcGFyYXRvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXBhcmF0b3IpIHx8ICcnXG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuQnVuZGxlJDEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuXHR2YXIgYnVuZGxlID0gbmV3IEJ1bmRsZSQxKHtcblx0XHRpbnRybzogdGhpcy5pbnRybyxcblx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yXG5cdH0pO1xuXG5cdHRoaXMuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRidW5kbGUuYWRkU291cmNlKHtcblx0XHRcdGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsXG5cdFx0XHRjb250ZW50OiBzb3VyY2UuY29udGVudC5jbG9uZSgpLFxuXHRcdFx0c2VwYXJhdG9yOiBzb3VyY2Uuc2VwYXJhdG9yXG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBidW5kbGU7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUuZ2VuZXJhdGVEZWNvZGVkTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVEZWNvZGVkTWFwIChvcHRpb25zKSB7XG5cdFx0dmFyIHRoaXMkMSQxID0gdGhpcztcblx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHR2YXIgbmFtZXMgPSBbXTtcblx0dGhpcy5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdE9iamVjdC5rZXlzKHNvdXJjZS5jb250ZW50LnN0b3JlZE5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRpZiAoIX5uYW1lcy5pbmRleE9mKG5hbWUpKSB7IG5hbWVzLnB1c2gobmFtZSk7IH1cblx0XHR9KTtcblx0fSk7XG5cblx0dmFyIG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMpO1xuXG5cdGlmICh0aGlzLmludHJvKSB7XG5cdFx0bWFwcGluZ3MuYWR2YW5jZSh0aGlzLmludHJvKTtcblx0fVxuXG5cdHRoaXMuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UsIGkpIHtcblx0XHRpZiAoaSA+IDApIHtcblx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcyQxJDEuc2VwYXJhdG9yKTtcblx0XHR9XG5cblx0XHR2YXIgc291cmNlSW5kZXggPSBzb3VyY2UuZmlsZW5hbWUgPyB0aGlzJDEkMS51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWVbc291cmNlLmZpbGVuYW1lXSA6IC0xO1xuXHRcdHZhciBtYWdpY1N0cmluZyA9IHNvdXJjZS5jb250ZW50O1xuXHRcdHZhciBsb2NhdGUgPSBnZXRMb2NhdG9yJDEobWFnaWNTdHJpbmcub3JpZ2luYWwpO1xuXG5cdFx0aWYgKG1hZ2ljU3RyaW5nLmludHJvKSB7XG5cdFx0XHRtYXBwaW5ncy5hZHZhbmNlKG1hZ2ljU3RyaW5nLmludHJvKTtcblx0XHR9XG5cblx0XHRtYWdpY1N0cmluZy5maXJzdENodW5rLmVhY2hOZXh0KGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0ZShjaHVuay5zdGFydCk7XG5cblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIHsgbWFwcGluZ3MuYWR2YW5jZShjaHVuay5pbnRybyk7IH1cblxuXHRcdFx0aWYgKHNvdXJjZS5maWxlbmFtZSkge1xuXHRcdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdFx0bWFwcGluZ3MuYWRkRWRpdChcblx0XHRcdFx0XHRcdHNvdXJjZUluZGV4LFxuXHRcdFx0XHRcdFx0Y2h1bmsuY29udGVudCxcblx0XHRcdFx0XHRcdGxvYyxcblx0XHRcdFx0XHRcdGNodW5rLnN0b3JlTmFtZSA/IG5hbWVzLmluZGV4T2YoY2h1bmsub3JpZ2luYWwpIDogLTFcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1hcHBpbmdzLmFkZFVuZWRpdGVkQ2h1bmsoXG5cdFx0XHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0XHRcdGNodW5rLFxuXHRcdFx0XHRcdFx0bWFnaWNTdHJpbmcub3JpZ2luYWwsXG5cdFx0XHRcdFx0XHRsb2MsXG5cdFx0XHRcdFx0XHRtYWdpY1N0cmluZy5zb3VyY2VtYXBMb2NhdGlvbnNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKGNodW5rLmNvbnRlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2h1bmsub3V0cm8ubGVuZ3RoKSB7IG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsub3V0cm8pOyB9XG5cdFx0fSk7XG5cblx0XHRpZiAobWFnaWNTdHJpbmcub3V0cm8pIHtcblx0XHRcdG1hcHBpbmdzLmFkdmFuY2UobWFnaWNTdHJpbmcub3V0cm8pO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRmaWxlOiBvcHRpb25zLmZpbGUgPyBvcHRpb25zLmZpbGUuc3BsaXQoL1svXFxcXF0vKS5wb3AoKSA6IG51bGwsXG5cdFx0c291cmNlczogdGhpcy51bmlxdWVTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5maWxlID8gZ2V0UmVsYXRpdmVQYXRoKG9wdGlvbnMuZmlsZSwgc291cmNlLmZpbGVuYW1lKSA6IHNvdXJjZS5maWxlbmFtZTtcblx0XHR9KSxcblx0XHRzb3VyY2VzQ29udGVudDogdGhpcy51bmlxdWVTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IHNvdXJjZS5jb250ZW50IDogbnVsbDtcblx0XHR9KSxcblx0XHRuYW1lczogbmFtZXMsXG5cdFx0bWFwcGluZ3M6IG1hcHBpbmdzLnJhd1xuXHR9O1xufTtcblxuQnVuZGxlJDEucHJvdG90eXBlLmdlbmVyYXRlTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVNYXAgKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTb3VyY2VNYXAodGhpcy5nZW5lcmF0ZURlY29kZWRNYXAob3B0aW9ucykpO1xufTtcblxuQnVuZGxlJDEucHJvdG90eXBlLmdldEluZGVudFN0cmluZyA9IGZ1bmN0aW9uIGdldEluZGVudFN0cmluZyAoKSB7XG5cdHZhciBpbmRlbnRTdHJpbmdDb3VudHMgPSB7fTtcblxuXHR0aGlzLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0dmFyIGluZGVudFN0ciA9IHNvdXJjZS5jb250ZW50LmluZGVudFN0cjtcblxuXHRcdGlmIChpbmRlbnRTdHIgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoIWluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdKSB7IGluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdID0gMDsgfVxuXHRcdGluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdICs9IDE7XG5cdH0pO1xuXG5cdHJldHVybiAoXG5cdFx0T2JqZWN0LmtleXMoaW5kZW50U3RyaW5nQ291bnRzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gaW5kZW50U3RyaW5nQ291bnRzW2FdIC0gaW5kZW50U3RyaW5nQ291bnRzW2JdO1xuXHRcdH0pWzBdIHx8ICdcXHQnXG5cdCk7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gaW5kZW50IChpbmRlbnRTdHIpIHtcblx0XHR2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG5cdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGluZGVudFN0ciA9IHRoaXMuZ2V0SW5kZW50U3RyaW5nKCk7XG5cdH1cblxuXHRpZiAoaW5kZW50U3RyID09PSAnJykgeyByZXR1cm4gdGhpczsgfSAvLyBub29wXG5cblx0dmFyIHRyYWlsaW5nTmV3bGluZSA9ICF0aGlzLmludHJvIHx8IHRoaXMuaW50cm8uc2xpY2UoLTEpID09PSAnXFxuJztcblxuXHR0aGlzLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBpKSB7XG5cdFx0dmFyIHNlcGFyYXRvciA9IHNvdXJjZS5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5zZXBhcmF0b3IgOiB0aGlzJDEkMS5zZXBhcmF0b3I7XG5cdFx0dmFyIGluZGVudFN0YXJ0ID0gdHJhaWxpbmdOZXdsaW5lIHx8IChpID4gMCAmJiAvXFxyP1xcbiQvLnRlc3Qoc2VwYXJhdG9yKSk7XG5cblx0XHRzb3VyY2UuY29udGVudC5pbmRlbnQoaW5kZW50U3RyLCB7XG5cdFx0XHRleGNsdWRlOiBzb3VyY2UuaW5kZW50RXhjbHVzaW9uUmFuZ2VzLFxuXHRcdFx0aW5kZW50U3RhcnQ6IGluZGVudFN0YXJ0IC8vOiB0cmFpbGluZ05ld2xpbmUgfHwgL1xccj9cXG4kLy50ZXN0KCBzZXBhcmF0b3IgKSAgLy90cnVlLy8vXFxyP1xcbi8udGVzdCggc2VwYXJhdG9yIClcblx0XHR9KTtcblxuXHRcdHRyYWlsaW5nTmV3bGluZSA9IHNvdXJjZS5jb250ZW50Lmxhc3RDaGFyKCkgPT09ICdcXG4nO1xuXHR9KTtcblxuXHRpZiAodGhpcy5pbnRybykge1xuXHRcdHRoaXMuaW50cm8gPVxuXHRcdFx0aW5kZW50U3RyICtcblx0XHRcdHRoaXMuaW50cm8ucmVwbGFjZSgvXlteXFxuXS9nbSwgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXggPiAwID8gaW5kZW50U3RyICsgbWF0Y2ggOiBtYXRjaDtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQgKHN0cikge1xuXHR0aGlzLmludHJvID0gc3RyICsgdGhpcy5pbnRybztcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG5cdFx0dmFyIHRoaXMkMSQxID0gdGhpcztcblxuXHR2YXIgYm9keSA9IHRoaXMuc291cmNlc1xuXHRcdC5tYXAoZnVuY3Rpb24gKHNvdXJjZSwgaSkge1xuXHRcdFx0dmFyIHNlcGFyYXRvciA9IHNvdXJjZS5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5zZXBhcmF0b3IgOiB0aGlzJDEkMS5zZXBhcmF0b3I7XG5cdFx0XHR2YXIgc3RyID0gKGkgPiAwID8gc2VwYXJhdG9yIDogJycpICsgc291cmNlLmNvbnRlbnQudG9TdHJpbmcoKTtcblxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9KVxuXHRcdC5qb2luKCcnKTtcblxuXHRyZXR1cm4gdGhpcy5pbnRybyArIGJvZHk7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuXHRpZiAodGhpcy5pbnRyby5sZW5ndGggJiYgdGhpcy5pbnRyby50cmltKCkpXG5cdFx0eyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHRoaXMuc291cmNlcy5zb21lKGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuICFzb3VyY2UuY29udGVudC5pc0VtcHR5KCk7IH0pKVxuXHRcdHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiB0cnVlO1xufTtcblxuQnVuZGxlJDEucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCAoKSB7XG5cdHJldHVybiB0aGlzLnNvdXJjZXMucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIHNvdXJjZSkgeyByZXR1cm4gbGVuZ3RoICsgc291cmNlLmNvbnRlbnQubGVuZ3RoKCk7IH0sIHRoaXMuaW50cm8ubGVuZ3RoKTtcbn07XG5cbkJ1bmRsZSQxLnByb3RvdHlwZS50cmltTGluZXMgPSBmdW5jdGlvbiB0cmltTGluZXMgKCkge1xuXHRyZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcbn07XG5cbkJ1bmRsZSQxLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gdHJpbSAoY2hhclR5cGUpIHtcblx0cmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcbn07XG5cbkJ1bmRsZSQxLnByb3RvdHlwZS50cmltU3RhcnQgPSBmdW5jdGlvbiB0cmltU3RhcnQgKGNoYXJUeXBlKSB7XG5cdHZhciByeCA9IG5ldyBSZWdFeHAoJ14nICsgKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJysnKTtcblx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXG5cdGlmICghdGhpcy5pbnRybykge1xuXHRcdHZhciBzb3VyY2U7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0ZG8ge1xuXHRcdFx0c291cmNlID0gdGhpcy5zb3VyY2VzW2krK107XG5cdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IHdoaWxlICghc291cmNlLmNvbnRlbnQudHJpbVN0YXJ0QWJvcnRlZChjaGFyVHlwZSkpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5CdW5kbGUkMS5wcm90b3R5cGUudHJpbUVuZCA9IGZ1bmN0aW9uIHRyaW1FbmQgKGNoYXJUeXBlKSB7XG5cdHZhciByeCA9IG5ldyBSZWdFeHAoKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJyskJyk7XG5cblx0dmFyIHNvdXJjZTtcblx0dmFyIGkgPSB0aGlzLnNvdXJjZXMubGVuZ3RoIC0gMTtcblxuXHRkbyB7XG5cdFx0c291cmNlID0gdGhpcy5zb3VyY2VzW2ktLV07XG5cdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSB3aGlsZSAoIXNvdXJjZS5jb250ZW50LnRyaW1FbmRBYm9ydGVkKGNoYXJUeXBlKSk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCBNYWdpY1N0cmluZyQxID0gTWFnaWNTdHJpbmc7XG5cbmNvbnN0IEFOWV9TTEFTSF9SRUdFWCA9IC9bL1xcXFxdLztcbmZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZnJvbS5zcGxpdChBTllfU0xBU0hfUkVHRVgpLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCB0b1BhcnRzID0gdG8uc3BsaXQoQU5ZX1NMQVNIX1JFR0VYKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKGZyb21QYXJ0c1swXSA9PT0gJy4nKVxuICAgICAgICBmcm9tUGFydHMuc2hpZnQoKTtcbiAgICBpZiAodG9QYXJ0c1swXSA9PT0gJy4nKVxuICAgICAgICB0b1BhcnRzLnNoaWZ0KCk7XG4gICAgd2hpbGUgKGZyb21QYXJ0c1swXSAmJiB0b1BhcnRzWzBdICYmIGZyb21QYXJ0c1swXSA9PT0gdG9QYXJ0c1swXSkge1xuICAgICAgICBmcm9tUGFydHMuc2hpZnQoKTtcbiAgICAgICAgdG9QYXJ0cy5zaGlmdCgpO1xuICAgIH1cbiAgICB3aGlsZSAodG9QYXJ0c1swXSA9PT0gJy4uJyAmJiBmcm9tUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0b1BhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICB9XG4gICAgd2hpbGUgKGZyb21QYXJ0cy5wb3AoKSkge1xuICAgICAgICB0b1BhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICAgIHJldHVybiB0b1BhcnRzLmpvaW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGUobWFwLCBrZXksIGluaXQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGluaXQoKTtcbiAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgVW5rbm93bktleSA9IFN5bWJvbCgnVW5rbm93biBLZXknKTtcbmNvbnN0IFVua25vd25JbnRlZ2VyID0gU3ltYm9sKCdVbmtub3duIEludGVnZXInKTtcbmNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmNvbnN0IFVOS05PV05fUEFUSCA9IFtVbmtub3duS2V5XTtcbmNvbnN0IFVOS05PV05fSU5URUdFUl9QQVRIID0gW1Vua25vd25JbnRlZ2VyXTtcbmNvbnN0IEVudGl0aWVzS2V5ID0gU3ltYm9sKCdFbnRpdGllcycpO1xuY2xhc3MgUGF0aFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudGl0eVBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBbRW50aXRpZXNLZXldOiB7IHZhbHVlOiBuZXcgU2V0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IHRyYWNrZWRFbnRpdGllcyA9IHRoaXMuZ2V0RW50aXRpZXMocGF0aCk7XG4gICAgICAgIGlmICh0cmFja2VkRW50aXRpZXMuaGFzKGVudGl0eSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdHJhY2tlZEVudGl0aWVzLmFkZChlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIGVudGl0eSwgb25VbnRyYWNrZWQsIHJldHVybklmVHJhY2tlZCkge1xuICAgICAgICBjb25zdCB0cmFja2VkRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzKHBhdGgpO1xuICAgICAgICBpZiAodHJhY2tlZEVudGl0aWVzLmhhcyhlbnRpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHJldHVybklmVHJhY2tlZDtcbiAgICAgICAgdHJhY2tlZEVudGl0aWVzLmFkZChlbnRpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvblVudHJhY2tlZCgpO1xuICAgICAgICB0cmFja2VkRW50aXRpZXMuZGVsZXRlKGVudGl0eSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldEVudGl0aWVzKHBhdGgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRocyA9IHRoaXMuZW50aXR5UGF0aHM7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aFNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGhzID0gY3VycmVudFBhdGhzW3BhdGhTZWdtZW50XSA9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGhzW3BhdGhTZWdtZW50XSB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwsIHsgW0VudGl0aWVzS2V5XTogeyB2YWx1ZTogbmV3IFNldCgpIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXRoc1tFbnRpdGllc0tleV07XG4gICAgfVxufVxuY29uc3QgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSID0gbmV3IFBhdGhUcmFja2VyKCk7XG5jbGFzcyBEaXNjcmltaW5hdGVkUGF0aFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudGl0eVBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBbRW50aXRpZXNLZXldOiB7IHZhbHVlOiBuZXcgTWFwKCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgZGlzY3JpbWluYXRvciwgZW50aXR5KSB7XG4gICAgICAgIGxldCBjdXJyZW50UGF0aHMgPSB0aGlzLmVudGl0eVBhdGhzO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGhTZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRocyA9IGN1cnJlbnRQYXRoc1twYXRoU2VnbWVudF0gPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoc1twYXRoU2VnbWVudF0gfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsLCB7IFtFbnRpdGllc0tleV06IHsgdmFsdWU6IG5ldyBNYXAoKSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrZWRFbnRpdGllcyA9IGdldE9yQ3JlYXRlKGN1cnJlbnRQYXRoc1tFbnRpdGllc0tleV0sIGRpc2NyaW1pbmF0b3IsICgpID0+IG5ldyBTZXQoKSk7XG4gICAgICAgIGlmICh0cmFja2VkRW50aXRpZXMuaGFzKGVudGl0eSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdHJhY2tlZEVudGl0aWVzLmFkZChlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5jb25zdCBVbmtub3duVmFsdWUgPSBTeW1ib2woJ1Vua25vd24gVmFsdWUnKTtcbmNsYXNzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKF9wYXRoKSB7IH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoX2V2ZW50LCBfcGF0aCwgdGhpc1BhcmFtZXRlciwgX3JlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpc1BhcmFtZXRlci5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSBpdCByZXR1cm5zIGEgc3RyaW5naWZ5YWJsZSBsaXRlcmFsIHZhbHVlIGZvciB0aGlzIG5vZGUgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqIGZvciBpbmxpbmluZyBvciBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIE90aGVyd2lzZSBpdCBzaG91bGQgcmV0dXJuIFVua25vd25WYWx1ZS5cbiAgICAgKi9cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgoX3BhdGgsIF9yZWN1cnNpb25UcmFja2VyLCBfb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKF9wYXRoLCBfY2FsbE9wdGlvbnMsIF9yZWN1cnNpb25UcmFja2VyLCBfb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoX3BhdGgsIF9jb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKF9wYXRoLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgoX3BhdGgsIF9jYWxsT3B0aW9ucywgX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluY2x1ZGUoX2NvbnRleHQsIF9pbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICBhcmcuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBVTktOT1dOX0VYUFJFU1NJT04gPSBuZXcgKGNsYXNzIFVua25vd25FeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG59KSgpO1xuXG5jbGFzcyBWYXJpYWJsZSBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbHdheXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRSZWFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmtpbmQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlckJhc2VOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgaWRlbnRpZmllcnMgdGhhdCByZWZlcmVuY2UgdGhpcyB2YXJpYWJsZSB0byB0aGlzIHZhcmlhYmxlLlxuICAgICAqIE5lY2Vzc2FyeSB0byBiZSBhYmxlIHRvIGNoYW5nZSB2YXJpYWJsZSBuYW1lcy5cbiAgICAgKi9cbiAgICBhZGRSZWZlcmVuY2UoX2lkZW50aWZpZXIpIHsgfVxuICAgIGdldEJhc2VWYXJpYWJsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckJhc2VOYW1lIHx8IHRoaXMucmVuZGVyTmFtZSB8fCB0aGlzLm5hbWU7XG4gICAgfVxuICAgIGdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucmVuZGVyTmFtZSB8fCB0aGlzLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckJhc2VOYW1lID8gYCR7dGhpcy5yZW5kZXJCYXNlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKG5hbWUpfWAgOiBuYW1lO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIF9jb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgdmFyaWFibGUgYXMgYmVpbmcgcGFydCBvZiB0aGUgYnVuZGxlLCB3aGljaCBpcyB1c3VhbGx5IHRoZSBjYXNlIHdoZW4gb25lIG9mXG4gICAgICogaXRzIGlkZW50aWZpZXJzIGJlY29tZXMgcGFydCBvZiB0aGUgYnVuZGxlLiBSZXR1cm5zIHRydWUgaWYgaXQgaGFzIG5vdCBiZWVuIGluY2x1ZGVkXG4gICAgICogcHJldmlvdXNseS5cbiAgICAgKiBPbmNlIGEgdmFyaWFibGUgaXMgaW5jbHVkZWQsIGl0IHNob3VsZCB0YWtlIGNhcmUgYWxsIGl0cyBkZWNsYXJhdGlvbnMgYXJlIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBtYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpIHsgfVxuICAgIHNldFJlbmRlck5hbWVzKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQmFzZU5hbWUgPSBiYXNlTmFtZTtcbiAgICAgICAgdGhpcy5yZW5kZXJOYW1lID0gbmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIEV4dGVybmFsVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKG5hbWUpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuaXNOYW1lc3BhY2UgPSBuYW1lID09PSAnKic7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZShpZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdkZWZhdWx0JyB8fCB0aGlzLm5hbWUgPT09ICcqJykge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGUuc3VnZ2VzdE5hbWUoaWRlbnRpZmllci5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gKHRoaXMuaXNOYW1lc3BhY2UgPyAxIDogMCk7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZS51c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQkxBTksgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuY29uc3QgRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5jb25zdCBFTVBUWV9BUlJBWSA9IE9iamVjdC5mcmVlemUoW10pO1xuXG5mdW5jdGlvbiBnZXRMb2NhdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9mZnNldExpbmUgPSBvcHRpb25zLm9mZnNldExpbmUgfHwgMDtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gb3B0aW9ucy5vZmZzZXRDb2x1bW4gfHwgMDtcbiAgICB2YXIgb3JpZ2luYWxMaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgbGluZVJhbmdlcyA9IG9yaWdpbmFsTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgdmFyIHJhbmdlID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBsaW5lOiBpIH07XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnMocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydCA8PSBpbmRleCAmJiBpbmRleCA8IHJhbmdlLmVuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TG9jYXRpb24ocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7IGxpbmU6IG9mZnNldExpbmUgKyByYW5nZS5saW5lLCBjb2x1bW46IG9mZnNldENvbHVtbiArIGluZGV4IC0gcmFuZ2Uuc3RhcnQsIGNoYXJhY3RlcjogaW5kZXggfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9jYXRlKHNlYXJjaCwgc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IHNvdXJjZS5pbmRleE9mKHNlYXJjaCwgc3RhcnRJbmRleCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBsaW5lUmFuZ2VzW2ldO1xuICAgICAgICB2YXIgZCA9IHNlYXJjaCA+PSByYW5nZS5lbmQgPyAxIDogLTE7XG4gICAgICAgIHdoaWxlIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlQ29udGFpbnMocmFuZ2UsIHNlYXJjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHJhbmdlLCBzZWFyY2gpO1xuICAgICAgICAgICAgaSArPSBkO1xuICAgICAgICAgICAgcmFuZ2UgPSBsaW5lUmFuZ2VzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGU7XG59XG5mdW5jdGlvbiBsb2NhdGUoc291cmNlLCBzZWFyY2gsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYXRlIHRha2VzIGEgeyBzdGFydEluZGV4LCBvZmZzZXRMaW5lLCBvZmZzZXRDb2x1bW4gfSBvYmplY3QgYXMgdGhlIHRoaXJkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBnZXRMb2NhdG9yKHNvdXJjZSwgb3B0aW9ucykoc2VhcmNoLCBvcHRpb25zICYmIG9wdGlvbnMuc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIHNwYWNlcyhpKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRhYnNUb1NwYWNlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHQrLywgbWF0Y2ggPT4gbWF0Y2guc3BsaXQoJ1xcdCcpLmpvaW4oJyAgJykpO1xufVxuZnVuY3Rpb24gZ2V0Q29kZUZyYW1lKHNvdXJjZSwgbGluZSwgY29sdW1uKSB7XG4gICAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBmcmFtZVN0YXJ0ID0gTWF0aC5tYXgoMCwgbGluZSAtIDMpO1xuICAgIGxldCBmcmFtZUVuZCA9IE1hdGgubWluKGxpbmUgKyAyLCBsaW5lcy5sZW5ndGgpO1xuICAgIGxpbmVzID0gbGluZXMuc2xpY2UoZnJhbWVTdGFydCwgZnJhbWVFbmQpO1xuICAgIHdoaWxlICghL1xcUy8udGVzdChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgIGZyYW1lRW5kIC09IDE7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2l0cyA9IFN0cmluZyhmcmFtZUVuZCkubGVuZ3RoO1xuICAgIHJldHVybiBsaW5lc1xuICAgICAgICAubWFwKChzdHIsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaXNFcnJvckxpbmUgPSBmcmFtZVN0YXJ0ICsgaSArIDEgPT09IGxpbmU7XG4gICAgICAgIGxldCBsaW5lTnVtID0gU3RyaW5nKGkgKyBmcmFtZVN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlIChsaW5lTnVtLmxlbmd0aCA8IGRpZ2l0cylcbiAgICAgICAgICAgIGxpbmVOdW0gPSBgICR7bGluZU51bX1gO1xuICAgICAgICBpZiAoaXNFcnJvckxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljYXRvciA9IHNwYWNlcyhkaWdpdHMgKyAyICsgdGFic1RvU3BhY2VzKHN0ci5zbGljZSgwLCBjb2x1bW4pKS5sZW5ndGgpICsgJ14nO1xuICAgICAgICAgICAgcmV0dXJuIGAke2xpbmVOdW19OiAke3RhYnNUb1NwYWNlcyhzdHIpfVxcbiR7aW5kaWNhdG9yfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2xpbmVOdW19OiAke3RhYnNUb1NwYWNlcyhzdHIpfWA7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludFF1b3RlZFN0cmluZ0xpc3QobGlzdCwgdmVyYnMpIHtcbiAgICBjb25zdCBpc1NpbmdsZUl0ZW0gPSBsaXN0Lmxlbmd0aCA8PSAxO1xuICAgIGNvbnN0IHF1b3RlZExpc3QgPSBsaXN0Lm1hcChpdGVtID0+IGBcIiR7aXRlbX1cImApO1xuICAgIGxldCBvdXRwdXQgPSBpc1NpbmdsZUl0ZW1cbiAgICAgICAgPyBxdW90ZWRMaXN0WzBdXG4gICAgICAgIDogYCR7cXVvdGVkTGlzdC5zbGljZSgwLCAtMSkuam9pbignLCAnKX0gYW5kICR7cXVvdGVkTGlzdC5zbGljZSgtMSlbMF19YDtcbiAgICBpZiAodmVyYnMpIHtcbiAgICAgICAgb3V0cHV0ICs9IGAgJHtpc1NpbmdsZUl0ZW0gPyB2ZXJic1swXSA6IHZlcmJzWzFdfWA7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmNvbnN0IEFCU09MVVRFX1BBVEhfUkVHRVggPSAvXig/OlxcL3woPzpbQS1aYS16XTopP1tcXFxcfC9dKS87XG5jb25zdCBSRUxBVElWRV9QQVRIX1JFR0VYID0gL15cXC4/XFwuKFxcL3wkKS87XG5mdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICByZXR1cm4gQUJTT0xVVEVfUEFUSF9SRUdFWC50ZXN0KHBhdGgpO1xufVxuZnVuY3Rpb24gaXNSZWxhdGl2ZShwYXRoKSB7XG4gICAgcmV0dXJuIFJFTEFUSVZFX1BBVEhfUkVHRVgudGVzdChwYXRoKTtcbn1cbmNvbnN0IEJBQ0tTTEFTSF9SRUdFWCA9IC9cXFxcL2c7XG5mdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoQkFDS1NMQVNIX1JFR0VYLCAnLycpO1xufVxuXG5mdW5jdGlvbiBnZXRBbGlhc05hbWUoaWQpIHtcbiAgICBjb25zdCBiYXNlID0gYmFzZW5hbWUoaWQpO1xuICAgIHJldHVybiBiYXNlLnN1YnN0cmluZygwLCBiYXNlLmxlbmd0aCAtIGV4dG5hbWUoaWQpLmxlbmd0aCk7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUlkKGlkKSB7XG4gICAgaWYgKCFpc0Fic29sdXRlKGlkKSlcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIHJldHVybiByZWxhdGl2ZShyZXNvbHZlKCksIGlkKTtcbn1cbmZ1bmN0aW9uIGlzUGF0aEZyYWdtZW50KG5hbWUpIHtcbiAgICAvLyBzdGFydGluZyB3aXRoIFwiL1wiLCBcIi4vXCIsIFwiLi4vXCIsIFwiQzovXCJcbiAgICByZXR1cm4gKG5hbWVbMF0gPT09ICcvJyB8fCAobmFtZVswXSA9PT0gJy4nICYmIChuYW1lWzFdID09PSAnLycgfHwgbmFtZVsxXSA9PT0gJy4nKSkgfHwgaXNBYnNvbHV0ZShuYW1lKSk7XG59XG5jb25zdCBVUFBFUl9ESVJfUkVHRVggPSAvXihcXC5cXC5cXC8pKlxcLlxcLiQvO1xuZnVuY3Rpb24gZ2V0SW1wb3J0UGF0aChpbXBvcnRlcklkLCB0YXJnZXRQYXRoLCBzdHJpcEpzRXh0ZW5zaW9uLCBlbnN1cmVGaWxlTmFtZSkge1xuICAgIGxldCByZWxhdGl2ZVBhdGggPSBub3JtYWxpemUocmVsYXRpdmUoZGlybmFtZShpbXBvcnRlcklkKSwgdGFyZ2V0UGF0aCkpO1xuICAgIGlmIChzdHJpcEpzRXh0ZW5zaW9uICYmIHJlbGF0aXZlUGF0aC5lbmRzV2l0aCgnLmpzJykpIHtcbiAgICAgICAgcmVsYXRpdmVQYXRoID0gcmVsYXRpdmVQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICB9XG4gICAgaWYgKGVuc3VyZUZpbGVOYW1lKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGggPT09ICcnKVxuICAgICAgICAgICAgcmV0dXJuICcuLi8nICsgYmFzZW5hbWUodGFyZ2V0UGF0aCk7XG4gICAgICAgIGlmIChVUFBFUl9ESVJfUkVHRVgudGVzdChyZWxhdGl2ZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgICAgICAgICAuY29uY2F0KFsnLi4nLCBiYXNlbmFtZSh0YXJnZXRQYXRoKV0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXJlbGF0aXZlUGF0aCA/ICcuJyA6IHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpID8gcmVsYXRpdmVQYXRoIDogJy4vJyArIHJlbGF0aXZlUGF0aDtcbn1cblxuZnVuY3Rpb24gZXJyb3IoYmFzZSkge1xuICAgIGlmICghKGJhc2UgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgIGJhc2UgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihiYXNlLm1lc3NhZ2UpLCBiYXNlKTtcbiAgICB0aHJvdyBiYXNlO1xufVxuZnVuY3Rpb24gYXVnbWVudENvZGVMb2NhdGlvbihwcm9wcywgcG9zLCBzb3VyY2UsIGlkKSB7XG4gICAgaWYgKHR5cGVvZiBwb3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHsgbGluZSwgY29sdW1uIH0gPSBwb3M7XG4gICAgICAgIHByb3BzLmxvYyA9IHsgY29sdW1uLCBmaWxlOiBpZCwgbGluZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHMucG9zID0gcG9zO1xuICAgICAgICBjb25zdCB7IGxpbmUsIGNvbHVtbiB9ID0gbG9jYXRlKHNvdXJjZSwgcG9zLCB7IG9mZnNldExpbmU6IDEgfSk7XG4gICAgICAgIHByb3BzLmxvYyA9IHsgY29sdW1uLCBmaWxlOiBpZCwgbGluZSB9O1xuICAgIH1cbiAgICBpZiAocHJvcHMuZnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGxpbmUsIGNvbHVtbiB9ID0gcHJvcHMubG9jO1xuICAgICAgICBwcm9wcy5mcmFtZSA9IGdldENvZGVGcmFtZShzb3VyY2UsIGxpbmUsIGNvbHVtbik7XG4gICAgfVxufVxudmFyIEVycm9ycztcbihmdW5jdGlvbiAoRXJyb3JzKSB7XG4gICAgRXJyb3JzW1wiQUxSRUFEWV9DTE9TRURcIl0gPSBcIkFMUkVBRFlfQ0xPU0VEXCI7XG4gICAgRXJyb3JzW1wiQVNTRVRfTk9UX0ZJTkFMSVNFRFwiXSA9IFwiQVNTRVRfTk9UX0ZJTkFMSVNFRFwiO1xuICAgIEVycm9yc1tcIkFTU0VUX05PVF9GT1VORFwiXSA9IFwiQVNTRVRfTk9UX0ZPVU5EXCI7XG4gICAgRXJyb3JzW1wiQVNTRVRfU09VUkNFX0FMUkVBRFlfU0VUXCJdID0gXCJBU1NFVF9TT1VSQ0VfQUxSRUFEWV9TRVRcIjtcbiAgICBFcnJvcnNbXCJBU1NFVF9TT1VSQ0VfTUlTU0lOR1wiXSA9IFwiQVNTRVRfU09VUkNFX01JU1NJTkdcIjtcbiAgICBFcnJvcnNbXCJCQURfTE9BREVSXCJdID0gXCJCQURfTE9BREVSXCI7XG4gICAgRXJyb3JzW1wiQ0FOTk9UX0VNSVRfRlJPTV9PUFRJT05TX0hPT0tcIl0gPSBcIkNBTk5PVF9FTUlUX0ZST01fT1BUSU9OU19IT09LXCI7XG4gICAgRXJyb3JzW1wiQ0hVTktfTk9UX0dFTkVSQVRFRFwiXSA9IFwiQ0hVTktfTk9UX0dFTkVSQVRFRFwiO1xuICAgIEVycm9yc1tcIkNIVU5LX0lOVkFMSURcIl0gPSBcIkNIVU5LX0lOVkFMSURcIjtcbiAgICBFcnJvcnNbXCJDSVJDVUxBUl9SRUVYUE9SVFwiXSA9IFwiQ0lSQ1VMQVJfUkVFWFBPUlRcIjtcbiAgICBFcnJvcnNbXCJDWUNMSUNfQ1JPU1NfQ0hVTktfUkVFWFBPUlRcIl0gPSBcIkNZQ0xJQ19DUk9TU19DSFVOS19SRUVYUE9SVFwiO1xuICAgIEVycm9yc1tcIkRFUFJFQ0FURURfRkVBVFVSRVwiXSA9IFwiREVQUkVDQVRFRF9GRUFUVVJFXCI7XG4gICAgRXJyb3JzW1wiRVhURVJOQUxfU1lOVEhFVElDX0VYUE9SVFNcIl0gPSBcIkVYVEVSTkFMX1NZTlRIRVRJQ19FWFBPUlRTXCI7XG4gICAgRXJyb3JzW1wiRklMRV9OQU1FX0NPTkZMSUNUXCJdID0gXCJGSUxFX05BTUVfQ09ORkxJQ1RcIjtcbiAgICBFcnJvcnNbXCJGSUxFX05PVF9GT1VORFwiXSA9IFwiRklMRV9OT1RfRk9VTkRcIjtcbiAgICBFcnJvcnNbXCJJTlBVVF9IT09LX0lOX09VVFBVVF9QTFVHSU5cIl0gPSBcIklOUFVUX0hPT0tfSU5fT1VUUFVUX1BMVUdJTlwiO1xuICAgIEVycm9yc1tcIklOVkFMSURfQ0hVTktcIl0gPSBcIklOVkFMSURfQ0hVTktcIjtcbiAgICBFcnJvcnNbXCJJTlZBTElEX0VYUE9SVF9PUFRJT05cIl0gPSBcIklOVkFMSURfRVhQT1JUX09QVElPTlwiO1xuICAgIEVycm9yc1tcIklOVkFMSURfRVhURVJOQUxfSURcIl0gPSBcIklOVkFMSURfRVhURVJOQUxfSURcIjtcbiAgICBFcnJvcnNbXCJJTlZBTElEX09QVElPTlwiXSA9IFwiSU5WQUxJRF9PUFRJT05cIjtcbiAgICBFcnJvcnNbXCJJTlZBTElEX1BMVUdJTl9IT09LXCJdID0gXCJJTlZBTElEX1BMVUdJTl9IT09LXCI7XG4gICAgRXJyb3JzW1wiSU5WQUxJRF9ST0xMVVBfUEhBU0VcIl0gPSBcIklOVkFMSURfUk9MTFVQX1BIQVNFXCI7XG4gICAgRXJyb3JzW1wiTUlTU0lOR19FWFBPUlRcIl0gPSBcIk1JU1NJTkdfRVhQT1JUXCI7XG4gICAgRXJyb3JzW1wiTUlTU0lOR19JTVBMSUNJVF9ERVBFTkRBTlRcIl0gPSBcIk1JU1NJTkdfSU1QTElDSVRfREVQRU5EQU5UXCI7XG4gICAgRXJyb3JzW1wiTUlYRURfRVhQT1JUU1wiXSA9IFwiTUlYRURfRVhQT1JUU1wiO1xuICAgIEVycm9yc1tcIk5BTUVTUEFDRV9DT05GTElDVFwiXSA9IFwiTkFNRVNQQUNFX0NPTkZMSUNUXCI7XG4gICAgRXJyb3JzW1wiQU1CSUdVT1VTX0VYVEVSTkFMX05BTUVTUEFDRVNcIl0gPSBcIkFNQklHVU9VU19FWFRFUk5BTF9OQU1FU1BBQ0VTXCI7XG4gICAgRXJyb3JzW1wiTk9fVFJBTlNGT1JNX01BUF9PUl9BU1RfV0lUSE9VVF9DT0RFXCJdID0gXCJOT19UUkFOU0ZPUk1fTUFQX09SX0FTVF9XSVRIT1VUX0NPREVcIjtcbiAgICBFcnJvcnNbXCJQTFVHSU5fRVJST1JcIl0gPSBcIlBMVUdJTl9FUlJPUlwiO1xuICAgIEVycm9yc1tcIlBSRUZFUl9OQU1FRF9FWFBPUlRTXCJdID0gXCJQUkVGRVJfTkFNRURfRVhQT1JUU1wiO1xuICAgIEVycm9yc1tcIlNZTlRIRVRJQ19OQU1FRF9FWFBPUlRTX05FRURfTkFNRVNQQUNFX0VYUE9SVFwiXSA9IFwiU1lOVEhFVElDX05BTUVEX0VYUE9SVFNfTkVFRF9OQU1FU1BBQ0VfRVhQT1JUXCI7XG4gICAgRXJyb3JzW1wiVU5FWFBFQ1RFRF9OQU1FRF9JTVBPUlRcIl0gPSBcIlVORVhQRUNURURfTkFNRURfSU1QT1JUXCI7XG4gICAgRXJyb3JzW1wiVU5SRVNPTFZFRF9FTlRSWVwiXSA9IFwiVU5SRVNPTFZFRF9FTlRSWVwiO1xuICAgIEVycm9yc1tcIlVOUkVTT0xWRURfSU1QT1JUXCJdID0gXCJVTlJFU09MVkVEX0lNUE9SVFwiO1xuICAgIEVycm9yc1tcIlZBTElEQVRJT05fRVJST1JcIl0gPSBcIlZBTElEQVRJT05fRVJST1JcIjtcbn0pKEVycm9ycyB8fCAoRXJyb3JzID0ge30pKTtcbmZ1bmN0aW9uIGVyckFzc2V0Tm90RmluYWxpc2VkRm9yRmlsZU5hbWUobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5BU1NFVF9OT1RfRklOQUxJU0VELFxuICAgICAgICBtZXNzYWdlOiBgUGx1Z2luIGVycm9yIC0gVW5hYmxlIHRvIGdldCBmaWxlIG5hbWUgZm9yIGFzc2V0IFwiJHtuYW1lfVwiLiBFbnN1cmUgdGhhdCB0aGUgc291cmNlIGlzIHNldCBhbmQgdGhhdCBnZW5lcmF0ZSBpcyBjYWxsZWQgZmlyc3QuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJDYW5ub3RFbWl0RnJvbU9wdGlvbnNIb29rKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5DQU5OT1RfRU1JVF9GUk9NX09QVElPTlNfSE9PSyxcbiAgICAgICAgbWVzc2FnZTogYENhbm5vdCBlbWl0IGZpbGVzIG9yIHNldCBhc3NldCBzb3VyY2VzIGluIHRoZSBcIm91dHB1dE9wdGlvbnNcIiBob29rLCB1c2UgdGhlIFwicmVuZGVyU3RhcnRcIiBob29rIGluc3RlYWQuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJDaHVua05vdEdlbmVyYXRlZEZvckZpbGVOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuQ0hVTktfTk9UX0dFTkVSQVRFRCxcbiAgICAgICAgbWVzc2FnZTogYFBsdWdpbiBlcnJvciAtIFVuYWJsZSB0byBnZXQgZmlsZSBuYW1lIGZvciBjaHVuayBcIiR7bmFtZX1cIi4gRW5zdXJlIHRoYXQgZ2VuZXJhdGUgaXMgY2FsbGVkIGZpcnN0LmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyQ2h1bmtJbnZhbGlkKHsgZmlsZU5hbWUsIGNvZGUgfSwgZXhjZXB0aW9uKSB7XG4gICAgY29uc3QgZXJyb3JQcm9wcyA9IHtcbiAgICAgICAgY29kZTogRXJyb3JzLkNIVU5LX0lOVkFMSUQsXG4gICAgICAgIG1lc3NhZ2U6IGBDaHVuayBcIiR7ZmlsZU5hbWV9XCIgaXMgbm90IHZhbGlkIEphdmFTY3JpcHQ6ICR7ZXhjZXB0aW9uLm1lc3NhZ2V9LmBcbiAgICB9O1xuICAgIGF1Z21lbnRDb2RlTG9jYXRpb24oZXJyb3JQcm9wcywgZXhjZXB0aW9uLmxvYywgY29kZSwgZmlsZU5hbWUpO1xuICAgIHJldHVybiBlcnJvclByb3BzO1xufVxuZnVuY3Rpb24gZXJyQ2lyY3VsYXJSZWV4cG9ydChleHBvcnROYW1lLCBpbXBvcnRlZE1vZHVsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5DSVJDVUxBUl9SRUVYUE9SVCxcbiAgICAgICAgaWQ6IGltcG9ydGVkTW9kdWxlLFxuICAgICAgICBtZXNzYWdlOiBgXCIke2V4cG9ydE5hbWV9XCIgY2Fubm90IGJlIGV4cG9ydGVkIGZyb20gJHtyZWxhdGl2ZUlkKGltcG9ydGVkTW9kdWxlKX0gYXMgaXQgaXMgYSByZWV4cG9ydCB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyQ3ljbGljQ3Jvc3NDaHVua1JlZXhwb3J0KGV4cG9ydE5hbWUsIGV4cG9ydGVyLCByZWV4cG9ydGVyLCBpbXBvcnRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5DWUNMSUNfQ1JPU1NfQ0hVTktfUkVFWFBPUlQsXG4gICAgICAgIGV4cG9ydGVyLFxuICAgICAgICBpbXBvcnRlcixcbiAgICAgICAgbWVzc2FnZTogYEV4cG9ydCBcIiR7ZXhwb3J0TmFtZX1cIiBvZiBtb2R1bGUgJHtyZWxhdGl2ZUlkKGV4cG9ydGVyKX0gd2FzIHJlZXhwb3J0ZWQgdGhyb3VnaCBtb2R1bGUgJHtyZWxhdGl2ZUlkKHJlZXhwb3J0ZXIpfSB3aGlsZSBib3RoIG1vZHVsZXMgYXJlIGRlcGVuZGVuY2llcyBvZiBlYWNoIG90aGVyIGFuZCB3aWxsIGVuZCB1cCBpbiBkaWZmZXJlbnQgY2h1bmtzIGJ5IGN1cnJlbnQgUm9sbHVwIHNldHRpbmdzLiBUaGlzIHNjZW5hcmlvIGlzIG5vdCB3ZWxsIHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50IGFzIGl0IHdpbGwgcHJvZHVjZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBjaHVua3MgYW5kIHdpbGwgbGlrZWx5IGxlYWQgdG8gYnJva2VuIGV4ZWN1dGlvbiBvcmRlci5cXG5FaXRoZXIgY2hhbmdlIHRoZSBpbXBvcnQgaW4gJHtyZWxhdGl2ZUlkKGltcG9ydGVyKX0gdG8gcG9pbnQgZGlyZWN0bHkgdG8gdGhlIGV4cG9ydGluZyBtb2R1bGUgb3IgZG8gbm90IHVzZSBcInByZXNlcnZlTW9kdWxlc1wiIHRvIGVuc3VyZSB0aGVzZSBtb2R1bGVzIGVuZCB1cCBpbiB0aGUgc2FtZSBjaHVuay5gLFxuICAgICAgICByZWV4cG9ydGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyckFzc2V0UmVmZXJlbmNlSWROb3RGb3VuZEZvclNldFNvdXJjZShhc3NldFJlZmVyZW5jZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLkFTU0VUX05PVF9GT1VORCxcbiAgICAgICAgbWVzc2FnZTogYFBsdWdpbiBlcnJvciAtIFVuYWJsZSB0byBzZXQgdGhlIHNvdXJjZSBmb3IgdW5rbm93biBhc3NldCBcIiR7YXNzZXRSZWZlcmVuY2VJZH1cIi5gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyckFzc2V0U291cmNlQWxyZWFkeVNldChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLkFTU0VUX1NPVVJDRV9BTFJFQURZX1NFVCxcbiAgICAgICAgbWVzc2FnZTogYFVuYWJsZSB0byBzZXQgdGhlIHNvdXJjZSBmb3IgYXNzZXQgXCIke25hbWV9XCIsIHNvdXJjZSBhbHJlYWR5IHNldC5gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyck5vQXNzZXRTb3VyY2VTZXQoYXNzZXROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLkFTU0VUX1NPVVJDRV9NSVNTSU5HLFxuICAgICAgICBtZXNzYWdlOiBgUGx1Z2luIGVycm9yIGNyZWF0aW5nIGFzc2V0IFwiJHthc3NldE5hbWV9XCIgLSBubyBhc3NldCBzb3VyY2Ugc2V0LmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyQmFkTG9hZGVyKGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLkJBRF9MT0FERVIsXG4gICAgICAgIG1lc3NhZ2U6IGBFcnJvciBsb2FkaW5nICR7cmVsYXRpdmVJZChpZCl9OiBwbHVnaW4gbG9hZCBob29rIHNob3VsZCByZXR1cm4gYSBzdHJpbmcsIGEgeyBjb2RlLCBtYXAgfSBvYmplY3QsIG9yIG5vdGhpbmcvbnVsbGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyRGVwcmVjYXRpb24oZGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuREVQUkVDQVRFRF9GRUFUVVJFLFxuICAgICAgICAuLi4odHlwZW9mIGRlcHJlY2F0aW9uID09PSAnc3RyaW5nJyA/IHsgbWVzc2FnZTogZGVwcmVjYXRpb24gfSA6IGRlcHJlY2F0aW9uKVxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJGaWxlUmVmZXJlbmNlSWROb3RGb3VuZEZvckZpbGVuYW1lKGFzc2V0UmVmZXJlbmNlSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuRklMRV9OT1RfRk9VTkQsXG4gICAgICAgIG1lc3NhZ2U6IGBQbHVnaW4gZXJyb3IgLSBVbmFibGUgdG8gZ2V0IGZpbGUgbmFtZSBmb3IgdW5rbm93biBmaWxlIFwiJHthc3NldFJlZmVyZW5jZUlkfVwiLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyRmlsZU5hbWVDb25mbGljdChmaWxlTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5GSUxFX05BTUVfQ09ORkxJQ1QsXG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgZW1pdHRlZCBmaWxlIFwiJHtmaWxlTmFtZX1cIiBvdmVyd3JpdGVzIGEgcHJldmlvdXNseSBlbWl0dGVkIGZpbGUgb2YgdGhlIHNhbWUgbmFtZS5gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVycklucHV0SG9va0luT3V0cHV0UGx1Z2luKHBsdWdpbk5hbWUsIGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLklOUFVUX0hPT0tfSU5fT1VUUFVUX1BMVUdJTixcbiAgICAgICAgbWVzc2FnZTogYFRoZSBcIiR7aG9va05hbWV9XCIgaG9vayB1c2VkIGJ5IHRoZSBvdXRwdXQgcGx1Z2luICR7cGx1Z2luTmFtZX0gaXMgYSBidWlsZCB0aW1lIGhvb2sgYW5kIHdpbGwgbm90IGJlIHJ1biBmb3IgdGhhdCBwbHVnaW4uIEVpdGhlciB0aGlzIHBsdWdpbiBjYW5ub3QgYmUgdXNlZCBhcyBhbiBvdXRwdXQgcGx1Z2luLCBvciBpdCBzaG91bGQgaGF2ZSBhbiBvcHRpb24gdG8gY29uZmlndXJlIGl0IGFzIGFuIG91dHB1dCBwbHVnaW4uYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJDYW5ub3RBc3NpZ25Nb2R1bGVUb0NodW5rKG1vZHVsZUlkLCBhc3NpZ25Ub0FsaWFzLCBjdXJyZW50QWxpYXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuSU5WQUxJRF9DSFVOSyxcbiAgICAgICAgbWVzc2FnZTogYENhbm5vdCBhc3NpZ24gJHtyZWxhdGl2ZUlkKG1vZHVsZUlkKX0gdG8gdGhlIFwiJHthc3NpZ25Ub0FsaWFzfVwiIGNodW5rIGFzIGl0IGlzIGFscmVhZHkgaW4gdGhlIFwiJHtjdXJyZW50QWxpYXN9XCIgY2h1bmsuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJJbnZhbGlkRXhwb3J0T3B0aW9uVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuSU5WQUxJRF9FWFBPUlRfT1BUSU9OLFxuICAgICAgICBtZXNzYWdlOiBgXCJvdXRwdXQuZXhwb3J0c1wiIG11c3QgYmUgXCJkZWZhdWx0XCIsIFwibmFtZWRcIiwgXCJub25lXCIsIFwiYXV0b1wiLCBvciBsZWZ0IHVuc3BlY2lmaWVkIChkZWZhdWx0cyB0byBcImF1dG9cIiksIHJlY2VpdmVkIFwiJHtvcHRpb25WYWx1ZX1cImAsXG4gICAgICAgIHVybDogYGh0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyNvdXRwdXRleHBvcnRzYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJJbmNvbXBhdGlibGVFeHBvcnRPcHRpb25WYWx1ZShvcHRpb25WYWx1ZSwga2V5cywgZW50cnlNb2R1bGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiAnSU5WQUxJRF9FWFBPUlRfT1BUSU9OJyxcbiAgICAgICAgbWVzc2FnZTogYFwiJHtvcHRpb25WYWx1ZX1cIiB3YXMgc3BlY2lmaWVkIGZvciBcIm91dHB1dC5leHBvcnRzXCIsIGJ1dCBlbnRyeSBtb2R1bGUgXCIke3JlbGF0aXZlSWQoZW50cnlNb2R1bGUpfVwiIGhhcyB0aGUgZm9sbG93aW5nIGV4cG9ydHM6ICR7a2V5cy5qb2luKCcsICcpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJySW50ZXJuYWxJZENhbm5vdEJlRXh0ZXJuYWwoc291cmNlLCBpbXBvcnRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5JTlZBTElEX0VYVEVSTkFMX0lELFxuICAgICAgICBtZXNzYWdlOiBgJyR7c291cmNlfScgaXMgaW1wb3J0ZWQgYXMgYW4gZXh0ZXJuYWwgYnkgJHtyZWxhdGl2ZUlkKGltcG9ydGVyKX0sIGJ1dCBpcyBhbHJlYWR5IGFuIGV4aXN0aW5nIG5vbi1leHRlcm5hbCBtb2R1bGUgaWQuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJJbnZhbGlkT3B0aW9uKG9wdGlvbiwgdXJsSGFzaCwgZXhwbGFuYXRpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLklOVkFMSURfT1BUSU9OLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCB2YWx1ZSAke3ZhbHVlICE9PSB1bmRlZmluZWQgPyBgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGAgOiAnJ31mb3Igb3B0aW9uIFwiJHtvcHRpb259XCIgLSAke2V4cGxhbmF0aW9ufS5gLFxuICAgICAgICB1cmw6IGBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jJHt1cmxIYXNofWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJySW52YWxpZFJvbGx1cFBoYXNlRm9yQWRkV2F0Y2hGaWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5JTlZBTElEX1JPTExVUF9QSEFTRSxcbiAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjYWxsIGFkZFdhdGNoRmlsZSBhZnRlciB0aGUgYnVpbGQgaGFzIGZpbmlzaGVkLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJySW52YWxpZFJvbGx1cFBoYXNlRm9yQ2h1bmtFbWlzc2lvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuSU5WQUxJRF9ST0xMVVBfUEhBU0UsXG4gICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgZW1pdCBjaHVua3MgYWZ0ZXIgbW9kdWxlIGxvYWRpbmcgaGFzIGZpbmlzaGVkLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyTWlzc2luZ0V4cG9ydChleHBvcnROYW1lLCBpbXBvcnRpbmdNb2R1bGUsIGltcG9ydGVkTW9kdWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLk1JU1NJTkdfRVhQT1JULFxuICAgICAgICBtZXNzYWdlOiBgJyR7ZXhwb3J0TmFtZX0nIGlzIG5vdCBleHBvcnRlZCBieSAke3JlbGF0aXZlSWQoaW1wb3J0ZWRNb2R1bGUpfSwgaW1wb3J0ZWQgYnkgJHtyZWxhdGl2ZUlkKGltcG9ydGluZ01vZHVsZSl9YCxcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI2Vycm9yLW5hbWUtaXMtbm90LWV4cG9ydGVkLWJ5LW1vZHVsZWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJySW1wbGljaXREZXBlbmRhbnRDYW5ub3RCZUV4dGVybmFsKHVucmVzb2x2ZWRJZCwgaW1wbGljaXRseUxvYWRlZEJlZm9yZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5NSVNTSU5HX0lNUExJQ0lUX0RFUEVOREFOVCxcbiAgICAgICAgbWVzc2FnZTogYE1vZHVsZSBcIiR7cmVsYXRpdmVJZCh1bnJlc29sdmVkSWQpfVwiIHRoYXQgc2hvdWxkIGJlIGltcGxpY2l0bHkgbG9hZGVkIGJlZm9yZSBcIiR7cmVsYXRpdmVJZChpbXBsaWNpdGx5TG9hZGVkQmVmb3JlKX1cIiBjYW5ub3QgYmUgZXh0ZXJuYWwuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJVbnJlc29sdmVkSW1wbGljaXREZXBlbmRhbnQodW5yZXNvbHZlZElkLCBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLk1JU1NJTkdfSU1QTElDSVRfREVQRU5EQU5ULFxuICAgICAgICBtZXNzYWdlOiBgTW9kdWxlIFwiJHtyZWxhdGl2ZUlkKHVucmVzb2x2ZWRJZCl9XCIgdGhhdCBzaG91bGQgYmUgaW1wbGljaXRseSBsb2FkZWQgYmVmb3JlIFwiJHtyZWxhdGl2ZUlkKGltcGxpY2l0bHlMb2FkZWRCZWZvcmUpfVwiIGNvdWxkIG5vdCBiZSByZXNvbHZlZC5gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyckltcGxpY2l0RGVwZW5kYW50SXNOb3RJbmNsdWRlZChtb2R1bGUpIHtcbiAgICBjb25zdCBpbXBsaWNpdERlcGVuZGVuY2llcyA9IEFycmF5LmZyb20obW9kdWxlLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUsIGRlcGVuZGVuY3kgPT4gcmVsYXRpdmVJZChkZXBlbmRlbmN5LmlkKSkuc29ydCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5NSVNTSU5HX0lNUExJQ0lUX0RFUEVOREFOVCxcbiAgICAgICAgbWVzc2FnZTogYE1vZHVsZSBcIiR7cmVsYXRpdmVJZChtb2R1bGUuaWQpfVwiIHRoYXQgc2hvdWxkIGJlIGltcGxpY2l0bHkgbG9hZGVkIGJlZm9yZSAke3ByaW50UXVvdGVkU3RyaW5nTGlzdChpbXBsaWNpdERlcGVuZGVuY2llcyl9IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgbW9kdWxlIGdyYXBoLiBFaXRoZXIgaXQgd2FzIG5vdCBpbXBvcnRlZCBieSBhbiBpbmNsdWRlZCBtb2R1bGUgb3Igb25seSB2aWEgYSB0cmVlLXNoYWtlbiBkeW5hbWljIGltcG9ydCwgb3Igbm8gaW1wb3J0ZWQgYmluZGluZ3Mgd2VyZSB1c2VkIGFuZCBpdCBoYWQgb3RoZXJ3aXNlIG5vIHNpZGUtZWZmZWN0cy5gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyck1peGVkRXhwb3J0KGZhY2FkZU1vZHVsZUlkLCBuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLk1JWEVEX0VYUE9SVFMsXG4gICAgICAgIGlkOiBmYWNhZGVNb2R1bGVJZCxcbiAgICAgICAgbWVzc2FnZTogYEVudHJ5IG1vZHVsZSBcIiR7cmVsYXRpdmVJZChmYWNhZGVNb2R1bGVJZCl9XCIgaXMgdXNpbmcgbmFtZWQgYW5kIGRlZmF1bHQgZXhwb3J0cyB0b2dldGhlci4gQ29uc3VtZXJzIG9mIHlvdXIgYnVuZGxlIHdpbGwgaGF2ZSB0byB1c2UgXFxgJHtuYW1lIHx8ICdjaHVuayd9W1wiZGVmYXVsdFwiXVxcYCB0byBhY2Nlc3MgdGhlIGRlZmF1bHQgZXhwb3J0LCB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnQuIFVzZSBcXGBvdXRwdXQuZXhwb3J0czogXCJuYW1lZFwiXFxgIHRvIGRpc2FibGUgdGhpcyB3YXJuaW5nYCxcbiAgICAgICAgdXJsOiBgaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI291dHB1dGV4cG9ydHNgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVyck5hbWVzcGFjZUNvbmZsaWN0KG5hbWUsIHJlZXhwb3J0aW5nTW9kdWxlSWQsIHNvdXJjZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuTkFNRVNQQUNFX0NPTkZMSUNULFxuICAgICAgICBtZXNzYWdlOiBgQ29uZmxpY3RpbmcgbmFtZXNwYWNlczogXCIke3JlbGF0aXZlSWQocmVleHBvcnRpbmdNb2R1bGVJZCl9XCIgcmUtZXhwb3J0cyBcIiR7bmFtZX1cIiBmcm9tIG9uZSBvZiB0aGUgbW9kdWxlcyAke3ByaW50UXVvdGVkU3RyaW5nTGlzdChzb3VyY2VzLm1hcChtb2R1bGVJZCA9PiByZWxhdGl2ZUlkKG1vZHVsZUlkKSkpfSAod2lsbCBiZSBpZ25vcmVkKWAsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHJlZXhwb3J0ZXI6IHJlZXhwb3J0aW5nTW9kdWxlSWQsXG4gICAgICAgIHNvdXJjZXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyQW1iaWd1b3VzRXh0ZXJuYWxOYW1lc3BhY2VzKG5hbWUsIHJlZXhwb3J0aW5nTW9kdWxlLCB1c2VkTW9kdWxlLCBzb3VyY2VzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLkFNQklHVU9VU19FWFRFUk5BTF9OQU1FU1BBQ0VTLFxuICAgICAgICBtZXNzYWdlOiBgQW1iaWd1b3VzIGV4dGVybmFsIG5hbWVzcGFjZSByZXNvbHV0aW9uOiBcIiR7cmVsYXRpdmVJZChyZWV4cG9ydGluZ01vZHVsZSl9XCIgcmUtZXhwb3J0cyBcIiR7bmFtZX1cIiBmcm9tIG9uZSBvZiB0aGUgZXh0ZXJuYWwgbW9kdWxlcyAke3ByaW50UXVvdGVkU3RyaW5nTGlzdChzb3VyY2VzLm1hcChtb2R1bGUgPT4gcmVsYXRpdmVJZChtb2R1bGUpKSl9LCBndWVzc2luZyBcIiR7cmVsYXRpdmVJZCh1c2VkTW9kdWxlKX1cIi5gLFxuICAgICAgICBuYW1lLFxuICAgICAgICByZWV4cG9ydGVyOiByZWV4cG9ydGluZ01vZHVsZSxcbiAgICAgICAgc291cmNlc1xuICAgIH07XG59XG5mdW5jdGlvbiBlcnJOb1RyYW5zZm9ybU1hcE9yQXN0V2l0aG91dENvZGUocGx1Z2luTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5OT19UUkFOU0ZPUk1fTUFQX09SX0FTVF9XSVRIT1VUX0NPREUsXG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgcGx1Z2luIFwiJHtwbHVnaW5OYW1lfVwiIHJldHVybmVkIGEgXCJtYXBcIiBvciBcImFzdFwiIHdpdGhvdXQgcmV0dXJuaW5nIGAgK1xuICAgICAgICAgICAgJ2EgXCJjb2RlXCIuIFRoaXMgd2lsbCBiZSBpZ25vcmVkLidcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyUHJlZmVyTmFtZWRFeHBvcnRzKGZhY2FkZU1vZHVsZUlkKSB7XG4gICAgY29uc3QgZmlsZSA9IHJlbGF0aXZlSWQoZmFjYWRlTW9kdWxlSWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5QUkVGRVJfTkFNRURfRVhQT1JUUyxcbiAgICAgICAgaWQ6IGZhY2FkZU1vZHVsZUlkLFxuICAgICAgICBtZXNzYWdlOiBgRW50cnkgbW9kdWxlIFwiJHtmaWxlfVwiIGlzIGltcGxpY2l0bHkgdXNpbmcgXCJkZWZhdWx0XCIgZXhwb3J0IG1vZGUsIHdoaWNoIG1lYW5zIGZvciBDb21tb25KUyBvdXRwdXQgdGhhdCBpdHMgZGVmYXVsdCBleHBvcnQgaXMgYXNzaWduZWQgdG8gXCJtb2R1bGUuZXhwb3J0c1wiLiBGb3IgbWFueSB0b29scywgc3VjaCBDb21tb25KUyBvdXRwdXQgd2lsbCBub3QgYmUgaW50ZXJjaGFuZ2VhYmxlIHdpdGggdGhlIG9yaWdpbmFsIEVTIG1vZHVsZS4gSWYgdGhpcyBpcyBpbnRlbmRlZCwgZXhwbGljaXRseSBzZXQgXCJvdXRwdXQuZXhwb3J0c1wiIHRvIGVpdGhlciBcImF1dG9cIiBvciBcImRlZmF1bHRcIiwgb3RoZXJ3aXNlIHlvdSBtaWdodCB3YW50IHRvIGNvbnNpZGVyIGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgXCIke2ZpbGV9XCIgdG8gdXNlIG5hbWVkIGV4cG9ydHMgb25seS5gLFxuICAgICAgICB1cmw6IGBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jb3V0cHV0ZXhwb3J0c2BcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyU3ludGhldGljTmFtZWRFeHBvcnRzTmVlZE5hbWVzcGFjZUV4cG9ydChpZCwgc3ludGhldGljTmFtZWRFeHBvcnRzT3B0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLlNZTlRIRVRJQ19OQU1FRF9FWFBPUlRTX05FRURfTkFNRVNQQUNFX0VYUE9SVCxcbiAgICAgICAgaWQsXG4gICAgICAgIG1lc3NhZ2U6IGBNb2R1bGUgXCIke3JlbGF0aXZlSWQoaWQpfVwiIHRoYXQgaXMgbWFya2VkIHdpdGggJ3N5bnRoZXRpY05hbWVkRXhwb3J0czogJHtKU09OLnN0cmluZ2lmeShzeW50aGV0aWNOYW1lZEV4cG9ydHNPcHRpb24pfScgbmVlZHMgJHt0eXBlb2Ygc3ludGhldGljTmFtZWRFeHBvcnRzT3B0aW9uID09PSAnc3RyaW5nJyAmJiBzeW50aGV0aWNOYW1lZEV4cG9ydHNPcHRpb24gIT09ICdkZWZhdWx0J1xuICAgICAgICAgICAgPyBgYW4gZXhwbGljaXQgZXhwb3J0IG5hbWVkIFwiJHtzeW50aGV0aWNOYW1lZEV4cG9ydHNPcHRpb259XCJgXG4gICAgICAgICAgICA6ICdhIGRlZmF1bHQgZXhwb3J0J30gdGhhdCBkb2VzIG5vdCByZWV4cG9ydCBhbiB1bnJlc29sdmVkIG5hbWVkIGV4cG9ydCBvZiB0aGUgc2FtZSBtb2R1bGUuYFxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJVbmV4cGVjdGVkTmFtZWRJbXBvcnQoaWQsIGltcG9ydGVkLCBpc1JlZXhwb3J0KSB7XG4gICAgY29uc3QgaW1wb3J0VHlwZSA9IGlzUmVleHBvcnQgPyAncmVleHBvcnQnIDogJ2ltcG9ydCc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLlVORVhQRUNURURfTkFNRURfSU1QT1JULFxuICAgICAgICBpZCxcbiAgICAgICAgbWVzc2FnZTogYFRoZSBuYW1lZCBleHBvcnQgXCIke2ltcG9ydGVkfVwiIHdhcyAke2ltcG9ydFR5cGV9ZWQgZnJvbSB0aGUgZXh0ZXJuYWwgbW9kdWxlICR7cmVsYXRpdmVJZChpZCl9IGV2ZW4gdGhvdWdoIGl0cyBpbnRlcm9wIHR5cGUgaXMgXCJkZWZhdWx0T25seVwiLiBFaXRoZXIgcmVtb3ZlIG9yIGNoYW5nZSB0aGlzICR7aW1wb3J0VHlwZX0gb3IgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgXCJvdXRwdXQuaW50ZXJvcFwiIG9wdGlvbi5gLFxuICAgICAgICB1cmw6ICdodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jb3V0cHV0aW50ZXJvcCdcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyVW5leHBlY3RlZE5hbWVzcGFjZVJlZXhwb3J0KGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLlVORVhQRUNURURfTkFNRURfSU1QT1JULFxuICAgICAgICBpZCxcbiAgICAgICAgbWVzc2FnZTogYFRoZXJlIHdhcyBhIG5hbWVzcGFjZSBcIipcIiByZWV4cG9ydCBmcm9tIHRoZSBleHRlcm5hbCBtb2R1bGUgJHtyZWxhdGl2ZUlkKGlkKX0gZXZlbiB0aG91Z2ggaXRzIGludGVyb3AgdHlwZSBpcyBcImRlZmF1bHRPbmx5XCIuIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGFzIG5hbWVzcGFjZSByZWV4cG9ydHMgb25seSByZWV4cG9ydCBuYW1lZCBleHBvcnRzLiBJZiB0aGlzIGlzIG5vdCBpbnRlbmRlZCwgZWl0aGVyIHJlbW92ZSBvciBjaGFuZ2UgdGhpcyByZWV4cG9ydCBvciBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBcIm91dHB1dC5pbnRlcm9wXCIgb3B0aW9uLmAsXG4gICAgICAgIHVybDogJ2h0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyNvdXRwdXRpbnRlcm9wJ1xuICAgIH07XG59XG5mdW5jdGlvbiBlcnJFbnRyeUNhbm5vdEJlRXh0ZXJuYWwodW5yZXNvbHZlZElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLlVOUkVTT0xWRURfRU5UUlksXG4gICAgICAgIG1lc3NhZ2U6IGBFbnRyeSBtb2R1bGUgY2Fubm90IGJlIGV4dGVybmFsICgke3JlbGF0aXZlSWQodW5yZXNvbHZlZElkKX0pLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyVW5yZXNvbHZlZEVudHJ5KHVucmVzb2x2ZWRJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5VTlJFU09MVkVEX0VOVFJZLFxuICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IHJlc29sdmUgZW50cnkgbW9kdWxlICgke3JlbGF0aXZlSWQodW5yZXNvbHZlZElkKX0pLmBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyVW5yZXNvbHZlZEltcG9ydChzb3VyY2UsIGltcG9ydGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogRXJyb3JzLlVOUkVTT0xWRURfSU1QT1JULFxuICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IHJlc29sdmUgJyR7c291cmNlfScgZnJvbSAke3JlbGF0aXZlSWQoaW1wb3J0ZXIpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyVW5yZXNvbHZlZEltcG9ydFRyZWF0ZWRBc0V4dGVybmFsKHNvdXJjZSwgaW1wb3J0ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuVU5SRVNPTFZFRF9JTVBPUlQsXG4gICAgICAgIGltcG9ydGVyOiByZWxhdGl2ZUlkKGltcG9ydGVyKSxcbiAgICAgICAgbWVzc2FnZTogYCcke3NvdXJjZX0nIGlzIGltcG9ydGVkIGJ5ICR7cmVsYXRpdmVJZChpbXBvcnRlcil9LCBidXQgY291bGQgbm90IGJlIHJlc29sdmVkIFx1MjAxMyB0cmVhdGluZyBpdCBhcyBhbiBleHRlcm5hbCBkZXBlbmRlbmN5YCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB1cmw6ICdodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jd2FybmluZy10cmVhdGluZy1tb2R1bGUtYXMtZXh0ZXJuYWwtZGVwZW5kZW5jeSdcbiAgICB9O1xufVxuZnVuY3Rpb24gZXJyRXh0ZXJuYWxTeW50aGV0aWNFeHBvcnRzKHNvdXJjZSwgaW1wb3J0ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuRVhURVJOQUxfU1lOVEhFVElDX0VYUE9SVFMsXG4gICAgICAgIGltcG9ydGVyOiByZWxhdGl2ZUlkKGltcG9ydGVyKSxcbiAgICAgICAgbWVzc2FnZTogYEV4dGVybmFsICcke3NvdXJjZX0nIGNhbiBub3QgaGF2ZSAnc3ludGhldGljTmFtZWRFeHBvcnRzJyBlbmFibGVkLmAsXG4gICAgICAgIHNvdXJjZVxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJGYWlsZWRWYWxpZGF0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBFcnJvcnMuVkFMSURBVElPTl9FUlJPUixcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59XG5mdW5jdGlvbiBlcnJBbHJlYWR5Q2xvc2VkKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IEVycm9ycy5BTFJFQURZX0NMT1NFRCxcbiAgICAgICAgbWVzc2FnZTogJ0J1bmRsZSBpcyBhbHJlYWR5IGNsb3NlZCwgbm8gbW9yZSBjYWxscyB0byBcImdlbmVyYXRlXCIgb3IgXCJ3cml0ZVwiIGFyZSBhbGxvd2VkLidcbiAgICB9O1xufVxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGRlcHJlY2F0aW9uLCBhY3RpdmVEZXByZWNhdGlvbiwgb3B0aW9ucykge1xuICAgIHdhcm5EZXByZWNhdGlvbldpdGhPcHRpb25zKGRlcHJlY2F0aW9uLCBhY3RpdmVEZXByZWNhdGlvbiwgb3B0aW9ucy5vbndhcm4sIG9wdGlvbnMuc3RyaWN0RGVwcmVjYXRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGlvbldpdGhPcHRpb25zKGRlcHJlY2F0aW9uLCBhY3RpdmVEZXByZWNhdGlvbiwgd2Fybiwgc3RyaWN0RGVwcmVjYXRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZURlcHJlY2F0aW9uIHx8IHN0cmljdERlcHJlY2F0aW9ucykge1xuICAgICAgICBjb25zdCB3YXJuaW5nID0gZXJyRGVwcmVjYXRpb24oZGVwcmVjYXRpb24pO1xuICAgICAgICBpZiAoc3RyaWN0RGVwcmVjYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Iod2FybmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgd2Fybih3YXJuaW5nKTtcbiAgICB9XG59XG5cbmNvbnN0IFJFU0VSVkVEX05BTUVTID0gbmV3IFNldChbXG4gICAgJ2F3YWl0JyxcbiAgICAnYnJlYWsnLFxuICAgICdjYXNlJyxcbiAgICAnY2F0Y2gnLFxuICAgICdjbGFzcycsXG4gICAgJ2NvbnN0JyxcbiAgICAnY29udGludWUnLFxuICAgICdkZWJ1Z2dlcicsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWxldGUnLFxuICAgICdkbycsXG4gICAgJ2Vsc2UnLFxuICAgICdlbnVtJyxcbiAgICAnZXZhbCcsXG4gICAgJ2V4cG9ydCcsXG4gICAgJ2V4dGVuZHMnLFxuICAgICdmYWxzZScsXG4gICAgJ2ZpbmFsbHknLFxuICAgICdmb3InLFxuICAgICdmdW5jdGlvbicsXG4gICAgJ2lmJyxcbiAgICAnaW1wbGVtZW50cycsXG4gICAgJ2ltcG9ydCcsXG4gICAgJ2luJyxcbiAgICAnaW5zdGFuY2VvZicsXG4gICAgJ2ludGVyZmFjZScsXG4gICAgJ2xldCcsXG4gICAgJ05hTicsXG4gICAgJ25ldycsXG4gICAgJ251bGwnLFxuICAgICdwYWNrYWdlJyxcbiAgICAncHJpdmF0ZScsXG4gICAgJ3Byb3RlY3RlZCcsXG4gICAgJ3B1YmxpYycsXG4gICAgJ3JldHVybicsXG4gICAgJ3N0YXRpYycsXG4gICAgJ3N1cGVyJyxcbiAgICAnc3dpdGNoJyxcbiAgICAndGhpcycsXG4gICAgJ3Rocm93JyxcbiAgICAndHJ1ZScsXG4gICAgJ3RyeScsXG4gICAgJ3R5cGVvZicsXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ3ZhcicsXG4gICAgJ3ZvaWQnLFxuICAgICd3aGlsZScsXG4gICAgJ3dpdGgnLFxuICAgICd5aWVsZCdcbl0pO1xuY29uc3QgUkVTRVJWRURfTkFNRVMkMSA9IFJFU0VSVkVEX05BTUVTO1xuXG5jb25zdCBpbGxlZ2FsQ2hhcmFjdGVycyA9IC9bXiRfYS16QS1aMC05XS9nO1xuY29uc3Qgc3RhcnRzV2l0aERpZ2l0ID0gKHN0cikgPT4gL1xcZC8udGVzdChzdHJbMF0pO1xuZnVuY3Rpb24gaXNMZWdhbChzdHIpIHtcbiAgICBpZiAoc3RhcnRzV2l0aERpZ2l0KHN0cikgfHwgUkVTRVJWRURfTkFNRVMkMS5oYXMoc3RyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhaWxsZWdhbENoYXJhY3RlcnMudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gbWFrZUxlZ2FsKHN0cikge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoaWxsZWdhbENoYXJhY3RlcnMsICdfJyk7XG4gICAgaWYgKHN0YXJ0c1dpdGhEaWdpdChzdHIpIHx8IFJFU0VSVkVEX05BTUVTJDEuaGFzKHN0cikpXG4gICAgICAgIHN0ciA9IGBfJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyIHx8ICdfJztcbn1cblxuY2xhc3MgRXh0ZXJuYWxNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlkLCBtb2R1bGVTaWRlRWZmZWN0cywgbWV0YSwgcmVub3JtYWxpemVSZW5kZXJQYXRoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGggPSByZW5vcm1hbGl6ZVJlbmRlclBhdGg7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYXJpYWJsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5keW5hbWljSW1wb3J0ZXJzID0gW107XG4gICAgICAgIHRoaXMuZXhlY0luZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW1wb3J0ZXJzID0gW107XG4gICAgICAgIHRoaXMubW9zdENvbW1vblN1Z2dlc3Rpb24gPSAwO1xuICAgICAgICB0aGlzLm5hbWVTdWdnZXN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VWYXJpYWJsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5yZWV4cG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lID0gJyc7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGVkVmFyaWFibGVOYW1lID0gbWFrZUxlZ2FsKGlkLnNwbGl0KC9bXFxcXC9dLykucG9wKCkpO1xuICAgICAgICBjb25zdCB7IGltcG9ydGVycywgZHluYW1pY0ltcG9ydGVycyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaW5mbyA9ICh0aGlzLmluZm8gPSB7XG4gICAgICAgICAgICBhc3Q6IG51bGwsXG4gICAgICAgICAgICBjb2RlOiBudWxsLFxuICAgICAgICAgICAgZHluYW1pY2FsbHlJbXBvcnRlZElkUmVzb2x1dGlvbnM6IEVNUFRZX0FSUkFZLFxuICAgICAgICAgICAgZHluYW1pY2FsbHlJbXBvcnRlZElkczogRU1QVFlfQVJSQVksXG4gICAgICAgICAgICBnZXQgZHluYW1pY0ltcG9ydGVycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHluYW1pY0ltcG9ydGVycy5zb3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzRGVmYXVsdEV4cG9ydDogbnVsbCxcbiAgICAgICAgICAgIGdldCBoYXNNb2R1bGVTaWRlRWZmZWN0cygpIHtcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oJ0FjY2Vzc2luZyBNb2R1bGVJbmZvLmhhc01vZHVsZVNpZGVFZmZlY3RzIGZyb20gcGx1Z2lucyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIE1vZHVsZUluZm8ubW9kdWxlU2lkZUVmZmVjdHMgaW5zdGVhZC4nLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm8ubW9kdWxlU2lkZUVmZmVjdHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJPbmVPZjogRU1QVFlfQVJSQVksXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgICAgIGltcG9ydGVkSWRSZXNvbHV0aW9uczogRU1QVFlfQVJSQVksXG4gICAgICAgICAgICBpbXBvcnRlZElkczogRU1QVFlfQVJSQVksXG4gICAgICAgICAgICBnZXQgaW1wb3J0ZXJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRlcnMuc29ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRW50cnk6IGZhbHNlLFxuICAgICAgICAgICAgaXNFeHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIGlzSW5jbHVkZWQ6IG51bGwsXG4gICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgICAgICAgICBzeW50aGV0aWNOYW1lZEV4cG9ydHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIaWRlIHRoZSBkZXByZWNhdGVkIGtleSBzbyB0aGF0IGl0IG9ubHkgd2FybnMgd2hlbiBhY2Nlc3NlZCBleHBsaWNpdGx5XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmluZm8sICdoYXNNb2R1bGVTaWRlRWZmZWN0cycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZGVjbGFyYXRpb25zLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIFtkZWNsYXJhdGlvbl07XG4gICAgICAgIGNvbnN0IGV4dGVybmFsVmFyaWFibGUgPSBuZXcgRXh0ZXJuYWxWYXJpYWJsZSh0aGlzLCBuYW1lKTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMuc2V0KG5hbWUsIGV4dGVybmFsVmFyaWFibGUpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkVmFyaWFibGVzLnNldChleHRlcm5hbFZhcmlhYmxlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIFtleHRlcm5hbFZhcmlhYmxlXTtcbiAgICB9XG4gICAgc2V0UmVuZGVyUGF0aChvcHRpb25zLCBpbnB1dEJhc2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQYXRoID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhdGhzID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5wYXRocyh0aGlzLmlkKSA6IG9wdGlvbnMucGF0aHNbdGhpcy5pZF07XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclBhdGggPSB0aGlzLnJlbm9ybWFsaXplUmVuZGVyUGF0aFxuICAgICAgICAgICAgICAgID8gbm9ybWFsaXplKHJlbGF0aXZlJDEoaW5wdXRCYXNlLCB0aGlzLmlkKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VnZ2VzdE5hbWUobmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKChfYSA9IHRoaXMubmFtZVN1Z2dlc3Rpb25zLmdldChuYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyAxO1xuICAgICAgICB0aGlzLm5hbWVTdWdnZXN0aW9ucy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPiB0aGlzLm1vc3RDb21tb25TdWdnZXN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vc3RDb21tb25TdWdnZXN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FyblVudXNlZEltcG9ydHMoKSB7XG4gICAgICAgIGNvbnN0IHVudXNlZCA9IEFycmF5LmZyb20odGhpcy5kZWNsYXJhdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKChbbmFtZSwgZGVjbGFyYXRpb25dKSA9PiBuYW1lICE9PSAnKicgJiYgIWRlY2xhcmF0aW9uLmluY2x1ZGVkICYmICF0aGlzLnJlZXhwb3J0ZWQgJiYgIWRlY2xhcmF0aW9uLnJlZmVyZW5jZWQpXG4gICAgICAgICAgICAubWFwKChbbmFtZV0pID0+IG5hbWUpO1xuICAgICAgICBpZiAodW51c2VkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1wb3J0ZXJzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdW51c2VkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGltcG9ydGVyIG9mIHRoaXMuZGVjbGFyYXRpb25zLmdldChuYW1lKS5tb2R1bGUuaW1wb3J0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZXJzU2V0LmFkZChpbXBvcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0ZXJzQXJyYXkgPSBbLi4uaW1wb3J0ZXJzU2V0XTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9ud2Fybih7XG4gICAgICAgICAgICBjb2RlOiAnVU5VU0VEX0VYVEVSTkFMX0lNUE9SVCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHtwcmludFF1b3RlZFN0cmluZ0xpc3QodW51c2VkLCBbJ2lzJywgJ2FyZSddKX0gaW1wb3J0ZWQgZnJvbSBleHRlcm5hbCBtb2R1bGUgXCIke3RoaXMuaWR9XCIgYnV0IG5ldmVyIHVzZWQgaW4gJHtwcmludFF1b3RlZFN0cmluZ0xpc3QoaW1wb3J0ZXJzQXJyYXkubWFwKGltcG9ydGVyID0+IHJlbGF0aXZlSWQoaW1wb3J0ZXIpKSl9LmAsXG4gICAgICAgICAgICBuYW1lczogdW51c2VkLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgc291cmNlczogaW1wb3J0ZXJzQXJyYXlcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2Uobikge1xuXHRpZiAobi5fX2VzTW9kdWxlKSByZXR1cm4gbjtcblx0dmFyIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxudmFyIHV0aWxzJDMgPSB7fTtcblxuY29uc3QgcGF0aCQxID0gcmVxdWlyZSQkMDtcbmNvbnN0IFdJTl9TTEFTSCA9ICdcXFxcXFxcXC8nO1xuY29uc3QgV0lOX05PX1NMQVNIID0gYFteJHtXSU5fU0xBU0h9XWA7XG5cbi8qKlxuICogUG9zaXggZ2xvYiByZWdleFxuICovXG5cbmNvbnN0IERPVF9MSVRFUkFMID0gJ1xcXFwuJztcbmNvbnN0IFBMVVNfTElURVJBTCA9ICdcXFxcKyc7XG5jb25zdCBRTUFSS19MSVRFUkFMID0gJ1xcXFw/JztcbmNvbnN0IFNMQVNIX0xJVEVSQUwgPSAnXFxcXC8nO1xuY29uc3QgT05FX0NIQVIgPSAnKD89LiknO1xuY29uc3QgUU1BUksgPSAnW14vXSc7XG5jb25zdCBFTkRfQU5DSE9SID0gYCg/OiR7U0xBU0hfTElURVJBTH18JClgO1xuY29uc3QgU1RBUlRfQU5DSE9SID0gYCg/Ol58JHtTTEFTSF9MSVRFUkFMfSlgO1xuY29uc3QgRE9UU19TTEFTSCA9IGAke0RPVF9MSVRFUkFMfXsxLDJ9JHtFTkRfQU5DSE9SfWA7XG5jb25zdCBOT19ET1QgPSBgKD8hJHtET1RfTElURVJBTH0pYDtcbmNvbnN0IE5PX0RPVFMgPSBgKD8hJHtTVEFSVF9BTkNIT1J9JHtET1RTX1NMQVNIfSlgO1xuY29uc3QgTk9fRE9UX1NMQVNIID0gYCg/ISR7RE9UX0xJVEVSQUx9ezAsMX0ke0VORF9BTkNIT1J9KWA7XG5jb25zdCBOT19ET1RTX1NMQVNIID0gYCg/ISR7RE9UU19TTEFTSH0pYDtcbmNvbnN0IFFNQVJLX05PX0RPVCA9IGBbXi4ke1NMQVNIX0xJVEVSQUx9XWA7XG5jb25zdCBTVEFSID0gYCR7UU1BUkt9Kj9gO1xuXG5jb25zdCBQT1NJWF9DSEFSUyA9IHtcbiAgRE9UX0xJVEVSQUwsXG4gIFBMVVNfTElURVJBTCxcbiAgUU1BUktfTElURVJBTCxcbiAgU0xBU0hfTElURVJBTCxcbiAgT05FX0NIQVIsXG4gIFFNQVJLLFxuICBFTkRfQU5DSE9SLFxuICBET1RTX1NMQVNILFxuICBOT19ET1QsXG4gIE5PX0RPVFMsXG4gIE5PX0RPVF9TTEFTSCxcbiAgTk9fRE9UU19TTEFTSCxcbiAgUU1BUktfTk9fRE9ULFxuICBTVEFSLFxuICBTVEFSVF9BTkNIT1Jcbn07XG5cbi8qKlxuICogV2luZG93cyBnbG9iIHJlZ2V4XG4gKi9cblxuY29uc3QgV0lORE9XU19DSEFSUyA9IHtcbiAgLi4uUE9TSVhfQ0hBUlMsXG5cbiAgU0xBU0hfTElURVJBTDogYFske1dJTl9TTEFTSH1dYCxcbiAgUU1BUks6IFdJTl9OT19TTEFTSCxcbiAgU1RBUjogYCR7V0lOX05PX1NMQVNIfSo/YCxcbiAgRE9UU19TTEFTSDogYCR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKWAsXG4gIE5PX0RPVDogYCg/ISR7RE9UX0xJVEVSQUx9KWAsXG4gIE5PX0RPVFM6IGAoPyEoPzpefFske1dJTl9TTEFTSH1dKSR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBOT19ET1RfU0xBU0g6IGAoPyEke0RPVF9MSVRFUkFMfXswLDF9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgTk9fRE9UU19TTEFTSDogYCg/ISR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBRTUFSS19OT19ET1Q6IGBbXi4ke1dJTl9TTEFTSH1dYCxcbiAgU1RBUlRfQU5DSE9SOiBgKD86XnxbJHtXSU5fU0xBU0h9XSlgLFxuICBFTkRfQU5DSE9SOiBgKD86WyR7V0lOX1NMQVNIfV18JClgXG59O1xuXG4vKipcbiAqIFBPU0lYIEJyYWNrZXQgUmVnZXhcbiAqL1xuXG5jb25zdCBQT1NJWF9SRUdFWF9TT1VSQ0UkMSA9IHtcbiAgYWxudW06ICdhLXpBLVowLTknLFxuICBhbHBoYTogJ2EtekEtWicsXG4gIGFzY2lpOiAnXFxcXHgwMC1cXFxceDdGJyxcbiAgYmxhbms6ICcgXFxcXHQnLFxuICBjbnRybDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnLFxuICBkaWdpdDogJzAtOScsXG4gIGdyYXBoOiAnXFxcXHgyMS1cXFxceDdFJyxcbiAgbG93ZXI6ICdhLXonLFxuICBwcmludDogJ1xcXFx4MjAtXFxcXHg3RSAnLFxuICBwdW5jdDogJ1xcXFwtIVwiIyQlJlxcJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX4nLFxuICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcbiAgdXBwZXI6ICdBLVonLFxuICB3b3JkOiAnQS1aYS16MC05XycsXG4gIHhkaWdpdDogJ0EtRmEtZjAtOSdcbn07XG5cbnZhciBjb25zdGFudHMkMiA9IHtcbiAgTUFYX0xFTkdUSDogMTAyNCAqIDY0LFxuICBQT1NJWF9SRUdFWF9TT1VSQ0U6IFBPU0lYX1JFR0VYX1NPVVJDRSQxLFxuXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgUkVHRVhfQkFDS1NMQVNIOiAvXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOiAvXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlM6IC9bLSorPy5eJHt9KHwpW1xcXV0vLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6IC8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDogLyhbLSorPy5eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6IC8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxcblxuICAvLyBSZXBsYWNlIGdsb2JzIHdpdGggZXF1aXZhbGVudCBwYXR0ZXJucyB0byByZWR1Y2UgcGFyc2luZyB0aW1lLlxuICBSRVBMQUNFTUVOVFM6IHtcbiAgICAnKioqJzogJyonLFxuICAgICcqKi8qKic6ICcqKicsXG4gICAgJyoqLyoqLyoqJzogJyoqJ1xuICB9LFxuXG4gIC8vIERpZ2l0c1xuICBDSEFSXzA6IDQ4LCAvKiAwICovXG4gIENIQVJfOTogNTcsIC8qIDkgKi9cblxuICAvLyBBbHBoYWJldCBjaGFycy5cbiAgQ0hBUl9VUFBFUkNBU0VfQTogNjUsIC8qIEEgKi9cbiAgQ0hBUl9MT1dFUkNBU0VfQTogOTcsIC8qIGEgKi9cbiAgQ0hBUl9VUFBFUkNBU0VfWjogOTAsIC8qIFogKi9cbiAgQ0hBUl9MT1dFUkNBU0VfWjogMTIyLCAvKiB6ICovXG5cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiA0MCwgLyogKCAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOiA0MSwgLyogKSAqL1xuXG4gIENIQVJfQVNURVJJU0s6IDQyLCAvKiAqICovXG5cbiAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG4gIENIQVJfQU1QRVJTQU5EOiAzOCwgLyogJiAqL1xuICBDSEFSX0FUOiA2NCwgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNIOiA5MiwgLyogXFwgKi9cbiAgQ0hBUl9DQVJSSUFHRV9SRVRVUk46IDEzLCAvKiBcXHIgKi9cbiAgQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDogOTQsIC8qIF4gKi9cbiAgQ0hBUl9DT0xPTjogNTgsIC8qIDogKi9cbiAgQ0hBUl9DT01NQTogNDQsIC8qICwgKi9cbiAgQ0hBUl9ET1Q6IDQ2LCAvKiAuICovXG4gIENIQVJfRE9VQkxFX1FVT1RFOiAzNCwgLyogXCIgKi9cbiAgQ0hBUl9FUVVBTDogNjEsIC8qID0gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLOiAzMywgLyogISAqL1xuICBDSEFSX0ZPUk1fRkVFRDogMTIsIC8qIFxcZiAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0g6IDQ3LCAvKiAvICovXG4gIENIQVJfR1JBVkVfQUNDRU5UOiA5NiwgLyogYCAqL1xuICBDSEFSX0hBU0g6IDM1LCAvKiAjICovXG4gIENIQVJfSFlQSEVOX01JTlVTOiA0NSwgLyogLSAqL1xuICBDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDogNjAsIC8qIDwgKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAxMjMsIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiA5MSwgLyogWyAqL1xuICBDSEFSX0xJTkVfRkVFRDogMTAsIC8qIFxcbiAqL1xuICBDSEFSX05PX0JSRUFLX1NQQUNFOiAxNjAsIC8qIFxcdTAwQTAgKi9cbiAgQ0hBUl9QRVJDRU5UOiAzNywgLyogJSAqL1xuICBDSEFSX1BMVVM6IDQzLCAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSzogNjMsIC8qID8gKi9cbiAgQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOiA2MiwgLyogPiAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOiAxMjUsIC8qIH0gKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDogOTMsIC8qIF0gKi9cbiAgQ0hBUl9TRU1JQ09MT046IDU5LCAvKiA7ICovXG4gIENIQVJfU0lOR0xFX1FVT1RFOiAzOSwgLyogJyAqL1xuICBDSEFSX1NQQUNFOiAzMiwgLyogICAqL1xuICBDSEFSX1RBQjogOSwgLyogXFx0ICovXG4gIENIQVJfVU5ERVJTQ09SRTogOTUsIC8qIF8gKi9cbiAgQ0hBUl9WRVJUSUNBTF9MSU5FOiAxMjQsIC8qIHwgKi9cbiAgQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6IDY1Mjc5LCAvKiBcXHVGRUZGICovXG5cbiAgU0VQOiBwYXRoJDEuc2VwLFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRVhUR0xPQl9DSEFSU1xuICAgKi9cblxuICBleHRnbG9iQ2hhcnMoY2hhcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyEnOiB7IHR5cGU6ICduZWdhdGUnLCBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6IGApKSR7Y2hhcnMuU1RBUn0pYCB9LFxuICAgICAgJz8nOiB7IHR5cGU6ICdxbWFyaycsIG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAgICAgJysnOiB7IHR5cGU6ICdwbHVzJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICAgICAnKic6IHsgdHlwZTogJ3N0YXInLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgICAgICdAJzogeyB0eXBlOiAnYXQnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIEdMT0JfQ0hBUlNcbiAgICovXG5cbiAgZ2xvYkNoYXJzKHdpbjMyKSB7XG4gICAgcmV0dXJuIHdpbjMyID09PSB0cnVlID8gV0lORE9XU19DSEFSUyA6IFBPU0lYX0NIQVJTO1xuICB9XG59O1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUkJDA7XG5jb25zdCB3aW4zMiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5jb25zdCB7XG4gIFJFR0VYX0JBQ0tTTEFTSCxcbiAgUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSUyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUxcbn0gPSBjb25zdGFudHMkMjtcblxuZXhwb3J0cy5pc09iamVjdCA9IHZhbCA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbmV4cG9ydHMuaGFzUmVnZXhDaGFycyA9IHN0ciA9PiBSRUdFWF9TUEVDSUFMX0NIQVJTLnRlc3Qoc3RyKTtcbmV4cG9ydHMuaXNSZWdleENoYXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA9PT0gMSAmJiBleHBvcnRzLmhhc1JlZ2V4Q2hhcnMoc3RyKTtcbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUwsICdcXFxcJDEnKTtcbmV4cG9ydHMudG9Qb3NpeFNsYXNoZXMgPSBzdHIgPT4gc3RyLnJlcGxhY2UoUkVHRVhfQkFDS1NMQVNILCAnLycpO1xuXG5leHBvcnRzLnJlbW92ZUJhY2tzbGFzaGVzID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsIG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2ggPT09ICdcXFxcJyA/ICcnIDogbWF0Y2g7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5zdXBwb3J0c0xvb2tiZWhpbmRzID0gKCkgPT4ge1xuICBjb25zdCBzZWdzID0gcHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIGlmIChzZWdzLmxlbmd0aCA9PT0gMyAmJiBzZWdzWzBdID49IDkgfHwgKHNlZ3NbMF0gPT09IDggJiYgc2Vnc1sxXSA+PSAxMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLmlzV2luZG93cyA9IG9wdGlvbnMgPT4ge1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy53aW5kb3dzID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy53aW5kb3dzO1xuICB9XG4gIHJldHVybiB3aW4zMiA9PT0gdHJ1ZSB8fCBwYXRoLnNlcCA9PT0gJ1xcXFwnO1xufTtcblxuZXhwb3J0cy5lc2NhcGVMYXN0ID0gKGlucHV0LCBjaGFyLCBsYXN0SWR4KSA9PiB7XG4gIGNvbnN0IGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKGNoYXIsIGxhc3RJZHgpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGlucHV0O1xuICBpZiAoaW5wdXRbaWR4IC0gMV0gPT09ICdcXFxcJykgcmV0dXJuIGV4cG9ydHMuZXNjYXBlTGFzdChpbnB1dCwgY2hhciwgaWR4IC0gMSk7XG4gIHJldHVybiBgJHtpbnB1dC5zbGljZSgwLCBpZHgpfVxcXFwke2lucHV0LnNsaWNlKGlkeCl9YDtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHJlZml4ID0gKGlucHV0LCBzdGF0ZSA9IHt9KSA9PiB7XG4gIGxldCBvdXRwdXQgPSBpbnB1dDtcbiAgaWYgKG91dHB1dC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDIpO1xuICAgIHN0YXRlLnByZWZpeCA9ICcuLyc7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmV4cG9ydHMud3JhcE91dHB1dCA9IChpbnB1dCwgc3RhdGUgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRpb25zLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgb3V0cHV0ID0gYCR7cHJlcGVuZH0oPzoke2lucHV0fSkke2FwcGVuZH1gO1xuICBpZiAoc3RhdGUubmVnYXRlZCA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IGAoPzpeKD8hJHtvdXRwdXR9KS4qJClgO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xufSh1dGlscyQzKSk7XG5cbmNvbnN0IHV0aWxzJDIgPSB1dGlscyQzO1xuY29uc3Qge1xuICBDSEFSX0FTVEVSSVNLLCAgICAgICAgICAgICAvKiAqICovXG4gIENIQVJfQVQsICAgICAgICAgICAgICAgICAgIC8qIEAgKi9cbiAgQ0hBUl9CQUNLV0FSRF9TTEFTSCwgICAgICAgLyogXFwgKi9cbiAgQ0hBUl9DT01NQSwgICAgICAgICAgICAgICAgLyogLCAqL1xuICBDSEFSX0RPVCwgICAgICAgICAgICAgICAgICAvKiAuICovXG4gIENIQVJfRVhDTEFNQVRJT05fTUFSSywgICAgIC8qICEgKi9cbiAgQ0hBUl9GT1JXQVJEX1NMQVNILCAgICAgICAgLyogLyAqL1xuICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UsICAgICAvKiB7ICovXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUywgICAgIC8qICggKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VULCAgLyogWyAqL1xuICBDSEFSX1BMVVMsICAgICAgICAgICAgICAgICAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSywgICAgICAgIC8qID8gKi9cbiAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSwgICAgLyogfSAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTLCAgICAvKiApICovXG4gIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgIC8qIF0gKi9cbn0gPSBjb25zdGFudHMkMjtcblxuY29uc3QgaXNQYXRoU2VwYXJhdG9yID0gY29kZSA9PiB7XG4gIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcbn07XG5cbmNvbnN0IGRlcHRoID0gdG9rZW4gPT4ge1xuICBpZiAodG9rZW4uaXNQcmVmaXggIT09IHRydWUpIHtcbiAgICB0b2tlbi5kZXB0aCA9IHRva2VuLmlzR2xvYnN0YXIgPyBJbmZpbml0eSA6IDE7XG4gIH1cbn07XG5cbi8qKlxuICogUXVpY2tseSBzY2FucyBhIGdsb2IgcGF0dGVybiBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIGhhbmRmdWwgb2ZcbiAqIHVzZWZ1bCBwcm9wZXJ0aWVzLCBsaWtlIGBpc0dsb2JgLCBgcGF0aGAgKHRoZSBsZWFkaW5nIG5vbi1nbG9iLCBpZiBpdCBleGlzdHMpLFxuICogYGdsb2JgICh0aGUgYWN0dWFsIHBhdHRlcm4pLCBgbmVnYXRlZGAgKHRydWUgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYCFgIGJ1dCBub3RcbiAqIHdpdGggYCEoYCkgYW5kIGBuZWdhdGVkRXh0Z2xvYmAgKHRydWUgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYCEoYCkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBtID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiBjb25zb2xlLmxvZyhwbS5zY2FuKCdmb28vYmFyLyouanMnKSk7XG4gKiB7IGlzR2xvYjogdHJ1ZSwgaW5wdXQ6ICdmb28vYmFyLyouanMnLCBiYXNlOiAnZm9vL2JhcicsIGdsb2I6ICcqLmpzJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRva2VucyBhbmQgcmVnZXggc291cmNlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3Qgc2NhbiQxID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IHNjYW5Ub0VuZCA9IG9wdHMucGFydHMgPT09IHRydWUgfHwgb3B0cy5zY2FuVG9FbmQgPT09IHRydWU7XG4gIGNvbnN0IHNsYXNoZXMgPSBbXTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgbGV0IHN0ciA9IGlucHV0O1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gIGxldCBpc0JyYWNrZXQgPSBmYWxzZTtcbiAgbGV0IGlzR2xvYiA9IGZhbHNlO1xuICBsZXQgaXNFeHRnbG9iID0gZmFsc2U7XG4gIGxldCBpc0dsb2JzdGFyID0gZmFsc2U7XG4gIGxldCBicmFjZUVzY2FwZWQgPSBmYWxzZTtcbiAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG4gIGxldCBuZWdhdGVkID0gZmFsc2U7XG4gIGxldCBuZWdhdGVkRXh0Z2xvYiA9IGZhbHNlO1xuICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgbGV0IGJyYWNlcyA9IDA7XG4gIGxldCBwcmV2O1xuICBsZXQgY29kZTtcbiAgbGV0IHRva2VuID0geyB2YWx1ZTogJycsIGRlcHRoOiAwLCBpc0dsb2I6IGZhbHNlIH07XG5cbiAgY29uc3QgZW9zID0gKCkgPT4gaW5kZXggPj0gbGVuZ3RoO1xuICBjb25zdCBwZWVrID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgY29uc3QgYWR2YW5jZSA9ICgpID0+IHtcbiAgICBwcmV2ID0gY29kZTtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH07XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY29kZSA9IGFkdmFuY2UoKTtcbiAgICBsZXQgbmV4dDtcblxuICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG5cbiAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgICAgYnJhY2VFc2NhcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChicmFjZUVzY2FwZWQgPT09IHRydWUgfHwgY29kZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICBicmFjZXMrKztcblxuICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChjb2RlID0gYWR2YW5jZSgpKSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicmFjZUVzY2FwZWQgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9ET1QgJiYgKGNvZGUgPSBhZHZhbmNlKCkpID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0NPTU1BKSB7XG4gICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICAgIGJyYWNlcy0tO1xuXG4gICAgICAgICAgaWYgKGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgYnJhY2VFc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgc2xhc2hlcy5wdXNoKGluZGV4KTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIHRva2VuID0geyB2YWx1ZTogJycsIGRlcHRoOiAwLCBpc0dsb2I6IGZhbHNlIH07XG5cbiAgICAgIGlmIChmaW5pc2hlZCA9PT0gdHJ1ZSkgY29udGludWU7XG4gICAgICBpZiAocHJldiA9PT0gQ0hBUl9ET1QgJiYgaW5kZXggPT09IChzdGFydCArIDEpKSB7XG4gICAgICAgIHN0YXJ0ICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub2V4dCAhPT0gdHJ1ZSkge1xuICAgICAgY29uc3QgaXNFeHRnbG9iQ2hhciA9IGNvZGUgPT09IENIQVJfUExVU1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX0FUXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfQVNURVJJU0tcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9RVUVTVElPTl9NQVJLXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSztcblxuICAgICAgaWYgKGlzRXh0Z2xvYkNoYXIgPT09IHRydWUgJiYgcGVlaygpID09PSBDSEFSX0xFRlRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgaXNFeHRnbG9iID0gdG9rZW4uaXNFeHRnbG9iID0gdHJ1ZTtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLICYmIGluZGV4ID09PSBzdGFydCkge1xuICAgICAgICAgIG5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0FTVEVSSVNLKSB7XG4gICAgICBpZiAocHJldiA9PT0gQ0hBUl9BU1RFUklTSykgaXNHbG9ic3RhciA9IHRva2VuLmlzR2xvYnN0YXIgPSB0cnVlO1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX1FVRVNUSU9OX01BUkspIHtcbiAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKG5leHQgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgPT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgICAgICBpc0JyYWNrZXQgPSB0b2tlbi5pc0JyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vbmVnYXRlICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSyAmJiBpbmRleCA9PT0gc3RhcnQpIHtcbiAgICAgIG5lZ2F0ZWQgPSB0b2tlbi5uZWdhdGVkID0gdHJ1ZTtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub3BhcmVuICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2IgPT09IHRydWUpIHtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubm9leHQgPT09IHRydWUpIHtcbiAgICBpc0V4dGdsb2IgPSBmYWxzZTtcbiAgICBpc0dsb2IgPSBmYWxzZTtcbiAgfVxuXG4gIGxldCBiYXNlID0gc3RyO1xuICBsZXQgcHJlZml4ID0gJyc7XG4gIGxldCBnbG9iID0gJyc7XG5cbiAgaWYgKHN0YXJ0ID4gMCkge1xuICAgIHByZWZpeCA9IHN0ci5zbGljZSgwLCBzdGFydCk7XG4gICAgc3RyID0gc3RyLnNsaWNlKHN0YXJ0KTtcbiAgICBsYXN0SW5kZXggLT0gc3RhcnQ7XG4gIH1cblxuICBpZiAoYmFzZSAmJiBpc0dsb2IgPT09IHRydWUgJiYgbGFzdEluZGV4ID4gMCkge1xuICAgIGJhc2UgPSBzdHIuc2xpY2UoMCwgbGFzdEluZGV4KTtcbiAgICBnbG9iID0gc3RyLnNsaWNlKGxhc3RJbmRleCk7XG4gIH0gZWxzZSBpZiAoaXNHbG9iID09PSB0cnVlKSB7XG4gICAgYmFzZSA9ICcnO1xuICAgIGdsb2IgPSBzdHI7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IHN0cjtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGJhc2UgIT09ICcnICYmIGJhc2UgIT09ICcvJyAmJiBiYXNlICE9PSBzdHIpIHtcbiAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGJhc2UuY2hhckNvZGVBdChiYXNlLmxlbmd0aCAtIDEpKSkge1xuICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgaWYgKGdsb2IpIGdsb2IgPSB1dGlscyQyLnJlbW92ZUJhY2tzbGFzaGVzKGdsb2IpO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGJhc2UgPSB1dGlscyQyLnJlbW92ZUJhY2tzbGFzaGVzKGJhc2UpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHByZWZpeCxcbiAgICBpbnB1dCxcbiAgICBzdGFydCxcbiAgICBiYXNlLFxuICAgIGdsb2IsXG4gICAgaXNCcmFjZSxcbiAgICBpc0JyYWNrZXQsXG4gICAgaXNHbG9iLFxuICAgIGlzRXh0Z2xvYixcbiAgICBpc0dsb2JzdGFyLFxuICAgIG5lZ2F0ZWQsXG4gICAgbmVnYXRlZEV4dGdsb2JcbiAgfTtcblxuICBpZiAob3B0cy50b2tlbnMgPT09IHRydWUpIHtcbiAgICBzdGF0ZS5tYXhEZXB0aCA9IDA7XG4gICAgaWYgKCFpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgaWYgKG9wdHMucGFydHMgPT09IHRydWUgfHwgb3B0cy50b2tlbnMgPT09IHRydWUpIHtcbiAgICBsZXQgcHJldkluZGV4O1xuXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2xhc2hlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBuID0gcHJldkluZGV4ID8gcHJldkluZGV4ICsgMSA6IHN0YXJ0O1xuICAgICAgY29uc3QgaSA9IHNsYXNoZXNbaWR4XTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2UobiwgaSk7XG4gICAgICBpZiAob3B0cy50b2tlbnMpIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gMCAmJiBzdGFydCAhPT0gMCkge1xuICAgICAgICAgIHRva2Vuc1tpZHhdLmlzUHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0b2tlbnNbaWR4XS52YWx1ZSA9IHByZWZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnNbaWR4XS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoKHRva2Vuc1tpZHhdKTtcbiAgICAgICAgc3RhdGUubWF4RGVwdGggKz0gdG9rZW5zW2lkeF0uZGVwdGg7XG4gICAgICB9XG4gICAgICBpZiAoaWR4ICE9PSAwIHx8IHZhbHVlICE9PSAnJykge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZJbmRleCAmJiBwcmV2SW5kZXggKyAxIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKHByZXZJbmRleCArIDEpO1xuICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzLnRva2Vucykge1xuICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlcHRoKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBzdGF0ZS5tYXhEZXB0aCArPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmRlcHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnNsYXNoZXMgPSBzbGFzaGVzO1xuICAgIHN0YXRlLnBhcnRzID0gcGFydHM7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG52YXIgc2Nhbl8xID0gc2NhbiQxO1xuXG5jb25zdCBjb25zdGFudHMkMSA9IGNvbnN0YW50cyQyO1xuY29uc3QgdXRpbHMkMSA9IHV0aWxzJDM7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBQT1NJWF9SRUdFWF9TT1VSQ0UsXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsXG4gIFJFUExBQ0VNRU5UU1xufSA9IGNvbnN0YW50cyQxO1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5jb25zdCBleHBhbmRSYW5nZSA9IChhcmdzLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBhbmRSYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLmV4cGFuZFJhbmdlKC4uLmFyZ3MsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXJncy5zb3J0KCk7XG4gIGNvbnN0IHZhbHVlID0gYFske2FyZ3Muam9pbignLScpfV1gO1xuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtZXNzYWdlIGZvciBhIHN5bnRheCBlcnJvclxuICovXG5cbmNvbnN0IHN5bnRheEVycm9yID0gKHR5cGUsIGNoYXIpID0+IHtcbiAgcmV0dXJuIGBNaXNzaW5nICR7dHlwZX06IFwiJHtjaGFyfVwiIC0gdXNlIFwiXFxcXFxcXFwke2NoYXJ9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5jb25zdCBwYXJzZSQxID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlucHV0ID0gUkVQTEFDRU1FTlRTW2lucHV0XSB8fCBpbnB1dDtcblxuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuXG4gIGxldCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGlmIChsZW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsZW59LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7bWF4fWApO1xuICB9XG5cbiAgY29uc3QgYm9zID0geyB0eXBlOiAnYm9zJywgdmFsdWU6ICcnLCBvdXRwdXQ6IG9wdHMucHJlcGVuZCB8fCAnJyB9O1xuICBjb25zdCB0b2tlbnMgPSBbYm9zXTtcblxuICBjb25zdCBjYXB0dXJlID0gb3B0cy5jYXB0dXJlID8gJycgOiAnPzonO1xuICBjb25zdCB3aW4zMiA9IHV0aWxzJDEuaXNXaW5kb3dzKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IFBMQVRGT1JNX0NIQVJTID0gY29uc3RhbnRzJDEuZ2xvYkNoYXJzKHdpbjMyKTtcbiAgY29uc3QgRVhUR0xPQl9DSEFSUyA9IGNvbnN0YW50cyQxLmV4dGdsb2JDaGFycyhQTEFURk9STV9DSEFSUyk7XG5cbiAgY29uc3Qge1xuICAgIERPVF9MSVRFUkFMLFxuICAgIFBMVVNfTElURVJBTCxcbiAgICBTTEFTSF9MSVRFUkFMLFxuICAgIE9ORV9DSEFSLFxuICAgIERPVFNfU0xBU0gsXG4gICAgTk9fRE9ULFxuICAgIE5PX0RPVF9TTEFTSCxcbiAgICBOT19ET1RTX1NMQVNILFxuICAgIFFNQVJLLFxuICAgIFFNQVJLX05PX0RPVCxcbiAgICBTVEFSLFxuICAgIFNUQVJUX0FOQ0hPUlxuICB9ID0gUExBVEZPUk1fQ0hBUlM7XG5cbiAgY29uc3QgZ2xvYnN0YXIgPSBvcHRzID0+IHtcbiAgICByZXR1cm4gYCgke2NhcHR1cmV9KD86KD8hJHtTVEFSVF9BTkNIT1J9JHtvcHRzLmRvdCA/IERPVFNfU0xBU0ggOiBET1RfTElURVJBTH0pLikqPylgO1xuICB9O1xuXG4gIGNvbnN0IG5vZG90ID0gb3B0cy5kb3QgPyAnJyA6IE5PX0RPVDtcbiAgY29uc3QgcW1hcmtOb0RvdCA9IG9wdHMuZG90ID8gUU1BUksgOiBRTUFSS19OT19ET1Q7XG4gIGxldCBzdGFyID0gb3B0cy5iYXNoID09PSB0cnVlID8gZ2xvYnN0YXIob3B0cykgOiBTVEFSO1xuXG4gIGlmIChvcHRzLmNhcHR1cmUpIHtcbiAgICBzdGFyID0gYCgke3N0YXJ9KWA7XG4gIH1cblxuICAvLyBtaW5pbWF0Y2ggb3B0aW9ucyBzdXBwb3J0XG4gIGlmICh0eXBlb2Ygb3B0cy5ub2V4dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0cy5ub2V4dGdsb2IgPSBvcHRzLm5vZXh0O1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgaW5wdXQsXG4gICAgaW5kZXg6IC0xLFxuICAgIHN0YXJ0OiAwLFxuICAgIGRvdDogb3B0cy5kb3QgPT09IHRydWUsXG4gICAgY29uc3VtZWQ6ICcnLFxuICAgIG91dHB1dDogJycsXG4gICAgcHJlZml4OiAnJyxcbiAgICBiYWNrdHJhY2s6IGZhbHNlLFxuICAgIG5lZ2F0ZWQ6IGZhbHNlLFxuICAgIGJyYWNrZXRzOiAwLFxuICAgIGJyYWNlczogMCxcbiAgICBwYXJlbnM6IDAsXG4gICAgcXVvdGVzOiAwLFxuICAgIGdsb2JzdGFyOiBmYWxzZSxcbiAgICB0b2tlbnNcbiAgfTtcblxuICBpbnB1dCA9IHV0aWxzJDEucmVtb3ZlUHJlZml4KGlucHV0LCBzdGF0ZSk7XG4gIGxlbiA9IGlucHV0Lmxlbmd0aDtcblxuICBjb25zdCBleHRnbG9icyA9IFtdO1xuICBjb25zdCBicmFjZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IHByZXYgPSBib3M7XG4gIGxldCB2YWx1ZTtcblxuICAvKipcbiAgICogVG9rZW5pemluZyBoZWxwZXJzXG4gICAqL1xuXG4gIGNvbnN0IGVvcyA9ICgpID0+IHN0YXRlLmluZGV4ID09PSBsZW4gLSAxO1xuICBjb25zdCBwZWVrID0gc3RhdGUucGVlayA9IChuID0gMSkgPT4gaW5wdXRbc3RhdGUuaW5kZXggKyBuXTtcbiAgY29uc3QgYWR2YW5jZSA9IHN0YXRlLmFkdmFuY2UgPSAoKSA9PiBpbnB1dFsrK3N0YXRlLmluZGV4XSB8fCAnJztcbiAgY29uc3QgcmVtYWluaW5nID0gKCkgPT4gaW5wdXQuc2xpY2Uoc3RhdGUuaW5kZXggKyAxKTtcbiAgY29uc3QgY29uc3VtZSA9ICh2YWx1ZSA9ICcnLCBudW0gPSAwKSA9PiB7XG4gICAgc3RhdGUuY29uc3VtZWQgKz0gdmFsdWU7XG4gICAgc3RhdGUuaW5kZXggKz0gbnVtO1xuICB9O1xuXG4gIGNvbnN0IGFwcGVuZCA9IHRva2VuID0+IHtcbiAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcbiAgICBjb25zdW1lKHRva2VuLnZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBuZWdhdGUgPSAoKSA9PiB7XG4gICAgbGV0IGNvdW50ID0gMTtcblxuICAgIHdoaWxlIChwZWVrKCkgPT09ICchJyAmJiAocGVlaygyKSAhPT0gJygnIHx8IHBlZWsoMykgPT09ICc/JykpIHtcbiAgICAgIGFkdmFuY2UoKTtcbiAgICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChjb3VudCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5uZWdhdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5zdGFydCsrO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGNvbnN0IGluY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdKys7XG4gICAgc3RhY2sucHVzaCh0eXBlKTtcbiAgfTtcblxuICBjb25zdCBkZWNyZW1lbnQgPSB0eXBlID0+IHtcbiAgICBzdGF0ZVt0eXBlXS0tO1xuICAgIHN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIHRva2VucyBvbnRvIHRoZSB0b2tlbnMgYXJyYXkuIFRoaXMgaGVscGVyIHNwZWVkcyB1cFxuICAgKiB0b2tlbml6aW5nIGJ5IDEpIGhlbHBpbmcgdXMgYXZvaWQgYmFja3RyYWNraW5nIGFzIG11Y2ggYXMgcG9zc2libGUsXG4gICAqIGFuZCAyKSBoZWxwaW5nIHVzIGF2b2lkIGNyZWF0aW5nIGV4dHJhIHRva2VucyB3aGVuIGNvbnNlY3V0aXZlXG4gICAqIGNoYXJhY3RlcnMgYXJlIHBsYWluIHRleHQuIFRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgYW5kIHNpbXBsaWZpZXNcbiAgICogbG9va2JlaGluZHMuXG4gICAqL1xuXG4gIGNvbnN0IHB1c2ggPSB0b2sgPT4ge1xuICAgIGlmIChwcmV2LnR5cGUgPT09ICdnbG9ic3RhcicpIHtcbiAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmICh0b2sudHlwZSA9PT0gJ2NvbW1hJyB8fCB0b2sudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSB0b2suZXh0Z2xvYiA9PT0gdHJ1ZSB8fCAoZXh0Z2xvYnMubGVuZ3RoICYmICh0b2sudHlwZSA9PT0gJ3BpcGUnIHx8IHRvay50eXBlID09PSAncGFyZW4nKSk7XG5cbiAgICAgIGlmICh0b2sudHlwZSAhPT0gJ3NsYXNoJyAmJiB0b2sudHlwZSAhPT0gJ3BhcmVuJyAmJiAhaXNCcmFjZSAmJiAhaXNFeHRnbG9iKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi5vdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgcHJldi50eXBlID0gJ3N0YXInO1xuICAgICAgICBwcmV2LnZhbHVlID0gJyonO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2Lm91dHB1dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoICYmIHRvay50eXBlICE9PSAncGFyZW4nKSB7XG4gICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5pbm5lciArPSB0b2sudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHRvay52YWx1ZSB8fCB0b2sub3V0cHV0KSBhcHBlbmQodG9rKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICd0ZXh0JyAmJiB0b2sudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBwcmV2LnZhbHVlICs9IHRvay52YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gKHByZXYub3V0cHV0IHx8ICcnKSArIHRvay52YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2sucHJldiA9IHByZXY7XG4gICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICBwcmV2ID0gdG9rO1xuICB9O1xuXG4gIGNvbnN0IGV4dGdsb2JPcGVuID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9rZW4gPSB7IC4uLkVYVEdMT0JfQ0hBUlNbdmFsdWVdLCBjb25kaXRpb25zOiAxLCBpbm5lcjogJycgfTtcblxuICAgIHRva2VuLnByZXYgPSBwcmV2O1xuICAgIHRva2VuLnBhcmVucyA9IHN0YXRlLnBhcmVucztcbiAgICB0b2tlbi5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQ7XG4gICAgY29uc3Qgb3V0cHV0ID0gKG9wdHMuY2FwdHVyZSA/ICcoJyA6ICcnKSArIHRva2VuLm9wZW47XG5cbiAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuICAgIHB1c2goeyB0eXBlLCB2YWx1ZSwgb3V0cHV0OiBzdGF0ZS5vdXRwdXQgPyAnJyA6IE9ORV9DSEFSIH0pO1xuICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZTogYWR2YW5jZSgpLCBvdXRwdXQgfSk7XG4gICAgZXh0Z2xvYnMucHVzaCh0b2tlbik7XG4gIH07XG5cbiAgY29uc3QgZXh0Z2xvYkNsb3NlID0gdG9rZW4gPT4ge1xuICAgIGxldCBvdXRwdXQgPSB0b2tlbi5jbG9zZSArIChvcHRzLmNhcHR1cmUgPyAnKScgOiAnJyk7XG4gICAgbGV0IHJlc3Q7XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ25lZ2F0ZScpIHtcbiAgICAgIGxldCBleHRnbG9iU3RhciA9IHN0YXI7XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lciAmJiB0b2tlbi5pbm5lci5sZW5ndGggPiAxICYmIHRva2VuLmlubmVyLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgZXh0Z2xvYlN0YXIgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGdsb2JTdGFyICE9PSBzdGFyIHx8IGVvcygpIHx8IC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKSB7XG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkkKSkke2V4dGdsb2JTdGFyfWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5pbm5lci5pbmNsdWRlcygnKicpICYmIChyZXN0ID0gcmVtYWluaW5nKCkpICYmIC9eXFwuW15cXFxcLy5dKyQvLnRlc3QocmVzdCkpIHtcbiAgICAgICAgLy8gQW55IG5vbi1tYWdpY2FsIHN0cmluZyAoYC50c2ApIG9yIGV2ZW4gbmVzdGVkIGV4cHJlc3Npb24gKGAue3RzLHRzeH1gKSBjYW4gZm9sbG93IGFmdGVyIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gcGFyc2UgdGhlIHN0cmluZyBhbmQgdXNlIGl0IGluIHRoZSBvdXRwdXQgb2YgdGhlIG9yaWdpbmFsIHBhdHRlcm4uXG4gICAgICAgIC8vIFN1aXRhYmxlIHBhdHRlcm5zOiBgLyEoKi5kKS50c2AsIGAvISgqLmQpLnt0cyx0c3h9YCwgYCoqLyEoKi1kYmcpLkAoanMpYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGlzYWJsaW5nIHRoZSBgZmFzdHBhdGhzYCBvcHRpb24gZHVlIHRvIGEgcHJvYmxlbSB3aXRoIHBhcnNpbmcgc3RyaW5ncyBhcyBgLnRzYCBpbiB0aGUgcGF0dGVybiBsaWtlIGAqKi8hKCouZCkudHNgLlxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UkMShyZXN0LCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSkub3V0cHV0O1xuXG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkke2V4cHJlc3Npb259KSR7ZXh0Z2xvYlN0YXJ9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5wcmV2LnR5cGUgPT09ICdib3MnKSB7XG4gICAgICAgIHN0YXRlLm5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dCB9KTtcbiAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGYXN0IHBhdGhzXG4gICAqL1xuXG4gIGlmIChvcHRzLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QoaW5wdXQpKSB7XG4gICAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG5cbiAgICBsZXQgb3V0cHV0ID0gaW5wdXQucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsIChtLCBlc2MsIGNoYXJzLCBmaXJzdCwgcmVzdCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChmaXJzdCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJz8nKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHFtYXJrTm9Eb3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFNQVJLLnJlcGVhdChjaGFycy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gRE9UX0xJVEVSQUwucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJyonKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IHN0YXIgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjID8gbSA6IGBcXFxcJHttfWA7XG4gICAgfSk7XG5cbiAgICBpZiAoYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcKy9nLCBtID0+IHtcbiAgICAgICAgICByZXR1cm4gbS5sZW5ndGggJSAyID09PSAwID8gJ1xcXFxcXFxcJyA6IChtID8gJ1xcXFwnIDogJycpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3V0cHV0ID09PSBpbnB1dCAmJiBvcHRzLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBpbnB1dDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscyQxLndyYXBPdXRwdXQob3V0cHV0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRva2VuaXplIGlucHV0IHVudGlsIHdlIHJlYWNoIGVuZC1vZi1zdHJpbmdcbiAgICovXG5cbiAgd2hpbGUgKCFlb3MoKSkge1xuICAgIHZhbHVlID0gYWR2YW5jZSgpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFx1MDAwMCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFxcXCcpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBwZWVrKCk7XG5cbiAgICAgIGlmIChuZXh0ID09PSAnLycgJiYgb3B0cy5iYXNoICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCA9PT0gJy4nIHx8IG5leHQgPT09ICc7Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJztcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2xsYXBzZSBzbGFzaGVzIHRvIHJlZHVjZSBwb3RlbnRpYWwgZm9yIGV4cGxvaXRzXG4gICAgICBjb25zdCBtYXRjaCA9IC9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO1xuICAgICAgbGV0IHNsYXNoZXMgPSAwO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID4gMikge1xuICAgICAgICBzbGFzaGVzID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5pbmRleCArPSBzbGFzaGVzO1xuICAgICAgICBpZiAoc2xhc2hlcyAlIDIgIT09IDApIHtcbiAgICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSBhZHZhbmNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBhZHZhbmNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5icmFja2V0cyA9PT0gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW5zaWRlIGEgcmVnZXggY2hhcmFjdGVyIGNsYXNzLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGJyYWNrZXQuXG4gICAgICovXG5cbiAgICBpZiAoc3RhdGUuYnJhY2tldHMgPiAwICYmICh2YWx1ZSAhPT0gJ10nIHx8IHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuICAgICAgaWYgKG9wdHMucG9zaXggIT09IGZhbHNlICYmIHZhbHVlID09PSAnOicpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuICAgICAgICBpZiAoaW5uZXIuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICAgIHByZXYucG9zaXggPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHByZXYudmFsdWUubGFzdEluZGV4T2YoJ1snKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHByZXYudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwcmV2LnZhbHVlLnNsaWNlKGlkeCArIDIpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXggPSBQT1NJWF9SRUdFWF9TT1VSQ0VbcmVzdF07XG4gICAgICAgICAgICBpZiAocG9zaXgpIHtcbiAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IHByZSArIHBvc2l4O1xuICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBhZHZhbmNlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFib3Mub3V0cHV0ICYmIHRva2Vucy5pbmRleE9mKHByZXYpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYm9zLm91dHB1dCA9IE9ORV9DSEFSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlID09PSAnWycgJiYgcGVlaygpICE9PSAnOicpIHx8ICh2YWx1ZSA9PT0gJy0nICYmIHBlZWsoKSA9PT0gJ10nKSkge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09ICddJyAmJiAocHJldi52YWx1ZSA9PT0gJ1snIHx8IHByZXYudmFsdWUgPT09ICdbXicpKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnBvc2l4ID09PSB0cnVlICYmIHZhbHVlID09PSAnIScgJiYgcHJldi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgIHZhbHVlID0gJ14nO1xuICAgICAgfVxuXG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbnNpZGUgYSBxdW90ZWQgc3RyaW5nLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGRvdWJsZSBxdW90ZS5cbiAgICAgKi9cblxuICAgIGlmIChzdGF0ZS5xdW90ZXMgPT09IDEgJiYgdmFsdWUgIT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdXRpbHMkMS5lc2NhcGVSZWdleCh2YWx1ZSk7XG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3VibGUgcXVvdGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdcIicpIHtcbiAgICAgIHN0YXRlLnF1b3RlcyA9IHN0YXRlLnF1b3RlcyA9PT0gMSA/IDAgOiAxO1xuICAgICAgaWYgKG9wdHMua2VlcFF1b3RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcmVudGhlc2VzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcoJykge1xuICAgICAgaW5jcmVtZW50KCdwYXJlbnMnKTtcbiAgICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJyknKSB7XG4gICAgICBpZiAoc3RhdGUucGFyZW5zID09PSAwICYmIG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdvcGVuaW5nJywgJygnKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGdsb2IgPSBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChleHRnbG9iICYmIHN0YXRlLnBhcmVucyA9PT0gZXh0Z2xvYi5wYXJlbnMgKyAxKSB7XG4gICAgICAgIGV4dGdsb2JDbG9zZShleHRnbG9icy5wb3AoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgdmFsdWUsIG91dHB1dDogc3RhdGUucGFyZW5zID8gJyknIDogJ1xcXFwpJyB9KTtcbiAgICAgIGRlY3JlbWVudCgncGFyZW5zJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcXVhcmUgYnJhY2tldHNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1snKSB7XG4gICAgICBpZiAob3B0cy5ub2JyYWNrZXQgPT09IHRydWUgfHwgIXJlbWFpbmluZygpLmluY2x1ZGVzKCddJykpIHtcbiAgICAgICAgaWYgKG9wdHMubm9icmFja2V0ICE9PSB0cnVlICYmIG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnXScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNyZW1lbnQoJ2JyYWNrZXRzJyk7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnYnJhY2tldCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnXScpIHtcbiAgICAgIGlmIChvcHRzLm5vYnJhY2tldCA9PT0gdHJ1ZSB8fCAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdicmFja2V0JyAmJiBwcmV2LnZhbHVlLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuYnJhY2tldHMgPT09IDApIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ29wZW5pbmcnLCAnWycpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IGBcXFxcJHt2YWx1ZX1gIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuXG4gICAgICBjb25zdCBwcmV2VmFsdWUgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuICAgICAgaWYgKHByZXYucG9zaXggIT09IHRydWUgJiYgcHJldlZhbHVlWzBdID09PSAnXicgJiYgIXByZXZWYWx1ZS5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgIHZhbHVlID0gYC8ke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBhcHBlbmQoeyB2YWx1ZSB9KTtcblxuICAgICAgLy8gd2hlbiBsaXRlcmFsIGJyYWNrZXRzIGFyZSBleHBsaWNpdGx5IGRpc2FibGVkXG4gICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIG1hdGNoIHdpdGggYSByZWdleCBjaGFyYWN0ZXIgY2xhc3NcbiAgICAgIGlmIChvcHRzLmxpdGVyYWxCcmFja2V0cyA9PT0gZmFsc2UgfHwgdXRpbHMkMS5oYXNSZWdleENoYXJzKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscyQxLmVzY2FwZVJlZ2V4KHByZXYudmFsdWUpO1xuICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBlbmFibGVkXG4gICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIGVzY2FwZSB0aGUgYnJhY2tldHMgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzXG4gICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IGVzY2FwZWQ7XG4gICAgICAgIHByZXYudmFsdWUgPSBlc2NhcGVkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgdXNlciBzcGVjaWZpZXMgbm90aGluZywgdHJ5IHRvIG1hdGNoIGJvdGhcbiAgICAgIHByZXYudmFsdWUgPSBgKCR7Y2FwdHVyZX0ke2VzY2FwZWR9fCR7cHJldi52YWx1ZX0pYDtcbiAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2LnZhbHVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnJhY2VzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICd7JyAmJiBvcHRzLm5vYnJhY2UgIT09IHRydWUpIHtcbiAgICAgIGluY3JlbWVudCgnYnJhY2VzJyk7XG5cbiAgICAgIGNvbnN0IG9wZW4gPSB7XG4gICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvdXRwdXQ6ICcoJyxcbiAgICAgICAgb3V0cHV0SW5kZXg6IHN0YXRlLm91dHB1dC5sZW5ndGgsXG4gICAgICAgIHRva2Vuc0luZGV4OiBzdGF0ZS50b2tlbnMubGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBicmFjZXMucHVzaChvcGVuKTtcbiAgICAgIHB1c2gob3Blbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICd9Jykge1xuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAob3B0cy5ub2JyYWNlID09PSB0cnVlIHx8ICFicmFjZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXQgPSAnKSc7XG5cbiAgICAgIGlmIChicmFjZS5kb3RzID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHRva2Vucy5zbGljZSgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlICE9PSAnZG90cycpIHtcbiAgICAgICAgICAgIHJhbmdlLnVuc2hpZnQoYXJyW2ldLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBleHBhbmRSYW5nZShyYW5nZSwgb3B0cyk7XG4gICAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmFjZS5jb21tYSAhPT0gdHJ1ZSAmJiBicmFjZS5kb3RzICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCBicmFjZS5vdXRwdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IHRva3MgPSBzdGF0ZS50b2tlbnMuc2xpY2UoYnJhY2UudG9rZW5zSW5kZXgpO1xuICAgICAgICBicmFjZS52YWx1ZSA9IGJyYWNlLm91dHB1dCA9ICdcXFxceyc7XG4gICAgICAgIHZhbHVlID0gb3V0cHV0ID0gJ1xcXFx9JztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gb3V0O1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdG9rcykge1xuICAgICAgICAgIHN0YXRlLm91dHB1dCArPSAodC5vdXRwdXQgfHwgdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdicmFjZScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuICAgICAgYnJhY2VzLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlwZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ3wnKSB7XG4gICAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoID4gMCkge1xuICAgICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5jb25kaXRpb25zKys7XG4gICAgICB9XG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbW1hc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLCcpIHtcbiAgICAgIGxldCBvdXRwdXQgPSB2YWx1ZTtcblxuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGJyYWNlICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSAnYnJhY2VzJykge1xuICAgICAgICBicmFjZS5jb21tYSA9IHRydWU7XG4gICAgICAgIG91dHB1dCA9ICd8JztcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdjb21tYScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbGFzaGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcvJykge1xuICAgICAgLy8gaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2xvYiBpcyBcIi4vXCIsIGFkdmFuY2UgdGhlIHN0YXJ0XG4gICAgICAvLyB0byB0aGUgY3VycmVudCBpbmRleCwgYW5kIGRvbid0IGFkZCB0aGUgXCIuL1wiIGNoYXJhY3RlcnNcbiAgICAgIC8vIHRvIHRoZSBzdGF0ZS4gVGhpcyBncmVhdGx5IHNpbXBsaWZpZXMgbG9va2JlaGluZHMgd2hlblxuICAgICAgLy8gY2hlY2tpbmcgZm9yIEJPUyBjaGFyYWN0ZXJzIGxpa2UgXCIhXCIgYW5kIFwiLlwiIChub3QgXCIuL1wiKVxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcgJiYgc3RhdGUuaW5kZXggPT09IHN0YXRlLnN0YXJ0ICsgMSkge1xuICAgICAgICBzdGF0ZS5zdGFydCA9IHN0YXRlLmluZGV4ICsgMTtcbiAgICAgICAgc3RhdGUuY29uc3VtZWQgPSAnJztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gJyc7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgcHJldiA9IGJvczsgLy8gcmVzZXQgXCJwcmV2XCIgdG8gdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWUsIG91dHB1dDogU0xBU0hfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvdHNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJy4nKSB7XG4gICAgICBpZiAoc3RhdGUuYnJhY2VzID4gMCAmJiBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICAgIGlmIChwcmV2LnZhbHVlID09PSAnLicpIHByZXYub3V0cHV0ID0gRE9UX0xJVEVSQUw7XG4gICAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcHJldi50eXBlID0gJ2RvdHMnO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSB2YWx1ZTtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgYnJhY2UuZG90cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHN0YXRlLmJyYWNlcyArIHN0YXRlLnBhcmVucykgPT09IDAgJiYgcHJldi50eXBlICE9PSAnYm9zJyAmJiBwcmV2LnR5cGUgIT09ICdzbGFzaCcpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogRE9UX0xJVEVSQUwgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2RvdCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFya3NcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJz8nKSB7XG4gICAgICBjb25zdCBpc0dyb3VwID0gcHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCc7XG4gICAgICBpZiAoIWlzR3JvdXAgJiYgb3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdxbWFyaycsIHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3BhcmVuJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKG5leHQgPT09ICc8JyAmJiAhdXRpbHMkMS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocHJldi52YWx1ZSA9PT0gJygnICYmICEvWyE9PDpdLy50ZXN0KG5leHQpKSB8fCAobmV4dCA9PT0gJzwnICYmICEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpKSB7XG4gICAgICAgICAgb3V0cHV0ID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuZG90ICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnYm9zJykpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLX05PX0RPVCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncW1hcmsnLCB2YWx1ZSwgb3V0cHV0OiBRTUFSSyB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4Y2xhbWF0aW9uXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICchJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnKSB7XG4gICAgICAgIGlmIChwZWVrKDIpICE9PSAnPycgfHwgIS9bIT08Ol0vLnRlc3QocGVlaygzKSkpIHtcbiAgICAgICAgICBleHRnbG9iT3BlbignbmVnYXRlJywgdmFsdWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLm5vbmVnYXRlICE9PSB0cnVlICYmIHN0YXRlLmluZGV4ID09PSAwKSB7XG4gICAgICAgIG5lZ2F0ZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbHVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcrJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBleHRnbG9iT3BlbigncGx1cycsIHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCcpIHx8IG9wdHMucmVnZXggPT09IGZhbHNlKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlLCBvdXRwdXQ6IFBMVVNfTElURVJBTCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJldiAmJiAocHJldi50eXBlID09PSAnYnJhY2tldCcgfHwgcHJldi50eXBlID09PSAncGFyZW4nIHx8IHByZXYudHlwZSA9PT0gJ2JyYWNlJykpIHx8IHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZTogUExVU19MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dFxuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnQCcpIHtcbiAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdhdCcsIGV4dGdsb2I6IHRydWUsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0XG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgIT09ICcqJykge1xuICAgICAgaWYgKHZhbHVlID09PSAnJCcgfHwgdmFsdWUgPT09ICdeJykge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaCA9IFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLmV4ZWMocmVtYWluaW5nKCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhbHVlICs9IG1hdGNoWzBdO1xuICAgICAgICBzdGF0ZS5pbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnNcbiAgICAgKi9cblxuICAgIGlmIChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdnbG9ic3RhcicgfHwgcHJldi5zdGFyID09PSB0cnVlKSkge1xuICAgICAgcHJldi50eXBlID0gJ3N0YXInO1xuICAgICAgcHJldi5zdGFyID0gdHJ1ZTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG4gICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdCA9IHJlbWFpbmluZygpO1xuICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiAvXlxcKFteP10vLnRlc3QocmVzdCkpIHtcbiAgICAgIGV4dGdsb2JPcGVuKCdzdGFyJywgdmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXYudHlwZSA9PT0gJ3N0YXInKSB7XG4gICAgICBpZiAob3B0cy5ub2dsb2JzdGFyID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJpb3IgPSBwcmV2LnByZXY7XG4gICAgICBjb25zdCBiZWZvcmUgPSBwcmlvci5wcmV2O1xuICAgICAgY29uc3QgaXNTdGFydCA9IHByaW9yLnR5cGUgPT09ICdzbGFzaCcgfHwgcHJpb3IudHlwZSA9PT0gJ2Jvcyc7XG4gICAgICBjb25zdCBhZnRlclN0YXIgPSBiZWZvcmUgJiYgKGJlZm9yZS50eXBlID09PSAnc3RhcicgfHwgYmVmb3JlLnR5cGUgPT09ICdnbG9ic3RhcicpO1xuXG4gICAgICBpZiAob3B0cy5iYXNoID09PSB0cnVlICYmICghaXNTdGFydCB8fCAocmVzdFswXSAmJiByZXN0WzBdICE9PSAnLycpKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmIChwcmlvci50eXBlID09PSAnY29tbWEnIHx8IHByaW9yLnR5cGUgPT09ICdicmFjZScpO1xuICAgICAgY29uc3QgaXNFeHRnbG9iID0gZXh0Z2xvYnMubGVuZ3RoICYmIChwcmlvci50eXBlID09PSAncGlwZScgfHwgcHJpb3IudHlwZSA9PT0gJ3BhcmVuJyk7XG4gICAgICBpZiAoIWlzU3RhcnQgJiYgcHJpb3IudHlwZSAhPT0gJ3BhcmVuJyAmJiAhaXNCcmFjZSAmJiAhaXNFeHRnbG9iKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RyaXAgY29uc2VjdXRpdmUgYC8qKi9gXG4gICAgICB3aGlsZSAocmVzdC5zbGljZSgwLCAzKSA9PT0gJy8qKicpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBpbnB1dFtzdGF0ZS5pbmRleCArIDRdO1xuICAgICAgICBpZiAoYWZ0ZXIgJiYgYWZ0ZXIgIT09ICcvJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDMpO1xuICAgICAgICBjb25zdW1lKCcvKionLCAzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdib3MnICYmIGVvcygpKSB7XG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cyk7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdzbGFzaCcgJiYgcHJpb3IucHJldi50eXBlICE9PSAnYm9zJyAmJiAhYWZ0ZXJTdGFyICYmIGVvcygpKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuICAgICAgICBwcmlvci5vdXRwdXQgPSBgKD86JHtwcmlvci5vdXRwdXR9YDtcblxuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpICsgKG9wdHMuc3RyaWN0U2xhc2hlcyA/ICcpJyA6ICd8JCknKTtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQ7XG4gICAgICAgIGNvbnN1bWUodmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdzbGFzaCcgJiYgcHJpb3IucHJldi50eXBlICE9PSAnYm9zJyAmJiByZXN0WzBdID09PSAnLycpIHtcbiAgICAgICAgY29uc3QgZW5kID0gcmVzdFsxXSAhPT0gdm9pZCAwID8gJ3wkJyA6ICcnO1xuXG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuICAgICAgICBwcmlvci5vdXRwdXQgPSBgKD86JHtwcmlvci5vdXRwdXR9YDtcblxuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGAke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH18JHtTTEFTSF9MSVRFUkFMfSR7ZW5kfSlgO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuXG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dDtcbiAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN1bWUodmFsdWUgKyBhZHZhbmNlKCkpO1xuXG4gICAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZTogJy8nLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yLnR5cGUgPT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBwcmV2Lm91dHB1dCA9IGAoPzpefCR7U0xBU0hfTElURVJBTH18JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KWA7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIGNvbnN1bWUodmFsdWUgKyBhZHZhbmNlKCkpO1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWU6ICcvJywgb3V0cHV0OiAnJyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBzaW5nbGUgc3RhciBmcm9tIG91dHB1dFxuICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2Lm91dHB1dC5sZW5ndGgpO1xuXG4gICAgICAvLyByZXNldCBwcmV2aW91cyB0b2tlbiB0byBnbG9ic3RhclxuICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cyk7XG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuXG4gICAgICAvLyByZXNldCBvdXRwdXQgd2l0aCBnbG9ic3RhclxuICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiBzdGFyIH07XG5cbiAgICBpZiAob3B0cy5iYXNoID09PSB0cnVlKSB7XG4gICAgICB0b2tlbi5vdXRwdXQgPSAnLio/JztcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdib3MnIHx8IHByZXYudHlwZSA9PT0gJ3NsYXNoJykge1xuICAgICAgICB0b2tlbi5vdXRwdXQgPSBub2RvdCArIHRva2VuLm91dHB1dDtcbiAgICAgIH1cbiAgICAgIHB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnIHx8IHByZXYudHlwZSA9PT0gJ3BhcmVuJykgJiYgb3B0cy5yZWdleCA9PT0gdHJ1ZSkge1xuICAgICAgdG9rZW4ub3V0cHV0ID0gdmFsdWU7XG4gICAgICBwdXNoKHRva2VuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5pbmRleCA9PT0gc3RhdGUuc3RhcnQgfHwgcHJldi50eXBlID09PSAnc2xhc2gnIHx8IHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RfU0xBU0g7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcblxuICAgICAgfSBlbHNlIGlmIChvcHRzLmRvdCA9PT0gdHJ1ZSkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gTk9fRE9UU19TTEFTSDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gTk9fRE9UU19TTEFTSDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IG5vZG90O1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBub2RvdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBlZWsoKSAhPT0gJyonKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBPTkVfQ0hBUjtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gT05FX0NIQVI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaCh0b2tlbik7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUuYnJhY2tldHMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzJDEuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICdbJyk7XG4gICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJyknKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMkMS5lc2NhcGVMYXN0KHN0YXRlLm91dHB1dCwgJygnKTtcbiAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLmJyYWNlcyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ30nKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMkMS5lc2NhcGVMYXN0KHN0YXRlLm91dHB1dCwgJ3snKTtcbiAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuICB9XG5cbiAgaWYgKG9wdHMuc3RyaWN0U2xhc2hlcyAhPT0gdHJ1ZSAmJiAocHJldi50eXBlID09PSAnc3RhcicgfHwgcHJldi50eXBlID09PSAnYnJhY2tldCcpKSB7XG4gICAgcHVzaCh7IHR5cGU6ICdtYXliZV9zbGFzaCcsIHZhbHVlOiAnJywgb3V0cHV0OiBgJHtTTEFTSF9MSVRFUkFMfT9gIH0pO1xuICB9XG5cbiAgLy8gcmVidWlsZCB0aGUgb3V0cHV0IGlmIHdlIGhhZCB0byBiYWNrdHJhY2sgYXQgYW55IHBvaW50XG4gIGlmIChzdGF0ZS5iYWNrdHJhY2sgPT09IHRydWUpIHtcbiAgICBzdGF0ZS5vdXRwdXQgPSAnJztcblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2Ygc3RhdGUudG9rZW5zKSB7XG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcblxuICAgICAgaWYgKHRva2VuLnN1ZmZpeCkge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4uc3VmZml4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogRmFzdCBwYXRocyBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9ucyBmb3IgY29tbW9uIGdsb2IgcGF0dGVybnMuXG4gKiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHByb2Nlc3NpbmcgYW5kIGhhcyB2ZXJ5IGxpdHRsZSBkb3duc2lkZVxuICogaW1wYWN0IHdoZW4gbm9uZSBvZiB0aGUgZmFzdCBwYXRocyBtYXRjaC5cbiAqL1xuXG5wYXJzZSQxLmZhc3RwYXRocyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGlmIChsZW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsZW59LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7bWF4fWApO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuICBjb25zdCB3aW4zMiA9IHV0aWxzJDEuaXNXaW5kb3dzKG9wdGlvbnMpO1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBTTEFTSF9MSVRFUkFMLFxuICAgIE9ORV9DSEFSLFxuICAgIERPVFNfU0xBU0gsXG4gICAgTk9fRE9ULFxuICAgIE5PX0RPVFMsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBTVEFSLFxuICAgIFNUQVJUX0FOQ0hPUlxuICB9ID0gY29uc3RhbnRzJDEuZ2xvYkNoYXJzKHdpbjMyKTtcblxuICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gTk9fRE9UUyA6IE5PX0RPVDtcbiAgY29uc3Qgc2xhc2hEb3QgPSBvcHRzLmRvdCA/IE5PX0RPVFNfU0xBU0ggOiBOT19ET1Q7XG4gIGNvbnN0IGNhcHR1cmUgPSBvcHRzLmNhcHR1cmUgPyAnJyA6ICc/Oic7XG4gIGNvbnN0IHN0YXRlID0geyBuZWdhdGVkOiBmYWxzZSwgcHJlZml4OiAnJyB9O1xuICBsZXQgc3RhciA9IG9wdHMuYmFzaCA9PT0gdHJ1ZSA/ICcuKj8nIDogU1RBUjtcblxuICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuICB9XG5cbiAgY29uc3QgZ2xvYnN0YXIgPSBvcHRzID0+IHtcbiAgICBpZiAob3B0cy5ub2dsb2JzdGFyID09PSB0cnVlKSByZXR1cm4gc3RhcjtcbiAgICByZXR1cm4gYCgke2NhcHR1cmV9KD86KD8hJHtTVEFSVF9BTkNIT1J9JHtvcHRzLmRvdCA/IERPVFNfU0xBU0ggOiBET1RfTElURVJBTH0pLikqPylgO1xuICB9O1xuXG4gIGNvbnN0IGNyZWF0ZSA9IHN0ciA9PiB7XG4gICAgc3dpdGNoIChzdHIpIHtcbiAgICAgIGNhc2UgJyonOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnLionOlxuICAgICAgICByZXR1cm4gYCR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKi4qJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7c3Rhcn0ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyovKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke3N0YXJ9JHtTTEFTSF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzbGFzaERvdH0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKionOlxuICAgICAgICByZXR1cm4gbm9kb3QgKyBnbG9ic3RhcihvcHRzKTtcblxuICAgICAgY2FzZSAnKiovKic6XG4gICAgICAgIHJldHVybiBgKD86JHtub2RvdH0ke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pPyR7c2xhc2hEb3R9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKiovKi4qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke3N0YXJ9JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKi8uKic6XG4gICAgICAgIHJldHVybiBgKD86JHtub2RvdH0ke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pPyR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eKC4qPylcXC4oXFx3KykkLy5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgICAgICBjb25zdCBzb3VyY2UgPSBjcmVhdGUobWF0Y2hbMV0pO1xuICAgICAgICBpZiAoIXNvdXJjZSkgcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiBzb3VyY2UgKyBET1RfTElURVJBTCArIG1hdGNoWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBvdXRwdXQgPSB1dGlscyQxLnJlbW92ZVByZWZpeChpbnB1dCwgc3RhdGUpO1xuICBsZXQgc291cmNlID0gY3JlYXRlKG91dHB1dCk7XG5cbiAgaWYgKHNvdXJjZSAmJiBvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUpIHtcbiAgICBzb3VyY2UgKz0gYCR7U0xBU0hfTElURVJBTH0/YDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG52YXIgcGFyc2VfMSA9IHBhcnNlJDE7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlJCQwO1xuY29uc3Qgc2NhbiA9IHNjYW5fMTtcbmNvbnN0IHBhcnNlID0gcGFyc2VfMTtcbmNvbnN0IHV0aWxzID0gdXRpbHMkMztcbmNvbnN0IGNvbnN0YW50cyA9IGNvbnN0YW50cyQyO1xuY29uc3QgaXNPYmplY3QgPSB2YWwgPT4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdGNoZXIgZnVuY3Rpb24gZnJvbSBvbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLiBUaGVcbiAqIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBpcyBhIG1hdGNoLiBUaGUgcmV0dXJuZWQgbWF0Y2hlclxuICogZnVuY3Rpb24gYWxzbyB0YWtlcyBhIGJvb2xlYW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0aGF0LCB3aGVuIHRydWUsXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoKGdsb2JbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgaXNNYXRjaCA9IHBpY29tYXRjaCgnKi4hKCphKScpO1xuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpOyAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmInKSk7IC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAbmFtZSBwaWNvbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgZ2xvYnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMuXG4gKiBAcGFyYW0ge09iamVjdD19IGBvcHRpb25zYFxuICogQHJldHVybiB7RnVuY3Rpb249fSBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3QgcGljb21hdGNoJDEgPSAoZ2xvYiwgb3B0aW9ucywgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShnbG9iKSkge1xuICAgIGNvbnN0IGZucyA9IGdsb2IubWFwKGlucHV0ID0+IHBpY29tYXRjaCQxKGlucHV0LCBvcHRpb25zLCByZXR1cm5TdGF0ZSkpO1xuICAgIGNvbnN0IGFycmF5TWF0Y2hlciA9IHN0ciA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGlzTWF0Y2ggb2YgZm5zKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gaXNNYXRjaChzdHIpO1xuICAgICAgICBpZiAoc3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheU1hdGNoZXI7XG4gIH1cblxuICBjb25zdCBpc1N0YXRlID0gaXNPYmplY3QoZ2xvYikgJiYgZ2xvYi50b2tlbnMgJiYgZ2xvYi5pbnB1dDtcblxuICBpZiAoZ2xvYiA9PT0gJycgfHwgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJyAmJiAhaXNTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHBvc2l4ID0gdXRpbHMuaXNXaW5kb3dzKG9wdGlvbnMpO1xuICBjb25zdCByZWdleCA9IGlzU3RhdGVcbiAgICA/IHBpY29tYXRjaCQxLmNvbXBpbGVSZShnbG9iLCBvcHRpb25zKVxuICAgIDogcGljb21hdGNoJDEubWFrZVJlKGdsb2IsIG9wdGlvbnMsIGZhbHNlLCB0cnVlKTtcblxuICBjb25zdCBzdGF0ZSA9IHJlZ2V4LnN0YXRlO1xuICBkZWxldGUgcmVnZXguc3RhdGU7XG5cbiAgbGV0IGlzSWdub3JlZCA9ICgpID0+IGZhbHNlO1xuICBpZiAob3B0cy5pZ25vcmUpIHtcbiAgICBjb25zdCBpZ25vcmVPcHRzID0geyAuLi5vcHRpb25zLCBpZ25vcmU6IG51bGwsIG9uTWF0Y2g6IG51bGwsIG9uUmVzdWx0OiBudWxsIH07XG4gICAgaXNJZ25vcmVkID0gcGljb21hdGNoJDEob3B0cy5pZ25vcmUsIGlnbm9yZU9wdHMsIHJldHVyblN0YXRlKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXIgPSAoaW5wdXQsIHJldHVybk9iamVjdCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBpc01hdGNoLCBtYXRjaCwgb3V0cHV0IH0gPSBwaWNvbWF0Y2gkMS50ZXN0KGlucHV0LCByZWdleCwgb3B0aW9ucywgeyBnbG9iLCBwb3NpeCB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7IGdsb2IsIHN0YXRlLCByZWdleCwgcG9zaXgsIGlucHV0LCBvdXRwdXQsIG1hdGNoLCBpc01hdGNoIH07XG5cbiAgICBpZiAodHlwZW9mIG9wdHMub25SZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdHMub25SZXN1bHQocmVzdWx0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXRjaCA9PT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmV0dXJuT2JqZWN0ID8gcmVzdWx0IDogZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzSWdub3JlZChpbnB1dCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbklnbm9yZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzLm9uSWdub3JlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5vbk1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLm9uTWF0Y2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IHRydWU7XG4gIH07XG5cbiAgaWYgKHJldHVyblN0YXRlKSB7XG4gICAgbWF0Y2hlci5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXI7XG59O1xuXG4vKipcbiAqIFRlc3QgYGlucHV0YCB3aXRoIHRoZSBnaXZlbiBgcmVnZXhgLiBUaGlzIGlzIHVzZWQgYnkgdGhlIG1haW5cbiAqIGBwaWNvbWF0Y2goKWAgZnVuY3Rpb24gdG8gdGVzdCB0aGUgaW5wdXQgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC50ZXN0KGlucHV0LCByZWdleFssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gudGVzdCgnZm9vL2JhcicsIC9eKD86KFteL10qPylcXC8oW14vXSo/KSkkLykpO1xuICogLy8geyBpc01hdGNoOiB0cnVlLCBtYXRjaDogWyAnZm9vLycsICdmb28nLCAnYmFyJyBdLCBvdXRwdXQ6ICdmb28vYmFyJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIFN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtSZWdFeHB9IGByZWdleGBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBtYXRjaGluZyBpbmZvLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gkMS50ZXN0ID0gKGlucHV0LCByZWdleCwgb3B0aW9ucywgeyBnbG9iLCBwb3NpeCB9ID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGlucHV0ID09PSAnJykge1xuICAgIHJldHVybiB7IGlzTWF0Y2g6IGZhbHNlLCBvdXRwdXQ6ICcnIH07XG4gIH1cblxuICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgKHBvc2l4ID8gdXRpbHMudG9Qb3NpeFNsYXNoZXMgOiBudWxsKTtcbiAgbGV0IG1hdGNoID0gaW5wdXQgPT09IGdsb2I7XG4gIGxldCBvdXRwdXQgPSAobWF0Y2ggJiYgZm9ybWF0KSA/IGZvcm1hdChpbnB1dCkgOiBpbnB1dDtcblxuICBpZiAobWF0Y2ggPT09IGZhbHNlKSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0ID8gZm9ybWF0KGlucHV0KSA6IGlucHV0O1xuICAgIG1hdGNoID0gb3V0cHV0ID09PSBnbG9iO1xuICB9XG5cbiAgaWYgKG1hdGNoID09PSBmYWxzZSB8fCBvcHRzLmNhcHR1cmUgPT09IHRydWUpIHtcbiAgICBpZiAob3B0cy5tYXRjaEJhc2UgPT09IHRydWUgfHwgb3B0cy5iYXNlbmFtZSA9PT0gdHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBwaWNvbWF0Y2gkMS5tYXRjaEJhc2UoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCBwb3NpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhvdXRwdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzTWF0Y2g6IEJvb2xlYW4obWF0Y2gpLCBtYXRjaCwgb3V0cHV0IH07XG59O1xuXG4vKipcbiAqIE1hdGNoIHRoZSBiYXNlbmFtZSBvZiBhIGZpbGVwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIGdsb2JbLCBvcHRpb25zXSk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gubWF0Y2hCYXNlKCdmb28vYmFyLmpzJywgJyouanMnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gYGdsb2JgIEdsb2IgcGF0dGVybiBvciByZWdleCBjcmVhdGVkIGJ5IFsubWFrZVJlXSgjbWFrZVJlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaCQxLm1hdGNoQmFzZSA9IChpbnB1dCwgZ2xvYiwgb3B0aW9ucywgcG9zaXggPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucykpID0+IHtcbiAgY29uc3QgcmVnZXggPSBnbG9iIGluc3RhbmNlb2YgUmVnRXhwID8gZ2xvYiA6IHBpY29tYXRjaCQxLm1ha2VSZShnbG9iLCBvcHRpb25zKTtcbiAgcmV0dXJuIHJlZ2V4LnRlc3QocGF0aC5iYXNlbmFtZShpbnB1dCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgKiphbnkqKiBvZiB0aGUgZ2l2ZW4gZ2xvYiBgcGF0dGVybnNgIG1hdGNoIHRoZSBzcGVjaWZpZWQgYHN0cmluZ2AuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guaXNNYXRjaCgnYS5hJywgWydiLionLCAnKi5hJ10pKTsgLy89PiB0cnVlXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guaXNNYXRjaCgnYS5hJywgJ2IuKicpKTsgLy89PiBmYWxzZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gc3RyIFRoZSBzdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXR0ZXJucyBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFNlZSBhdmFpbGFibGUgW29wdGlvbnNdKCNvcHRpb25zKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGF0dGVybnMgbWF0Y2ggYHN0cmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoJDEuaXNNYXRjaCA9IChzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gkMShwYXR0ZXJucywgb3B0aW9ucykoc3RyKTtcblxuLyoqXG4gKiBQYXJzZSBhIGdsb2IgcGF0dGVybiB0byBjcmVhdGUgdGhlIHNvdXJjZSBzdHJpbmcgZm9yIGEgcmVndWxhclxuICogZXhwcmVzc2lvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiBjb25zdCByZXN1bHQgPSBwaWNvbWF0Y2gucGFyc2UocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHVzZWZ1bCBwcm9wZXJ0aWVzIGFuZCBvdXRwdXQgdG8gYmUgdXNlZCBhcyBhIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaCQxLnBhcnNlID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHJldHVybiBwYXR0ZXJuLm1hcChwID0+IHBpY29tYXRjaCQxLnBhcnNlKHAsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHBhcnNlKHBhdHRlcm4sIHsgLi4ub3B0aW9ucywgZmFzdHBhdGhzOiBmYWxzZSB9KTtcbn07XG5cbi8qKlxuICogU2NhbiBhIGdsb2IgcGF0dGVybiB0byBzZXBhcmF0ZSB0aGUgcGF0dGVybiBpbnRvIHNlZ21lbnRzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5zY2FuKGlucHV0Wywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5zY2FuKCchLi9mb28vKi5qcycpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHsgcHJlZml4OiAnIS4vJyxcbiAqICAgaW5wdXQ6ICchLi9mb28vKi5qcycsXG4gKiAgIHN0YXJ0OiAzLFxuICogICBiYXNlOiAnZm9vJyxcbiAqICAgZ2xvYjogJyouanMnLFxuICogICBpc0JyYWNlOiBmYWxzZSxcbiAqICAgaXNCcmFja2V0OiBmYWxzZSxcbiAqICAgaXNHbG9iOiB0cnVlLFxuICogICBpc0V4dGdsb2I6IGZhbHNlLFxuICogICBpc0dsb2JzdGFyOiBmYWxzZSxcbiAqICAgbmVnYXRlZDogdHJ1ZSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIEdsb2IgcGF0dGVybiB0byBzY2FuLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaCQxLnNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNjYW4oaW5wdXQsIG9wdGlvbnMpO1xuXG4vKipcbiAqIENvbXBpbGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgYHN0YXRlYCBvYmplY3QgcmV0dXJuZWQgYnkgdGhlXG4gKiBbcGFyc2UoKV0oI3BhcnNlKSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVybk91dHB1dGAgSW50ZW5kZWQgZm9yIGltcGxlbWVudG9ycywgdGhpcyBhcmd1bWVudCBhbGxvd3MgeW91IHRvIHJldHVybiB0aGUgcmF3IG91dHB1dCBmcm9tIHRoZSBwYXJzZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5TdGF0ZWAgQWRkcyB0aGUgc3RhdGUgdG8gYSBgc3RhdGVgIHByb3BlcnR5IG9uIHRoZSByZXR1cm5lZCByZWdleC4gVXNlZnVsIGZvciBpbXBsZW1lbnRvcnMgYW5kIGRlYnVnZ2luZy5cbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoJDEuY29tcGlsZVJlID0gKHN0YXRlLCBvcHRpb25zLCByZXR1cm5PdXRwdXQgPSBmYWxzZSwgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuICBpZiAocmV0dXJuT3V0cHV0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm91dHB1dDtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBwcmVwZW5kID0gb3B0cy5jb250YWlucyA/ICcnIDogJ14nO1xuICBjb25zdCBhcHBlbmQgPSBvcHRzLmNvbnRhaW5zID8gJycgOiAnJCc7XG5cbiAgbGV0IHNvdXJjZSA9IGAke3ByZXBlbmR9KD86JHtzdGF0ZS5vdXRwdXR9KSR7YXBwZW5kfWA7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG4gICAgc291cmNlID0gYF4oPyEke3NvdXJjZX0pLiokYDtcbiAgfVxuXG4gIGNvbnN0IHJlZ2V4ID0gcGljb21hdGNoJDEudG9SZWdleChzb3VyY2UsIG9wdGlvbnMpO1xuICBpZiAocmV0dXJuU3RhdGUgPT09IHRydWUpIHtcbiAgICByZWdleC5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHBhcnNlZCBnbG9iIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcbiAqIC8vIHBpY29tYXRjaC5jb21waWxlUmUoc3RhdGVbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLmNvbXBpbGVSZShzdGF0ZSkpO1xuICogLy89PiAvXig/Oig/IVxcLikoPz0uKVteL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RhdGVgIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgYC5wYXJzZWAgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgY29tcGlsZWQgb3V0cHV0LCBpbnN0ZWFkIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGlzIG5vdCBleHBvc2VkIG9uIHRoZSBvcHRpb25zIHRvIHByZXZlbnQgZW5kLXVzZXJzIGZyb20gbXV0YXRpbmcgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyc2VkIGdsb2Igd2l0aCB0aGUgcmV0dXJuZWQgcmVndWxhciBleHByZXNzaW9uLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gkMS5tYWtlUmUgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSwgcmV0dXJuT3V0cHV0ID0gZmFsc2UsIHJldHVyblN0YXRlID0gZmFsc2UpID0+IHtcbiAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgcGFyc2VkID0geyBuZWdhdGVkOiBmYWxzZSwgZmFzdHBhdGhzOiB0cnVlIH07XG5cbiAgaWYgKG9wdGlvbnMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAoaW5wdXRbMF0gPT09ICcuJyB8fCBpbnB1dFswXSA9PT0gJyonKSkge1xuICAgIHBhcnNlZC5vdXRwdXQgPSBwYXJzZS5mYXN0cGF0aHMoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFwYXJzZWQub3V0cHV0KSB7XG4gICAgcGFyc2VkID0gcGFyc2UoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHBpY29tYXRjaCQxLmNvbXBpbGVSZShwYXJzZWQsIG9wdGlvbnMsIHJldHVybk91dHB1dCwgcmV0dXJuU3RhdGUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgZ2l2ZW4gcmVnZXggc291cmNlIHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2VbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgeyBvdXRwdXQgfSA9IHBpY29tYXRjaC5wYXJzZSgnKi5qcycpO1xuICogY29uc29sZS5sb2cocGljb21hdGNoLnRvUmVnZXgob3V0cHV0KSk7XG4gKiAvLz0+IC9eKD86KD8hXFwuKSg/PS4pW14vXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzb3VyY2VgIFJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2Ugc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7UmVnRXhwfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gkMS50b1JlZ2V4ID0gKHNvdXJjZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0cy5mbGFncyB8fCAob3B0cy5ub2Nhc2UgPyAnaScgOiAnJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnID09PSB0cnVlKSB0aHJvdyBlcnI7XG4gICAgcmV0dXJuIC8kXi87XG4gIH1cbn07XG5cbi8qKlxuICogUGljb21hdGNoIGNvbnN0YW50cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5waWNvbWF0Y2gkMS5jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbi8qKlxuICogRXhwb3NlIFwicGljb21hdGNoXCJcbiAqL1xuXG52YXIgcGljb21hdGNoXzEgPSBwaWNvbWF0Y2gkMTtcblxudmFyIHBpY29tYXRjaCA9IHBpY29tYXRjaF8xO1xuXG5jb25zdCBwbSA9IHBpY29tYXRjaDtcblxuY29uc3QgZXh0cmFjdG9ycyA9IHtcbiAgICBBcnJheVBhdHRlcm4obmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBwYXJhbS5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgZXh0cmFjdG9yc1tlbGVtZW50LnR5cGVdKG5hbWVzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgQXNzaWdubWVudFBhdHRlcm4obmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGV4dHJhY3RvcnNbcGFyYW0ubGVmdC50eXBlXShuYW1lcywgcGFyYW0ubGVmdCk7XG4gICAgfSxcbiAgICBJZGVudGlmaWVyKG5hbWVzLCBwYXJhbSkge1xuICAgICAgICBuYW1lcy5wdXNoKHBhcmFtLm5hbWUpO1xuICAgIH0sXG4gICAgTWVtYmVyRXhwcmVzc2lvbigpIHsgfSxcbiAgICBPYmplY3RQYXR0ZXJuKG5hbWVzLCBwYXJhbSkge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcGFyYW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUeXBlc2NyaXB0IHJlcG9ydHMgdGhhdCB0aGlzIGlzIG5vdCBhIHZhbGlkIHR5cGVcbiAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0b3JzLlJlc3RFbGVtZW50KG5hbWVzLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RvcnNbcHJvcC52YWx1ZS50eXBlXShuYW1lcywgcHJvcC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJlc3RFbGVtZW50KG5hbWVzLCBwYXJhbSkge1xuICAgICAgICBleHRyYWN0b3JzW3BhcmFtLmFyZ3VtZW50LnR5cGVdKG5hbWVzLCBwYXJhbS5hcmd1bWVudCk7XG4gICAgfVxufTtcbmNvbnN0IGV4dHJhY3RBc3NpZ25lZE5hbWVzID0gZnVuY3Rpb24gZXh0cmFjdEFzc2lnbmVkTmFtZXMocGFyYW0pIHtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGV4dHJhY3RvcnNbcGFyYW0udHlwZV0obmFtZXMsIHBhcmFtKTtcbiAgICByZXR1cm4gbmFtZXM7XG59O1xuXG4vLyBIZWxwZXIgc2luY2UgVHlwZXNjcmlwdCBjYW4ndCBkZXRlY3QgcmVhZG9ubHkgYXJyYXlzIHdpdGggQXJyYXkuaXNBcnJheVxuZnVuY3Rpb24gaXNBcnJheSQxKGFyZykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG59XG5mdW5jdGlvbiBlbnN1cmVBcnJheSQxKHRoaW5nKSB7XG4gICAgaWYgKGlzQXJyYXkkMSh0aGluZykpXG4gICAgICAgIHJldHVybiB0aGluZztcbiAgICBpZiAodGhpbmcgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbdGhpbmddO1xufVxuXG5jb25zdCBub3JtYWxpemVQYXRoID0gZnVuY3Rpb24gbm9ybWFsaXplUGF0aChmaWxlbmFtZSkge1xuICAgIHJldHVybiBmaWxlbmFtZS5zcGxpdCh3aW4zMi5zZXApLmpvaW4ocG9zaXguc2VwKTtcbn07XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXJTdHJpbmcoaWQsIHJlc29sdXRpb25CYXNlKSB7XG4gICAgaWYgKHJlc29sdXRpb25CYXNlID09PSBmYWxzZSB8fCBpc0Fic29sdXRlJDEoaWQpIHx8IGlkLnN0YXJ0c1dpdGgoJyonKSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8vIHJlc29sdmUoJycpIGlzIHZhbGlkIGFuZCB3aWxsIGRlZmF1bHQgdG8gcHJvY2Vzcy5jd2QoKVxuICAgIGNvbnN0IGJhc2VQYXRoID0gbm9ybWFsaXplUGF0aChyZXNvbHZlKHJlc29sdXRpb25CYXNlIHx8ICcnKSlcbiAgICAgICAgLy8gZXNjYXBlIGFsbCBwb3NzaWJsZSAocG9zaXggKyB3aW4pIHBhdGggY2hhcmFjdGVycyB0aGF0IG1pZ2h0IGludGVyZmVyZSB3aXRoIHJlZ2V4XG4gICAgICAgIC5yZXBsYWNlKC9bLV4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSB1c2UgcG9zaXguam9pbiBiZWNhdXNlOlxuICAgIC8vIDEuIHRoZSBiYXNlUGF0aCBoYXMgYmVlbiBub3JtYWxpemVkIHRvIHVzZSAvXG4gICAgLy8gMi4gdGhlIGluY29taW5nIGdsb2IgKGlkKSBtYXRjaGVyLCBhbHNvIHVzZXMgL1xuICAgIC8vIG90aGVyd2lzZSBOb2RlIHdpbGwgZm9yY2UgYmFja3NsYXNoIChcXCkgb24gd2luZG93c1xuICAgIHJldHVybiBwb3NpeC5qb2luKGJhc2VQYXRoLCBpZCk7XG59XG5jb25zdCBjcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoaW5jbHVkZSwgZXhjbHVkZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdXRpb25CYXNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc29sdmU7XG4gICAgY29uc3QgZ2V0TWF0Y2hlciA9IChpZCkgPT4gaWQgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgPyBpZFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHRlc3Q6ICh3aGF0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyByZWZhY3RvciBpcyBhIHRhZCBvdmVybHkgdmVyYm9zZSBidXQgbWFrZXMgZm9yIGVhc3kgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGdldE1hdGNoZXJTdHJpbmcoaWQsIHJlc29sdXRpb25CYXNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHBtKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHdoYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgY29uc3QgaW5jbHVkZU1hdGNoZXJzID0gZW5zdXJlQXJyYXkkMShpbmNsdWRlKS5tYXAoZ2V0TWF0Y2hlcik7XG4gICAgY29uc3QgZXhjbHVkZU1hdGNoZXJzID0gZW5zdXJlQXJyYXkkMShleGNsdWRlKS5tYXAoZ2V0TWF0Y2hlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlc3VsdChpZCkge1xuICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKC9cXDAvLnRlc3QoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBwYXRoSWQgPSBub3JtYWxpemVQYXRoKGlkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGNsdWRlTWF0Y2hlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXIgPSBleGNsdWRlTWF0Y2hlcnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KHBhdGhJZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jbHVkZU1hdGNoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gaW5jbHVkZU1hdGNoZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIudGVzdChwYXRoSWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhaW5jbHVkZU1hdGNoZXJzLmxlbmd0aDtcbiAgICB9O1xufTtcblxuY29uc3QgcmVzZXJ2ZWRXb3JkcyQxID0gJ2JyZWFrIGNhc2UgY2xhc3MgY2F0Y2ggY29uc3QgY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkZWxldGUgZG8gZWxzZSBleHBvcnQgZXh0ZW5kcyBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbXBvcnQgaW4gaW5zdGFuY2VvZiBsZXQgbmV3IHJldHVybiBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGggeWllbGQgZW51bSBhd2FpdCBpbXBsZW1lbnRzIHBhY2thZ2UgcHJvdGVjdGVkIHN0YXRpYyBpbnRlcmZhY2UgcHJpdmF0ZSBwdWJsaWMnO1xuY29uc3QgYnVpbHRpbnMkMSA9ICdhcmd1bWVudHMgSW5maW5pdHkgTmFOIHVuZGVmaW5lZCBudWxsIHRydWUgZmFsc2UgZXZhbCB1bmV2YWwgaXNGaW5pdGUgaXNOYU4gcGFyc2VGbG9hdCBwYXJzZUludCBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgZXNjYXBlIHVuZXNjYXBlIE9iamVjdCBGdW5jdGlvbiBCb29sZWFuIFN5bWJvbCBFcnJvciBFdmFsRXJyb3IgSW50ZXJuYWxFcnJvciBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFN5bnRheEVycm9yIFR5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgSW50OEFycmF5IFVpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgSW50MTZBcnJheSBVaW50MTZBcnJheSBJbnQzMkFycmF5IFVpbnQzMkFycmF5IEZsb2F0MzJBcnJheSBGbG9hdDY0QXJyYXkgTWFwIFNldCBXZWFrTWFwIFdlYWtTZXQgU0lNRCBBcnJheUJ1ZmZlciBEYXRhVmlldyBKU09OIFByb21pc2UgR2VuZXJhdG9yIEdlbmVyYXRvckZ1bmN0aW9uIFJlZmxlY3QgUHJveHkgSW50bCc7XG5jb25zdCBmb3JiaWRkZW5JZGVudGlmaWVycyA9IG5ldyBTZXQoYCR7cmVzZXJ2ZWRXb3JkcyQxfSAke2J1aWx0aW5zJDF9YC5zcGxpdCgnICcpKTtcbmZvcmJpZGRlbklkZW50aWZpZXJzLmFkZCgnJyk7XG5cbmNvbnN0IEJST0tFTl9GTE9XX05PTkUgPSAwO1xuY29uc3QgQlJPS0VOX0ZMT1dfQlJFQUtfQ09OVElOVUUgPSAxO1xuY29uc3QgQlJPS0VOX0ZMT1dfRVJST1JfUkVUVVJOX0xBQkVMID0gMjtcbmZ1bmN0aW9uIGNyZWF0ZUluY2x1c2lvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnJva2VuRmxvdzogQlJPS0VOX0ZMT1dfTk9ORSxcbiAgICAgICAgaW5jbHVkZWRDYWxsQXJndW1lbnRzOiBuZXcgU2V0KCksXG4gICAgICAgIGluY2x1ZGVkTGFiZWxzOiBuZXcgU2V0KClcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzRWZmZWN0c0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzZWQ6IG5ldyBQYXRoVHJhY2tlcigpLFxuICAgICAgICBhc3NpZ25lZDogbmV3IFBhdGhUcmFja2VyKCksXG4gICAgICAgIGJyb2tlbkZsb3c6IEJST0tFTl9GTE9XX05PTkUsXG4gICAgICAgIGNhbGxlZDogbmV3IERpc2NyaW1pbmF0ZWRQYXRoVHJhY2tlcigpLFxuICAgICAgICBpZ25vcmU6IHtcbiAgICAgICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgICAgICBjb250aW51ZXM6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICByZXR1cm5ZaWVsZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZWRMYWJlbHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaW5zdGFudGlhdGVkOiBuZXcgRGlzY3JpbWluYXRlZFBhdGhUcmFja2VyKCksXG4gICAgICAgIHJlcGxhY2VkVmFyaWFibGVJbml0czogbmV3IE1hcCgpXG4gICAgfTtcbn1cblxuY29uc3QgTk9fQVJHUyA9IFtdO1xuXG5mdW5jdGlvbiBhc3NlbWJsZU1lbWJlckRlc2NyaXB0aW9ucyhtZW1iZXJEZXNjcmlwdGlvbnMsIGluaGVyaXRlZERlc2NyaXB0aW9ucyA9IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShpbmhlcml0ZWREZXNjcmlwdGlvbnMsIG1lbWJlckRlc2NyaXB0aW9ucyk7XG59XG5jb25zdCBVTkRFRklORURfRVhQUkVTU0lPTiA9IG5ldyAoY2xhc3MgVW5kZWZpbmVkRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59KSgpO1xuY29uc3QgcmV0dXJuc1Vua25vd24gPSB7XG4gICAgdmFsdWU6IHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICByZXR1cm5zOiBVTktOT1dOX0VYUFJFU1NJT05cbiAgICB9XG59O1xuY29uc3QgVU5LTk9XTl9MSVRFUkFMX0JPT0xFQU4gPSBuZXcgKGNsYXNzIFVua25vd25Cb29sZWFuIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZW1iZXJSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZChsaXRlcmFsQm9vbGVhbk1lbWJlcnMsIHBhdGhbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNNZW1iZXJFZmZlY3RXaGVuQ2FsbGVkKGxpdGVyYWxCb29sZWFuTWVtYmVycywgcGF0aFswXSwgY2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKCk7XG5jb25zdCByZXR1cm5zQm9vbGVhbiA9IHtcbiAgICB2YWx1ZToge1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIHJldHVybnM6IFVOS05PV05fTElURVJBTF9CT09MRUFOXG4gICAgfVxufTtcbmNvbnN0IFVOS05PV05fTElURVJBTF9OVU1CRVIgPSBuZXcgKGNsYXNzIFVua25vd25OdW1iZXIgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1lbWJlclJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkKGxpdGVyYWxOdW1iZXJNZW1iZXJzLCBwYXRoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzTWVtYmVyRWZmZWN0V2hlbkNhbGxlZChsaXRlcmFsTnVtYmVyTWVtYmVycywgcGF0aFswXSwgY2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKCk7XG5jb25zdCByZXR1cm5zTnVtYmVyID0ge1xuICAgIHZhbHVlOiB7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgcmV0dXJuczogVU5LTk9XTl9MSVRFUkFMX05VTUJFUlxuICAgIH1cbn07XG5jb25zdCBVTktOT1dOX0xJVEVSQUxfU1RSSU5HID0gbmV3IChjbGFzcyBVbmtub3duU3RyaW5nIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZW1iZXJSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZChsaXRlcmFsU3RyaW5nTWVtYmVycywgcGF0aFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc01lbWJlckVmZmVjdFdoZW5DYWxsZWQobGl0ZXJhbFN0cmluZ01lbWJlcnMsIHBhdGhbMF0sIGNhbGxPcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KSgpO1xuY29uc3QgcmV0dXJuc1N0cmluZyA9IHtcbiAgICB2YWx1ZToge1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIHJldHVybnM6IFVOS05PV05fTElURVJBTF9TVFJJTkdcbiAgICB9XG59O1xuY29uc3Qgb2JqZWN0TWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICBoYXNPd25Qcm9wZXJ0eTogcmV0dXJuc0Jvb2xlYW4sXG4gICAgaXNQcm90b3R5cGVPZjogcmV0dXJuc0Jvb2xlYW4sXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGU6IHJldHVybnNCb29sZWFuLFxuICAgIHRvTG9jYWxlU3RyaW5nOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvU3RyaW5nOiByZXR1cm5zU3RyaW5nLFxuICAgIHZhbHVlT2Y6IHJldHVybnNVbmtub3duXG59KTtcbmNvbnN0IGxpdGVyYWxCb29sZWFuTWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICB2YWx1ZU9mOiByZXR1cm5zQm9vbGVhblxufSwgb2JqZWN0TWVtYmVycyk7XG5jb25zdCBsaXRlcmFsTnVtYmVyTWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICB0b0V4cG9uZW50aWFsOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvRml4ZWQ6IHJldHVybnNTdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6IHJldHVybnNTdHJpbmcsXG4gICAgdG9QcmVjaXNpb246IHJldHVybnNTdHJpbmcsXG4gICAgdmFsdWVPZjogcmV0dXJuc051bWJlclxufSwgb2JqZWN0TWVtYmVycyk7XG5jb25zdCBsaXRlcmFsU3RyaW5nTWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICBhbmNob3I6IHJldHVybnNTdHJpbmcsXG4gICAgYXQ6IHJldHVybnNVbmtub3duLFxuICAgIGJpZzogcmV0dXJuc1N0cmluZyxcbiAgICBibGluazogcmV0dXJuc1N0cmluZyxcbiAgICBib2xkOiByZXR1cm5zU3RyaW5nLFxuICAgIGNoYXJBdDogcmV0dXJuc1N0cmluZyxcbiAgICBjaGFyQ29kZUF0OiByZXR1cm5zTnVtYmVyLFxuICAgIGNvZGVQb2ludEF0OiByZXR1cm5zVW5rbm93bixcbiAgICBjb25jYXQ6IHJldHVybnNTdHJpbmcsXG4gICAgZW5kc1dpdGg6IHJldHVybnNCb29sZWFuLFxuICAgIGZpeGVkOiByZXR1cm5zU3RyaW5nLFxuICAgIGZvbnRjb2xvcjogcmV0dXJuc1N0cmluZyxcbiAgICBmb250c2l6ZTogcmV0dXJuc1N0cmluZyxcbiAgICBpbmNsdWRlczogcmV0dXJuc0Jvb2xlYW4sXG4gICAgaW5kZXhPZjogcmV0dXJuc051bWJlcixcbiAgICBpdGFsaWNzOiByZXR1cm5zU3RyaW5nLFxuICAgIGxhc3RJbmRleE9mOiByZXR1cm5zTnVtYmVyLFxuICAgIGxpbms6IHJldHVybnNTdHJpbmcsXG4gICAgbG9jYWxlQ29tcGFyZTogcmV0dXJuc051bWJlcixcbiAgICBtYXRjaDogcmV0dXJuc1Vua25vd24sXG4gICAgbWF0Y2hBbGw6IHJldHVybnNVbmtub3duLFxuICAgIG5vcm1hbGl6ZTogcmV0dXJuc1N0cmluZyxcbiAgICBwYWRFbmQ6IHJldHVybnNTdHJpbmcsXG4gICAgcGFkU3RhcnQ6IHJldHVybnNTdHJpbmcsXG4gICAgcmVwZWF0OiByZXR1cm5zU3RyaW5nLFxuICAgIHJlcGxhY2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNhbGxzQXJnczogWzFdLFxuICAgICAgICAgICAgcmV0dXJuczogVU5LTk9XTl9MSVRFUkFMX1NUUklOR1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlQWxsOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjYWxsc0FyZ3M6IFsxXSxcbiAgICAgICAgICAgIHJldHVybnM6IFVOS05PV05fTElURVJBTF9TVFJJTkdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoOiByZXR1cm5zTnVtYmVyLFxuICAgIHNsaWNlOiByZXR1cm5zU3RyaW5nLFxuICAgIHNtYWxsOiByZXR1cm5zU3RyaW5nLFxuICAgIHNwbGl0OiByZXR1cm5zVW5rbm93bixcbiAgICBzdGFydHNXaXRoOiByZXR1cm5zQm9vbGVhbixcbiAgICBzdHJpa2U6IHJldHVybnNTdHJpbmcsXG4gICAgc3ViOiByZXR1cm5zU3RyaW5nLFxuICAgIHN1YnN0cjogcmV0dXJuc1N0cmluZyxcbiAgICBzdWJzdHJpbmc6IHJldHVybnNTdHJpbmcsXG4gICAgc3VwOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvTG9jYWxlTG93ZXJDYXNlOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvTG9jYWxlVXBwZXJDYXNlOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvTG93ZXJDYXNlOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvU3RyaW5nOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvVXBwZXJDYXNlOiByZXR1cm5zU3RyaW5nLFxuICAgIHRyaW06IHJldHVybnNTdHJpbmcsXG4gICAgdHJpbUVuZDogcmV0dXJuc1N0cmluZyxcbiAgICB0cmltTGVmdDogcmV0dXJuc1N0cmluZyxcbiAgICB0cmltUmlnaHQ6IHJldHVybnNTdHJpbmcsXG4gICAgdHJpbVN0YXJ0OiByZXR1cm5zU3RyaW5nLFxuICAgIHZhbHVlT2Y6IHJldHVybnNTdHJpbmdcbn0sIG9iamVjdE1lbWJlcnMpO1xuZnVuY3Rpb24gZ2V0TGl0ZXJhbE1lbWJlcnNGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxCb29sZWFuTWVtYmVycztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsTnVtYmVyTWVtYmVycztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsU3RyaW5nTWVtYmVycztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBoYXNNZW1iZXJFZmZlY3RXaGVuQ2FsbGVkKG1lbWJlcnMsIG1lbWJlck5hbWUsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1iZXJOYW1lICE9PSAnc3RyaW5nJyB8fCAhbWVtYmVyc1ttZW1iZXJOYW1lXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFtZW1iZXJzW21lbWJlck5hbWVdLmNhbGxzQXJncylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3QgYXJnSW5kZXggb2YgbWVtYmVyc1ttZW1iZXJOYW1lXS5jYWxsc0FyZ3MpIHtcbiAgICAgICAgaWYgKGNhbGxPcHRpb25zLmFyZ3NbYXJnSW5kZXhdICYmXG4gICAgICAgICAgICBjYWxsT3B0aW9ucy5hcmdzW2FyZ0luZGV4XS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB7XG4gICAgICAgICAgICAgICAgYXJnczogTk9fQVJHUyxcbiAgICAgICAgICAgICAgICB0aGlzUGFyYW06IG51bGwsXG4gICAgICAgICAgICAgICAgd2l0aE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0sIGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldE1lbWJlclJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkKG1lbWJlcnMsIG1lbWJlck5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG1lbWJlck5hbWUgIT09ICdzdHJpbmcnIHx8ICFtZW1iZXJzW21lbWJlck5hbWVdKVxuICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgIHJldHVybiBtZW1iZXJzW21lbWJlck5hbWVdLnJldHVybnM7XG59XG5cbi8vIEFTVCB3YWxrZXIgbW9kdWxlIGZvciBNb3ppbGxhIFBhcnNlciBBUEkgY29tcGF0aWJsZSB0cmVlc1xuXG5mdW5jdGlvbiBza2lwVGhyb3VnaChub2RlLCBzdCwgYykgeyBjKG5vZGUsIHN0KTsgfVxuZnVuY3Rpb24gaWdub3JlKF9ub2RlLCBfc3QsIF9jKSB7fVxuXG4vLyBOb2RlIHdhbGtlcnMuXG5cbnZhciBiYXNlJDEgPSB7fTtcblxuYmFzZSQxLlByb2dyYW0gPSBiYXNlJDEuQmxvY2tTdGF0ZW1lbnQgPSBiYXNlJDEuU3RhdGljQmxvY2sgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmJvZHk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgc3RtdCA9IGxpc3RbaV07XG5cbiAgICBjKHN0bXQsIHN0LCBcIlN0YXRlbWVudFwiKTtcbiAgfVxufTtcbmJhc2UkMS5TdGF0ZW1lbnQgPSBza2lwVGhyb3VnaDtcbmJhc2UkMS5FbXB0eVN0YXRlbWVudCA9IGlnbm9yZTtcbmJhc2UkMS5FeHByZXNzaW9uU3RhdGVtZW50ID0gYmFzZSQxLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gYmFzZSQxLkNoYWluRXhwcmVzc2lvbiA9XG4gIGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLmV4cHJlc3Npb24sIHN0LCBcIkV4cHJlc3Npb25cIik7IH07XG5iYXNlJDEuSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGMobm9kZS5jb25zZXF1ZW50LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gIGlmIChub2RlLmFsdGVybmF0ZSkgeyBjKG5vZGUuYWx0ZXJuYXRlLCBzdCwgXCJTdGF0ZW1lbnRcIik7IH1cbn07XG5iYXNlJDEuTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTsgfTtcbmJhc2UkMS5CcmVha1N0YXRlbWVudCA9IGJhc2UkMS5Db250aW51ZVN0YXRlbWVudCA9IGlnbm9yZTtcbmJhc2UkMS5XaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5vYmplY3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG59O1xuYmFzZSQxLlN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUuZGlzY3JpbWluYW50LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBub2RlLmNhc2VzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgIHZhciBjcyA9IGxpc3QkMVtpJDFdO1xuXG4gICAgaWYgKGNzLnRlc3QpIHsgYyhjcy50ZXN0LCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBjcy5jb25zZXF1ZW50OyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBjb25zID0gbGlzdFtpXTtcblxuICAgICAgYyhjb25zLCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gICAgfVxuICB9XG59O1xuYmFzZSQxLlN3aXRjaENhc2UgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgaWYgKG5vZGUudGVzdCkgeyBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuY29uc2VxdWVudDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBjb25zID0gbGlzdFtpXTtcblxuICAgIGMoY29ucywgc3QsIFwiU3RhdGVtZW50XCIpO1xuICB9XG59O1xuYmFzZSQxLlJldHVyblN0YXRlbWVudCA9IGJhc2UkMS5ZaWVsZEV4cHJlc3Npb24gPSBiYXNlJDEuQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmFyZ3VtZW50KSB7IGMobm9kZS5hcmd1bWVudCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxufTtcbmJhc2UkMS5UaHJvd1N0YXRlbWVudCA9IGJhc2UkMS5TcHJlYWRFbGVtZW50ID1cbiAgZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUuYXJndW1lbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7IH07XG5iYXNlJDEuVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5ibG9jaywgc3QsIFwiU3RhdGVtZW50XCIpO1xuICBpZiAobm9kZS5oYW5kbGVyKSB7IGMobm9kZS5oYW5kbGVyLCBzdCk7IH1cbiAgaWYgKG5vZGUuZmluYWxpemVyKSB7IGMobm9kZS5maW5hbGl6ZXIsIHN0LCBcIlN0YXRlbWVudFwiKTsgfVxufTtcbmJhc2UkMS5DYXRjaENsYXVzZSA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5wYXJhbSkgeyBjKG5vZGUucGFyYW0sIHN0LCBcIlBhdHRlcm5cIik7IH1cbiAgYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTtcbn07XG5iYXNlJDEuV2hpbGVTdGF0ZW1lbnQgPSBiYXNlJDEuRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTtcbn07XG5iYXNlJDEuRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmluaXQpIHsgYyhub2RlLmluaXQsIHN0LCBcIkZvckluaXRcIik7IH1cbiAgaWYgKG5vZGUudGVzdCkgeyBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICBpZiAobm9kZS51cGRhdGUpIHsgYyhub2RlLnVwZGF0ZSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpO1xufTtcbmJhc2UkMS5Gb3JJblN0YXRlbWVudCA9IGJhc2UkMS5Gb3JPZlN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUubGVmdCwgc3QsIFwiRm9ySW5pdFwiKTtcbiAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpO1xufTtcbmJhc2UkMS5Gb3JJbml0ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7IGMobm9kZSwgc3QpOyB9XG4gIGVsc2UgeyBjKG5vZGUsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbn07XG5iYXNlJDEuRGVidWdnZXJTdGF0ZW1lbnQgPSBpZ25vcmU7XG5cbmJhc2UkMS5GdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUsIHN0LCBcIkZ1bmN0aW9uXCIpOyB9O1xuYmFzZSQxLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmRlY2xhcmF0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgIGMoZGVjbCwgc3QpO1xuICB9XG59O1xuYmFzZSQxLlZhcmlhYmxlRGVjbGFyYXRvciA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUuaWQsIHN0LCBcIlBhdHRlcm5cIik7XG4gIGlmIChub2RlLmluaXQpIHsgYyhub2RlLmluaXQsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbn07XG5cbmJhc2UkMS5GdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5pZCkgeyBjKG5vZGUuaWQsIHN0LCBcIlBhdHRlcm5cIik7IH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBjKHBhcmFtLCBzdCwgXCJQYXR0ZXJuXCIpO1xuICB9XG4gIGMobm9kZS5ib2R5LCBzdCwgbm9kZS5leHByZXNzaW9uID8gXCJFeHByZXNzaW9uXCIgOiBcIlN0YXRlbWVudFwiKTtcbn07XG5cbmJhc2UkMS5QYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgIHsgYyhub2RlLCBzdCwgXCJWYXJpYWJsZVBhdHRlcm5cIik7IH1cbiAgZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB7IGMobm9kZSwgc3QsIFwiTWVtYmVyUGF0dGVyblwiKTsgfVxuICBlbHNlXG4gICAgeyBjKG5vZGUsIHN0KTsgfVxufTtcbmJhc2UkMS5WYXJpYWJsZVBhdHRlcm4gPSBpZ25vcmU7XG5iYXNlJDEuTWVtYmVyUGF0dGVybiA9IHNraXBUaHJvdWdoO1xuYmFzZSQxLlJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUuYXJndW1lbnQsIHN0LCBcIlBhdHRlcm5cIik7IH07XG5iYXNlJDEuQXJyYXlQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5lbGVtZW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgZWx0ID0gbGlzdFtpXTtcblxuICAgIGlmIChlbHQpIHsgYyhlbHQsIHN0LCBcIlBhdHRlcm5cIik7IH1cbiAgfVxufTtcbmJhc2UkMS5PYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIGlmIChwcm9wLnR5cGUgPT09IFwiUHJvcGVydHlcIikge1xuICAgICAgaWYgKHByb3AuY29tcHV0ZWQpIHsgYyhwcm9wLmtleSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgICAgYyhwcm9wLnZhbHVlLCBzdCwgXCJQYXR0ZXJuXCIpO1xuICAgIH0gZWxzZSBpZiAocHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIGMocHJvcC5hcmd1bWVudCwgc3QsIFwiUGF0dGVyblwiKTtcbiAgICB9XG4gIH1cbn07XG5cbmJhc2UkMS5FeHByZXNzaW9uID0gc2tpcFRocm91Z2g7XG5iYXNlJDEuVGhpc0V4cHJlc3Npb24gPSBiYXNlJDEuU3VwZXIgPSBiYXNlJDEuTWV0YVByb3BlcnR5ID0gaWdub3JlO1xuYmFzZSQxLkFycmF5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuZWxlbWVudHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGVsdCA9IGxpc3RbaV07XG5cbiAgICBpZiAoZWx0KSB7IGMoZWx0LCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gIH1cbn07XG5iYXNlJDEuT2JqZWN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIGMocHJvcCwgc3QpO1xuICB9XG59O1xuYmFzZSQxLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IGJhc2UkMS5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGJhc2UkMS5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuYmFzZSQxLlNlcXVlbmNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuZXhwcmVzc2lvbnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZXhwciA9IGxpc3RbaV07XG5cbiAgICBjKGV4cHIsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH1cbn07XG5iYXNlJDEuVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5xdWFzaXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcXVhc2kgPSBsaXN0W2ldO1xuXG4gICAgYyhxdWFzaSwgc3QpO1xuICB9XG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gbm9kZS5leHByZXNzaW9uczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpXG4gICAge1xuICAgIHZhciBleHByID0gbGlzdCQxW2kkMV07XG5cbiAgICBjKGV4cHIsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH1cbn07XG5iYXNlJDEuVGVtcGxhdGVFbGVtZW50ID0gaWdub3JlO1xuYmFzZSQxLlVuYXJ5RXhwcmVzc2lvbiA9IGJhc2UkMS5VcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5hcmd1bWVudCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbn07XG5iYXNlJDEuQmluYXJ5RXhwcmVzc2lvbiA9IGJhc2UkMS5Mb2dpY2FsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUubGVmdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UkMS5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IGJhc2UkMS5Bc3NpZ25tZW50UGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUubGVmdCwgc3QsIFwiUGF0dGVyblwiKTtcbiAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UkMS5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGMobm9kZS5jb25zZXF1ZW50LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUuYWx0ZXJuYXRlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UkMS5OZXdFeHByZXNzaW9uID0gYmFzZSQxLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5jYWxsZWUsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGlmIChub2RlLmFyZ3VtZW50cylcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5hcmd1bWVudHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcblxuICAgICAgICBjKGFyZywgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gfVxufTtcbmJhc2UkMS5NZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5vYmplY3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7IGMobm9kZS5wcm9wZXJ0eSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxufTtcbmJhc2UkMS5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gYmFzZSQxLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5kZWNsYXJhdGlvbilcbiAgICB7IGMobm9kZS5kZWNsYXJhdGlvbiwgc3QsIG5vZGUudHlwZSA9PT0gXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgfHwgbm9kZS5kZWNsYXJhdGlvbi5pZCA/IFwiU3RhdGVtZW50XCIgOiBcIkV4cHJlc3Npb25cIik7IH1cbiAgaWYgKG5vZGUuc291cmNlKSB7IGMobm9kZS5zb3VyY2UsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbn07XG5iYXNlJDEuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgaWYgKG5vZGUuZXhwb3J0ZWQpXG4gICAgeyBjKG5vZGUuZXhwb3J0ZWQsIHN0KTsgfVxuICBjKG5vZGUuc291cmNlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UkMS5JbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgIGMoc3BlYywgc3QpO1xuICB9XG4gIGMobm9kZS5zb3VyY2UsIHN0LCBcIkV4cHJlc3Npb25cIik7XG59O1xuYmFzZSQxLkltcG9ydEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLnNvdXJjZSwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbn07XG5iYXNlJDEuSW1wb3J0U3BlY2lmaWVyID0gYmFzZSQxLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBiYXNlJDEuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYmFzZSQxLklkZW50aWZpZXIgPSBiYXNlJDEuUHJpdmF0ZUlkZW50aWZpZXIgPSBiYXNlJDEuTGl0ZXJhbCA9IGlnbm9yZTtcblxuYmFzZSQxLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUudGFnLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUucXVhc2ksIHN0LCBcIkV4cHJlc3Npb25cIik7XG59O1xuYmFzZSQxLkNsYXNzRGVjbGFyYXRpb24gPSBiYXNlJDEuQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUsIHN0LCBcIkNsYXNzXCIpOyB9O1xuYmFzZSQxLkNsYXNzID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmlkKSB7IGMobm9kZS5pZCwgc3QsIFwiUGF0dGVyblwiKTsgfVxuICBpZiAobm9kZS5zdXBlckNsYXNzKSB7IGMobm9kZS5zdXBlckNsYXNzLCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gIGMobm9kZS5ib2R5LCBzdCk7XG59O1xuYmFzZSQxLkNsYXNzQm9keSA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuYm9keTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBlbHQgPSBsaXN0W2ldO1xuXG4gICAgYyhlbHQsIHN0KTtcbiAgfVxufTtcbmJhc2UkMS5NZXRob2REZWZpbml0aW9uID0gYmFzZSQxLlByb3BlcnR5RGVmaW5pdGlvbiA9IGJhc2UkMS5Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5jb21wdXRlZCkgeyBjKG5vZGUua2V5LCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gIGlmIChub2RlLnZhbHVlKSB7IGMobm9kZS52YWx1ZSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxufTtcblxuY29uc3QgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24kMSA9ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbic7XG5jb25zdCBCaW5hcnlFeHByZXNzaW9uJDEgPSAnQmluYXJ5RXhwcmVzc2lvbic7XG5jb25zdCBCbG9ja1N0YXRlbWVudCQxID0gJ0Jsb2NrU3RhdGVtZW50JztcbmNvbnN0IENhbGxFeHByZXNzaW9uJDEgPSAnQ2FsbEV4cHJlc3Npb24nO1xuY29uc3QgQ2hhaW5FeHByZXNzaW9uJDEgPSAnQ2hhaW5FeHByZXNzaW9uJztcbmNvbnN0IENvbmRpdGlvbmFsRXhwcmVzc2lvbiQxID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic7XG5jb25zdCBFeHByZXNzaW9uU3RhdGVtZW50JDEgPSAnRXhwcmVzc2lvblN0YXRlbWVudCc7XG5jb25zdCBJZGVudGlmaWVyJDEgPSAnSWRlbnRpZmllcic7XG5jb25zdCBJbXBvcnREZWZhdWx0U3BlY2lmaWVyJDEgPSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcic7XG5jb25zdCBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIkMSA9ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInO1xuY29uc3QgTG9naWNhbEV4cHJlc3Npb24kMSA9ICdMb2dpY2FsRXhwcmVzc2lvbic7XG5jb25zdCBOZXdFeHByZXNzaW9uJDEgPSAnTmV3RXhwcmVzc2lvbic7XG5jb25zdCBQcm9ncmFtJDEgPSAnUHJvZ3JhbSc7XG5jb25zdCBQcm9wZXJ0eSQxID0gJ1Byb3BlcnR5JztcbmNvbnN0IFJldHVyblN0YXRlbWVudCQxID0gJ1JldHVyblN0YXRlbWVudCc7XG5jb25zdCBTZXF1ZW5jZUV4cHJlc3Npb24kMSA9ICdTZXF1ZW5jZUV4cHJlc3Npb24nO1xuXG4vLyB0aGlzIGxvb2tzIHJpZGljdWxvdXMsIGJ1dCBpdCBwcmV2ZW50cyBzb3VyY2VtYXAgdG9vbGluZyBmcm9tIG1pc3Rha2luZ1xuLy8gdGhpcyBmb3IgYW4gYWN0dWFsIHNvdXJjZU1hcHBpbmdVUkxcbmxldCBTT1VSQ0VNQVBQSU5HX1VSTCA9ICdzb3VyY2VNYSc7XG5TT1VSQ0VNQVBQSU5HX1VSTCArPSAncHBpbmdVUkwnO1xuY29uc3Qgd2hpdGVTcGFjZU5vTmV3bGluZSA9ICdbIFxcXFxmXFxcXHJcXFxcdFxcXFx2XFxcXHUwMGEwXFxcXHUxNjgwXFxcXHUyMDAwLVxcXFx1MjAwYVxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFxcXFx1ZmVmZl0nO1xuY29uc3QgU09VUkNFTUFQUElOR19VUkxfUkUgPSBuZXcgUmVnRXhwKGBeIyR7d2hpdGVTcGFjZU5vTmV3bGluZX0rJHtTT1VSQ0VNQVBQSU5HX1VSTH09LitgKTtcblxuY29uc3QgQU5OT1RBVElPTl9LRVkgPSAnX3JvbGx1cEFubm90YXRpb25zJztcbmNvbnN0IElOVkFMSURfQ09NTUVOVF9LRVkgPSAnX3JvbGx1cFJlbW92ZWQnO1xuZnVuY3Rpb24gaGFuZGxlUHVyZUFubm90YXRpb25zT2ZOb2RlKG5vZGUsIHN0YXRlLCB0eXBlID0gbm9kZS50eXBlKSB7XG4gICAgY29uc3QgeyBhbm5vdGF0aW9ucyB9ID0gc3RhdGU7XG4gICAgbGV0IGNvbW1lbnQgPSBhbm5vdGF0aW9uc1tzdGF0ZS5hbm5vdGF0aW9uSW5kZXhdO1xuICAgIHdoaWxlIChjb21tZW50ICYmIG5vZGUuc3RhcnQgPj0gY29tbWVudC5lbmQpIHtcbiAgICAgICAgbWFya1B1cmVOb2RlKG5vZGUsIGNvbW1lbnQsIHN0YXRlLmNvZGUpO1xuICAgICAgICBjb21tZW50ID0gYW5ub3RhdGlvbnNbKytzdGF0ZS5hbm5vdGF0aW9uSW5kZXhdO1xuICAgIH1cbiAgICBpZiAoY29tbWVudCAmJiBjb21tZW50LmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgICBiYXNlJDFbdHlwZV0obm9kZSwgc3RhdGUsIGhhbmRsZVB1cmVBbm5vdGF0aW9uc09mTm9kZSk7XG4gICAgICAgIHdoaWxlICgoY29tbWVudCA9IGFubm90YXRpb25zW3N0YXRlLmFubm90YXRpb25JbmRleF0pICYmIGNvbW1lbnQuZW5kIDw9IG5vZGUuZW5kKSB7XG4gICAgICAgICAgICArK3N0YXRlLmFubm90YXRpb25JbmRleDtcbiAgICAgICAgICAgIGFubm90YXRlTm9kZShub2RlLCBjb21tZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBuZWl0aGVyV2l0aGVzcGFjZU5vckJyYWNrZXRzID0gL1teXFxzKF0vZztcbmNvbnN0IG5vV2hpdGVzcGFjZSA9IC9cXFMvZztcbmZ1bmN0aW9uIG1hcmtQdXJlTm9kZShub2RlLCBjb21tZW50LCBjb2RlKSB7XG4gICAgY29uc3QgYW5ub3RhdGVkTm9kZXMgPSBbXTtcbiAgICBsZXQgaW52YWxpZEFubm90YXRpb247XG4gICAgY29uc3QgY29kZUluQmV0d2VlbiA9IGNvZGUuc2xpY2UoY29tbWVudC5lbmQsIG5vZGUuc3RhcnQpO1xuICAgIGlmIChkb2VzTm90TWF0Y2hPdXRzaWRlQ29tbWVudChjb2RlSW5CZXR3ZWVuLCBuZWl0aGVyV2l0aGVzcGFjZU5vckJyYWNrZXRzKSkge1xuICAgICAgICBjb25zdCBwYXJlbnRTdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBhbm5vdGF0ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEV4cHJlc3Npb25TdGF0ZW1lbnQkMTpcbiAgICAgICAgICAgICAgICBjYXNlIENoYWluRXhwcmVzc2lvbiQxOlxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIFNlcXVlbmNlRXhwcmVzc2lvbiQxOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgcGFyZW50aGVzZXMsIHRoZSBhbm5vdGF0aW9uIHdvdWxkIGFwcGx5IHRvIHRoZSBlbnRpcmUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9lc05vdE1hdGNoT3V0c2lkZUNvbW1lbnQoY29kZS5zbGljZShwYXJlbnRTdGFydCwgbm9kZS5zdGFydCksIG5vV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEFubm90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbmRpdGlvbmFsRXhwcmVzc2lvbiQxOlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgcGFyZW50aGVzZXMsIHRoZSBhbm5vdGF0aW9uIHdvdWxkIGFwcGx5IHRvIHRoZSBlbnRpcmUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9lc05vdE1hdGNoT3V0c2lkZUNvbW1lbnQoY29kZS5zbGljZShwYXJlbnRTdGFydCwgbm9kZS5zdGFydCksIG5vV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnRlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQW5ub3RhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9naWNhbEV4cHJlc3Npb24kMTpcbiAgICAgICAgICAgICAgICBjYXNlIEJpbmFyeUV4cHJlc3Npb24kMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHBhcmVudGhlc2VzLCB0aGUgYW5ub3RhdGlvbiB3b3VsZCBhcHBseSB0byB0aGUgZW50aXJlIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvZXNOb3RNYXRjaE91dHNpZGVDb21tZW50KGNvZGUuc2xpY2UocGFyZW50U3RhcnQsIG5vZGUuc3RhcnQpLCBub1doaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEFubm90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENhbGxFeHByZXNzaW9uJDE6XG4gICAgICAgICAgICAgICAgY2FzZSBOZXdFeHByZXNzaW9uJDE6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRBbm5vdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnZhbGlkQW5ub3RhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbnZhbGlkQW5ub3RhdGlvbikge1xuICAgICAgICBhbm5vdGF0ZU5vZGUobm9kZSwgY29tbWVudCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFubm90YXRlZE5vZGVzKSB7XG4gICAgICAgICAgICBhbm5vdGF0ZU5vZGUobm9kZSwgY29tbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkb2VzTm90TWF0Y2hPdXRzaWRlQ29tbWVudChjb2RlLCBmb3JiaWRkZW5DaGFycykge1xuICAgIGxldCBuZXh0TWF0Y2g7XG4gICAgd2hpbGUgKChuZXh0TWF0Y2ggPSBmb3JiaWRkZW5DaGFycy5leGVjKGNvZGUpKSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dE1hdGNoWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQWZ0ZXJTbGFzaCA9IGNvZGUuY2hhckNvZGVBdChmb3JiaWRkZW5DaGFycy5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoYXJDb2RlQWZ0ZXJTbGFzaCA9PT0gNDIgLypcIipcIiovKSB7XG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuQ2hhcnMubGFzdEluZGV4ID0gY29kZS5pbmRleE9mKCcqLycsIGZvcmJpZGRlbkNoYXJzLmxhc3RJbmRleCArIDEpICsgMjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlQWZ0ZXJTbGFzaCA9PT0gNDcgLypcIi9cIiovKSB7XG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuQ2hhcnMubGFzdEluZGV4ID0gY29kZS5pbmRleE9mKCdcXG4nLCBmb3JiaWRkZW5DaGFycy5sYXN0SW5kZXggKyAxKSArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yYmlkZGVuQ2hhcnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHB1cmVDb21tZW50UmVnZXggPSAvW0AjXV9fUFVSRV9fLztcbmZ1bmN0aW9uIGFkZEFubm90YXRpb25zKGNvbW1lbnRzLCBlc1RyZWVBc3QsIGNvZGUpIHtcbiAgICBjb25zdCBhbm5vdGF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU1hcHBpbmdDb21tZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBjb21tZW50cykge1xuICAgICAgICBpZiAocHVyZUNvbW1lbnRSZWdleC50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFNPVVJDRU1BUFBJTkdfVVJMX1JFLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBzb3VyY2VNYXBwaW5nQ29tbWVudHMpIHtcbiAgICAgICAgYW5ub3RhdGVOb2RlKGVzVHJlZUFzdCwgY29tbWVudCwgZmFsc2UpO1xuICAgIH1cbiAgICBoYW5kbGVQdXJlQW5ub3RhdGlvbnNPZk5vZGUoZXNUcmVlQXN0LCB7XG4gICAgICAgIGFubm90YXRpb25JbmRleDogMCxcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIGNvZGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFubm90YXRlTm9kZShub2RlLCBjb21tZW50LCB2YWxpZCkge1xuICAgIGNvbnN0IGtleSA9IHZhbGlkID8gQU5OT1RBVElPTl9LRVkgOiBJTlZBTElEX0NPTU1FTlRfS0VZO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gbm9kZVtrZXldO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICBwcm9wZXJ0eS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZVtrZXldID0gW2NvbW1lbnRdO1xuICAgIH1cbn1cblxuY29uc3Qga2V5cyA9IHtcbiAgICBMaXRlcmFsOiBbXSxcbiAgICBQcm9ncmFtOiBbJ2JvZHknXVxufTtcbmZ1bmN0aW9uIGdldEFuZENyZWF0ZUtleXMoZXNUcmVlTm9kZSkge1xuICAgIGtleXNbZXNUcmVlTm9kZS50eXBlXSA9IE9iamVjdC5rZXlzKGVzVHJlZU5vZGUpLmZpbHRlcihrZXkgPT4gdHlwZW9mIGVzVHJlZU5vZGVba2V5XSA9PT0gJ29iamVjdCcgJiYga2V5LmNoYXJDb2RlQXQoMCkgIT09IDk1IC8qIF8gKi8pO1xuICAgIHJldHVybiBrZXlzW2VzVHJlZU5vZGUudHlwZV07XG59XG5cbmNvbnN0IElOQ0xVREVfUEFSQU1FVEVSUyA9ICd2YXJpYWJsZXMnO1xuY2xhc3MgTm9kZUJhc2UgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3Rvcihlc1RyZWVOb2RlLCBwYXJlbnQsIHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXNUcmVlTm9kZSA9IGVzVHJlZU5vZGU7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXNbZXNUcmVlTm9kZS50eXBlXSB8fCBnZXRBbmRDcmVhdGVLZXlzKGVzVHJlZU5vZGUpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gcGFyZW50LmNvbnRleHQ7XG4gICAgICAgIHRoaXMuY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpO1xuICAgICAgICB0aGlzLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5tYWdpY1N0cmluZy5hZGRTb3VyY2VtYXBMb2NhdGlvbih0aGlzLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5jb250ZXh0Lm1hZ2ljU3RyaW5nLmFkZFNvdXJjZW1hcExvY2F0aW9uKHRoaXMuZW5kKTtcbiAgICB9XG4gICAgYWRkRXhwb3J0ZWRWYXJpYWJsZXMoX3ZhcmlhYmxlcywgX2V4cG9ydE5hbWVzQnlWYXJpYWJsZSkgeyB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyB0byBiaW5kIGFzc2lnbm1lbnRzIHRvIHZhcmlhYmxlcyBhbmQgZG8gYW55IGluaXRpYWxpc2F0aW9ucyB0aGF0XG4gICAgICogcmVxdWlyZSB0aGUgc2NvcGVzIHRvIGJlIHBvcHVsYXRlZCB3aXRoIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBiaW5kKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmluZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGlmIHRoaXMgbm9kZSBzaG91bGQgcmVjZWl2ZSBhIGRpZmZlcmVudCBzY29wZSB0aGFuIHRoZSBwYXJlbnQgc2NvcGUuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHBhcmVudFNjb3BlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVvcHRpbWl6ZWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgY2hpbGQuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICh0aGlzLmRlb3B0aW1pemVkID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVBc1NpbmdsZVN0YXRlbWVudChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byBwZXJmb3JtIHNwZWNpYWwgaW5pdGlhbGlzYXRpb24gc3RlcHMgYWZ0ZXIgdGhlIHNjb3BlIGlzIGluaXRpYWxpc2VkXG4gICAgICovXG4gICAgaW5pdGlhbGlzZSgpIHsgfVxuICAgIGluc2VydFNlbWljb2xvbihjb2RlKSB7XG4gICAgICAgIGlmIChjb2RlLm9yaWdpbmFsW3RoaXMuZW5kIC0gMV0gIT09ICc7Jykge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGVzVHJlZU5vZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGF0IHdheSwgd2UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gYWRkIGN1c3RvbSBpbml0aWFsaXNhdGlvbiBhbmQgdGhlbiBjYWxsIHN1cGVyLnBhcnNlTm9kZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChrZXkuY2hhckNvZGVBdCgwKSA9PT0gOTUgLyogXyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IEFOTk9UQVRJT05fS0VZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBJTlZBTElEX0NPTU1FTlRfS0VZKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBzdGFydCwgZW5kIH0gb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubWFnaWNTdHJpbmcucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0ucHVzaChjaGlsZCA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyAodGhpcy5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3RvcihjaGlsZC50eXBlKSkoY2hpbGQsIHRoaXMsIHRoaXMuc2NvcGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBuZXcgKHRoaXMuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IodmFsdWUudHlwZSkpKHZhbHVlLCB0aGlzLCB0aGlzLnNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmNsdWRlZCB8fCAoIWNvbnRleHQuYnJva2VuRmxvdyAmJiB0aGlzLmhhc0VmZmVjdHMoY3JlYXRlSGFzRWZmZWN0c0NvbnRleHQoKSkpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuXG5jbGFzcyBTcHJlYWRFbGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgW1Vua25vd25LZXksIC4uLnBhdGhdLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBjb25zdCB7IHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9uc1xuICAgICAgICAgICAgLnRyZWVzaGFrZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKFVOS05PV05fUEFUSCwgY29udGV4dCkpKSk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgLy8gT25seSBwcm9wZXJ0aWVzIG9mIHByb3BlcnRpZXMgb2YgdGhlIGFyZ3VtZW50IGNvdWxkIGJlY29tZSBzdWJqZWN0IHRvIHJlYXNzaWdubWVudFxuICAgICAgICAvLyBUaGlzIHdpbGwgYWxzbyByZWFzc2lnbiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBpdGVyYXRvcnNcbiAgICAgICAgdGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChbVW5rbm93bktleSwgVW5rbm93bktleV0pO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY29uc3QgRVZFTlRfQUNDRVNTRUQgPSAwO1xuY29uc3QgRVZFTlRfQVNTSUdORUQgPSAxO1xuY29uc3QgRVZFTlRfQ0FMTEVEID0gMjtcblxuY2xhc3MgTWV0aG9kIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBFVkVOVF9DQUxMRUQgJiYgcGF0aC5sZW5ndGggPT09IDAgJiYgdGhpcy5kZXNjcmlwdGlvbi5tdXRhdGVzU2VsZkFzQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXNQYXJhbWV0ZXIuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9JTlRFR0VSX1BBVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmRlc2NyaXB0aW9uLnJldHVybnNQcmltaXRpdmUgfHxcbiAgICAgICAgICAgICh0aGlzLmRlc2NyaXB0aW9uLnJldHVybnMgPT09ICdzZWxmJ1xuICAgICAgICAgICAgICAgID8gY2FsbE9wdGlvbnMudGhpc1BhcmFtIHx8IFVOS05PV05fRVhQUkVTU0lPTlxuICAgICAgICAgICAgICAgIDogdGhpcy5kZXNjcmlwdGlvbi5yZXR1cm5zKCkpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwIHx8XG4gICAgICAgICAgICAodGhpcy5kZXNjcmlwdGlvbi5tdXRhdGVzU2VsZkFzQXJyYXkgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gY2FsbE9wdGlvbnMudGhpc1BhcmFtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChVTktOT1dOX0lOVEVHRVJfUEFUSCwgY29udGV4dCkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRlc2NyaXB0aW9uLmNhbGxzQXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYXJnSW5kZXggb2YgdGhpcy5kZXNjcmlwdGlvbi5jYWxsc0FyZ3MpIHtcbiAgICAgICAgICAgIGlmICgoX2IgPSBjYWxsT3B0aW9ucy5hcmdzW2FyZ0luZGV4XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKEVNUFRZX1BBVEgsIHtcbiAgICAgICAgICAgICAgICBhcmdzOiBOT19BUkdTLFxuICAgICAgICAgICAgICAgIHRoaXNQYXJhbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3aXRoTmV3OiBmYWxzZVxuICAgICAgICAgICAgfSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgYXJnLmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgTUVUSE9EX1JFVFVSTlNfQk9PTEVBTiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IGZhbHNlLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0xJVEVSQUxfQk9PTEVBTlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX1JFVFVSTlNfU1RSSU5HID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogZmFsc2UsXG4gICAgICAgIHJldHVybnM6IG51bGwsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IFVOS05PV05fTElURVJBTF9TVFJJTkdcbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9SRVRVUk5TX05VTUJFUiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IGZhbHNlLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0xJVEVSQUxfTlVNQkVSXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfUkVUVVJOU19VTktOT1dOID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogZmFsc2UsXG4gICAgICAgIHJldHVybnM6IG51bGwsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IFVOS05PV05fRVhQUkVTU0lPTlxuICAgIH0pXG5dO1xuXG5jb25zdCBJTlRFR0VSX1JFR19FWFAgPSAvXlxcZCskLztcbmNsYXNzIE9iamVjdEVudGl0eSBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIC8vIElmIGEgUHJvcGVydHlNYXAgaXMgdXNlZCwgdGhpcyB3aWxsIGJlIHRha2VuIGFzIHByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlcbiAgICAvLyBhbmQgd2UgYXNzdW1lIHRoZXJlIGFyZSBubyBzZXR0ZXJzIG9yIGdldHRlcnNcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzLCBwcm90b3R5cGVFeHByZXNzaW9uLCBpbW11dGFibGUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24gPSBwcm90b3R5cGVFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLmltbXV0YWJsZSA9IGltbXV0YWJsZTtcbiAgICAgICAgdGhpcy5hbGxQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRQYXRocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWRCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZ2V0dGVyc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oYXNVbmtub3duRGVvcHRpbWl6ZWRJbnRlZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5zZXR0ZXJzQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRoaXNQYXJhbWV0ZXJzVG9CZURlb3B0aW1pemVkID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnVua25vd25JbnRlZ2VyUHJvcHMgPSBbXTtcbiAgICAgICAgdGhpcy51bm1hdGNoYWJsZUdldHRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMudW5tYXRjaGFibGVTZXR0ZXJzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUHJvcGVydHlNYXBzKHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5ID0gdGhpcy5wcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5ID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydGllc0ZvcktleSBvZiBPYmplY3QudmFsdWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxQcm9wZXJ0aWVzLnB1c2goLi4ucHJvcGVydGllc0ZvcktleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFsbFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0aWVzIG9mIE9iamVjdC52YWx1ZXModGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5KS5jb25jYXQoT2JqZWN0LnZhbHVlcyh0aGlzLnNldHRlcnNCeUtleSkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoaWxlIHRoZSBwcm90b3R5cGUgaXRzZWxmIGNhbm5vdCBiZSBtdXRhdGVkLCBlYWNoIHByb3BlcnR5IGNhblxuICAgICAgICAoX2EgPSB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZW9wdGltaXplUGF0aChbVW5rbm93bktleSwgVW5rbm93bktleV0pO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVDYWNoZWRFbnRpdGllcygpO1xuICAgIH1cbiAgICBkZW9wdGltaXplSW50ZWdlclByb3BlcnRpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5IHx8IHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkSW50ZWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkSW50ZWdlciA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcGVydGllc0FuZEdldHRlcnNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSkpIHtcbiAgICAgICAgICAgIGlmIChJTlRFR0VSX1JFR19FWFAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzQW5kR2V0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlb3B0aW1pemVDYWNoZWRJbnRlZ2VyRW50aXRpZXMoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5IHx8IHRoaXMuaW1tdXRhYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzBdO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFVua25vd25JbnRlZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlb3B0aW1pemVJbnRlZ2VyUHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZW9wdGltaXplQWxsUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkUGF0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRQYXRoc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IGRlb3B0aW1pemVDYWNoZSBleGFjdCBtYXRjaGVzIGFzIGluIGFsbCBvdGhlciBjYXNlcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmV0dXJuIGEgbGl0ZXJhbCB2YWx1ZSBvciByZXR1cm4gZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJQYXRoID0gcGF0aC5sZW5ndGggPT09IDEgPyBVTktOT1dOX1BBVEggOiBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/ICh0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlba2V5XSB8fCB0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnMpLmNvbmNhdCh0aGlzLnNldHRlcnNCeUtleVtrZXldIHx8IHRoaXMudW5tYXRjaGFibGVTZXR0ZXJzKVxuICAgICAgICAgICAgOiB0aGlzLmFsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVQYXRoKHN1YlBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlb3B0aW1pemVQYXRoKHBhdGgubGVuZ3RoID09PSAxID8gW1Vua25vd25LZXksIFVua25vd25LZXldIDogcGF0aCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnN1YlBhdGhdID0gcGF0aDtcbiAgICAgICAgaWYgKHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgfHxcbiAgICAgICAgICAgIC8vIHNpbmdsZSBwYXRocyB0aGF0IGFyZSBkZW9wdGltaXplZCB3aWxsIG5vdCBiZWNvbWUgZ2V0dGVycyBvciBzZXR0ZXJzXG4gICAgICAgICAgICAoKGV2ZW50ID09PSBFVkVOVF9DQUxMRUQgfHwgcGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplZFBhdGhzW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzUGFyYW1ldGVyLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Byb3BlcnRpZXNGb3JFeGFjdE1hdGNoQnlLZXksIHJlbGV2YW50UHJvcGVydGllc0J5S2V5LCByZWxldmFudFVubWF0Y2hhYmxlUHJvcGVydGllc10gPSBldmVudCA9PT0gRVZFTlRfQ0FMTEVEIHx8IHBhdGgubGVuZ3RoID4gMVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSxcbiAgICAgICAgICAgICAgICB0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnNcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogZXZlbnQgPT09IEVWRU5UX0FDQ0VTU0VEXG4gICAgICAgICAgICAgICAgPyBbdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LCB0aGlzLmdldHRlcnNCeUtleSwgdGhpcy51bm1hdGNoYWJsZUdldHRlcnNdXG4gICAgICAgICAgICAgICAgOiBbdGhpcy5wcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5LCB0aGlzLnNldHRlcnNCeUtleSwgdGhpcy51bm1hdGNoYWJsZVNldHRlcnNdO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzRm9yRXhhY3RNYXRjaEJ5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gcmVsZXZhbnRQcm9wZXJ0aWVzQnlLZXlba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgc3ViUGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRoaXNQYXJhbWV0ZXJzVG9CZURlb3B0aW1pemVkLmFkZCh0aGlzUGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiByZWxldmFudFVubWF0Y2hhYmxlUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgc3ViUGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSU5URUdFUl9SRUdfRVhQLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy51bmtub3duSW50ZWdlclByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgc3ViUGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0aWVzIG9mIE9iamVjdC52YWx1ZXMocmVsZXZhbnRQcm9wZXJ0aWVzQnlLZXkpLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgcmVsZXZhbnRVbm1hdGNoYWJsZVByb3BlcnRpZXNcbiAgICAgICAgICAgIF0pKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgc3ViUGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnVua25vd25JbnRlZ2VyUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHN1YlBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudGhpc1BhcmFtZXRlcnNUb0JlRGVvcHRpbWl6ZWQuYWRkKHRoaXNQYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25BdFBhdGggPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25BbmRUcmFja0Rlb3B0KGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25BdFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXRQYXRoLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLnNsaWNlKDEpLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25BdFBhdGggPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25BbmRUcmFja0Rlb3B0KGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25BdFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXRQYXRoLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGguc2xpY2UoMSksIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnN1YlBhdGhdID0gcGF0aDtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uQXRQYXRoID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uKGtleSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbkF0UGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXRQYXRoLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoc3ViUGF0aCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm90b3R5cGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbi5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXJzID0gdGhpcy5nZXR0ZXJzQnlLZXlba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdldHRlciBvZiBnZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoc3ViUGF0aCwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBnZXR0ZXIgb2YgdGhpcy51bm1hdGNoYWJsZUdldHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoc3ViUGF0aCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZXR0ZXJzIG9mIE9iamVjdC52YWx1ZXModGhpcy5nZXR0ZXJzQnlLZXkpLmNvbmNhdChbdGhpcy51bm1hdGNoYWJsZUdldHRlcnNdKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZ2V0dGVyIG9mIGdldHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldHRlci5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHN1YlBhdGgsIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5zdWJQYXRoXSA9IHBhdGg7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkF0UGF0aCA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbihrZXkpO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25BdFBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbkF0UGF0aC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHN1YlBhdGgsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIHRlc3QgZm9yIHVua25vd24gcHJvcGVydGllcyBhcyBpbiB0aGF0IGNhc2UsIGhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5IGlzIHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0ZXJzID0gdGhpcy5zZXR0ZXJzQnlLZXlba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNldHRlciBvZiBzZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGVyLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgoc3ViUGF0aCwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnVubWF0Y2hhYmxlU2V0dGVycykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHN1YlBhdGgsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm90b3R5cGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGVFeHByZXNzaW9uLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBleHByZXNzaW9uQXRQYXRoID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uKGtleSk7XG4gICAgICAgIGlmIChleHByZXNzaW9uQXRQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbkF0UGF0aC5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLnNsaWNlKDEpLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbi5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJ1aWxkUHJvcGVydHlNYXBzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgeyBhbGxQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LCBwcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5LCBzZXR0ZXJzQnlLZXksIGdldHRlcnNCeUtleSwgdW5rbm93bkludGVnZXJQcm9wcywgdW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kR2V0dGVycywgdW5tYXRjaGFibGVHZXR0ZXJzLCB1bm1hdGNoYWJsZVNldHRlcnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHVubWF0Y2hhYmxlUHJvcGVydGllc0FuZFNldHRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCBraW5kLCBwcm9wZXJ0eSB9ID0gcHJvcGVydGllc1tpbmRleF07XG4gICAgICAgICAgICBhbGxQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gVW5rbm93bkludGVnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93bkludGVnZXJQcm9wcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSAnc2V0JylcbiAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGFibGVTZXR0ZXJzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSAnZ2V0JylcbiAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGFibGVHZXR0ZXJzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnZ2V0JylcbiAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kU2V0dGVycy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ3NldCcpXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXlba2V5XSA9IFtwcm9wZXJ0eSwgLi4udW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kU2V0dGVyc107XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJzQnlLZXlba2V5XSA9IFtwcm9wZXJ0eSwgLi4udW5tYXRjaGFibGVTZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSAnZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZEdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZUdldHRlcnNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZFNldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRTZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZEdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGVkRW50aXRpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVDYWNoZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLnRoaXNQYXJhbWV0ZXJzVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlZEludGVnZXJFbnRpdGllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5KSkge1xuICAgICAgICAgICAgaWYgKElOVEVHRVJfUkVHX0VYUC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMudGhpc1BhcmFtZXRlcnNUb0JlRGVvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9JTlRFR0VSX1BBVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1lbWJlckV4cHJlc3Npb24oa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5IHx8XG4gICAgICAgICAgICB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkSW50ZWdlciAmJiBJTlRFR0VSX1JFR19FWFAudGVzdChrZXkpKSB8fFxuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplZFBhdGhzW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleVtrZXldO1xuICAgICAgICBpZiAoKHByb3BlcnRpZXMgPT09IG51bGwgfHwgcHJvcGVydGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcGVydGllcy5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydGllc1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydGllcyB8fFxuICAgICAgICAgICAgdGhpcy51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgICh0aGlzLnVua25vd25JbnRlZ2VyUHJvcHMubGVuZ3RoICYmIElOVEVHRVJfUkVHX0VYUC50ZXN0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRNZW1iZXJFeHByZXNzaW9uQW5kVHJhY2tEZW9wdChrZXksIG9yaWdpbikge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbihrZXkpO1xuICAgICAgICBpZiAoIShleHByZXNzaW9uID09PSBVTktOT1dOX0VYUFJFU1NJT04gfHwgdGhpcy5pbW11dGFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9ICh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXlba2V5XSA9XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5W2tleV0gfHwgW10pO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbn1cblxuY29uc3QgaXNJbnRlZ2VyID0gKHByb3ApID0+IHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiAvXlxcZCskLy50ZXN0KHByb3ApO1xuLy8gVGhpcyBtYWtlcyBzdXJlIHVua25vd24gcHJvcGVydGllcyBhcmUgbm90IGhhbmRsZWQgYXMgXCJ1bmRlZmluZWRcIiBidXQgYXNcbi8vIFwidW5rbm93blwiIGJ1dCB3aXRob3V0IGFjY2VzcyBzaWRlIGVmZmVjdHMuIEFuIGV4Y2VwdGlvbiBpcyBkb25lIGZvciBudW1lcmljXG4vLyBwcm9wZXJ0aWVzIGFzIHdlIGRvIG5vdCBleHBlY3QgbmV3IGJ1aWx0aW4gcHJvcGVydGllcyB0byBiZSBudW1iZXJzLCB0aGlzXG4vLyB3aWxsIGltcHJvdmUgdHJlZS1zaGFraW5nIGZvciBvdXQtb2YtYm91bmRzIGFycmF5IHByb3BlcnRpZXNcbmNvbnN0IE9CSkVDVF9QUk9UT1RZUEVfRkFMTEJBQ0sgPSBuZXcgKGNsYXNzIE9iamVjdFByb3RvdHlwZUZhbGxiYWNrRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlcikge1xuICAgICAgICBpZiAoZXZlbnQgPT09IEVWRU5UX0NBTExFRCAmJiBwYXRoLmxlbmd0aCA9PT0gMSAmJiAhaXNJbnRlZ2VyKHBhdGhbMF0pKSB7XG4gICAgICAgICAgICB0aGlzUGFyYW1ldGVyLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gV2UgaWdub3JlIG51bWJlciBwcm9wZXJ0aWVzIGFzIHdlIGRvIG5vdCBleHBlY3QgbmV3IHByb3BlcnRpZXMgdG8gYmVcbiAgICAgICAgLy8gbnVtYmVycyBhbmQgYWxzbyB3YW50IHRvIGtlZXAgaGFuZGxpbmcgb3V0LW9mLWJvdW5kIGFycmF5IGVsZW1lbnRzIGFzXG4gICAgICAgIC8vIFwidW5kZWZpbmVkXCJcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSAxICYmIGlzSW50ZWdlcihwYXRoWzBdKSA/IHVuZGVmaW5lZCA6IFVua25vd25WYWx1ZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxO1xuICAgIH1cbn0pKCk7XG5jb25zdCBPQkpFQ1RfUFJPVE9UWVBFID0gbmV3IE9iamVjdEVudGl0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGhhc093blByb3BlcnR5OiBNRVRIT0RfUkVUVVJOU19CT09MRUFOLFxuICAgIGlzUHJvdG90eXBlT2Y6IE1FVEhPRF9SRVRVUk5TX0JPT0xFQU4sXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGU6IE1FVEhPRF9SRVRVUk5TX0JPT0xFQU4sXG4gICAgdG9Mb2NhbGVTdHJpbmc6IE1FVEhPRF9SRVRVUk5TX1NUUklORyxcbiAgICB0b1N0cmluZzogTUVUSE9EX1JFVFVSTlNfU1RSSU5HLFxuICAgIHZhbHVlT2Y6IE1FVEhPRF9SRVRVUk5TX1VOS05PV05cbn0sIE9CSkVDVF9QUk9UT1RZUEVfRkFMTEJBQ0ssIHRydWUpO1xuXG5jb25zdCBORVdfQVJSQVlfUFJPUEVSVElFUyA9IFtcbiAgICB7IGtleTogVW5rbm93bkludGVnZXIsIGtpbmQ6ICdpbml0JywgcHJvcGVydHk6IFVOS05PV05fRVhQUkVTU0lPTiB9LFxuICAgIHsga2V5OiAnbGVuZ3RoJywga2luZDogJ2luaXQnLCBwcm9wZXJ0eTogVU5LTk9XTl9MSVRFUkFMX05VTUJFUiB9XG5dO1xuY29uc3QgTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX0JPT0xFQU4gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogWzBdLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX0JPT0xFQU5cbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19OVU1CRVIgPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogWzBdLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX05VTUJFUlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IHRydWUsXG4gICAgICAgIHJldHVybnM6ICgpID0+IG5ldyBPYmplY3RFbnRpdHkoTkVXX0FSUkFZX1BST1BFUlRJRVMsIEFSUkFZX1BST1RPVFlQRSksXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IG51bGxcbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogKCkgPT4gbmV3IE9iamVjdEVudGl0eShORVdfQVJSQVlfUFJPUEVSVElFUywgQVJSQVlfUFJPVE9UWVBFKSxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogbnVsbFxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBbMF0sXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogJ2Rlb3B0LW9ubHknLFxuICAgICAgICByZXR1cm5zOiAoKSA9PiBuZXcgT2JqZWN0RW50aXR5KE5FV19BUlJBWV9QUk9QRVJUSUVTLCBBUlJBWV9QUk9UT1RZUEUpLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBudWxsXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfTlVNQkVSID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogdHJ1ZSxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX05VTUJFUlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1VOS05PV04gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiB0cnVlLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0VYUFJFU1NJT05cbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV04gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiAnZGVvcHQtb25seScsXG4gICAgICAgIHJldHVybnM6IG51bGwsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IFVOS05PV05fRVhQUkVTU0lPTlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV04gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogWzBdLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9FWFBSRVNTSU9OXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfU0VMRiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IHRydWUsXG4gICAgICAgIHJldHVybnM6ICdzZWxmJyxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogbnVsbFxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX0NBTExTX0FSR19NVVRBVEVTX1NFTEZfUkVUVVJOU19TRUxGID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IFswXSxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiB0cnVlLFxuICAgICAgICByZXR1cm5zOiAnc2VsZicsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IG51bGxcbiAgICB9KVxuXTtcbmNvbnN0IEFSUkFZX1BST1RPVFlQRSA9IG5ldyBPYmplY3RFbnRpdHkoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCBhY2Nlc3NvcnMgaGF2ZSBlZmZlY3RzIGFzIHdlIGRvIG5vdCB0cmFjayB0aGUgYWNjZXNzZWQgdmFsdWUgYWZ0ZXJ3YXJkc1xuICAgIGF0OiBNRVRIT0RfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIGNvbmNhdDogTUVUSE9EX0RFT1BUU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZLFxuICAgIGNvcHlXaXRoaW46IE1FVEhPRF9NVVRBVEVTX1NFTEZfUkVUVVJOU19TRUxGLFxuICAgIGVudHJpZXM6IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBldmVyeTogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX0JPT0xFQU4sXG4gICAgZmlsbDogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1NFTEYsXG4gICAgZmlsdGVyOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZLFxuICAgIGZpbmQ6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIGZpbmRJbmRleDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05VTUJFUixcbiAgICBmaW5kTGFzdDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV04sXG4gICAgZmluZExhc3RJbmRleDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05VTUJFUixcbiAgICBmbGF0OiBNRVRIT0RfREVPUFRTX1NFTEZfUkVUVVJOU19ORVdfQVJSQVksXG4gICAgZmxhdE1hcDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBmb3JFYWNoOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICBncm91cEJ5OiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICBncm91cEJ5VG9NYXA6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIGluY2x1ZGVzOiBNRVRIT0RfUkVUVVJOU19CT09MRUFOLFxuICAgIGluZGV4T2Y6IE1FVEhPRF9SRVRVUk5TX05VTUJFUixcbiAgICBqb2luOiBNRVRIT0RfUkVUVVJOU19TVFJJTkcsXG4gICAga2V5czogTUVUSE9EX1JFVFVSTlNfVU5LTk9XTixcbiAgICBsYXN0SW5kZXhPZjogTUVUSE9EX1JFVFVSTlNfTlVNQkVSLFxuICAgIG1hcDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBwb3A6IE1FVEhPRF9NVVRBVEVTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIHB1c2g6IE1FVEhPRF9NVVRBVEVTX1NFTEZfUkVUVVJOU19OVU1CRVIsXG4gICAgcmVkdWNlOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICByZWR1Y2VSaWdodDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV04sXG4gICAgcmV2ZXJzZTogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1NFTEYsXG4gICAgc2hpZnQ6IE1FVEhPRF9NVVRBVEVTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIHNsaWNlOiBNRVRIT0RfREVPUFRTX1NFTEZfUkVUVVJOU19ORVdfQVJSQVksXG4gICAgc29tZTogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX0JPT0xFQU4sXG4gICAgc29ydDogTUVUSE9EX0NBTExTX0FSR19NVVRBVEVTX1NFTEZfUkVUVVJOU19TRUxGLFxuICAgIHNwbGljZTogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICB0b0xvY2FsZVN0cmluZzogTUVUSE9EX1JFVFVSTlNfU1RSSU5HLFxuICAgIHRvU3RyaW5nOiBNRVRIT0RfUkVUVVJOU19TVFJJTkcsXG4gICAgdW5zaGlmdDogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX05VTUJFUixcbiAgICB2YWx1ZXM6IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV05cbn0sIE9CSkVDVF9QUk9UT1RZUEUsIHRydWUpO1xuXG5jbGFzcyBBcnJheUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub2JqZWN0RW50aXR5ID0gbnVsbDtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZ2V0T2JqZWN0RW50aXR5KCkge1xuICAgICAgICBpZiAodGhpcy5vYmplY3RFbnRpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgeyBrZXk6ICdsZW5ndGgnLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBVTktOT1dOX0xJVEVSQUxfTlVNQkVSIH1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhhc1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU3ByZWFkRWxlbWVudCB8fCBoYXNTcHJlYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTcHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnVuc2hpZnQoeyBrZXk6IFVua25vd25JbnRlZ2VyLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHsga2V5OiBTdHJpbmcoaW5kZXgpLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBVTkRFRklORURfRVhQUkVTU0lPTiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh7IGtleTogU3RyaW5nKGluZGV4KSwga2luZDogJ2luaXQnLCBwcm9wZXJ0eTogZWxlbWVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMub2JqZWN0RW50aXR5ID0gbmV3IE9iamVjdEVudGl0eShwcm9wZXJ0aWVzLCBBUlJBWV9QUk9UT1RZUEUpKTtcbiAgICB9XG59XG5cbmNsYXNzIEFycmF5UGF0dGVybiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNsYXJlKGtpbmQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKC4uLmVsZW1lbnQuZGVjbGFyZShraW5kLCBVTktOT1dOX0VYUFJFU1NJT04pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVzO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKEVNUFRZX1BBVEgsIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIExvY2FsVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVjbGFyYXRvciwgaW5pdCwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5jYWxsZWRGcm9tVHJ5U3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdG9yID8gW2RlY2xhcmF0b3JdIDogW107XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6YXRpb25UcmFja2VyID0gY29udGV4dC5kZW9wdGltaXphdGlvblRyYWNrZXI7XG4gICAgICAgIHRoaXMubW9kdWxlID0gY29udGV4dC5tb2R1bGU7XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGluaXQpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMucHVzaChpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEluaXRpYWxpemVycyA9IHRoaXMubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCk7XG4gICAgICAgIGlmIChpbml0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSW5pdGlhbGl6ZXJzLnB1c2goaW5pdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29saWRhdGVJbml0aWFsaXplcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbGl6ZXIgb2YgdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXIuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQgfHxcbiAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6YXRpb25UcmFja2VyLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZWFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlYXNzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZDtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuaW5pdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmluaXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFzc2lnbmVkIHx8ICF0aGlzLmluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzUGFyYW1ldGVyLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdXJzaW9uVHJhY2tlci53aXRoVHJhY2tlZEVudGl0eUF0UGF0aChwYXRoLCB0aGlzLmluaXQsICgpID0+IHRoaXMuaW5pdC5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZCB8fCAhdGhpcy5pbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN1cnNpb25UcmFja2VyLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIHRoaXMuaW5pdCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9LCBVbmtub3duVmFsdWUpO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZCB8fCAhdGhpcy5pbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN1cnNpb25UcmFja2VyLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIHRoaXMuaW5pdCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9LCBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFzc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAodGhpcy5pbml0ICYmXG4gICAgICAgICAgICAhY29udGV4dC5hY2Nlc3NlZC50cmFja0VudGl0eUF0UGF0aEFuZEdldElmVHJhY2tlZChwYXRoLCB0aGlzKSAmJlxuICAgICAgICAgICAgdGhpcy5pbml0Lmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluaXQgJiZcbiAgICAgICAgICAgICFjb250ZXh0LmFjY2Vzc2VkLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIHRoaXMpICYmXG4gICAgICAgICAgICB0aGlzLmluaXQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5pdCAmJlxuICAgICAgICAgICAgIShjYWxsT3B0aW9ucy53aXRoTmV3ID8gY29udGV4dC5pbnN0YW50aWF0ZWQgOiBjb250ZXh0LmNhbGxlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgY2FsbE9wdGlvbnMsIHRoaXMpICYmXG4gICAgICAgICAgICB0aGlzLmluaXQuaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgdGhpcy5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub2RlIGlzIGEgZGVmYXVsdCBleHBvcnQsIGl0IGNhbiBzYXZlIGEgdHJlZS1zaGFraW5nIHJ1biB0byBpbmNsdWRlIHRoZSBmdWxsIGRlY2xhcmF0aW9uIG5vd1xuICAgICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24uaW5jbHVkZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLmluY2x1ZGUoY3JlYXRlSW5jbHVzaW9uQ29udGV4dCgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBkZWNsYXJhdGlvbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHByb3Blcmx5IGluY2x1ZGUgcGFyZW50cyBpbiBjYXNlIHRoZXkgYXJlIHBhcnQgb2YgYSBkZWFkIGJyYW5jaFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIC5pbmNsdWRlKCkgbWlnaHQgcHVsbCBpbiBtb3JlIGRlYWQgY29kZVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gUHJvZ3JhbSQxKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQgfHwgKHRoaXMuaW5pdCAmJiBjb250ZXh0LmluY2x1ZGVkQ2FsbEFyZ3VtZW50cy5oYXModGhpcy5pbml0KSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhcmcuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbml0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkQ2FsbEFyZ3VtZW50cy5hZGQodGhpcy5pbml0KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdC5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRDYWxsQXJndW1lbnRzLmRlbGV0ZSh0aGlzLmluaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcmtDYWxsZWRGcm9tVHJ5U3RhdGVtZW50KCkge1xuICAgICAgICB0aGlzLmNhbGxlZEZyb21UcnlTdGF0ZW1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBtYXJrSW5pdGlhbGl6ZXJzRm9yRGVvcHRpbWl6YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycyA9IHRoaXMuaW5pdCA9PT0gbnVsbCA/IFtdIDogW3RoaXMuaW5pdF07XG4gICAgICAgICAgICB0aGlzLmluaXQgPSBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgICAgICB0aGlzLmlzUmVhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycztcbiAgICB9XG59XG5cbmNvbnN0IGNoYXJzID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXyQnO1xuY29uc3QgYmFzZSA9IDY0O1xuZnVuY3Rpb24gdG9CYXNlNjQobnVtKSB7XG4gICAgbGV0IG91dFN0ciA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgY3VyRGlnaXQgPSBudW0gJSBiYXNlO1xuICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGJhc2UpO1xuICAgICAgICBvdXRTdHIgPSBjaGFyc1tjdXJEaWdpdF0gKyBvdXRTdHI7XG4gICAgfSB3aGlsZSAobnVtICE9PSAwKTtcbiAgICByZXR1cm4gb3V0U3RyO1xufVxuXG5mdW5jdGlvbiBnZXRTYWZlTmFtZShiYXNlTmFtZSwgdXNlZE5hbWVzKSB7XG4gICAgbGV0IHNhZmVOYW1lID0gYmFzZU5hbWU7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICB3aGlsZSAodXNlZE5hbWVzLmhhcyhzYWZlTmFtZSkgfHwgUkVTRVJWRURfTkFNRVMkMS5oYXMoc2FmZU5hbWUpKSB7XG4gICAgICAgIHNhZmVOYW1lID0gYCR7YmFzZU5hbWV9JCR7dG9CYXNlNjQoY291bnQrKyl9YDtcbiAgICB9XG4gICAgdXNlZE5hbWVzLmFkZChzYWZlTmFtZSk7XG4gICAgcmV0dXJuIHNhZmVOYW1lO1xufVxuXG5jbGFzcyBTY29wZSQxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgY29udGV4dCwgaW5pdCwgX2lzSG9pc3RlZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICBsZXQgdmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgdmFyaWFibGUuYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IG5ldyBMb2NhbFZhcmlhYmxlKGlkZW50aWZpZXIubmFtZSwgaWRlbnRpZmllciwgaW5pdCB8fCBVTkRFRklORURfRVhQUkVTU0lPTiwgY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQobmFtZSwgdmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG4gICAgY29udGFpbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZXMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICBmaW5kVmFyaWFibGUoX25hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFcnJvcjogZmluZFZhcmlhYmxlIG5lZWRzIHRvIGJlIGltcGxlbWVudGVkIGJ5IGEgc3ViY2xhc3MnKTtcbiAgICB9XG59XG5cbmNsYXNzIENoaWxkU2NvcGUgZXh0ZW5kcyBTY29wZSQxIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgYWRkQWNjZXNzZWREeW5hbWljSW1wb3J0KGltcG9ydEV4cHJlc3Npb24pIHtcbiAgICAgICAgKHRoaXMuYWNjZXNzZWREeW5hbWljSW1wb3J0cyB8fCAodGhpcy5hY2Nlc3NlZER5bmFtaWNJbXBvcnRzID0gbmV3IFNldCgpKSkuYWRkKGltcG9ydEV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRBY2Nlc3NlZER5bmFtaWNJbXBvcnQoaW1wb3J0RXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQWNjZXNzZWRHbG9iYWxzKGdsb2JhbHMsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzZWRHbG9iYWxzID0gYWNjZXNzZWRHbG9iYWxzQnlTY29wZS5nZXQodGhpcykgfHwgbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZ2xvYmFscykge1xuICAgICAgICAgICAgYWNjZXNzZWRHbG9iYWxzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLnNldCh0aGlzLCBhY2Nlc3NlZEdsb2JhbHMpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRBY2Nlc3NlZEdsb2JhbHMoZ2xvYmFscywgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTmFtZXNwYWNlTWVtYmVyQWNjZXNzKG5hbWUsIHZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIHRoaXMucGFyZW50LmFkZE5hbWVzcGFjZU1lbWJlckFjY2VzcyhuYW1lLCB2YXJpYWJsZSk7XG4gICAgfVxuICAgIGFkZFJldHVybkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnBhcmVudCBpbnN0YW5jZW9mIENoaWxkU2NvcGUgJiYgdGhpcy5wYXJlbnQuYWRkUmV0dXJuRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICB9XG4gICAgYWRkVXNlZE91dHNpZGVOYW1lcyh1c2VkTmFtZXMsIGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHVzZWROYW1lcy5hZGQodmFyaWFibGUuZ2V0QmFzZVZhcmlhYmxlTmFtZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnc3lzdGVtJyAmJiBleHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKCdleHBvcnRzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY2Vzc2VkR2xvYmFscyA9IGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoYWNjZXNzZWRHbG9iYWxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYWNjZXNzZWRHbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgdXNlZE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWlucyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSkgfHwgdGhpcy5wYXJlbnQuY29udGFpbnMobmFtZSk7XG4gICAgfVxuICAgIGRlY29uZmxpY3QoZm9ybWF0LCBleHBvcnROYW1lc0J5VmFyaWFibGUsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgY29uc3QgdXNlZE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFkZFVzZWRPdXRzaWRlTmFtZXModXNlZE5hbWVzLCBmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc2VkRHluYW1pY0ltcG9ydHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1wb3J0RXhwcmVzc2lvbiBvZiB0aGlzLmFjY2Vzc2VkRHluYW1pY0ltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0RXhwcmVzc2lvbi5pbmxpbmVOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZE5hbWVzLmFkZChpbXBvcnRFeHByZXNzaW9uLmlubGluZU5hbWVzcGFjZS5nZXRCYXNlVmFyaWFibGVOYW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YXJpYWJsZV0gb2YgdGhpcy52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5pbmNsdWRlZCB8fCB2YXJpYWJsZS5hbHdheXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGdldFNhZmVOYW1lKG5hbWUsIHVzZWROYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgc2NvcGUuZGVjb25mbGljdChmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZExleGljYWxCb3VuZGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmRMZXhpY2FsQm91bmRhcnkoKTtcbiAgICB9XG4gICAgZmluZFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga25vd25WYXJpYWJsZSA9IHRoaXMudmFyaWFibGVzLmdldChuYW1lKSB8fCB0aGlzLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChrbm93blZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4ga25vd25WYXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMucGFyZW50LmZpbmRWYXJpYWJsZShuYW1lKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH1cbn1cblxuY2xhc3MgUGFyYW1ldGVyU2NvcGUgZXh0ZW5kcyBDaGlsZFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFzUmVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhvaXN0ZWRCb2R5VmFyU2NvcGUgPSBuZXcgQ2hpbGRTY29wZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBhcmFtZXRlciB0byB0aGlzIHNjb3BlLiBQYXJhbWV0ZXJzIG11c3QgYmUgYWRkZWQgaW4gdGhlIGNvcnJlY3RcbiAgICAgKiBvcmRlciwgZS5nLiBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICovXG4gICAgYWRkUGFyYW1ldGVyRGVjbGFyYXRpb24oaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICBsZXQgdmFyaWFibGUgPSB0aGlzLmhvaXN0ZWRCb2R5VmFyU2NvcGUudmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5hZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhYmxlID0gbmV3IExvY2FsVmFyaWFibGUobmFtZSwgaWRlbnRpZmllciwgVU5LTk9XTl9FWFBSRVNTSU9OLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG4gICAgYWRkUGFyYW1ldGVyVmFyaWFibGVzKHBhcmFtZXRlcnMsIGhhc1Jlc3QpIHtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXJMaXN0IG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHBhcmFtZXRlckxpc3QpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIuYWx3YXlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzUmVzdCA9IGhhc1Jlc3Q7XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgbGV0IGNhbGxlZEZyb21UcnlTdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGFyZ0luY2x1ZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3RQYXJhbSA9IHRoaXMuaGFzUmVzdCAmJiB0aGlzLnBhcmFtZXRlcnNbdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrZWRBcmcgb2YgYXJncykge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRBcmcgaW5zdGFuY2VvZiBTcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgICAgICBhcmcuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gYXJncy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbVZhcnMgPSB0aGlzLnBhcmFtZXRlcnNbaW5kZXhdIHx8IHJlc3RQYXJhbTtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtVmFycykge1xuICAgICAgICAgICAgICAgIGNhbGxlZEZyb21UcnlTdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1WYXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZW1wdHkgZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgICBhcmdJbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHBhcmFtVmFycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnSW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmNhbGxlZEZyb21UcnlTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWRGcm9tVHJ5U3RhdGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJnSW5jbHVkZWQgJiYgYXJnLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBhcmdJbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnSW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBhcmcuaW5jbHVkZShjb250ZXh0LCBjYWxsZWRGcm9tVHJ5U3RhdGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUmV0dXJuVmFsdWVTY29wZSBleHRlbmRzIFBhcmFtZXRlclNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9ucyA9IFtdO1xuICAgIH1cbiAgICBhZGRSZXR1cm5FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5FeHByZXNzaW9uID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXR1cm5FeHByZXNzaW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVybkV4cHJlc3Npb247XG4gICAgfVxuICAgIHVwZGF0ZVJldHVybkV4cHJlc3Npb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHVybkV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9uID0gdGhpcy5yZXR1cm5FeHByZXNzaW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRXhwcmVzc2lvbiA9IFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLnJldHVybkV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmVlc2hha2VOb2RlKG5vZGUsIGNvZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb2RlLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICBpZiAobm9kZS5hbm5vdGF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2Ygbm9kZS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGFubm90YXRpb24uc3RhcnQsIGFubm90YXRpb24uZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUFubm90YXRpb25zKG5vZGUsIGNvZGUpIHtcbiAgICBpZiAoIW5vZGUuYW5ub3RhdGlvbnMgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gRXhwcmVzc2lvblN0YXRlbWVudCQxKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKG5vZGUuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIG5vZGUuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGFubm90YXRpb24uc3RhcnQsIGFubm90YXRpb24uZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTk9fU0VNSUNPTE9OID0geyBpc05vU3RhdGVtZW50OiB0cnVlIH07XG4vLyBUaGlzIGFzc3VtZXMgdGhlcmUgYXJlIG9ubHkgd2hpdGUtc3BhY2UgYW5kIGNvbW1lbnRzIGJldHdlZW4gc3RhcnQgYW5kIHRoZSBzdHJpbmcgd2UgYXJlIGxvb2tpbmcgZm9yXG5mdW5jdGlvbiBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgc2VhcmNoU3RyaW5nLCBzdGFydCA9IDApIHtcbiAgICBsZXQgc2VhcmNoUG9zLCBjaGFyQ29kZUFmdGVyU2xhc2g7XG4gICAgc2VhcmNoUG9zID0gY29kZS5pbmRleE9mKHNlYXJjaFN0cmluZywgc3RhcnQpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXJ0ID0gY29kZS5pbmRleE9mKCcvJywgc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xIHx8IHN0YXJ0ID49IHNlYXJjaFBvcylcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hQb3M7XG4gICAgICAgIGNoYXJDb2RlQWZ0ZXJTbGFzaCA9IGNvZGUuY2hhckNvZGVBdCgrK3N0YXJ0KTtcbiAgICAgICAgKytzdGFydDtcbiAgICAgICAgLy8gV2l0aCBvdXIgYXNzdW1wdGlvbiwgJy8nIGFsd2F5cyBzdGFydHMgYSBjb21tZW50LiBEZXRlcm1pbmUgY29tbWVudCB0eXBlOlxuICAgICAgICBzdGFydCA9XG4gICAgICAgICAgICBjaGFyQ29kZUFmdGVyU2xhc2ggPT09IDQ3IC8qXCIvXCIqL1xuICAgICAgICAgICAgICAgID8gY29kZS5pbmRleE9mKCdcXG4nLCBzdGFydCkgKyAxXG4gICAgICAgICAgICAgICAgOiBjb2RlLmluZGV4T2YoJyovJywgc3RhcnQpICsgMjtcbiAgICAgICAgaWYgKHN0YXJ0ID4gc2VhcmNoUG9zKSB7XG4gICAgICAgICAgICBzZWFyY2hQb3MgPSBjb2RlLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBOT05fV0hJVEVTUEFDRSA9IC9cXFMvZztcbmZ1bmN0aW9uIGZpbmROb25XaGl0ZVNwYWNlKGNvZGUsIGluZGV4KSB7XG4gICAgTk9OX1dISVRFU1BBQ0UubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgcmVzdWx0ID0gTk9OX1dISVRFU1BBQ0UuZXhlYyhjb2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LmluZGV4O1xufVxuLy8gVGhpcyBhc3N1bWVzIFwiY29kZVwiIG9ubHkgY29udGFpbnMgd2hpdGUtc3BhY2UgYW5kIGNvbW1lbnRzXG4vLyBSZXR1cm5zIHBvc2l0aW9uIG9mIGxpbmUtY29tbWVudCBpZiBhcHBsaWNhYmxlXG5mdW5jdGlvbiBmaW5kRmlyc3RMaW5lQnJlYWtPdXRzaWRlQ29tbWVudChjb2RlKSB7XG4gICAgbGV0IGxpbmVCcmVha1BvcywgY2hhckNvZGVBZnRlclNsYXNoLCBzdGFydCA9IDA7XG4gICAgbGluZUJyZWFrUG9zID0gY29kZS5pbmRleE9mKCdcXG4nLCBzdGFydCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhcnQgPSBjb2RlLmluZGV4T2YoJy8nLCBzdGFydCk7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEgfHwgc3RhcnQgPiBsaW5lQnJlYWtQb3MpXG4gICAgICAgICAgICByZXR1cm4gW2xpbmVCcmVha1BvcywgbGluZUJyZWFrUG9zICsgMV07XG4gICAgICAgIC8vIFdpdGggb3VyIGFzc3VtcHRpb24sICcvJyBhbHdheXMgc3RhcnRzIGEgY29tbWVudC4gRGV0ZXJtaW5lIGNvbW1lbnQgdHlwZTpcbiAgICAgICAgY2hhckNvZGVBZnRlclNsYXNoID0gY29kZS5jaGFyQ29kZUF0KHN0YXJ0ICsgMSk7XG4gICAgICAgIGlmIChjaGFyQ29kZUFmdGVyU2xhc2ggPT09IDQ3IC8qXCIvXCIqLylcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnQsIGxpbmVCcmVha1BvcyArIDFdO1xuICAgICAgICBzdGFydCA9IGNvZGUuaW5kZXhPZignKi8nLCBzdGFydCArIDMpICsgMjtcbiAgICAgICAgaWYgKHN0YXJ0ID4gbGluZUJyZWFrUG9zKSB7XG4gICAgICAgICAgICBsaW5lQnJlYWtQb3MgPSBjb2RlLmluZGV4T2YoJ1xcbicsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlclN0YXRlbWVudExpc3Qoc3RhdGVtZW50cywgY29kZSwgc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgIGxldCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVTdGFydCwgY3VycmVudE5vZGVOZWVkc0JvdW5kYXJpZXMsIG5leHROb2RlU3RhcnQ7XG4gICAgbGV0IG5leHROb2RlID0gc3RhdGVtZW50c1swXTtcbiAgICBsZXQgbmV4dE5vZGVOZWVkc0JvdW5kYXJpZXMgPSAhbmV4dE5vZGUuaW5jbHVkZWQgfHwgbmV4dE5vZGUubmVlZHNCb3VuZGFyaWVzO1xuICAgIGlmIChuZXh0Tm9kZU5lZWRzQm91bmRhcmllcykge1xuICAgICAgICBuZXh0Tm9kZVN0YXJ0ID1cbiAgICAgICAgICAgIHN0YXJ0ICsgZmluZEZpcnN0TGluZUJyZWFrT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZShzdGFydCwgbmV4dE5vZGUuc3RhcnQpKVsxXTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDw9IHN0YXRlbWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IG5leHROb2RlO1xuICAgICAgICBjdXJyZW50Tm9kZVN0YXJ0ID0gbmV4dE5vZGVTdGFydDtcbiAgICAgICAgY3VycmVudE5vZGVOZWVkc0JvdW5kYXJpZXMgPSBuZXh0Tm9kZU5lZWRzQm91bmRhcmllcztcbiAgICAgICAgbmV4dE5vZGUgPSBzdGF0ZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIG5leHROb2RlTmVlZHNCb3VuZGFyaWVzID1cbiAgICAgICAgICAgIG5leHROb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFuZXh0Tm9kZS5pbmNsdWRlZCB8fCBuZXh0Tm9kZS5uZWVkc0JvdW5kYXJpZXM7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZU5lZWRzQm91bmRhcmllcyB8fCBuZXh0Tm9kZU5lZWRzQm91bmRhcmllcykge1xuICAgICAgICAgICAgbmV4dE5vZGVTdGFydCA9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuZW5kICtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0TGluZUJyZWFrT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZShjdXJyZW50Tm9kZS5lbmQsIG5leHROb2RlID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXh0Tm9kZS5zdGFydCkpWzFdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGVOZWVkc0JvdW5kYXJpZXNcbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50Tm9kZS5yZW5kZXIoY29kZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuZXh0Tm9kZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGN1cnJlbnROb2RlU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50Tm9kZS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlc2hha2VOb2RlKGN1cnJlbnROb2RlLCBjb2RlLCBjdXJyZW50Tm9kZVN0YXJ0LCBuZXh0Tm9kZVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IHBhcnQgb2YgdGhlIGZpcnN0IG5vZGVcbmZ1bmN0aW9uIGdldENvbW1hU2VwYXJhdGVkTm9kZXNXaXRoQm91bmRhcmllcyhub2RlcywgY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHNwbGl0VXBOb2RlcyA9IFtdO1xuICAgIGxldCBub2RlLCBuZXh0Tm9kZSwgbmV4dE5vZGVTdGFydCwgY29udGVudEVuZCwgY2hhcjtcbiAgICBsZXQgc2VwYXJhdG9yID0gc3RhcnQgLSAxO1xuICAgIGZvciAobGV0IG5leHRJbmRleCA9IDA7IG5leHRJbmRleCA8IG5vZGVzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICAgICAgbmV4dE5vZGUgPSBub2Rlc1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPVxuICAgICAgICAgICAgICAgIG5vZGUuZW5kICtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uobm9kZS5lbmQsIG5leHROb2RlLnN0YXJ0KSwgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Tm9kZVN0YXJ0ID0gY29udGVudEVuZCA9XG4gICAgICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgIGZpbmRGaXJzdExpbmVCcmVha091dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uoc2VwYXJhdG9yICsgMSwgbmV4dE5vZGUuc3RhcnQpKVsxXTtcbiAgICAgICAgd2hpbGUgKCgoY2hhciA9IGNvZGUub3JpZ2luYWwuY2hhckNvZGVBdChuZXh0Tm9kZVN0YXJ0KSksXG4gICAgICAgICAgICBjaGFyID09PSAzMiAvKlwiIFwiKi8gfHwgY2hhciA9PT0gOSAvKlwiXFx0XCIqLyB8fCBjaGFyID09PSAxMCAvKlwiXFxuXCIqLyB8fCBjaGFyID09PSAxMykgLypcIlxcclwiKi8pXG4gICAgICAgICAgICBuZXh0Tm9kZVN0YXJ0Kys7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwbGl0VXBOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50RW5kLFxuICAgICAgICAgICAgICAgIGVuZDogbmV4dE5vZGVTdGFydCxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgICAgICBzdGFydCA9IG5leHROb2RlU3RhcnQ7XG4gICAgfVxuICAgIHNwbGl0VXBOb2Rlcy5wdXNoKHtcbiAgICAgICAgY29udGVudEVuZDogZW5kLFxuICAgICAgICBlbmQsXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIHNlcGFyYXRvcjogbnVsbCxcbiAgICAgICAgc3RhcnRcbiAgICB9KTtcbiAgICByZXR1cm4gc3BsaXRVcE5vZGVzO1xufVxuLy8gVGhpcyBhc3N1bWVzIHRoZXJlIGFyZSBvbmx5IHdoaXRlLXNwYWNlIGFuZCBjb21tZW50cyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcbmZ1bmN0aW9uIHJlbW92ZUxpbmVCcmVha3MoY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IFtyZW1vdmVTdGFydCwgcmVtb3ZlRW5kXSA9IGZpbmRGaXJzdExpbmVCcmVha091dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICBpZiAocmVtb3ZlU3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb2RlLnJlbW92ZShzdGFydCArIHJlbW92ZVN0YXJ0LCAoc3RhcnQgKz0gcmVtb3ZlRW5kKSk7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9ja1Njb3BlIGV4dGVuZHMgQ2hpbGRTY29wZSB7XG4gICAgYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgY29udGV4dCwgaW5pdCwgaXNIb2lzdGVkKSB7XG4gICAgICAgIGlmIChpc0hvaXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5wYXJlbnQuYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgY29udGV4dCwgaW5pdCwgaXNIb2lzdGVkKTtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSB0byBtYWtlIHN1cmUgdGhlIGluaXQgaXMgZGVvcHRpbWl6ZWQgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBjYWxsIGRlb3B0aW1pemVQYXRoIGhlcmUuXG4gICAgICAgICAgICB2YXJpYWJsZS5tYXJrSW5pdGlhbGl6ZXJzRm9yRGVvcHRpbWl6YXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5hZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEV4cHJlc3Npb25TdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZSAhPT0gJ3VzZSBzdHJpY3QnICYmXG4gICAgICAgICAgICB0aGlzLnBhcmVudC50eXBlID09PSBQcm9ncmFtJDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC53YXJuKFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2UgZWl0aGVyIHdheSAoZGVsZXRpbmcgb3Igbm90KSBjYW4gbGVhZCB0byBlcnJvcnMuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29kZTogJ01PRFVMRV9MRVZFTF9ESVJFQ1RJVkUnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNb2R1bGUgbGV2ZWwgZGlyZWN0aXZlcyBjYXVzZSBlcnJvcnMgd2hlbiBidW5kbGVkLCAnJHt0aGlzLmRpcmVjdGl2ZX0nIHdhcyBpZ25vcmVkLmBcbiAgICAgICAgICAgIH0sIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZWQpXG4gICAgICAgICAgICB0aGlzLmluc2VydFNlbWljb2xvbihjb2RlKTtcbiAgICB9XG4gICAgc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZSAmJiB0aGlzLmRpcmVjdGl2ZSAhPT0gJ3VzZSBzdHJpY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnR5cGUgIT09IFByb2dyYW0kMTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCk7XG4gICAgfVxufVxuXG5jbGFzcyBCbG9ja1N0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kaXJlY3RseUluY2x1ZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZEltcGxpY2l0UmV0dXJuRXhwcmVzc2lvblRvU2NvcGUoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTdGF0ZW1lbnQgPSB0aGlzLmJvZHlbdGhpcy5ib2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWxhc3RTdGF0ZW1lbnQgfHwgbGFzdFN0YXRlbWVudC50eXBlICE9PSBSZXR1cm5TdGF0ZW1lbnQkMSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZS5hZGRSZXR1cm5FeHByZXNzaW9uKFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHRoaXMucGFyZW50LnByZXZlbnRDaGlsZEJsb2NrU2NvcGVcbiAgICAgICAgICAgID8gcGFyZW50U2NvcGVcbiAgICAgICAgICAgIDogbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVvcHRpbWl6ZUJvZHkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuYnJva2VuRmxvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghKHRoaXMuZGVvcHRpbWl6ZUJvZHkgJiYgdGhpcy5kaXJlY3RseUluY2x1ZGVkKSkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGx5SW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVvcHRpbWl6ZUJvZHkpXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCBub2RlLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RCb2R5U3RhdGVtZW50ID0gdGhpcy5ib2R5WzBdO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVCb2R5ID1cbiAgICAgICAgICAgIGZpcnN0Qm9keVN0YXRlbWVudCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBmaXJzdEJvZHlTdGF0ZW1lbnQuZGlyZWN0aXZlID09PSAndXNlIGFzbSc7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZW1lbnRMaXN0KHRoaXMuYm9keSwgY29kZSwgdGhpcy5zdGFydCArIDEsIHRoaXMuZW5kIC0gMSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vQHRzLWNoZWNrXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJ2VzdHJlZScpLk5vZGV9IE5vZGUgKi9cbi8qKiBAdHlwZWRlZiB7Tm9kZSB8IHtcbiAqICAgdHlwZTogJ1Byb3BlcnR5RGVmaW5pdGlvbic7XG4gKiAgIGNvbXB1dGVkOiBib29sZWFuO1xuICogICB2YWx1ZTogTm9kZVxuICogfX0gTm9kZVdpdGhQcm9wZXJ0eURlZmluaXRpb24gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtOb2RlV2l0aFByb3BlcnR5RGVmaW5pdGlvbn0gbm9kZVxuICogQHBhcmFtIHtOb2RlV2l0aFByb3BlcnR5RGVmaW5pdGlvbn0gcGFyZW50XG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzX3JlZmVyZW5jZSAobm9kZSwgcGFyZW50KSB7XG5cdGlmIChub2RlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuXHRcdHJldHVybiAhbm9kZS5jb21wdXRlZCAmJiBpc19yZWZlcmVuY2Uobm9kZS5vYmplY3QsIG5vZGUpO1xuXHR9XG5cblx0aWYgKG5vZGUudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0aWYgKCFwYXJlbnQpIHJldHVybiB0cnVlO1xuXG5cdFx0c3dpdGNoIChwYXJlbnQudHlwZSkge1xuXHRcdFx0Ly8gZGlzcmVnYXJkIGBiYXJgIGluIGBmb28uYmFyYFxuXHRcdFx0Y2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50Lm9iamVjdDtcblxuXHRcdFx0Ly8gZGlzcmVnYXJkIHRoZSBgZm9vYCBpbiBgY2xhc3Mge2Zvbygpe319YCBidXQga2VlcCBpdCBpbiBgY2xhc3Mge1tmb29dKCl7fX1gXG5cdFx0XHRjYXNlICdNZXRob2REZWZpbml0aW9uJzogcmV0dXJuIHBhcmVudC5jb21wdXRlZDtcblxuXHRcdFx0Ly8gZGlzcmVnYXJkIHRoZSBgZm9vYCBpbiBgY2xhc3Mge2Zvbz1iYXJ9YCBidXQga2VlcCBpdCBpbiBgY2xhc3Mge1tmb29dPWJhcn1gIGFuZCBgY2xhc3Mge2Jhcj1mb299YFxuXHRcdFx0Y2FzZSAnUHJvcGVydHlEZWZpbml0aW9uJzogcmV0dXJuIHBhcmVudC5jb21wdXRlZCB8fCBub2RlID09PSBwYXJlbnQudmFsdWU7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCB0aGUgYGJhcmAgaW4gYHsgYmFyOiBmb28gfWAsIGJ1dCBrZWVwIGl0IGluIGB7IFtiYXJdOiBmb28gfWBcblx0XHRcdGNhc2UgJ1Byb3BlcnR5JzogcmV0dXJuIHBhcmVudC5jb21wdXRlZCB8fCBub2RlID09PSBwYXJlbnQudmFsdWU7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCB0aGUgYGJhcmAgaW4gYGV4cG9ydCB7IGZvbyBhcyBiYXIgfWAgb3Jcblx0XHRcdC8vIHRoZSBmb28gaW4gYGltcG9ydCB7IGZvbyBhcyBiYXIgfWBcblx0XHRcdGNhc2UgJ0V4cG9ydFNwZWNpZmllcic6XG5cdFx0XHRjYXNlICdJbXBvcnRTcGVjaWZpZXInOiByZXR1cm4gbm9kZSA9PT0gcGFyZW50LmxvY2FsO1xuXG5cdFx0XHQvLyBkaXNyZWdhcmQgdGhlIGBmb29gIGluIGBmb286IHdoaWxlICguLi4pIHsgLi4uIGJyZWFrIGZvbzsgLi4uIGNvbnRpbnVlIGZvbzt9YFxuXHRcdFx0Y2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG5cdFx0XHRjYXNlICdCcmVha1N0YXRlbWVudCc6XG5cdFx0XHRjYXNlICdDb250aW51ZVN0YXRlbWVudCc6IHJldHVybiBmYWxzZTtcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyogZXNsaW50IHNvcnQta2V5czogXCJvZmZcIiAqL1xuY29uc3QgVmFsdWVQcm9wZXJ0aWVzID0gU3ltYm9sKCdWYWx1ZSBQcm9wZXJ0aWVzJyk7XG5jb25zdCBQVVJFID0geyBwdXJlOiB0cnVlIH07XG5jb25zdCBJTVBVUkUgPSB7IHB1cmU6IGZhbHNlIH07XG4vLyBXZSB1c2Ugc2hvcnRlbmVkIHZhcmlhYmxlcyB0byByZWR1Y2UgZmlsZSBzaXplIGhlcmVcbi8qIE9CSkVDVCAqL1xuY29uc3QgTyA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgW1ZhbHVlUHJvcGVydGllc106IElNUFVSRVxufTtcbi8qIFBVUkUgRlVOQ1RJT04gKi9cbmNvbnN0IFBGID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRVxufTtcbi8qIENPTlNUUlVDVE9SICovXG5jb25zdCBDID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgIHByb3RvdHlwZTogT1xufTtcbi8qIFBVUkUgQ09OU1RSVUNUT1IgKi9cbmNvbnN0IFBDID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICBwcm90b3R5cGU6IE9cbn07XG5jb25zdCBBUlJBWV9UWVBFID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICBmcm9tOiBQRixcbiAgICBvZjogUEYsXG4gICAgcHJvdG90eXBlOiBPXG59O1xuY29uc3QgSU5UTF9NRU1CRVIgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBQVVJFLFxuICAgIHN1cHBvcnRlZExvY2FsZXNPZjogUENcbn07XG5jb25zdCBrbm93bkdsb2JhbHMgPSB7XG4gICAgLy8gUGxhY2Vob2xkZXJzIGZvciBnbG9iYWwgb2JqZWN0cyB0byBhdm9pZCBzaGFwZSBtdXRhdGlvbnNcbiAgICBnbG9iYWw6IE8sXG4gICAgZ2xvYmFsVGhpczogTyxcbiAgICBzZWxmOiBPLFxuICAgIHdpbmRvdzogTyxcbiAgICAvLyBDb21tb24gZ2xvYmFsc1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgIEFycmF5OiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IElNUFVSRSxcbiAgICAgICAgZnJvbTogTyxcbiAgICAgICAgaXNBcnJheTogUEYsXG4gICAgICAgIG9mOiBQRixcbiAgICAgICAgcHJvdG90eXBlOiBPXG4gICAgfSxcbiAgICBBcnJheUJ1ZmZlcjoge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBQVVJFLFxuICAgICAgICBpc1ZpZXc6IFBGLFxuICAgICAgICBwcm90b3R5cGU6IE9cbiAgICB9LFxuICAgIEF0b21pY3M6IE8sXG4gICAgQmlnSW50OiBDLFxuICAgIEJpZ0ludDY0QXJyYXk6IEMsXG4gICAgQmlnVWludDY0QXJyYXk6IEMsXG4gICAgQm9vbGVhbjogUEMsXG4gICAgY29uc3RydWN0b3I6IEMsXG4gICAgRGF0YVZpZXc6IFBDLFxuICAgIERhdGU6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICAgICAgbm93OiBQRixcbiAgICAgICAgcGFyc2U6IFBGLFxuICAgICAgICBwcm90b3R5cGU6IE8sXG4gICAgICAgIFVUQzogUEZcbiAgICB9LFxuICAgIGRlY29kZVVSSTogUEYsXG4gICAgZGVjb2RlVVJJQ29tcG9uZW50OiBQRixcbiAgICBlbmNvZGVVUkk6IFBGLFxuICAgIGVuY29kZVVSSUNvbXBvbmVudDogUEYsXG4gICAgRXJyb3I6IFBDLFxuICAgIGVzY2FwZTogUEYsXG4gICAgZXZhbDogTyxcbiAgICBFdmFsRXJyb3I6IFBDLFxuICAgIEZsb2F0MzJBcnJheTogQVJSQVlfVFlQRSxcbiAgICBGbG9hdDY0QXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgRnVuY3Rpb246IEMsXG4gICAgaGFzT3duUHJvcGVydHk6IE8sXG4gICAgSW5maW5pdHk6IE8sXG4gICAgSW50MTZBcnJheTogQVJSQVlfVFlQRSxcbiAgICBJbnQzMkFycmF5OiBBUlJBWV9UWVBFLFxuICAgIEludDhBcnJheTogQVJSQVlfVFlQRSxcbiAgICBpc0Zpbml0ZTogUEYsXG4gICAgaXNOYU46IFBGLFxuICAgIGlzUHJvdG90eXBlT2Y6IE8sXG4gICAgSlNPTjogTyxcbiAgICBNYXA6IFBDLFxuICAgIE1hdGg6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBhYnM6IFBGLFxuICAgICAgICBhY29zOiBQRixcbiAgICAgICAgYWNvc2g6IFBGLFxuICAgICAgICBhc2luOiBQRixcbiAgICAgICAgYXNpbmg6IFBGLFxuICAgICAgICBhdGFuOiBQRixcbiAgICAgICAgYXRhbjI6IFBGLFxuICAgICAgICBhdGFuaDogUEYsXG4gICAgICAgIGNicnQ6IFBGLFxuICAgICAgICBjZWlsOiBQRixcbiAgICAgICAgY2x6MzI6IFBGLFxuICAgICAgICBjb3M6IFBGLFxuICAgICAgICBjb3NoOiBQRixcbiAgICAgICAgZXhwOiBQRixcbiAgICAgICAgZXhwbTE6IFBGLFxuICAgICAgICBmbG9vcjogUEYsXG4gICAgICAgIGZyb3VuZDogUEYsXG4gICAgICAgIGh5cG90OiBQRixcbiAgICAgICAgaW11bDogUEYsXG4gICAgICAgIGxvZzogUEYsXG4gICAgICAgIGxvZzEwOiBQRixcbiAgICAgICAgbG9nMXA6IFBGLFxuICAgICAgICBsb2cyOiBQRixcbiAgICAgICAgbWF4OiBQRixcbiAgICAgICAgbWluOiBQRixcbiAgICAgICAgcG93OiBQRixcbiAgICAgICAgcmFuZG9tOiBQRixcbiAgICAgICAgcm91bmQ6IFBGLFxuICAgICAgICBzaWduOiBQRixcbiAgICAgICAgc2luOiBQRixcbiAgICAgICAgc2luaDogUEYsXG4gICAgICAgIHNxcnQ6IFBGLFxuICAgICAgICB0YW46IFBGLFxuICAgICAgICB0YW5oOiBQRixcbiAgICAgICAgdHJ1bmM6IFBGXG4gICAgfSxcbiAgICBOYU46IE8sXG4gICAgTnVtYmVyOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IFBVUkUsXG4gICAgICAgIGlzRmluaXRlOiBQRixcbiAgICAgICAgaXNJbnRlZ2VyOiBQRixcbiAgICAgICAgaXNOYU46IFBGLFxuICAgICAgICBpc1NhZmVJbnRlZ2VyOiBQRixcbiAgICAgICAgcGFyc2VGbG9hdDogUEYsXG4gICAgICAgIHBhcnNlSW50OiBQRixcbiAgICAgICAgcHJvdG90eXBlOiBPXG4gICAgfSxcbiAgICBPYmplY3Q6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICAgICAgY3JlYXRlOiBQRixcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBQRixcbiAgICAgICAgZ2V0T3duUHJvcGVydHlOYW1lczogUEYsXG4gICAgICAgIGdldE93blByb3BlcnR5U3ltYm9sczogUEYsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBQRixcbiAgICAgICAgaXM6IFBGLFxuICAgICAgICBpc0V4dGVuc2libGU6IFBGLFxuICAgICAgICBpc0Zyb3plbjogUEYsXG4gICAgICAgIGlzU2VhbGVkOiBQRixcbiAgICAgICAga2V5czogUEYsXG4gICAgICAgIGZyb21FbnRyaWVzOiBQRixcbiAgICAgICAgZW50cmllczogUEYsXG4gICAgICAgIHByb3RvdHlwZTogT1xuICAgIH0sXG4gICAgcGFyc2VGbG9hdDogUEYsXG4gICAgcGFyc2VJbnQ6IFBGLFxuICAgIFByb21pc2U6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBhbGw6IE8sXG4gICAgICAgIHByb3RvdHlwZTogTyxcbiAgICAgICAgcmFjZTogTyxcbiAgICAgICAgcmVqZWN0OiBPLFxuICAgICAgICByZXNvbHZlOiBPXG4gICAgfSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZTogTyxcbiAgICBQcm94eTogTyxcbiAgICBSYW5nZUVycm9yOiBQQyxcbiAgICBSZWZlcmVuY2VFcnJvcjogUEMsXG4gICAgUmVmbGVjdDogTyxcbiAgICBSZWdFeHA6IFBDLFxuICAgIFNldDogUEMsXG4gICAgU2hhcmVkQXJyYXlCdWZmZXI6IEMsXG4gICAgU3RyaW5nOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IFBVUkUsXG4gICAgICAgIGZyb21DaGFyQ29kZTogUEYsXG4gICAgICAgIGZyb21Db2RlUG9pbnQ6IFBGLFxuICAgICAgICBwcm90b3R5cGU6IE8sXG4gICAgICAgIHJhdzogUEZcbiAgICB9LFxuICAgIFN5bWJvbDoge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBQVVJFLFxuICAgICAgICBmb3I6IFBGLFxuICAgICAgICBrZXlGb3I6IFBGLFxuICAgICAgICBwcm90b3R5cGU6IE9cbiAgICB9LFxuICAgIFN5bnRheEVycm9yOiBQQyxcbiAgICB0b0xvY2FsZVN0cmluZzogTyxcbiAgICB0b1N0cmluZzogTyxcbiAgICBUeXBlRXJyb3I6IFBDLFxuICAgIFVpbnQxNkFycmF5OiBBUlJBWV9UWVBFLFxuICAgIFVpbnQzMkFycmF5OiBBUlJBWV9UWVBFLFxuICAgIFVpbnQ4QXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgVWludDhDbGFtcGVkQXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgLy8gVGVjaG5pY2FsbHksIHRoaXMgaXMgYSBnbG9iYWwsIGJ1dCBpdCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nXG4gICAgLy8gdW5kZWZpbmVkOiA/LFxuICAgIHVuZXNjYXBlOiBQRixcbiAgICBVUklFcnJvcjogUEMsXG4gICAgdmFsdWVPZjogTyxcbiAgICBXZWFrTWFwOiBQQyxcbiAgICBXZWFrU2V0OiBQQyxcbiAgICAvLyBBZGRpdGlvbmFsIGdsb2JhbHMgc2hhcmVkIGJ5IE5vZGUgYW5kIEJyb3dzZXIgdGhhdCBhcmUgbm90IHN0cmljdGx5IHBhcnQgb2YgdGhlIGxhbmd1YWdlXG4gICAgY2xlYXJJbnRlcnZhbDogQyxcbiAgICBjbGVhclRpbWVvdXQ6IEMsXG4gICAgY29uc29sZTogTyxcbiAgICBJbnRsOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IElNUFVSRSxcbiAgICAgICAgQ29sbGF0b3I6IElOVExfTUVNQkVSLFxuICAgICAgICBEYXRlVGltZUZvcm1hdDogSU5UTF9NRU1CRVIsXG4gICAgICAgIExpc3RGb3JtYXQ6IElOVExfTUVNQkVSLFxuICAgICAgICBOdW1iZXJGb3JtYXQ6IElOVExfTUVNQkVSLFxuICAgICAgICBQbHVyYWxSdWxlczogSU5UTF9NRU1CRVIsXG4gICAgICAgIFJlbGF0aXZlVGltZUZvcm1hdDogSU5UTF9NRU1CRVJcbiAgICB9LFxuICAgIHNldEludGVydmFsOiBDLFxuICAgIHNldFRpbWVvdXQ6IEMsXG4gICAgVGV4dERlY29kZXI6IEMsXG4gICAgVGV4dEVuY29kZXI6IEMsXG4gICAgVVJMOiBDLFxuICAgIFVSTFNlYXJjaFBhcmFtczogQyxcbiAgICAvLyBCcm93c2VyIHNwZWNpZmljIGdsb2JhbHNcbiAgICBBYm9ydENvbnRyb2xsZXI6IEMsXG4gICAgQWJvcnRTaWduYWw6IEMsXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogTyxcbiAgICBhbGVydDogTyxcbiAgICBBbmFseXNlck5vZGU6IEMsXG4gICAgQW5pbWF0aW9uOiBDLFxuICAgIEFuaW1hdGlvbkV2ZW50OiBDLFxuICAgIGFwcGxpY2F0aW9uQ2FjaGU6IE8sXG4gICAgQXBwbGljYXRpb25DYWNoZTogQyxcbiAgICBBcHBsaWNhdGlvbkNhY2hlRXJyb3JFdmVudDogQyxcbiAgICBhdG9iOiBPLFxuICAgIEF0dHI6IEMsXG4gICAgQXVkaW86IEMsXG4gICAgQXVkaW9CdWZmZXI6IEMsXG4gICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlOiBDLFxuICAgIEF1ZGlvQ29udGV4dDogQyxcbiAgICBBdWRpb0Rlc3RpbmF0aW9uTm9kZTogQyxcbiAgICBBdWRpb0xpc3RlbmVyOiBDLFxuICAgIEF1ZGlvTm9kZTogQyxcbiAgICBBdWRpb1BhcmFtOiBDLFxuICAgIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50OiBDLFxuICAgIEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZTogQyxcbiAgICBBdWRpb1dvcmtsZXROb2RlOiBDLFxuICAgIEJhclByb3A6IEMsXG4gICAgQmFzZUF1ZGlvQ29udGV4dDogQyxcbiAgICBCYXR0ZXJ5TWFuYWdlcjogQyxcbiAgICBCZWZvcmVVbmxvYWRFdmVudDogQyxcbiAgICBCaXF1YWRGaWx0ZXJOb2RlOiBDLFxuICAgIEJsb2I6IEMsXG4gICAgQmxvYkV2ZW50OiBDLFxuICAgIGJsdXI6IE8sXG4gICAgQnJvYWRjYXN0Q2hhbm5lbDogQyxcbiAgICBidG9hOiBPLFxuICAgIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k6IEMsXG4gICAgQ2FjaGU6IEMsXG4gICAgY2FjaGVzOiBPLFxuICAgIENhY2hlU3RvcmFnZTogQyxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogTyxcbiAgICBjYW5jZWxJZGxlQ2FsbGJhY2s6IE8sXG4gICAgQ2FudmFzQ2FwdHVyZU1lZGlhU3RyZWFtVHJhY2s6IEMsXG4gICAgQ2FudmFzR3JhZGllbnQ6IEMsXG4gICAgQ2FudmFzUGF0dGVybjogQyxcbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6IEMsXG4gICAgQ2hhbm5lbE1lcmdlck5vZGU6IEMsXG4gICAgQ2hhbm5lbFNwbGl0dGVyTm9kZTogQyxcbiAgICBDaGFyYWN0ZXJEYXRhOiBDLFxuICAgIGNsaWVudEluZm9ybWF0aW9uOiBPLFxuICAgIENsaXBib2FyZEV2ZW50OiBDLFxuICAgIGNsb3NlOiBPLFxuICAgIGNsb3NlZDogTyxcbiAgICBDbG9zZUV2ZW50OiBDLFxuICAgIENvbW1lbnQ6IEMsXG4gICAgQ29tcG9zaXRpb25FdmVudDogQyxcbiAgICBjb25maXJtOiBPLFxuICAgIENvbnN0YW50U291cmNlTm9kZTogQyxcbiAgICBDb252b2x2ZXJOb2RlOiBDLFxuICAgIENvdW50UXVldWluZ1N0cmF0ZWd5OiBDLFxuICAgIGNyZWF0ZUltYWdlQml0bWFwOiBPLFxuICAgIENyZWRlbnRpYWw6IEMsXG4gICAgQ3JlZGVudGlhbHNDb250YWluZXI6IEMsXG4gICAgY3J5cHRvOiBPLFxuICAgIENyeXB0bzogQyxcbiAgICBDcnlwdG9LZXk6IEMsXG4gICAgQ1NTOiBDLFxuICAgIENTU0NvbmRpdGlvblJ1bGU6IEMsXG4gICAgQ1NTRm9udEZhY2VSdWxlOiBDLFxuICAgIENTU0dyb3VwaW5nUnVsZTogQyxcbiAgICBDU1NJbXBvcnRSdWxlOiBDLFxuICAgIENTU0tleWZyYW1lUnVsZTogQyxcbiAgICBDU1NLZXlmcmFtZXNSdWxlOiBDLFxuICAgIENTU01lZGlhUnVsZTogQyxcbiAgICBDU1NOYW1lc3BhY2VSdWxlOiBDLFxuICAgIENTU1BhZ2VSdWxlOiBDLFxuICAgIENTU1J1bGU6IEMsXG4gICAgQ1NTUnVsZUxpc3Q6IEMsXG4gICAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogQyxcbiAgICBDU1NTdHlsZVJ1bGU6IEMsXG4gICAgQ1NTU3R5bGVTaGVldDogQyxcbiAgICBDU1NTdXBwb3J0c1J1bGU6IEMsXG4gICAgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5OiBDLFxuICAgIGN1c3RvbUVsZW1lbnRzOiBPLFxuICAgIEN1c3RvbUV2ZW50OiBDLFxuICAgIERhdGFUcmFuc2ZlcjogQyxcbiAgICBEYXRhVHJhbnNmZXJJdGVtOiBDLFxuICAgIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBDLFxuICAgIGRlZmF1bHRzdGF0dXM6IE8sXG4gICAgZGVmYXVsdFN0YXR1czogTyxcbiAgICBEZWxheU5vZGU6IEMsXG4gICAgRGV2aWNlTW90aW9uRXZlbnQ6IEMsXG4gICAgRGV2aWNlT3JpZW50YXRpb25FdmVudDogQyxcbiAgICBkZXZpY2VQaXhlbFJhdGlvOiBPLFxuICAgIGRpc3BhdGNoRXZlbnQ6IE8sXG4gICAgZG9jdW1lbnQ6IE8sXG4gICAgRG9jdW1lbnQ6IEMsXG4gICAgRG9jdW1lbnRGcmFnbWVudDogQyxcbiAgICBEb2N1bWVudFR5cGU6IEMsXG4gICAgRE9NRXJyb3I6IEMsXG4gICAgRE9NRXhjZXB0aW9uOiBDLFxuICAgIERPTUltcGxlbWVudGF0aW9uOiBDLFxuICAgIERPTU1hdHJpeDogQyxcbiAgICBET01NYXRyaXhSZWFkT25seTogQyxcbiAgICBET01QYXJzZXI6IEMsXG4gICAgRE9NUG9pbnQ6IEMsXG4gICAgRE9NUG9pbnRSZWFkT25seTogQyxcbiAgICBET01RdWFkOiBDLFxuICAgIERPTVJlY3Q6IEMsXG4gICAgRE9NUmVjdFJlYWRPbmx5OiBDLFxuICAgIERPTVN0cmluZ0xpc3Q6IEMsXG4gICAgRE9NU3RyaW5nTWFwOiBDLFxuICAgIERPTVRva2VuTGlzdDogQyxcbiAgICBEcmFnRXZlbnQ6IEMsXG4gICAgRHluYW1pY3NDb21wcmVzc29yTm9kZTogQyxcbiAgICBFbGVtZW50OiBDLFxuICAgIEVycm9yRXZlbnQ6IEMsXG4gICAgRXZlbnQ6IEMsXG4gICAgRXZlbnRTb3VyY2U6IEMsXG4gICAgRXZlbnRUYXJnZXQ6IEMsXG4gICAgZXh0ZXJuYWw6IE8sXG4gICAgZmV0Y2g6IE8sXG4gICAgRmlsZTogQyxcbiAgICBGaWxlTGlzdDogQyxcbiAgICBGaWxlUmVhZGVyOiBDLFxuICAgIGZpbmQ6IE8sXG4gICAgZm9jdXM6IE8sXG4gICAgRm9jdXNFdmVudDogQyxcbiAgICBGb250RmFjZTogQyxcbiAgICBGb250RmFjZVNldExvYWRFdmVudDogQyxcbiAgICBGb3JtRGF0YTogQyxcbiAgICBmcmFtZXM6IE8sXG4gICAgR2Fpbk5vZGU6IEMsXG4gICAgR2FtZXBhZDogQyxcbiAgICBHYW1lcGFkQnV0dG9uOiBDLFxuICAgIEdhbWVwYWRFdmVudDogQyxcbiAgICBnZXRDb21wdXRlZFN0eWxlOiBPLFxuICAgIGdldFNlbGVjdGlvbjogTyxcbiAgICBIYXNoQ2hhbmdlRXZlbnQ6IEMsXG4gICAgSGVhZGVyczogQyxcbiAgICBoaXN0b3J5OiBPLFxuICAgIEhpc3Rvcnk6IEMsXG4gICAgSFRNTEFsbENvbGxlY3Rpb246IEMsXG4gICAgSFRNTEFuY2hvckVsZW1lbnQ6IEMsXG4gICAgSFRNTEFyZWFFbGVtZW50OiBDLFxuICAgIEhUTUxBdWRpb0VsZW1lbnQ6IEMsXG4gICAgSFRNTEJhc2VFbGVtZW50OiBDLFxuICAgIEhUTUxCb2R5RWxlbWVudDogQyxcbiAgICBIVE1MQlJFbGVtZW50OiBDLFxuICAgIEhUTUxCdXR0b25FbGVtZW50OiBDLFxuICAgIEhUTUxDYW52YXNFbGVtZW50OiBDLFxuICAgIEhUTUxDb2xsZWN0aW9uOiBDLFxuICAgIEhUTUxDb250ZW50RWxlbWVudDogQyxcbiAgICBIVE1MRGF0YUVsZW1lbnQ6IEMsXG4gICAgSFRNTERhdGFMaXN0RWxlbWVudDogQyxcbiAgICBIVE1MRGV0YWlsc0VsZW1lbnQ6IEMsXG4gICAgSFRNTERpYWxvZ0VsZW1lbnQ6IEMsXG4gICAgSFRNTERpcmVjdG9yeUVsZW1lbnQ6IEMsXG4gICAgSFRNTERpdkVsZW1lbnQ6IEMsXG4gICAgSFRNTERMaXN0RWxlbWVudDogQyxcbiAgICBIVE1MRG9jdW1lbnQ6IEMsXG4gICAgSFRNTEVsZW1lbnQ6IEMsXG4gICAgSFRNTEVtYmVkRWxlbWVudDogQyxcbiAgICBIVE1MRmllbGRTZXRFbGVtZW50OiBDLFxuICAgIEhUTUxGb250RWxlbWVudDogQyxcbiAgICBIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbjogQyxcbiAgICBIVE1MRm9ybUVsZW1lbnQ6IEMsXG4gICAgSFRNTEZyYW1lRWxlbWVudDogQyxcbiAgICBIVE1MRnJhbWVTZXRFbGVtZW50OiBDLFxuICAgIEhUTUxIZWFkRWxlbWVudDogQyxcbiAgICBIVE1MSGVhZGluZ0VsZW1lbnQ6IEMsXG4gICAgSFRNTEhSRWxlbWVudDogQyxcbiAgICBIVE1MSHRtbEVsZW1lbnQ6IEMsXG4gICAgSFRNTElGcmFtZUVsZW1lbnQ6IEMsXG4gICAgSFRNTEltYWdlRWxlbWVudDogQyxcbiAgICBIVE1MSW5wdXRFbGVtZW50OiBDLFxuICAgIEhUTUxMYWJlbEVsZW1lbnQ6IEMsXG4gICAgSFRNTExlZ2VuZEVsZW1lbnQ6IEMsXG4gICAgSFRNTExJRWxlbWVudDogQyxcbiAgICBIVE1MTGlua0VsZW1lbnQ6IEMsXG4gICAgSFRNTE1hcEVsZW1lbnQ6IEMsXG4gICAgSFRNTE1hcnF1ZWVFbGVtZW50OiBDLFxuICAgIEhUTUxNZWRpYUVsZW1lbnQ6IEMsXG4gICAgSFRNTE1lbnVFbGVtZW50OiBDLFxuICAgIEhUTUxNZXRhRWxlbWVudDogQyxcbiAgICBIVE1MTWV0ZXJFbGVtZW50OiBDLFxuICAgIEhUTUxNb2RFbGVtZW50OiBDLFxuICAgIEhUTUxPYmplY3RFbGVtZW50OiBDLFxuICAgIEhUTUxPTGlzdEVsZW1lbnQ6IEMsXG4gICAgSFRNTE9wdEdyb3VwRWxlbWVudDogQyxcbiAgICBIVE1MT3B0aW9uRWxlbWVudDogQyxcbiAgICBIVE1MT3B0aW9uc0NvbGxlY3Rpb246IEMsXG4gICAgSFRNTE91dHB1dEVsZW1lbnQ6IEMsXG4gICAgSFRNTFBhcmFncmFwaEVsZW1lbnQ6IEMsXG4gICAgSFRNTFBhcmFtRWxlbWVudDogQyxcbiAgICBIVE1MUGljdHVyZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFByZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFByb2dyZXNzRWxlbWVudDogQyxcbiAgICBIVE1MUXVvdGVFbGVtZW50OiBDLFxuICAgIEhUTUxTY3JpcHRFbGVtZW50OiBDLFxuICAgIEhUTUxTZWxlY3RFbGVtZW50OiBDLFxuICAgIEhUTUxTaGFkb3dFbGVtZW50OiBDLFxuICAgIEhUTUxTbG90RWxlbWVudDogQyxcbiAgICBIVE1MU291cmNlRWxlbWVudDogQyxcbiAgICBIVE1MU3BhbkVsZW1lbnQ6IEMsXG4gICAgSFRNTFN0eWxlRWxlbWVudDogQyxcbiAgICBIVE1MVGFibGVDYXB0aW9uRWxlbWVudDogQyxcbiAgICBIVE1MVGFibGVDZWxsRWxlbWVudDogQyxcbiAgICBIVE1MVGFibGVDb2xFbGVtZW50OiBDLFxuICAgIEhUTUxUYWJsZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFRhYmxlUm93RWxlbWVudDogQyxcbiAgICBIVE1MVGFibGVTZWN0aW9uRWxlbWVudDogQyxcbiAgICBIVE1MVGVtcGxhdGVFbGVtZW50OiBDLFxuICAgIEhUTUxUZXh0QXJlYUVsZW1lbnQ6IEMsXG4gICAgSFRNTFRpbWVFbGVtZW50OiBDLFxuICAgIEhUTUxUaXRsZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFRyYWNrRWxlbWVudDogQyxcbiAgICBIVE1MVUxpc3RFbGVtZW50OiBDLFxuICAgIEhUTUxVbmtub3duRWxlbWVudDogQyxcbiAgICBIVE1MVmlkZW9FbGVtZW50OiBDLFxuICAgIElEQkN1cnNvcjogQyxcbiAgICBJREJDdXJzb3JXaXRoVmFsdWU6IEMsXG4gICAgSURCRGF0YWJhc2U6IEMsXG4gICAgSURCRmFjdG9yeTogQyxcbiAgICBJREJJbmRleDogQyxcbiAgICBJREJLZXlSYW5nZTogQyxcbiAgICBJREJPYmplY3RTdG9yZTogQyxcbiAgICBJREJPcGVuREJSZXF1ZXN0OiBDLFxuICAgIElEQlJlcXVlc3Q6IEMsXG4gICAgSURCVHJhbnNhY3Rpb246IEMsXG4gICAgSURCVmVyc2lvbkNoYW5nZUV2ZW50OiBDLFxuICAgIElkbGVEZWFkbGluZTogQyxcbiAgICBJSVJGaWx0ZXJOb2RlOiBDLFxuICAgIEltYWdlOiBDLFxuICAgIEltYWdlQml0bWFwOiBDLFxuICAgIEltYWdlQml0bWFwUmVuZGVyaW5nQ29udGV4dDogQyxcbiAgICBJbWFnZUNhcHR1cmU6IEMsXG4gICAgSW1hZ2VEYXRhOiBDLFxuICAgIGluZGV4ZWREQjogTyxcbiAgICBpbm5lckhlaWdodDogTyxcbiAgICBpbm5lcldpZHRoOiBPLFxuICAgIElucHV0RXZlbnQ6IEMsXG4gICAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXI6IEMsXG4gICAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTogQyxcbiAgICBpc1NlY3VyZUNvbnRleHQ6IE8sXG4gICAgS2V5Ym9hcmRFdmVudDogQyxcbiAgICBLZXlmcmFtZUVmZmVjdDogQyxcbiAgICBsZW5ndGg6IE8sXG4gICAgbG9jYWxTdG9yYWdlOiBPLFxuICAgIGxvY2F0aW9uOiBPLFxuICAgIExvY2F0aW9uOiBDLFxuICAgIGxvY2F0aW9uYmFyOiBPLFxuICAgIG1hdGNoTWVkaWE6IE8sXG4gICAgTWVkaWFEZXZpY2VJbmZvOiBDLFxuICAgIE1lZGlhRGV2aWNlczogQyxcbiAgICBNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGU6IEMsXG4gICAgTWVkaWFFbmNyeXB0ZWRFdmVudDogQyxcbiAgICBNZWRpYUVycm9yOiBDLFxuICAgIE1lZGlhS2V5TWVzc2FnZUV2ZW50OiBDLFxuICAgIE1lZGlhS2V5U2Vzc2lvbjogQyxcbiAgICBNZWRpYUtleVN0YXR1c01hcDogQyxcbiAgICBNZWRpYUtleVN5c3RlbUFjY2VzczogQyxcbiAgICBNZWRpYUxpc3Q6IEMsXG4gICAgTWVkaWFRdWVyeUxpc3Q6IEMsXG4gICAgTWVkaWFRdWVyeUxpc3RFdmVudDogQyxcbiAgICBNZWRpYVJlY29yZGVyOiBDLFxuICAgIE1lZGlhU2V0dGluZ3NSYW5nZTogQyxcbiAgICBNZWRpYVNvdXJjZTogQyxcbiAgICBNZWRpYVN0cmVhbTogQyxcbiAgICBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlOiBDLFxuICAgIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlOiBDLFxuICAgIE1lZGlhU3RyZWFtRXZlbnQ6IEMsXG4gICAgTWVkaWFTdHJlYW1UcmFjazogQyxcbiAgICBNZWRpYVN0cmVhbVRyYWNrRXZlbnQ6IEMsXG4gICAgbWVudWJhcjogTyxcbiAgICBNZXNzYWdlQ2hhbm5lbDogQyxcbiAgICBNZXNzYWdlRXZlbnQ6IEMsXG4gICAgTWVzc2FnZVBvcnQ6IEMsXG4gICAgTUlESUFjY2VzczogQyxcbiAgICBNSURJQ29ubmVjdGlvbkV2ZW50OiBDLFxuICAgIE1JRElJbnB1dDogQyxcbiAgICBNSURJSW5wdXRNYXA6IEMsXG4gICAgTUlESU1lc3NhZ2VFdmVudDogQyxcbiAgICBNSURJT3V0cHV0OiBDLFxuICAgIE1JRElPdXRwdXRNYXA6IEMsXG4gICAgTUlESVBvcnQ6IEMsXG4gICAgTWltZVR5cGU6IEMsXG4gICAgTWltZVR5cGVBcnJheTogQyxcbiAgICBNb3VzZUV2ZW50OiBDLFxuICAgIG1vdmVCeTogTyxcbiAgICBtb3ZlVG86IE8sXG4gICAgTXV0YXRpb25FdmVudDogQyxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBDLFxuICAgIE11dGF0aW9uUmVjb3JkOiBDLFxuICAgIG5hbWU6IE8sXG4gICAgTmFtZWROb2RlTWFwOiBDLFxuICAgIE5hdmlnYXRpb25QcmVsb2FkTWFuYWdlcjogQyxcbiAgICBuYXZpZ2F0b3I6IE8sXG4gICAgTmF2aWdhdG9yOiBDLFxuICAgIE5ldHdvcmtJbmZvcm1hdGlvbjogQyxcbiAgICBOb2RlOiBDLFxuICAgIE5vZGVGaWx0ZXI6IE8sXG4gICAgTm9kZUl0ZXJhdG9yOiBDLFxuICAgIE5vZGVMaXN0OiBDLFxuICAgIE5vdGlmaWNhdGlvbjogQyxcbiAgICBPZmZsaW5lQXVkaW9Db21wbGV0aW9uRXZlbnQ6IEMsXG4gICAgT2ZmbGluZUF1ZGlvQ29udGV4dDogQyxcbiAgICBvZmZzY3JlZW5CdWZmZXJpbmc6IE8sXG4gICAgT2Zmc2NyZWVuQ2FudmFzOiBDLFxuICAgIG9wZW46IE8sXG4gICAgb3BlbkRhdGFiYXNlOiBPLFxuICAgIE9wdGlvbjogQyxcbiAgICBvcmlnaW46IE8sXG4gICAgT3NjaWxsYXRvck5vZGU6IEMsXG4gICAgb3V0ZXJIZWlnaHQ6IE8sXG4gICAgb3V0ZXJXaWR0aDogTyxcbiAgICBQYWdlVHJhbnNpdGlvbkV2ZW50OiBDLFxuICAgIHBhZ2VYT2Zmc2V0OiBPLFxuICAgIHBhZ2VZT2Zmc2V0OiBPLFxuICAgIFBhbm5lck5vZGU6IEMsXG4gICAgcGFyZW50OiBPLFxuICAgIFBhdGgyRDogQyxcbiAgICBQYXltZW50QWRkcmVzczogQyxcbiAgICBQYXltZW50UmVxdWVzdDogQyxcbiAgICBQYXltZW50UmVxdWVzdFVwZGF0ZUV2ZW50OiBDLFxuICAgIFBheW1lbnRSZXNwb25zZTogQyxcbiAgICBwZXJmb3JtYW5jZTogTyxcbiAgICBQZXJmb3JtYW5jZTogQyxcbiAgICBQZXJmb3JtYW5jZUVudHJ5OiBDLFxuICAgIFBlcmZvcm1hbmNlTG9uZ1Rhc2tUaW1pbmc6IEMsXG4gICAgUGVyZm9ybWFuY2VNYXJrOiBDLFxuICAgIFBlcmZvcm1hbmNlTWVhc3VyZTogQyxcbiAgICBQZXJmb3JtYW5jZU5hdmlnYXRpb246IEMsXG4gICAgUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nOiBDLFxuICAgIFBlcmZvcm1hbmNlT2JzZXJ2ZXI6IEMsXG4gICAgUGVyZm9ybWFuY2VPYnNlcnZlckVudHJ5TGlzdDogQyxcbiAgICBQZXJmb3JtYW5jZVBhaW50VGltaW5nOiBDLFxuICAgIFBlcmZvcm1hbmNlUmVzb3VyY2VUaW1pbmc6IEMsXG4gICAgUGVyZm9ybWFuY2VUaW1pbmc6IEMsXG4gICAgUGVyaW9kaWNXYXZlOiBDLFxuICAgIFBlcm1pc3Npb25zOiBDLFxuICAgIFBlcm1pc3Npb25TdGF0dXM6IEMsXG4gICAgcGVyc29uYWxiYXI6IE8sXG4gICAgUGhvdG9DYXBhYmlsaXRpZXM6IEMsXG4gICAgUGx1Z2luOiBDLFxuICAgIFBsdWdpbkFycmF5OiBDLFxuICAgIFBvaW50ZXJFdmVudDogQyxcbiAgICBQb3BTdGF0ZUV2ZW50OiBDLFxuICAgIHBvc3RNZXNzYWdlOiBPLFxuICAgIFByZXNlbnRhdGlvbjogQyxcbiAgICBQcmVzZW50YXRpb25BdmFpbGFiaWxpdHk6IEMsXG4gICAgUHJlc2VudGF0aW9uQ29ubmVjdGlvbjogQyxcbiAgICBQcmVzZW50YXRpb25Db25uZWN0aW9uQXZhaWxhYmxlRXZlbnQ6IEMsXG4gICAgUHJlc2VudGF0aW9uQ29ubmVjdGlvbkNsb3NlRXZlbnQ6IEMsXG4gICAgUHJlc2VudGF0aW9uQ29ubmVjdGlvbkxpc3Q6IEMsXG4gICAgUHJlc2VudGF0aW9uUmVjZWl2ZXI6IEMsXG4gICAgUHJlc2VudGF0aW9uUmVxdWVzdDogQyxcbiAgICBwcmludDogTyxcbiAgICBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IEMsXG4gICAgUHJvZ3Jlc3NFdmVudDogQyxcbiAgICBQcm9taXNlUmVqZWN0aW9uRXZlbnQ6IEMsXG4gICAgcHJvbXB0OiBPLFxuICAgIFB1c2hNYW5hZ2VyOiBDLFxuICAgIFB1c2hTdWJzY3JpcHRpb246IEMsXG4gICAgUHVzaFN1YnNjcmlwdGlvbk9wdGlvbnM6IEMsXG4gICAgcXVldWVNaWNyb3Rhc2s6IE8sXG4gICAgUmFkaW9Ob2RlTGlzdDogQyxcbiAgICBSYW5nZTogQyxcbiAgICBSZWFkYWJsZVN0cmVhbTogQyxcbiAgICBSZW1vdGVQbGF5YmFjazogQyxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBPLFxuICAgIFJlcXVlc3Q6IEMsXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBPLFxuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IE8sXG4gICAgcmVzaXplQnk6IE8sXG4gICAgUmVzaXplT2JzZXJ2ZXI6IEMsXG4gICAgUmVzaXplT2JzZXJ2ZXJFbnRyeTogQyxcbiAgICByZXNpemVUbzogTyxcbiAgICBSZXNwb25zZTogQyxcbiAgICBSVENDZXJ0aWZpY2F0ZTogQyxcbiAgICBSVENEYXRhQ2hhbm5lbDogQyxcbiAgICBSVENEYXRhQ2hhbm5lbEV2ZW50OiBDLFxuICAgIFJUQ0R0bHNUcmFuc3BvcnQ6IEMsXG4gICAgUlRDSWNlQ2FuZGlkYXRlOiBDLFxuICAgIFJUQ0ljZVRyYW5zcG9ydDogQyxcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogQyxcbiAgICBSVENQZWVyQ29ubmVjdGlvbkljZUV2ZW50OiBDLFxuICAgIFJUQ1J0cFJlY2VpdmVyOiBDLFxuICAgIFJUQ1J0cFNlbmRlcjogQyxcbiAgICBSVENTY3RwVHJhbnNwb3J0OiBDLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogQyxcbiAgICBSVENTdGF0c1JlcG9ydDogQyxcbiAgICBSVENUcmFja0V2ZW50OiBDLFxuICAgIHNjcmVlbjogTyxcbiAgICBTY3JlZW46IEMsXG4gICAgc2NyZWVuTGVmdDogTyxcbiAgICBTY3JlZW5PcmllbnRhdGlvbjogQyxcbiAgICBzY3JlZW5Ub3A6IE8sXG4gICAgc2NyZWVuWDogTyxcbiAgICBzY3JlZW5ZOiBPLFxuICAgIFNjcmlwdFByb2Nlc3Nvck5vZGU6IEMsXG4gICAgc2Nyb2xsOiBPLFxuICAgIHNjcm9sbGJhcnM6IE8sXG4gICAgc2Nyb2xsQnk6IE8sXG4gICAgc2Nyb2xsVG86IE8sXG4gICAgc2Nyb2xsWDogTyxcbiAgICBzY3JvbGxZOiBPLFxuICAgIFNlY3VyaXR5UG9saWN5VmlvbGF0aW9uRXZlbnQ6IEMsXG4gICAgU2VsZWN0aW9uOiBDLFxuICAgIFNlcnZpY2VXb3JrZXI6IEMsXG4gICAgU2VydmljZVdvcmtlckNvbnRhaW5lcjogQyxcbiAgICBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uOiBDLFxuICAgIHNlc3Npb25TdG9yYWdlOiBPLFxuICAgIFNoYWRvd1Jvb3Q6IEMsXG4gICAgU2hhcmVkV29ya2VyOiBDLFxuICAgIFNvdXJjZUJ1ZmZlcjogQyxcbiAgICBTb3VyY2VCdWZmZXJMaXN0OiBDLFxuICAgIHNwZWVjaFN5bnRoZXNpczogTyxcbiAgICBTcGVlY2hTeW50aGVzaXNFdmVudDogQyxcbiAgICBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IEMsXG4gICAgU3RhdGljUmFuZ2U6IEMsXG4gICAgc3RhdHVzOiBPLFxuICAgIHN0YXR1c2JhcjogTyxcbiAgICBTdGVyZW9QYW5uZXJOb2RlOiBDLFxuICAgIHN0b3A6IE8sXG4gICAgU3RvcmFnZTogQyxcbiAgICBTdG9yYWdlRXZlbnQ6IEMsXG4gICAgU3RvcmFnZU1hbmFnZXI6IEMsXG4gICAgc3R5bGVNZWRpYTogTyxcbiAgICBTdHlsZVNoZWV0OiBDLFxuICAgIFN0eWxlU2hlZXRMaXN0OiBDLFxuICAgIFN1YnRsZUNyeXB0bzogQyxcbiAgICBTVkdBRWxlbWVudDogQyxcbiAgICBTVkdBbmdsZTogQyxcbiAgICBTVkdBbmltYXRlZEFuZ2xlOiBDLFxuICAgIFNWR0FuaW1hdGVkQm9vbGVhbjogQyxcbiAgICBTVkdBbmltYXRlZEVudW1lcmF0aW9uOiBDLFxuICAgIFNWR0FuaW1hdGVkSW50ZWdlcjogQyxcbiAgICBTVkdBbmltYXRlZExlbmd0aDogQyxcbiAgICBTVkdBbmltYXRlZExlbmd0aExpc3Q6IEMsXG4gICAgU1ZHQW5pbWF0ZWROdW1iZXI6IEMsXG4gICAgU1ZHQW5pbWF0ZWROdW1iZXJMaXN0OiBDLFxuICAgIFNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbzogQyxcbiAgICBTVkdBbmltYXRlZFJlY3Q6IEMsXG4gICAgU1ZHQW5pbWF0ZWRTdHJpbmc6IEMsXG4gICAgU1ZHQW5pbWF0ZWRUcmFuc2Zvcm1MaXN0OiBDLFxuICAgIFNWR0FuaW1hdGVFbGVtZW50OiBDLFxuICAgIFNWR0FuaW1hdGVNb3Rpb25FbGVtZW50OiBDLFxuICAgIFNWR0FuaW1hdGVUcmFuc2Zvcm1FbGVtZW50OiBDLFxuICAgIFNWR0FuaW1hdGlvbkVsZW1lbnQ6IEMsXG4gICAgU1ZHQ2lyY2xlRWxlbWVudDogQyxcbiAgICBTVkdDbGlwUGF0aEVsZW1lbnQ6IEMsXG4gICAgU1ZHQ29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbkVsZW1lbnQ6IEMsXG4gICAgU1ZHRGVmc0VsZW1lbnQ6IEMsXG4gICAgU1ZHRGVzY0VsZW1lbnQ6IEMsXG4gICAgU1ZHRGlzY2FyZEVsZW1lbnQ6IEMsXG4gICAgU1ZHRWxlbWVudDogQyxcbiAgICBTVkdFbGxpcHNlRWxlbWVudDogQyxcbiAgICBTVkdGRUJsZW5kRWxlbWVudDogQyxcbiAgICBTVkdGRUNvbG9yTWF0cml4RWxlbWVudDogQyxcbiAgICBTVkdGRUNvbXBvbmVudFRyYW5zZmVyRWxlbWVudDogQyxcbiAgICBTVkdGRUNvbXBvc2l0ZUVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVDb252b2x2ZU1hdHJpeEVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVEaWZmdXNlTGlnaHRpbmdFbGVtZW50OiBDLFxuICAgIFNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudDogQyxcbiAgICBTVkdGRURpc3RhbnRMaWdodEVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVEcm9wU2hhZG93RWxlbWVudDogQyxcbiAgICBTVkdGRUZsb29kRWxlbWVudDogQyxcbiAgICBTVkdGRUZ1bmNBRWxlbWVudDogQyxcbiAgICBTVkdGRUZ1bmNCRWxlbWVudDogQyxcbiAgICBTVkdGRUZ1bmNHRWxlbWVudDogQyxcbiAgICBTVkdGRUZ1bmNSRWxlbWVudDogQyxcbiAgICBTVkdGRUdhdXNzaWFuQmx1ckVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVJbWFnZUVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVNZXJnZUVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVNZXJnZU5vZGVFbGVtZW50OiBDLFxuICAgIFNWR0ZFTW9ycGhvbG9neUVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVPZmZzZXRFbGVtZW50OiBDLFxuICAgIFNWR0ZFUG9pbnRMaWdodEVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVTcGVjdWxhckxpZ2h0aW5nRWxlbWVudDogQyxcbiAgICBTVkdGRVNwb3RMaWdodEVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVUaWxlRWxlbWVudDogQyxcbiAgICBTVkdGRVR1cmJ1bGVuY2VFbGVtZW50OiBDLFxuICAgIFNWR0ZpbHRlckVsZW1lbnQ6IEMsXG4gICAgU1ZHRm9yZWlnbk9iamVjdEVsZW1lbnQ6IEMsXG4gICAgU1ZHR0VsZW1lbnQ6IEMsXG4gICAgU1ZHR2VvbWV0cnlFbGVtZW50OiBDLFxuICAgIFNWR0dyYWRpZW50RWxlbWVudDogQyxcbiAgICBTVkdHcmFwaGljc0VsZW1lbnQ6IEMsXG4gICAgU1ZHSW1hZ2VFbGVtZW50OiBDLFxuICAgIFNWR0xlbmd0aDogQyxcbiAgICBTVkdMZW5ndGhMaXN0OiBDLFxuICAgIFNWR0xpbmVhckdyYWRpZW50RWxlbWVudDogQyxcbiAgICBTVkdMaW5lRWxlbWVudDogQyxcbiAgICBTVkdNYXJrZXJFbGVtZW50OiBDLFxuICAgIFNWR01hc2tFbGVtZW50OiBDLFxuICAgIFNWR01hdHJpeDogQyxcbiAgICBTVkdNZXRhZGF0YUVsZW1lbnQ6IEMsXG4gICAgU1ZHTVBhdGhFbGVtZW50OiBDLFxuICAgIFNWR051bWJlcjogQyxcbiAgICBTVkdOdW1iZXJMaXN0OiBDLFxuICAgIFNWR1BhdGhFbGVtZW50OiBDLFxuICAgIFNWR1BhdHRlcm5FbGVtZW50OiBDLFxuICAgIFNWR1BvaW50OiBDLFxuICAgIFNWR1BvaW50TGlzdDogQyxcbiAgICBTVkdQb2x5Z29uRWxlbWVudDogQyxcbiAgICBTVkdQb2x5bGluZUVsZW1lbnQ6IEMsXG4gICAgU1ZHUHJlc2VydmVBc3BlY3RSYXRpbzogQyxcbiAgICBTVkdSYWRpYWxHcmFkaWVudEVsZW1lbnQ6IEMsXG4gICAgU1ZHUmVjdDogQyxcbiAgICBTVkdSZWN0RWxlbWVudDogQyxcbiAgICBTVkdTY3JpcHRFbGVtZW50OiBDLFxuICAgIFNWR1NldEVsZW1lbnQ6IEMsXG4gICAgU1ZHU3RvcEVsZW1lbnQ6IEMsXG4gICAgU1ZHU3RyaW5nTGlzdDogQyxcbiAgICBTVkdTdHlsZUVsZW1lbnQ6IEMsXG4gICAgU1ZHU1ZHRWxlbWVudDogQyxcbiAgICBTVkdTd2l0Y2hFbGVtZW50OiBDLFxuICAgIFNWR1N5bWJvbEVsZW1lbnQ6IEMsXG4gICAgU1ZHVGV4dENvbnRlbnRFbGVtZW50OiBDLFxuICAgIFNWR1RleHRFbGVtZW50OiBDLFxuICAgIFNWR1RleHRQYXRoRWxlbWVudDogQyxcbiAgICBTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50OiBDLFxuICAgIFNWR1RpdGxlRWxlbWVudDogQyxcbiAgICBTVkdUcmFuc2Zvcm06IEMsXG4gICAgU1ZHVHJhbnNmb3JtTGlzdDogQyxcbiAgICBTVkdUU3BhbkVsZW1lbnQ6IEMsXG4gICAgU1ZHVW5pdFR5cGVzOiBDLFxuICAgIFNWR1VzZUVsZW1lbnQ6IEMsXG4gICAgU1ZHVmlld0VsZW1lbnQ6IEMsXG4gICAgVGFza0F0dHJpYnV0aW9uVGltaW5nOiBDLFxuICAgIFRleHQ6IEMsXG4gICAgVGV4dEV2ZW50OiBDLFxuICAgIFRleHRNZXRyaWNzOiBDLFxuICAgIFRleHRUcmFjazogQyxcbiAgICBUZXh0VHJhY2tDdWU6IEMsXG4gICAgVGV4dFRyYWNrQ3VlTGlzdDogQyxcbiAgICBUZXh0VHJhY2tMaXN0OiBDLFxuICAgIFRpbWVSYW5nZXM6IEMsXG4gICAgdG9vbGJhcjogTyxcbiAgICB0b3A6IE8sXG4gICAgVG91Y2g6IEMsXG4gICAgVG91Y2hFdmVudDogQyxcbiAgICBUb3VjaExpc3Q6IEMsXG4gICAgVHJhY2tFdmVudDogQyxcbiAgICBUcmFuc2l0aW9uRXZlbnQ6IEMsXG4gICAgVHJlZVdhbGtlcjogQyxcbiAgICBVSUV2ZW50OiBDLFxuICAgIFZhbGlkaXR5U3RhdGU6IEMsXG4gICAgdmlzdWFsVmlld3BvcnQ6IE8sXG4gICAgVmlzdWFsVmlld3BvcnQ6IEMsXG4gICAgVlRUQ3VlOiBDLFxuICAgIFdhdmVTaGFwZXJOb2RlOiBDLFxuICAgIFdlYkFzc2VtYmx5OiBPLFxuICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ6IEMsXG4gICAgV2ViR0xBY3RpdmVJbmZvOiBDLFxuICAgIFdlYkdMQnVmZmVyOiBDLFxuICAgIFdlYkdMQ29udGV4dEV2ZW50OiBDLFxuICAgIFdlYkdMRnJhbWVidWZmZXI6IEMsXG4gICAgV2ViR0xQcm9ncmFtOiBDLFxuICAgIFdlYkdMUXVlcnk6IEMsXG4gICAgV2ViR0xSZW5kZXJidWZmZXI6IEMsXG4gICAgV2ViR0xSZW5kZXJpbmdDb250ZXh0OiBDLFxuICAgIFdlYkdMU2FtcGxlcjogQyxcbiAgICBXZWJHTFNoYWRlcjogQyxcbiAgICBXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdDogQyxcbiAgICBXZWJHTFN5bmM6IEMsXG4gICAgV2ViR0xUZXh0dXJlOiBDLFxuICAgIFdlYkdMVHJhbnNmb3JtRmVlZGJhY2s6IEMsXG4gICAgV2ViR0xVbmlmb3JtTG9jYXRpb246IEMsXG4gICAgV2ViR0xWZXJ0ZXhBcnJheU9iamVjdDogQyxcbiAgICBXZWJTb2NrZXQ6IEMsXG4gICAgV2hlZWxFdmVudDogQyxcbiAgICBXaW5kb3c6IEMsXG4gICAgV29ya2VyOiBDLFxuICAgIFdyaXRhYmxlU3RyZWFtOiBDLFxuICAgIFhNTERvY3VtZW50OiBDLFxuICAgIFhNTEh0dHBSZXF1ZXN0OiBDLFxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQ6IEMsXG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQ6IEMsXG4gICAgWE1MU2VyaWFsaXplcjogQyxcbiAgICBYUGF0aEV2YWx1YXRvcjogQyxcbiAgICBYUGF0aEV4cHJlc3Npb246IEMsXG4gICAgWFBhdGhSZXN1bHQ6IEMsXG4gICAgWFNMVFByb2Nlc3NvcjogQ1xufTtcbmZvciAoY29uc3QgZ2xvYmFsIG9mIFsnd2luZG93JywgJ2dsb2JhbCcsICdzZWxmJywgJ2dsb2JhbFRoaXMnXSkge1xuICAgIGtub3duR2xvYmFsc1tnbG9iYWxdID0ga25vd25HbG9iYWxzO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQXRQYXRoKHBhdGgpIHtcbiAgICBsZXQgY3VycmVudEdsb2JhbCA9IGtub3duR2xvYmFscztcbiAgICBmb3IgKGNvbnN0IHBhdGhTZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoU2VnbWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRHbG9iYWwgPSBjdXJyZW50R2xvYmFsW3BhdGhTZWdtZW50XTtcbiAgICAgICAgaWYgKCFjdXJyZW50R2xvYmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEdsb2JhbFtWYWx1ZVByb3BlcnRpZXNdO1xufVxuZnVuY3Rpb24gaXNQdXJlR2xvYmFsKHBhdGgpIHtcbiAgICBjb25zdCBnbG9iYWxBdFBhdGggPSBnZXRHbG9iYWxBdFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGdsb2JhbEF0UGF0aCAhPT0gbnVsbCAmJiBnbG9iYWxBdFBhdGgucHVyZTtcbn1cbmZ1bmN0aW9uIGlzR2xvYmFsTWVtYmVyKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbMF0gPT09ICd1bmRlZmluZWQnIHx8IGdldEdsb2JhbEF0UGF0aChwYXRoKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEdsb2JhbEF0UGF0aChwYXRoLnNsaWNlKDAsIC0xKSkgIT09IG51bGw7XG59XG5cbmNsYXNzIEdsb2JhbFZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzUmVhc3NpZ25lZCA9IHRydWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gIWlzR2xvYmFsTWVtYmVyKFt0aGlzLm5hbWUsIC4uLnBhdGhdKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gIWlzUHVyZUdsb2JhbChbdGhpcy5uYW1lLCAuLi5wYXRoXSk7XG4gICAgfVxufVxuXG5jb25zdCB0ZHpWYXJpYWJsZUtpbmRzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjbGFzczogdHJ1ZSxcbiAgICBjb25zdDogdHJ1ZSxcbiAgICBsZXQ6IHRydWUsXG4gICAgdmFyOiB0cnVlXG59O1xuY2xhc3MgSWRlbnRpZmllciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1REWkFjY2VzcyA9IG51bGw7XG4gICAgfVxuICAgIGFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsICYmIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXModGhpcy52YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHRoaXMudmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlID09PSBudWxsICYmIGlzX3JlZmVyZW5jZSh0aGlzLCB0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUgPSB0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5hZGRSZWZlcmVuY2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjbGFyZShraW5kLCBpbml0KSB7XG4gICAgICAgIGxldCB2YXJpYWJsZTtcbiAgICAgICAgY29uc3QgeyB0cmVlc2hha2UgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLnNjb3BlLmFkZERlY2xhcmF0aW9uKHRoaXMsIHRoaXMuY29udGV4dCwgaW5pdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVzaGFrZSAmJiB0cmVlc2hha2UuY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGUgaW5pdCBpcyBkZW9wdGltaXplZC4gV2UgY2Fubm90IGNhbGwgZGVvcHRpbWl6ZVBhdGggaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIC8vIGluIHN0cmljdCBtb2RlLCBmdW5jdGlvbnMgYXJlIG9ubHkgaG9pc3RlZCB3aXRoaW4gYSBzY29wZSBidXQgbm90IGFjcm9zcyBibG9jayBzY29wZXNcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMuc2NvcGUuYWRkRGVjbGFyYXRpb24odGhpcywgdGhpcy5jb250ZXh0LCBpbml0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdGhpcy5zY29wZS5hZGREZWNsYXJhdGlvbih0aGlzLCB0aGlzLmNvbnRleHQsIGluaXQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhcmFtZXRlcic6XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLnNjb3BlLmFkZFBhcmFtZXRlckRlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiBVbmV4cGVjdGVkIGlkZW50aWZpZXIga2luZCAke2tpbmR9LmApO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhYmxlLmtpbmQgPSBraW5kO1xuICAgICAgICByZXR1cm4gWyh0aGlzLnZhcmlhYmxlID0gdmFyaWFibGUpXTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgJiYgIXRoaXMuc2NvcGUuY29udGFpbnModGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNhbGxvd0ltcG9ydFJlYXNzaWdubWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQb3NzaWJsZVREWigpICYmIHRoaXMudmFyaWFibGUua2luZCAhPT0gJ3ZhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlLnVua25vd25HbG9iYWxTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZSBpbnN0YW5jZW9mIEdsb2JhbFZhcmlhYmxlICYmXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoRU1QVFlfUEFUSCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhcmlhYmxlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy52YXJpYWJsZSB8fFxuICAgICAgICAgICAgKHBhdGgubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRWYXJpYWJsZVJlc3BlY3RpbmdURFooKVxuICAgICAgICAgICAgICAgIDogdGhpcy52YXJpYWJsZSkuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMudmFyaWFibGUgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkuaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICB0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgICBpc1Bvc3NpYmxlVERaKCkge1xuICAgICAgICAvLyByZXR1cm4gY2FjaGVkIHZhbHVlIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHRoZSBuZXh0IHRyZWUtc2hha2luZyBwYXNzXG4gICAgICAgIGlmICh0aGlzLmlzVERaQWNjZXNzICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNURFpBY2Nlc3M7XG4gICAgICAgIGlmICghKHRoaXMudmFyaWFibGUgaW5zdGFuY2VvZiBMb2NhbFZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgIXRoaXMudmFyaWFibGUua2luZCB8fFxuICAgICAgICAgICAgISh0aGlzLnZhcmlhYmxlLmtpbmQgaW4gdGR6VmFyaWFibGVLaW5kcykpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pc1REWkFjY2VzcyA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbF9pZDtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUuZGVjbGFyYXRpb25zICYmXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIChkZWNsX2lkID0gdGhpcy52YXJpYWJsZS5kZWNsYXJhdGlvbnNbMF0pICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDwgZGVjbF9pZC5zdGFydCAmJlxuICAgICAgICAgICAgY2xvc2VzdFBhcmVudEZ1bmN0aW9uT3JQcm9ncmFtKHRoaXMpID09PSBjbG9zZXN0UGFyZW50RnVuY3Rpb25PclByb2dyYW0oZGVjbF9pZCkpIHtcbiAgICAgICAgICAgIC8vIGEgdmFyaWFibGUgYWNjZXNzZWQgYmVmb3JlIGl0cyBkZWNsYXJhdGlvblxuICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgZnVuY3Rpb24gb3IgYXQgdG9wIGxldmVsIG9mIG1vZHVsZVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlzVERaQWNjZXNzID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnZhcmlhYmxlLmluaXRSZWFjaGVkKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgYSBjb25zdC9sZXQgVERaIHZpb2xhdGlvbiBvclxuICAgICAgICAgICAgLy8gdmFyIHVzZSBiZWZvcmUgZGVjbGFyYXRpb24gd2FzIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlzVERaQWNjZXNzID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmlzVERaQWNjZXNzID0gZmFsc2UpO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmluaXRSZWFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIHsgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9LCB7IHJlbmRlcmVkUGFyZW50VHlwZSwgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50LCBpc1Nob3J0aGFuZFByb3BlcnR5IH0gPSBCTEFOSykge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudE9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1Nob3J0aGFuZFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KHRoaXMuc3RhcnQsIGAke3RoaXMubmFtZX06IGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIHN0cmljdCBtb2RlLCBhbnkgdmFyaWFibGUgbmFtZWQgXCJldmFsXCIgbXVzdCBiZSB0aGUgYWN0dWFsIFwiZXZhbFwiIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2V2YWwnICYmXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRQYXJlbnRUeXBlID09PSBDYWxsRXhwcmVzc2lvbiQxICYmXG4gICAgICAgICAgICAgICAgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRSaWdodCh0aGlzLnN0YXJ0LCAnMCwgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSAhPT0gbnVsbCAmJiB0aGlzLnZhcmlhYmxlIGluc3RhbmNlb2YgTG9jYWxWYXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5jb25zb2xpZGF0ZUluaXRpYWxpemVycygpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhbGxvd0ltcG9ydFJlYXNzaWdubWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAnSUxMRUdBTF9SRUFTU0lHTk1FTlQnLFxuICAgICAgICAgICAgbWVzc2FnZTogYElsbGVnYWwgcmVhc3NpZ25tZW50IHRvIGltcG9ydCAnJHt0aGlzLm5hbWV9J2BcbiAgICAgICAgfSwgdGhpcy5zdGFydCk7XG4gICAgfVxuICAgIGdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQb3NzaWJsZVREWigpKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3Nlc3RQYXJlbnRGdW5jdGlvbk9yUHJvZ3JhbShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIS9eUHJvZ3JhbXxGdW5jdGlvbi8udGVzdChub2RlLnR5cGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgLy8gb25lIG9mOiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiwgRnVuY3Rpb25EZWNsYXJhdGlvbiwgRnVuY3Rpb25FeHByZXNzaW9uIG9yIFByb2dyYW1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuY2xhc3MgUmVzdEVsZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkluaXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICB9XG4gICAgZGVjbGFyZShraW5kLCBpbml0KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25Jbml0ID0gaW5pdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJndW1lbnQuZGVjbGFyZShraW5kLCBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHBhdGgubGVuZ3RoID09PSAwICYmIHRoaXMuYXJndW1lbnQuZGVvcHRpbWl6ZVBhdGgoRU1QVFlfUEFUSCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwIHx8IHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChFTVBUWV9QQVRILCBjb250ZXh0KTtcbiAgICB9XG4gICAgbWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudC5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGVjbGFyYXRpb25Jbml0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uSW5pdC5kZW9wdGltaXplUGF0aChbVW5rbm93bktleSwgVW5rbm93bktleV0pO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRSZXR1cm4gPSBmYWxzZTtcbiAgICB9XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBSZXR1cm5WYWx1ZVNjb3BlKHBhcmVudFNjb3BlLCB0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIC8vIEEgcmVhc3NpZ25tZW50IG9mIFVOS05PV05fUEFUSCBpcyBjb25zaWRlcmVkIGVxdWl2YWxlbnQgdG8gaGF2aW5nIGxvc3QgdHJhY2tcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhlIHJldHVybiBleHByZXNzaW9uIG5lZWRzIHRvIGJlIHJlYXNzaWduZWRcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHBhdGhbMF0gPT09IFVua25vd25LZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXJyb3cgZnVuY3Rpb25zIGRvIG5vdCBtdXRhdGUgdGhlaXIgY29udGV4dFxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aCgpIHsgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWRSZXR1cm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlb3B0aW1pemVkUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmdldFJldHVybkV4cHJlc3Npb24oKS5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmdldFJldHVybkV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIF9jYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9uc1xuICAgICAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5FeHByZXNzaW9uID0gdGhpcy5zY29wZS5nZXRSZXR1cm5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBpZiAocmV0dXJuRXhwcmVzc2lvbi5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChbJ3RoZW4nXSwgeyBhcmdzOiBOT19BUkdTLCB0aGlzUGFyYW06IG51bGwsIHdpdGhOZXc6IGZhbHNlIH0sIGNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgKHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkV4cHJlc3Npb24uaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChbJ3RoZW4nXSwgY29udGV4dCkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWdub3JlLCBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICBjb250ZXh0Lmlnbm9yZSA9IHtcbiAgICAgICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgICAgICBjb250aW51ZXM6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICByZXR1cm5ZaWVsZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5ib2R5Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUgPSBpZ25vcmU7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEocGFyYW0gaW5zdGFuY2VvZiBJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gQlJPS0VOX0ZMT1dfTk9ORTtcbiAgICAgICAgdGhpcy5ib2R5LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgIH1cbiAgICBpbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgIHRoaXMuc2NvcGUuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHRoaXMuc2NvcGUuYWRkUGFyYW1ldGVyVmFyaWFibGVzKHRoaXMucGFyYW1zLm1hcChwYXJhbSA9PiBwYXJhbS5kZWNsYXJlKCdwYXJhbWV0ZXInLCBVTktOT1dOX0VYUFJFU1NJT04pKSwgdGhpcy5wYXJhbXNbdGhpcy5wYXJhbXMubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBSZXN0RWxlbWVudCk7XG4gICAgICAgIGlmICh0aGlzLmJvZHkgaW5zdGFuY2VvZiBCbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5LmFkZEltcGxpY2l0UmV0dXJuRXhwcmVzc2lvblRvU2NvcGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuYWRkUmV0dXJuRXhwcmVzc2lvbih0aGlzLmJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGlmIChlc1RyZWVOb2RlLmJvZHkudHlwZSA9PT0gQmxvY2tTdGF0ZW1lbnQkMSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gbmV3IEJsb2NrU3RhdGVtZW50KGVzVHJlZU5vZGUuYm9keSwgdGhpcywgdGhpcy5zY29wZS5ob2lzdGVkQm9keVZhclNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxufVxuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ucHJvdG90eXBlLnByZXZlbnRDaGlsZEJsb2NrU2NvcGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBnZXRTeXN0ZW1FeHBvcnRTdGF0ZW1lbnQoZXhwb3J0ZWRWYXJpYWJsZXMsIHsgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBzbmlwcGV0czogeyBfLCBnZXRPYmplY3QsIGdldFByb3BlcnR5QWNjZXNzIH0gfSwgbW9kaWZpZXIgPSAnJykge1xuICAgIGlmIChleHBvcnRlZFZhcmlhYmxlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldChleHBvcnRlZFZhcmlhYmxlc1swXSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gZXhwb3J0ZWRWYXJpYWJsZXNbMF07XG4gICAgICAgIHJldHVybiBgZXhwb3J0cygnJHtleHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKX0nLCR7X30ke3ZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSR7bW9kaWZpZXJ9KWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBleHBvcnRlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodmFyaWFibGUpKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goW2V4cG9ydE5hbWUsIHZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpICsgbW9kaWZpZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGV4cG9ydHMoJHtnZXRPYmplY3QoZmllbGRzLCB7IGxpbmVCcmVha0luZGVudDogbnVsbCB9KX0pYDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJTeXN0ZW1FeHBvcnRFeHByZXNzaW9uKGV4cG9ydGVkVmFyaWFibGUsIGV4cHJlc3Npb25TdGFydCwgZXhwcmVzc2lvbkVuZCwgY29kZSwgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIHNuaXBwZXRzOiB7IF8gfSB9KSB7XG4gICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCBgZXhwb3J0cygnJHtleHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KGV4cG9ydGVkVmFyaWFibGUpfScsJHtffWApO1xuICAgIGNvZGUuYXBwZW5kTGVmdChleHByZXNzaW9uRW5kLCAnKScpO1xufVxuZnVuY3Rpb24gcmVuZGVyU3lzdGVtRXhwb3J0RnVuY3Rpb24oZXhwb3J0ZWRWYXJpYWJsZXMsIGV4cHJlc3Npb25TdGFydCwgZXhwcmVzc2lvbkVuZCwgbmVlZHNQYXJlbnMsIGNvZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybklpZmVMZWZ0IH0gPSBvcHRpb25zLnNuaXBwZXRzO1xuICAgIGNvZGUucHJlcGVuZFJpZ2h0KGV4cHJlc3Npb25TdGFydCwgZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQoWyd2J10sIGAke2dldFN5c3RlbUV4cG9ydFN0YXRlbWVudChleHBvcnRlZFZhcmlhYmxlcywgb3B0aW9ucyl9LCR7X312YCwgeyBuZWVkc0Fycm93UmV0dXJuUGFyZW5zOiB0cnVlLCBuZWVkc1dyYXBwZWRGdW5jdGlvbjogbmVlZHNQYXJlbnMgfSkpO1xuICAgIGNvZGUuYXBwZW5kTGVmdChleHByZXNzaW9uRW5kLCAnKScpO1xufVxuZnVuY3Rpb24gcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VBZnRlckV4cHJlc3Npb24oZXhwb3J0ZWRWYXJpYWJsZSwgZXhwcmVzc2lvblN0YXJ0LCBleHByZXNzaW9uRW5kLCBuZWVkc1BhcmVucywgY29kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MgfSA9IG9wdGlvbnMuc25pcHBldHM7XG4gICAgY29kZS5hcHBlbmRMZWZ0KGV4cHJlc3Npb25FbmQsIGAsJHtffSR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KFtleHBvcnRlZFZhcmlhYmxlXSwgb3B0aW9ucyl9LCR7X30ke2V4cG9ydGVkVmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyl9YCk7XG4gICAgaWYgKG5lZWRzUGFyZW5zKSB7XG4gICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KGV4cHJlc3Npb25TdGFydCwgJygnKTtcbiAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGV4cHJlc3Npb25FbmQsICcpJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VCZWZvcmVFeHByZXNzaW9uKGV4cG9ydGVkVmFyaWFibGUsIGV4cHJlc3Npb25TdGFydCwgZXhwcmVzc2lvbkVuZCwgbmVlZHNQYXJlbnMsIGNvZGUsIG9wdGlvbnMsIG1vZGlmaWVyKSB7XG4gICAgY29uc3QgeyBfIH0gPSBvcHRpb25zLnNuaXBwZXRzO1xuICAgIGNvZGUucHJlcGVuZFJpZ2h0KGV4cHJlc3Npb25TdGFydCwgYCR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KFtleHBvcnRlZFZhcmlhYmxlXSwgb3B0aW9ucywgbW9kaWZpZXIpfSwke199YCk7XG4gICAgaWYgKG5lZWRzUGFyZW5zKSB7XG4gICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KGV4cHJlc3Npb25TdGFydCwgJygnKTtcbiAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGV4cHJlc3Npb25FbmQsICcpJyk7XG4gICAgfVxufVxuXG5jbGFzcyBPYmplY3RQYXR0ZXJuIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkudHlwZSA9PT0gUHJvcGVydHkkMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnZhbHVlLmFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmFyZ3VtZW50LmFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNsYXJlKGtpbmQsIGluaXQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaCguLi5wcm9wZXJ0eS5kZWNsYXJlKGtpbmQsIGluaXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVzO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5Lmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgoRU1QVFlfUEFUSCwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgcHJvcGVydHkubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBc3NpZ25tZW50RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gKHRoaXMucmlnaHQuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5sZWZ0Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgIHRoaXMubGVmdC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKEVNUFRZX1BBVEgsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgdGhpcy5yaWdodC5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGxldCBoYXNFZmZlY3RzQ29udGV4dDtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yICE9PSAnPScgfHxcbiAgICAgICAgICAgIHRoaXMubGVmdC5pbmNsdWRlZCB8fFxuICAgICAgICAgICAgKChoYXNFZmZlY3RzQ29udGV4dCA9IGNyZWF0ZUhhc0VmZmVjdHNDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5oYXNFZmZlY3RzKGhhc0VmZmVjdHNDb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChFTVBUWV9QQVRILCBoYXNFZmZlY3RzQ29udGV4dCkpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcHJldmVudEFTSSwgcmVuZGVyZWRQYXJlbnRUeXBlLCByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9uU3RhcnQgPSBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJz0nLCB0aGlzLmxlZnQuZW5kKSArIDEpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgaW5jbHVzaW9uU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHByZXZlbnRBU0kpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMaW5lQnJlYWtzKGNvZGUsIGluY2x1c2lvblN0YXJ0LCB0aGlzLnJpZ2h0LnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHJlbmRlcmVkUGFyZW50VHlwZSB8fCB0aGlzLnBhcmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB8fCB0aGlzLnBhcmVudC50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdzeXN0ZW0nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5sZWZ0LnZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWVzID0gb3B0aW9ucy5leHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3lzdGVtRXhwb3J0RXhwcmVzc2lvbih2YXJpYWJsZSwgdGhpcy5zdGFydCwgdGhpcy5lbmQsIGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VBZnRlckV4cHJlc3Npb24odmFyaWFibGUsIHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLnBhcmVudC50eXBlICE9PSBFeHByZXNzaW9uU3RhdGVtZW50JDEsIGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1QYXR0ZXJuRXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5hZGRFeHBvcnRlZFZhcmlhYmxlcyhzeXN0ZW1QYXR0ZXJuRXhwb3J0cywgb3B0aW9ucy5leHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGlmIChzeXN0ZW1QYXR0ZXJuRXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN5c3RlbUV4cG9ydEZ1bmN0aW9uKHN5c3RlbVBhdHRlcm5FeHBvcnRzLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgPT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGVmdC5pbmNsdWRlZCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0IGluc3RhbmNlb2YgT2JqZWN0UGF0dGVybiAmJlxuICAgICAgICAgICAgKHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBFeHByZXNzaW9uU3RhdGVtZW50JDEgfHxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCA9PT0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24kMSkpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5lbmQsICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxlZnQuZGVvcHRpbWl6ZVBhdGgoRU1QVFlfUEFUSCk7XG4gICAgICAgIHRoaXMucmlnaHQuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG59XG5cbmNsYXNzIEFzc2lnbm1lbnRQYXR0ZXJuIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMubGVmdC5hZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSk7XG4gICAgfVxuICAgIGRlY2xhcmUoa2luZCwgaW5pdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY2xhcmUoa2luZCwgaW5pdCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgcGF0aC5sZW5ndGggPT09IDAgJiYgdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCB8fCB0aGlzLmxlZnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChFTVBUWV9QQVRILCBjb250ZXh0KTtcbiAgICB9XG4gICAgbWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpIHtcbiAgICAgICAgdGhpcy5sZWZ0Lm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgaXNTaG9ydGhhbmRQcm9wZXJ0eSB9ID0gQkxBTkspIHtcbiAgICAgICAgdGhpcy5sZWZ0LnJlbmRlcihjb2RlLCBvcHRpb25zLCB7IGlzU2hvcnRoYW5kUHJvcGVydHkgfSk7XG4gICAgICAgIHRoaXMucmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVmdC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgdGhpcy5yaWdodC5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY2xhc3MgQXJndW1lbnRzVmFyaWFibGUgZXh0ZW5kcyBMb2NhbFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdhcmd1bWVudHMnLCBudWxsLCBVTktOT1dOX0VYUFJFU1NJT04sIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmNsYXNzIFRoaXNWYXJpYWJsZSBleHRlbmRzIExvY2FsVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ3RoaXMnLCBudWxsLCBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZFBhdGhzID0gW107XG4gICAgICAgIHRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudGhpc0Rlb3B0aW1pemF0aW9uTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnRoaXNEZW9wdGltaXphdGlvbnMgPSBuZXcgRGlzY3JpbWluYXRlZFBhdGhUcmFja2VyKCk7XG4gICAgfVxuICAgIGFkZEVudGl0eVRvQmVEZW9wdGltaXplZChlbnRpdHkpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuZGVvcHRpbWl6ZWRQYXRocykge1xuICAgICAgICAgICAgZW50aXR5LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGhpc0Rlb3B0aW1pemF0aW9uIG9mIHRoaXMudGhpc0Rlb3B0aW1pemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVRoaXNEZW9wdGltaXphdGlvbkV2ZW50KGVudGl0eSwgdGhpc0Rlb3B0aW1pemF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkLmFkZChlbnRpdHkpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphdGlvblRyYWNrZXIudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlb3B0aW1pemVkUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgZW50aXR5LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlcikge1xuICAgICAgICBjb25zdCB0aGlzRGVvcHRpbWl6YXRpb24gPSB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICB0aGlzUGFyYW1ldGVyXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy50aGlzRGVvcHRpbWl6YXRpb25zLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIGV2ZW50LCB0aGlzUGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUaGlzRGVvcHRpbWl6YXRpb25FdmVudChlbnRpdHksIHRoaXNEZW9wdGltaXphdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRoaXNEZW9wdGltaXphdGlvbkxpc3QucHVzaCh0aGlzRGVvcHRpbWl6YXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0SW5pdChjb250ZXh0KS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHx8XG4gICAgICAgICAgICBzdXBlci5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRJbml0KGNvbnRleHQpLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkgfHxcbiAgICAgICAgICAgIHN1cGVyLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgIH1cbiAgICBhcHBseVRoaXNEZW9wdGltaXphdGlvbkV2ZW50KGVudGl0eSwgeyBldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciB9KSB7XG4gICAgICAgIGVudGl0eS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIgPT09IHRoaXMgPyBlbnRpdHkgOiB0aGlzUGFyYW1ldGVyLCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIpO1xuICAgIH1cbiAgICBnZXRJbml0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQucmVwbGFjZWRWYXJpYWJsZUluaXRzLmdldCh0aGlzKSB8fCBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgfVxufVxuXG5jbGFzcyBGdW5jdGlvblNjb3BlIGV4dGVuZHMgUmV0dXJuVmFsdWVTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldCgnYXJndW1lbnRzJywgKHRoaXMuYXJndW1lbnRzVmFyaWFibGUgPSBuZXcgQXJndW1lbnRzVmFyaWFibGUoY29udGV4dCkpKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KCd0aGlzJywgKHRoaXMudGhpc1ZhcmlhYmxlID0gbmV3IFRoaXNWYXJpYWJsZShjb250ZXh0KSkpO1xuICAgIH1cbiAgICBmaW5kTGV4aWNhbEJvdW5kYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICBzdXBlci5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnRzVmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhcmcuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBGdW5jdGlvbk5vZGUgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRSZXR1cm4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Byb3RvdHlwZURlb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgRnVuY3Rpb25TY29wZShwYXJlbnRTY29wZSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoWzBdID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm90b3R5cGVEZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXRoWzBdID09PSBVbmtub3duS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb3RvdHlwZURlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBBIHJlYXNzaWdubWVudCBvZiBVTktOT1dOX1BBVEggaXMgY29uc2lkZXJlZCBlcXVpdmFsZW50IHRvIGhhdmluZyBsb3N0IHRyYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhlIHJldHVybiBleHByZXNzaW9uIG5lZWRzIHRvIGJlIHJlYXNzaWduZWQgYXMgd2VsbFxuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETyBmb3IgY29tcGxldGVuZXNzLCB3ZSBzaG91bGQgYWxzbyB0cmFjayBvdGhlciBldmVudHMgaGVyZVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlcikge1xuICAgICAgICBpZiAoZXZlbnQgPT09IEVWRU5UX0NBTExFRCkge1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNQYXJhbWV0ZXIuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUudGhpc1ZhcmlhYmxlLmFkZEVudGl0eVRvQmVEZW9wdGltaXplZCh0aGlzUGFyYW1ldGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplZFJldHVybiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5nZXRSZXR1cm5FeHByZXNzaW9uKCkuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5nZXRSZXR1cm5FeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkICE9PSBudWxsICYmIHRoaXMuaWQuaGFzRWZmZWN0cygpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDIgfHwgcGF0aFswXSAhPT0gJ3Byb3RvdHlwZScgfHwgdGhpcy5pc1Byb3RvdHlwZURlb3B0aW1pemVkO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAyIHx8IHBhdGhbMF0gIT09ICdwcm90b3R5cGUnIHx8IHRoaXMuaXNQcm90b3R5cGVEZW9wdGltaXplZDtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgICAgICAgICAudHJlZXNoYWtlO1xuICAgICAgICAgICAgY29uc3QgcmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgaWYgKHJldHVybkV4cHJlc3Npb24uaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgoWyd0aGVuJ10sIHsgYXJnczogTk9fQVJHUywgdGhpc1BhcmFtOiBudWxsLCB3aXRoTmV3OiBmYWxzZSB9LCBjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgICAgICAocHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgPT09ICdhbHdheXMnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5FeHByZXNzaW9uLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoWyd0aGVuJ10sIGNvbnRleHQpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlzSW5pdCA9IGNvbnRleHQucmVwbGFjZWRWYXJpYWJsZUluaXRzLmdldCh0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZSk7XG4gICAgICAgIGNvbnRleHQucmVwbGFjZWRWYXJpYWJsZUluaXRzLnNldCh0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZSwgY2FsbE9wdGlvbnMud2l0aE5ld1xuICAgICAgICAgICAgPyBuZXcgT2JqZWN0RW50aXR5KE9iamVjdC5jcmVhdGUobnVsbCksIE9CSkVDVF9QUk9UT1RZUEUpXG4gICAgICAgICAgICA6IFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdywgaWdub3JlIH0gPSBjb250ZXh0O1xuICAgICAgICBjb250ZXh0Lmlnbm9yZSA9IHtcbiAgICAgICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgICAgICBjb250aW51ZXM6IGZhbHNlLFxuICAgICAgICAgICAgbGFiZWxzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICByZXR1cm5ZaWVsZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5ib2R5Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgaWYgKHRoaXNJbml0KSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlcGxhY2VkVmFyaWFibGVJbml0cy5zZXQodGhpcy5zY29wZS50aGlzVmFyaWFibGUsIHRoaXNJbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVwbGFjZWRWYXJpYWJsZUluaXRzLmRlbGV0ZSh0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5pZ25vcmUgPSBpZ25vcmU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaWQpXG4gICAgICAgICAgICB0aGlzLmlkLmluY2x1ZGUoKTtcbiAgICAgICAgY29uc3QgaGFzQXJndW1lbnRzID0gdGhpcy5zY29wZS5hcmd1bWVudHNWYXJpYWJsZS5pbmNsdWRlZDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEocGFyYW0gaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB8fCBoYXNBcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3cgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IEJST0tFTl9GTE9XX05PTkU7XG4gICAgICAgIHRoaXMuYm9keS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICB0aGlzLnNjb3BlLmluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBpZiAodGhpcy5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZC5kZWNsYXJlKCdmdW5jdGlvbicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NvcGUuYWRkUGFyYW1ldGVyVmFyaWFibGVzKHRoaXMucGFyYW1zLm1hcChwYXJhbSA9PiBwYXJhbS5kZWNsYXJlKCdwYXJhbWV0ZXInLCBVTktOT1dOX0VYUFJFU1NJT04pKSwgdGhpcy5wYXJhbXNbdGhpcy5wYXJhbXMubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBSZXN0RWxlbWVudCk7XG4gICAgICAgIHRoaXMuYm9keS5hZGRJbXBsaWNpdFJldHVybkV4cHJlc3Npb25Ub1Njb3BlKCk7XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIHRoaXMuYm9keSA9IG5ldyBCbG9ja1N0YXRlbWVudChlc1RyZWVOb2RlLmJvZHksIHRoaXMsIHRoaXMuc2NvcGUuaG9pc3RlZEJvZHlWYXJTY29wZSk7XG4gICAgICAgIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG59XG5GdW5jdGlvbk5vZGUucHJvdG90eXBlLnByZXZlbnRDaGlsZEJsb2NrU2NvcGUgPSB0cnVlO1xuXG5jbGFzcyBBd2FpdEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGVja1RvcExldmVsQXdhaXQ6IGlmICghdGhpcy5jb250ZXh0LnVzZXNUb3BMZXZlbEF3YWl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGNoZWNrVG9wTGV2ZWxBd2FpdDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51c2VzVG9wTGV2ZWxBd2FpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcmd1bWVudC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxufVxuXG5jb25zdCBiaW5hcnlPcGVyYXRvcnMgPSB7XG4gICAgJyE9JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICE9IHJpZ2h0LFxuICAgICchPT0nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgIT09IHJpZ2h0LFxuICAgICclJzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICUgcmlnaHQsXG4gICAgJyYnOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgJiByaWdodCxcbiAgICAnKic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCAqIHJpZ2h0LFxuICAgIC8vIEF0IHRoZSBtb21lbnQsIFwiKipcIiB3aWxsIGJlIHRyYW5zcGlsZWQgdG8gTWF0aC5wb3dcbiAgICAnKionOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgKiogcmlnaHQsXG4gICAgJysnOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgKyByaWdodCxcbiAgICAnLSc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCAtIHJpZ2h0LFxuICAgICcvJzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0IC8gcmlnaHQsXG4gICAgJzwnOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgPCByaWdodCxcbiAgICAnPDwnOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgPDwgcmlnaHQsXG4gICAgJzw9JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0IDw9IHJpZ2h0LFxuICAgICc9PSc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA9PSByaWdodCxcbiAgICAnPT09JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ID09PSByaWdodCxcbiAgICAnPic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA+IHJpZ2h0LFxuICAgICc+PSc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA+PSByaWdodCxcbiAgICAnPj4nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgPj4gcmlnaHQsXG4gICAgJz4+Pic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA+Pj4gcmlnaHQsXG4gICAgJ14nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgXiByaWdodCxcbiAgICBpbjogKCkgPT4gVW5rbm93blZhbHVlLFxuICAgIGluc3RhbmNlb2Y6ICgpID0+IFVua25vd25WYWx1ZSxcbiAgICAnfCc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCB8IHJpZ2h0XG59O1xuY2xhc3MgQmluYXJ5RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7IH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICBjb25zdCBsZWZ0VmFsdWUgPSB0aGlzLmxlZnQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIGlmIChsZWZ0VmFsdWUgPT09IFVua25vd25WYWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB0aGlzLnJpZ2h0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICBpZiAocmlnaHRWYWx1ZSA9PT0gVW5rbm93blZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3JGbiA9IGJpbmFyeU9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXTtcbiAgICAgICAgaWYgKCFvcGVyYXRvckZuKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yRm4obGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIC8vIHN1cHBvcnQgc29tZSBpbXBsaWNpdCB0eXBlIGNvZXJjaW9uIHJ1bnRpbWUgZXJyb3JzXG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnKycgJiZcbiAgICAgICAgICAgIHRoaXMucGFyZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvblN0YXRlbWVudCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIHRoaXMpID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gc3VwZXIuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICB0aGlzLmxlZnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSk7XG4gICAgICAgIHRoaXMucmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgQnJlYWtTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmxhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuYWRkKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBCUk9LRU5fRkxPV19FUlJPUl9SRVRVUk5fTEFCRUw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmJyZWFrcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IEJST0tFTl9GTE9XX0JSRUFLX0NPTlRJTlVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5pbmNsdWRlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IHRoaXMubGFiZWwgPyBCUk9LRU5fRkxPV19FUlJPUl9SRVRVUk5fTEFCRUwgOiBCUk9LRU5fRkxPV19CUkVBS19DT05USU5VRTtcbiAgICB9XG59XG5cbmNsYXNzIExpdGVyYWwgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKCkgeyB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgLy8gdW5rbm93biBsaXRlcmFscyBjYW4gYWxzbyBiZSBudWxsIGJ1dCBkbyBub3Qgc3RhcnQgd2l0aCBhbiBcIm5cIlxuICAgICAgICAgICAgKHRoaXMudmFsdWUgPT09IG51bGwgJiYgdGhpcy5jb250ZXh0LmNvZGUuY2hhckNvZGVBdCh0aGlzLnN0YXJ0KSAhPT0gMTEwKSB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMudmFsdWUgPT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICAvLyB0byBzdXBwb3J0IHNoaW1zIGZvciByZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29kZS5jaGFyQ29kZUF0KHRoaXMuc3RhcnQpID09PSA0Nykge1xuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICByZXR1cm4gZ2V0TWVtYmVyUmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWQodGhpcy5tZW1iZXJzLCBwYXRoWzBdKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNNZW1iZXJFZmZlY3RXaGVuQ2FsbGVkKHRoaXMubWVtYmVycywgcGF0aFswXSwgY2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBnZXRMaXRlcmFsTWVtYmVyc0ZvclZhbHVlKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZXNUcmVlTm9kZS52YWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleCA9IGVzVHJlZU5vZGUucmVnZXg7XG4gICAgICAgIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29kZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMucHVzaChbdGhpcy5zdGFydCArIDEsIHRoaXMuZW5kIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUbyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25zXG5jb25zdCBNQVhfUEFUSF9ERVBUSCA9IDc7XG5mdW5jdGlvbiBnZXRSZXNvbHZhYmxlUHJvcGVydHlLZXkobWVtYmVyRXhwcmVzc2lvbikge1xuICAgIHJldHVybiBtZW1iZXJFeHByZXNzaW9uLmNvbXB1dGVkXG4gICAgICAgID8gZ2V0UmVzb2x2YWJsZUNvbXB1dGVkUHJvcGVydHlLZXkobWVtYmVyRXhwcmVzc2lvbi5wcm9wZXJ0eSlcbiAgICAgICAgOiBtZW1iZXJFeHByZXNzaW9uLnByb3BlcnR5Lm5hbWU7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZhYmxlQ29tcHV0ZWRQcm9wZXJ0eUtleShwcm9wZXJ0eUtleSkge1xuICAgIGlmIChwcm9wZXJ0eUtleSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwcm9wZXJ0eUtleS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGF0aElmTm90Q29tcHV0ZWQobWVtYmVyRXhwcmVzc2lvbikge1xuICAgIGNvbnN0IG5leHRQYXRoS2V5ID0gbWVtYmVyRXhwcmVzc2lvbi5wcm9wZXJ0eUtleTtcbiAgICBjb25zdCBvYmplY3QgPSBtZW1iZXJFeHByZXNzaW9uLm9iamVjdDtcbiAgICBpZiAodHlwZW9mIG5leHRQYXRoS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IGtleTogb2JqZWN0Lm5hbWUsIHBvczogb2JqZWN0LnN0YXJ0IH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6IG5leHRQYXRoS2V5LCBwb3M6IG1lbWJlckV4cHJlc3Npb24ucHJvcGVydHkuc3RhcnQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWVtYmVyRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGdldFBhdGhJZk5vdENvbXB1dGVkKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmVudFBhdGggJiYgWy4uLnBhcmVudFBhdGgsIHsga2V5OiBuZXh0UGF0aEtleSwgcG9zOiBtZW1iZXJFeHByZXNzaW9uLnByb3BlcnR5LnN0YXJ0IH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN0cmluZ0Zyb21QYXRoKHBhdGgpIHtcbiAgICBsZXQgcGF0aFN0cmluZyA9IHBhdGhbMF0ua2V5O1xuICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBwYXRoLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwYXRoU3RyaW5nICs9ICcuJyArIHBhdGhbaW5kZXhdLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhTdHJpbmc7XG59XG5jbGFzcyBNZW1iZXJFeHByZXNzaW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXBsYWNlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGJpbmQoKSB7XG4gICAgICAgIHRoaXMuYm91bmQgPSB0cnVlO1xuICAgICAgICBjb25zdCBwYXRoID0gZ2V0UGF0aElmTm90Q29tcHV0ZWQodGhpcyk7XG4gICAgICAgIGNvbnN0IGJhc2VWYXJpYWJsZSA9IHBhdGggJiYgdGhpcy5zY29wZS5maW5kVmFyaWFibGUocGF0aFswXS5rZXkpO1xuICAgICAgICBpZiAoYmFzZVZhcmlhYmxlICYmIGJhc2VWYXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRWYXJpYWJsZSA9IHRoaXMucmVzb2x2ZU5hbWVzcGFjZVZhcmlhYmxlcyhiYXNlVmFyaWFibGUsIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuYmluZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc29sdmVkVmFyaWFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlbWVudCA9IHJlc29sdmVkVmFyaWFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlID0gcmVzb2x2ZWRWYXJpYWJsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmFkZE5hbWVzcGFjZU1lbWJlckFjY2VzcyhnZXRTdHJpbmdGcm9tUGF0aChwYXRoKSwgcmVzb2x2ZWRWYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5iaW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9IHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUtleSA9IFVua25vd25LZXk7XG4gICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dOYW1lc3BhY2VSZWFzc2lnbm1lbnQoKTtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMucmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IE1BWF9QQVRIX0RFUFRIKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3QuZGVvcHRpbWl6ZVBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwgLi4ucGF0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwgLi4ucGF0aF0sIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1BhcmFtZXRlci5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChvcmlnaW4pO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgTUFYX1BBVEhfREVQVEgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLCAuLi5wYXRoXSwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9wZXJ0eS5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICAvLyBBc3NpZ25tZW50cyBkbyBub3QgYWNjZXNzIHRoZSBwcm9wZXJ0eSBiZWZvcmUgYXNzaWduaW5nXG4gICAgICAgICAgICAoISh0aGlzLnZhcmlhYmxlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlbWVudCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIEFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHRoaXMucGFyZW50Lm9wZXJhdG9yID09PSAnPScpKSAmJlxuICAgICAgICAgICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgKHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzID09PSAnYWx3YXlzJyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdC5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKFt0aGlzLmdldFByb3BlcnR5S2V5KCldLCBjb250ZXh0KSkpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0Lmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwgLi4ucGF0aF0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IE1BWF9QQVRIX0RFUFRIKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLCAuLi5wYXRoXSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IE1BWF9QQVRIX0RFUFRIKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwgLi4ucGF0aF0sIGNhbGxPcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh0aGlzLnZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9iamVjdC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBnZXRSZXNvbHZhYmxlUHJvcGVydHlLZXkodGhpcyk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkUGFyZW50VHlwZSwgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50LCByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgfHwgdGhpcy5yZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdGhpcy52YXJpYWJsZSA/IHRoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcykgOiB0aGlzLnJlcGxhY2VtZW50O1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkUGFyZW50VHlwZSAmJiBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQpXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAnMCwgJyArIHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIHJlcGxhY2VtZW50LCB7XG4gICAgICAgICAgICAgICAgY29udGVudE9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RvcmVOYW1lOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFBhcmVudFR5cGUgJiYgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRSaWdodCh0aGlzLnN0YXJ0LCAnMCwgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gTmFtZXNwYWNlcyBhcmUgbm90IGJvdW5kIGFuZCBzaG91bGQgbm90IGJlIGRlb3B0aW1pemVkXG4gICAgICAgIHRoaXMuYm91bmQgJiZcbiAgICAgICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAhKHRoaXMudmFyaWFibGUgfHwgdGhpcy5yZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgQXNzaWdubWVudHMgZG8gbm90IGFjY2VzcyB0aGUgcHJvcGVydHkgYmVmb3JlIGFzc2lnbmluZ1xuICAgICAgICAgICAgaWYgKCEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBBc3NpZ25tZW50RXhwcmVzc2lvbiAmJiB0aGlzLnBhcmVudC5vcGVyYXRvciA9PT0gJz0nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChFVkVOVF9BQ0NFU1NFRCwgW3RoaXMucHJvcGVydHlLZXldLCB0aGlzLm9iamVjdCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIEFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3QuZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKEVWRU5UX0FTU0lHTkVELCBbdGhpcy5wcm9wZXJ0eUtleV0sIHRoaXMub2JqZWN0LCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhbGxvd05hbWVzcGFjZVJlYXNzaWdubWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0IGluc3RhbmNlb2YgSWRlbnRpZmllcikge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZSh0aGlzLm9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh0aGlzLnZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lndhcm4oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnSUxMRUdBTF9OQU1FU1BBQ0VfUkVBU1NJR05NRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYElsbGVnYWwgcmVhc3NpZ25tZW50IHRvIGltcG9ydCAnJHt0aGlzLm9iamVjdC5uYW1lfSdgXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5S2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gVW5rbm93bktleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wZXJ0eS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm9wZXJ0eUtleSA9IHZhbHVlID09PSBVbmtub3duVmFsdWUgPyBVbmtub3duS2V5IDogU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHlLZXk7XG4gICAgfVxuICAgIHJlc29sdmVOYW1lc3BhY2VWYXJpYWJsZXMoYmFzZVZhcmlhYmxlLCBwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBiYXNlVmFyaWFibGU7XG4gICAgICAgIGlmICghYmFzZVZhcmlhYmxlLmlzTmFtZXNwYWNlIHx8IGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4dGVybmFsVmFyaWFibGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IHBhdGhbMF0ua2V5O1xuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGJhc2VWYXJpYWJsZS5jb250ZXh0LnRyYWNlRXhwb3J0KGV4cG9ydE5hbWUpO1xuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGJhc2VWYXJpYWJsZS5jb250ZXh0LmZpbGVOYW1lO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lndhcm4oe1xuICAgICAgICAgICAgICAgIGNvZGU6ICdNSVNTSU5HX0VYUE9SVCcsXG4gICAgICAgICAgICAgICAgZXhwb3J0ZXI6IHJlbGF0aXZlSWQoZmlsZU5hbWUpLFxuICAgICAgICAgICAgICAgIGltcG9ydGVyOiByZWxhdGl2ZUlkKHRoaXMuY29udGV4dC5maWxlTmFtZSksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCcke2V4cG9ydE5hbWV9JyBpcyBub3QgZXhwb3J0ZWQgYnkgJyR7cmVsYXRpdmVJZChmaWxlTmFtZSl9J2AsXG4gICAgICAgICAgICAgICAgbWlzc2luZzogZXhwb3J0TmFtZSxcbiAgICAgICAgICAgICAgICB1cmw6IGBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jZXJyb3ItbmFtZS1pcy1ub3QtZXhwb3J0ZWQtYnktbW9kdWxlYFxuICAgICAgICAgICAgfSwgcGF0aFswXS5wb3MpO1xuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVOYW1lc3BhY2VWYXJpYWJsZXModmFyaWFibGUsIHBhdGguc2xpY2UoMSkpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FsbEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9uID0gbnVsbDtcbiAgICB9XG4gICAgYmluZCgpIHtcbiAgICAgICAgc3VwZXIuYmluZCgpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKHRoaXMuY2FsbGVlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lndhcm4oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnQ0FOTk9UX0NBTExfTkFNRVNQQUNFJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjYWxsIGEgbmFtZXNwYWNlICgnJHt0aGlzLmNhbGxlZS5uYW1lfScpYFxuICAgICAgICAgICAgICAgIH0sIHRoaXMuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVlLm5hbWUgPT09ICdldmFsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC53YXJuKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ0VWQUwnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVXNlIG9mIGV2YWwgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQsIGFzIGl0IHBvc2VzIHNlY3VyaXR5IHJpc2tzIGFuZCBtYXkgY2F1c2UgaXNzdWVzIHdpdGggbWluaWZpY2F0aW9uYCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI2F2b2lkaW5nLWV2YWwnXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuYXJndW1lbnRzLFxuICAgICAgICAgICAgdGhpc1BhcmFtOiB0aGlzLmNhbGxlZSBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gJiYgIXRoaXMuY2FsbGVlLnZhcmlhYmxlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNhbGxlZS5vYmplY3RcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB3aXRoTmV3OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHVybkV4cHJlc3Npb24gIT09IFVOS05PV05fRVhQUkVTU0lPTikge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9uID0gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVvcHRpbWl6YXRpb25UcmFja2VyLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAocmV0dXJuRXhwcmVzc2lvbiAhPT0gVU5LTk9XTl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICByZXR1cm5FeHByZXNzaW9uLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICBjb25zdCByZXR1cm5FeHByZXNzaW9uID0gdGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICBpZiAocmV0dXJuRXhwcmVzc2lvbiA9PT0gVU5LTk9XTl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICB0aGlzUGFyYW1ldGVyLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWN1cnNpb25UcmFja2VyLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIHJldHVybkV4cHJlc3Npb24sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLmFkZCh0aGlzUGFyYW1ldGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm5FeHByZXNzaW9uLmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgcmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbihyZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgaWYgKHJldHVybkV4cHJlc3Npb24gPT09IFVOS05PV05fRVhQUkVTU0lPTikge1xuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdXJzaW9uVHJhY2tlci53aXRoVHJhY2tlZEVudGl0eUF0UGF0aChwYXRoLCByZXR1cm5FeHByZXNzaW9uLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlb3B0aW1pemFibGVEZXBlbmRlbnRFeHByZXNzaW9ucy5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuRXhwcmVzc2lvbi5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgfSwgVW5rbm93blZhbHVlKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICBjb25zdCByZXR1cm5FeHByZXNzaW9uID0gdGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5FeHByZXNzaW9uID09PSBVTktOT1dOX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2lvblRyYWNrZXIud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgocGF0aCwgcmV0dXJuRXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkV4cHJlc3Npb24uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH0sIFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiB0aGlzLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UuYW5ub3RhdGlvbnMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jYWxsZWUuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVlLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKEVNUFRZX1BBVEgsIHRoaXMuY2FsbE9wdGlvbnMsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoIWNvbnRleHQuYWNjZXNzZWQudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgdGhpcykgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICghY29udGV4dC5hc3NpZ25lZC50cmFja0VudGl0eUF0UGF0aEFuZEdldElmVHJhY2tlZChwYXRoLCB0aGlzKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKCkuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoIShjYWxsT3B0aW9ucy53aXRoTmV3ID8gY29udGV4dC5pbnN0YW50aWF0ZWQgOiBjb250ZXh0LmNhbGxlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgY2FsbE9wdGlvbnMsIHRoaXMpICYmXG4gICAgICAgICAgICB0aGlzLmdldFJldHVybkV4cHJlc3Npb24oKS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSA9PT0gSU5DTFVERV9QQVJBTUVURVJTICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsZWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsZWUudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZS52YXJpYWJsZS5tYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZS5pbmNsdWRlKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxlZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCB0aGlzLmFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IHJldHVybkV4cHJlc3Npb24gPSB0aGlzLmdldFJldHVybkV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKCFyZXR1cm5FeHByZXNzaW9uLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICByZXR1cm5FeHByZXNzaW9uLmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICB0aGlzLmNhbGxlZS5yZW5kZXIoY29kZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmd1bWVudHNbdGhpcy5hcmd1bWVudHMubGVuZ3RoIC0gMV0uaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiB0aGlzLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBhcmcucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0SW5jbHVkZWRJbmRleCA9IHRoaXMuYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RJbmNsdWRlZEluZGV4ID49IDAgJiYgIXRoaXMuYXJndW1lbnRzW2xhc3RJbmNsdWRlZEluZGV4XS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0SW5jbHVkZWRJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdEluY2x1ZGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDw9IGxhc3RJbmNsdWRlZEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50c1tpbmRleF0ucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnLCcsIHRoaXMuYXJndW1lbnRzW2xhc3RJbmNsdWRlZEluZGV4XS5lbmQpLCB0aGlzLmVuZCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwsICcoJywgdGhpcy5jYWxsZWUuZW5kKSArIDEsIHRoaXMuZW5kIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB0aGlzUGFyYW0gfSA9IHRoaXMuY2FsbE9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzUGFyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVlLmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChFVkVOVF9DQUxMRUQsIEVNUFRZX1BBVEgsIHRoaXNQYXJhbSwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHRoaXMuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIGFsbCBwcm9wZXJ0aWVzIG9mIHBhcmFtZXRlcnMgYmVoYXZlIGFzIFwidW5rbm93blwiXG4gICAgICAgICAgICBhcmd1bWVudC5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb24ocmVjdXJzaW9uVHJhY2tlciA9IFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUikge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5FeHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb24gPSBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuY2FsbGVlLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKEVNUFRZX1BBVEgsIHRoaXMuY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXR1cm5FeHByZXNzaW9uO1xuICAgIH1cbn1cblxuY2xhc3MgQ2F0Y2hTY29wZSBleHRlbmRzIFBhcmFtZXRlclNjb3BlIHtcbiAgICBhZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBpc0hvaXN0ZWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbWV0ZXIgPSB0aGlzLnZhcmlhYmxlcy5nZXQoaWRlbnRpZmllci5uYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUGFyYW1ldGVyKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSBzdGlsbCBjcmVhdGUgYSBob2lzdGVkIGRlY2xhcmF0aW9uLCB0aGUgaW5pdGlhbGl6ZXIgZ29lcyB0b1xuICAgICAgICAgICAgLy8gdGhlIHBhcmFtZXRlci4gTm90ZSB0aGF0IHRlY2huaWNhbGx5LCB0aGUgZGVjbGFyYXRpb24gbm93IGJlbG9uZ3MgdG9cbiAgICAgICAgICAgIC8vIHR3byB2YXJpYWJsZXMsIHdoaWNoIGlzIG5vdCBjb3JyZWN0IGJ1dCBzaG91bGQgbm90IGNhdXNlIGlzc3Vlcy5cbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIFVOREVGSU5FRF9FWFBSRVNTSU9OLCBpc0hvaXN0ZWQpO1xuICAgICAgICAgICAgZXhpc3RpbmdQYXJhbWV0ZXIuYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgaW5pdCk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdQYXJhbWV0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGlzSG9pc3RlZCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYXRjaENsYXVzZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IENhdGNoU2NvcGUocGFyZW50U2NvcGUsIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIC8vIFBhcmFtZXRlcnMgbmVlZCB0byBiZSBkZWNsYXJlZCBmaXJzdCBhcyB0aGUgbG9naWMgaXMgdGhhdCBpbml0aWFsaXplcnNcbiAgICAgICAgLy8gb2YgaG9pc3RlZCBib2R5IHZhcmlhYmxlcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHBhcmFtZXRlcnMgb2YgdGhlIHNhbWVcbiAgICAgICAgLy8gbmFtZSBpbnN0ZWFkIG9mIHRoZSB2YXJpYWJsZVxuICAgICAgICBjb25zdCB7IHBhcmFtIH0gPSBlc1RyZWVOb2RlO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW0gPSBuZXcgKHRoaXMuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IocGFyYW0udHlwZSkpKHBhcmFtLCB0aGlzLCB0aGlzLnNjb3BlKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW0uZGVjbGFyZSgncGFyYW1ldGVyJywgVU5LTk9XTl9FWFBSRVNTSU9OKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxufVxuXG5jbGFzcyBDaGFpbkV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIENsYXNzQm9keVNjb3BlIGV4dGVuZHMgQ2hpbGRTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjbGFzc05vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KCd0aGlzJywgKHRoaXMudGhpc1ZhcmlhYmxlID0gbmV3IExvY2FsVmFyaWFibGUoJ3RoaXMnLCBudWxsLCBjbGFzc05vZGUsIGNvbnRleHQpKSk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VTY29wZSA9IG5ldyBDaGlsZFNjb3BlKHRoaXMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlU2NvcGUudmFyaWFibGVzLnNldCgndGhpcycsIG5ldyBUaGlzVmFyaWFibGUoY29udGV4dCkpO1xuICAgIH1cbiAgICBmaW5kTGV4aWNhbEJvdW5kYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIENsYXNzQm9keSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IENsYXNzQm9keVNjb3BlKHBhcmVudFNjb3BlLCB0aGlzLnBhcmVudCwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMuc2NvcGUudGhpc1ZhcmlhYmxlKTtcbiAgICAgICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBjb25zdCBib2R5ID0gKHRoaXMuYm9keSA9IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIGVzVHJlZU5vZGUuYm9keSkge1xuICAgICAgICAgICAgYm9keS5wdXNoKG5ldyAodGhpcy5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uLnR5cGUpKShkZWZpbml0aW9uLCB0aGlzLCBkZWZpbml0aW9uLnN0YXRpYyA/IHRoaXMuc2NvcGUgOiB0aGlzLnNjb3BlLmluc3RhbmNlU2NvcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxufVxuXG5jbGFzcyBNZXRob2RCYXNlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFjY2Vzc2VkVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmFjY2Vzc29yQ2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcmdzOiBOT19BUkdTLFxuICAgICAgICAgICAgdGhpc1BhcmFtOiBudWxsLFxuICAgICAgICAgICAgd2l0aE5ldzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXMgZ2V0dGVyIHByb3BlcnRpZXMgZGlyZWN0bHkgcmVjZWl2ZSB0aGVpciB2YWx1ZXMgZnJvbSBmaXhlZCBmdW5jdGlvblxuICAgIC8vIGV4cHJlc3Npb25zLCB0aGVyZSBpcyBubyBrbm93biBzaXR1YXRpb24gd2hlcmUgYSBnZXR0ZXIgaXMgZGVvcHRpbWl6ZWQuXG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkgeyB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIGlmIChldmVudCA9PT0gRVZFTlRfQUNDRVNTRUQgJiYgdGhpcy5raW5kID09PSAnZ2V0JyAmJiBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKEVWRU5UX0NBTExFRCwgRU1QVFlfUEFUSCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50ID09PSBFVkVOVF9BU1NJR05FRCAmJiB0aGlzLmtpbmQgPT09ICdzZXQnICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoRVZFTlRfQ0FMTEVELCBFTVBUWV9QQVRILCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NlZFZhbHVlKCkuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXkuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdnZXQnICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmFjY2Vzc29yQ2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKEVNUFRZX1BBVEgsIHRoaXMuYWNjZXNzb3JDYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjZXNzZWRWYWx1ZSgpLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIGdldEFjY2Vzc2VkVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc2VkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NlZFZhbHVlID0gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5hY2Nlc3NlZFZhbHVlID0gdGhpcy52YWx1ZS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmFjY2Vzc29yQ2FsbE9wdGlvbnMsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFjY2Vzc2VkVmFsdWUgPSB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NlZFZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgTWV0aG9kRGVmaW5pdGlvbiBleHRlbmRzIE1ldGhvZEJhc2Uge1xufVxuXG5jbGFzcyBPYmplY3RNZW1iZXIgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihvYmplY3QsIGtleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5vYmplY3QuZGVvcHRpbWl6ZVBhdGgoW3RoaXMua2V5LCAuLi5wYXRoXSk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLm9iamVjdC5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIFt0aGlzLmtleSwgLi4ucGF0aF0sIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoW3RoaXMua2V5LCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoW3RoaXMua2V5LCAuLi5wYXRoXSwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKFt0aGlzLmtleSwgLi4ucGF0aF0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0Lmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgoW3RoaXMua2V5LCAuLi5wYXRoXSwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChbdGhpcy5rZXksIC4uLnBhdGhdLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc05vZGUgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub2JqZWN0RW50aXR5ID0gbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBDaGlsZFNjb3BlKHBhcmVudFNjb3BlKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBbGxQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGluaXRFZmZlY3QgPSAoKF9hID0gdGhpcy5zdXBlckNsYXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzRWZmZWN0cyhjb250ZXh0KSkgfHwgdGhpcy5ib2R5Lmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgICAgIChfYiA9IHRoaXMuaWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCk7XG4gICAgICAgIHJldHVybiBpbml0RWZmZWN0IHx8IHN1cGVyLmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKCFjYWxsT3B0aW9ucy53aXRoTmV3IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuY2xhc3NDb25zdHJ1Y3RvciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuY2xhc3NDb25zdHJ1Y3Rvci5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCBjYWxsT3B0aW9ucywgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnN1cGVyQ2xhc3MgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcy5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIChfYSA9IHRoaXMuc3VwZXJDbGFzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMuaWQuaW5jbHVkZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5pZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY2xhcmUoJ2NsYXNzJywgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHRoaXMuYm9keS5ib2R5KSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kIGluc3RhbmNlb2YgTWV0aG9kRGVmaW5pdGlvbiAmJiBtZXRob2Qua2luZCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NDb25zdHJ1Y3RvciA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGFzc0NvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0T2JqZWN0RW50aXR5KCkge1xuICAgICAgICBpZiAodGhpcy5vYmplY3RFbnRpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWNNZXRob2RzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiB0aGlzLmJvZHkuYm9keSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRlZmluaXRpb24uc3RhdGljID8gc3RhdGljUHJvcGVydGllcyA6IGR5bmFtaWNNZXRob2RzO1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbktpbmQgPSBkZWZpbml0aW9uLmtpbmQ7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgY2xhc3MgZmllbGRzIGRvIG5vdCBlbmQgdXAgb24gdGhlIHByb3RvdHlwZVxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IGR5bmFtaWNNZXRob2RzICYmICFkZWZpbml0aW9uS2luZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBkZWZpbml0aW9uS2luZCA9PT0gJ3NldCcgfHwgZGVmaW5pdGlvbktpbmQgPT09ICdnZXQnID8gZGVmaW5pdGlvbktpbmQgOiAnaW5pdCc7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlWYWx1ZSA9IGRlZmluaXRpb24ua2V5LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZSA9PT0gVW5rbm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh7IGtleTogVW5rbm93bktleSwga2luZCwgcHJvcGVydHk6IGRlZmluaXRpb24gfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gU3RyaW5nKGtleVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPVxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmtleSBpbnN0YW5jZW9mIElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGVmaW5pdGlvbi5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZGVmaW5pdGlvbi5rZXkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHsga2V5LCBraW5kLCBwcm9wZXJ0eTogZGVmaW5pdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWNQcm9wZXJ0aWVzLnVuc2hpZnQoe1xuICAgICAgICAgICAga2V5OiAncHJvdG90eXBlJyxcbiAgICAgICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgICAgIHByb3BlcnR5OiBuZXcgT2JqZWN0RW50aXR5KGR5bmFtaWNNZXRob2RzLCB0aGlzLnN1cGVyQ2xhc3MgPyBuZXcgT2JqZWN0TWVtYmVyKHRoaXMuc3VwZXJDbGFzcywgJ3Byb3RvdHlwZScpIDogT0JKRUNUX1BST1RPVFlQRSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAodGhpcy5vYmplY3RFbnRpdHkgPSBuZXcgT2JqZWN0RW50aXR5KHN0YXRpY1Byb3BlcnRpZXMsIHRoaXMuc3VwZXJDbGFzcyB8fCBPQkpFQ1RfUFJPVE9UWVBFKSk7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc0RlY2xhcmF0aW9uIGV4dGVuZHMgQ2xhc3NOb2RlIHtcbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkLnZhcmlhYmxlLmlzSWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGlmIChlc1RyZWVOb2RlLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gbmV3IElkZW50aWZpZXIoZXNUcmVlTm9kZS5pZCwgdGhpcywgdGhpcy5zY29wZS5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIGZvcm1hdCwgc25pcHBldHM6IHsgXyB9IH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnc3lzdGVtJyAmJiB0aGlzLmlkICYmIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXModGhpcy5pZC52YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCwgYCR7X30ke2dldFN5c3RlbUV4cG9ydFN0YXRlbWVudChbdGhpcy5pZC52YXJpYWJsZV0sIG9wdGlvbnMpfTtgKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc0V4cHJlc3Npb24gZXh0ZW5kcyBDbGFzc05vZGUge1xuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCA9PT0gRXhwcmVzc2lvblN0YXRlbWVudCQxKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZFJpZ2h0KHRoaXMuc3RhcnQsICcoJyk7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuZW5kLCAnKScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBNdWx0aUV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlFeHByZXNzaW9uKHRoaXMuZXhwcmVzc2lvbnMubWFwKGV4cHJlc3Npb24gPT4gZXhwcmVzc2lvbi5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgcmVsZXZhbnQgdG8gaW5jbHVkZSB2YWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBhbiBBU1QgcmVwcmVzZW50YXRpb24sXG4gICAgICAgIC8vIHN1Y2ggYXMgVW5rbm93bkFycmF5RXhwcmVzc2lvbi4gVGh1cyB3ZSBvbmx5IG5lZWQgdG8gaW5jbHVkZSB0aGVtIG9uY2UuXG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBpZiAoIWV4cHJlc3Npb24uaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb25kaXRpb25hbEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPSBudWxsO1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZWRCcmFuY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZEJyYW5jaCA9IHRoaXMudXNlZEJyYW5jaCA9PT0gdGhpcy5jb25zZXF1ZW50ID8gdGhpcy5hbHRlcm5hdGUgOiB0aGlzLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPSBudWxsO1xuICAgICAgICAgICAgdW51c2VkQnJhbmNoLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIHRoaXMuY29uc2VxdWVudC5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB0aGlzLmFsdGVybmF0ZS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2ggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAodXNlZEJyYW5jaCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbiksXG4gICAgICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAodXNlZEJyYW5jaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc2VxdWVudC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8IHRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25zZXF1ZW50Lmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlZEJyYW5jaC5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAodXNlZEJyYW5jaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbnNlcXVlbnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25zZXF1ZW50Lmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCB0aGlzLnRlc3Quc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSB8fCB1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncykge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50LCBwcmV2ZW50QVNJLCByZW5kZXJlZFBhcmVudFR5cGUsIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICghdGhpcy50ZXN0LmluY2x1ZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvblBvcyA9IGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnOicsIHRoaXMuY29uc2VxdWVudC5lbmQpO1xuICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9uU3RhcnQgPSBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCAodGhpcy5jb25zZXF1ZW50LmluY2x1ZGVkXG4gICAgICAgICAgICAgICAgPyBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJz8nLCB0aGlzLnRlc3QuZW5kKVxuICAgICAgICAgICAgICAgIDogY29sb25Qb3MpICsgMSk7XG4gICAgICAgICAgICBpZiAocHJldmVudEFTSSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpbmVCcmVha3MoY29kZSwgaW5jbHVzaW9uU3RhcnQsIHVzZWRCcmFuY2guc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgaW5jbHVzaW9uU3RhcnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc2VxdWVudC5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGNvbG9uUG9zLCB0aGlzLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVBbm5vdGF0aW9ucyh0aGlzLCBjb2RlKTtcbiAgICAgICAgICAgIHVzZWRCcmFuY2gucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudEFTSTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHJlbmRlcmVkUGFyZW50VHlwZSB8fCB0aGlzLnBhcmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB8fCB0aGlzLnBhcmVudC50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGVzdC5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXNlZEJyYW5jaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZWRCcmFuY2g7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IHRoaXMudGVzdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRlc3RWYWx1ZSA9PT0gVW5rbm93blZhbHVlXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogKHRoaXMudXNlZEJyYW5jaCA9IHRlc3RWYWx1ZSA/IHRoaXMuY29uc2VxdWVudCA6IHRoaXMuYWx0ZXJuYXRlKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRpbnVlU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0Lmlnbm9yZS5sYWJlbHMuaGFzKHRoaXMubGFiZWwubmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gQlJPS0VOX0ZMT1dfRVJST1JfUkVUVVJOX0xBQkVMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0Lmlnbm9yZS5jb250aW51ZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBCUk9LRU5fRkxPV19CUkVBS19DT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWwuaW5jbHVkZSgpO1xuICAgICAgICAgICAgY29udGV4dC5pbmNsdWRlZExhYmVscy5hZGQodGhpcy5sYWJlbC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSB0aGlzLmxhYmVsID8gQlJPS0VOX0ZMT1dfRVJST1JfUkVUVVJOX0xBQkVMIDogQlJPS0VOX0ZMT1dfQlJFQUtfQ09OVElOVUU7XG4gICAgfVxufVxuXG5jbGFzcyBEb1doaWxlU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93LCBpZ25vcmU6IHsgYnJlYWtzLCBjb250aW51ZXMgfSB9ID0gY29udGV4dDtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuYnJlYWtzID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuY29udGludWVzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmJyZWFrcyA9IGJyZWFrcztcbiAgICAgICAgY29udGV4dC5pZ25vcmUuY29udGludWVzID0gY29udGludWVzO1xuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICB9XG59XG5cbmNsYXNzIEVtcHR5U3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIEV4cG9ydEFsbERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIF9vcHRpb25zLCBub2RlUmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb2RlLnJlbW92ZShub2RlUmVuZGVyT3B0aW9ucy5zdGFydCwgbm9kZVJlbmRlck9wdGlvbnMuZW5kKTtcbiAgICB9XG59XG5FeHBvcnRBbGxEZWNsYXJhdGlvbi5wcm90b3R5cGUubmVlZHNCb3VuZGFyaWVzID0gdHJ1ZTtcblxuY2xhc3MgRnVuY3Rpb25EZWNsYXJhdGlvbiBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICBpZiAodGhpcy5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZC52YXJpYWJsZS5pc0lkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBpZiAoZXNUcmVlTm9kZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBJZGVudGlmaWVyKGVzVHJlZU5vZGUuaWQsIHRoaXMsIHRoaXMuc2NvcGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxufVxuXG4vLyBUaGUgaGVhZGVyIGVuZHMgYXQgdGhlIGZpcnN0IG5vbi13aGl0ZS1zcGFjZSBhZnRlciBcImRlZmF1bHRcIlxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25TdGFydChjb2RlLCBzdGFydCkge1xuICAgIHJldHVybiBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLCBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgJ2RlZmF1bHQnLCBzdGFydCkgKyA3KTtcbn1cbmZ1bmN0aW9uIGdldElkSW5zZXJ0UG9zaXRpb24oY29kZSwgZGVjbGFyYXRpb25LZXl3b3JkLCBlbmRNYXJrZXIsIHN0YXJ0KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25FbmQgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgZGVjbGFyYXRpb25LZXl3b3JkLCBzdGFydCkgKyBkZWNsYXJhdGlvbktleXdvcmQubGVuZ3RoO1xuICAgIGNvZGUgPSBjb2RlLnNsaWNlKGRlY2xhcmF0aW9uRW5kLCBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgZW5kTWFya2VyLCBkZWNsYXJhdGlvbkVuZCkpO1xuICAgIGNvbnN0IGdlbmVyYXRvclN0YXJQb3MgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgJyonKTtcbiAgICBpZiAoZ2VuZXJhdG9yU3RhclBvcyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gZGVjbGFyYXRpb25FbmQgKyBnZW5lcmF0b3JTdGFyUG9zICsgMTtcbn1cbmNsYXNzIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHN1cGVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh0aGlzLnZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZGVjbGFyYXRpb247XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25OYW1lID1cbiAgICAgICAgICAgIChkZWNsYXJhdGlvbi5pZCAmJiBkZWNsYXJhdGlvbi5pZC5uYW1lKSB8fCB0aGlzLmRlY2xhcmF0aW9uLm5hbWU7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB0aGlzLnNjb3BlLmFkZEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbih0aGlzLmRlY2xhcmF0aW9uTmFtZSB8fCB0aGlzLmNvbnRleHQuZ2V0TW9kdWxlTmFtZSgpLCB0aGlzLCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkRXhwb3J0KHRoaXMpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgbm9kZVJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBub2RlUmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb25TdGFydCA9IGdldERlY2xhcmF0aW9uU3RhcnQoY29kZS5vcmlnaW5hbCwgdGhpcy5zdGFydCk7XG4gICAgICAgIGlmICh0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJOYW1lZERlY2xhcmF0aW9uKGNvZGUsIGRlY2xhcmF0aW9uU3RhcnQsICdmdW5jdGlvbicsICcoJywgdGhpcy5kZWNsYXJhdGlvbi5pZCA9PT0gbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNsYXJhdGlvbiBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTmFtZWREZWNsYXJhdGlvbihjb2RlLCBkZWNsYXJhdGlvblN0YXJ0LCAnY2xhc3MnLCAneycsIHRoaXMuZGVjbGFyYXRpb24uaWQgPT09IG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFyaWFibGUuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpICE9PSB0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWx0b2dldGhlciB0byBwcmV2ZW50IHJlLWRlY2xhcmluZyB0aGUgc2FtZSB2YXJpYWJsZVxuICAgICAgICAgICAgdHJlZXNoYWtlTm9kZSh0aGlzLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclZhcmlhYmxlRGVjbGFyYXRpb24oY29kZSwgZGVjbGFyYXRpb25TdGFydCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCBkZWNsYXJhdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24ucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDogRXhwcmVzc2lvblN0YXRlbWVudCQxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2RlLm9yaWdpbmFsW3RoaXMuZW5kIC0gMV0gIT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCwgJzsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVuZGVyTmFtZWREZWNsYXJhdGlvbihjb2RlLCBkZWNsYXJhdGlvblN0YXJ0LCBkZWNsYXJhdGlvbktleXdvcmQsIGVuZE1hcmtlciwgbmVlZHNJZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgZm9ybWF0LCBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy52YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICAgICAgLy8gUmVtb3ZlIGBleHBvcnQgZGVmYXVsdGBcbiAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgZGVjbGFyYXRpb25TdGFydCk7XG4gICAgICAgIGlmIChuZWVkc0lkKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQoZ2V0SWRJbnNlcnRQb3NpdGlvbihjb2RlLm9yaWdpbmFsLCBkZWNsYXJhdGlvbktleXdvcmQsIGVuZE1hcmtlciwgZGVjbGFyYXRpb25TdGFydCksIGAgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdzeXN0ZW0nICYmXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiAmJlxuICAgICAgICAgICAgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh0aGlzLnZhcmlhYmxlKSkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCBgICR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KFt0aGlzLnZhcmlhYmxlXSwgb3B0aW9ucyl9O2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclZhcmlhYmxlRGVjbGFyYXRpb24oY29kZSwgZGVjbGFyYXRpb25TdGFydCwgeyBmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgc25pcHBldHM6IHsgY25zdCwgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9KSB7XG4gICAgICAgIGNvbnN0IGhhc1RyYWlsaW5nU2VtaWNvbG9uID0gY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kIC0gMSkgPT09IDU5OyAvKlwiO1wiKi9cbiAgICAgICAgY29uc3Qgc3lzdGVtRXhwb3J0TmFtZXMgPSBmb3JtYXQgPT09ICdzeXN0ZW0nICYmIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodGhpcy52YXJpYWJsZSk7XG4gICAgICAgIGlmIChzeXN0ZW1FeHBvcnROYW1lcykge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgZGVjbGFyYXRpb25TdGFydCwgYCR7Y25zdH0gJHt0aGlzLnZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSA9IGV4cG9ydHMoJyR7c3lzdGVtRXhwb3J0TmFtZXNbMF19JywgYCk7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZFJpZ2h0KGhhc1RyYWlsaW5nU2VtaWNvbG9uID8gdGhpcy5lbmQgLSAxIDogdGhpcy5lbmQsICcpJyArIChoYXNUcmFpbGluZ1NlbWljb2xvbiA/ICcnIDogJzsnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCBkZWNsYXJhdGlvblN0YXJ0LCBgJHtjbnN0fSAke3RoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyl9ID0gYCk7XG4gICAgICAgICAgICBpZiAoIWhhc1RyYWlsaW5nU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLnByb3RvdHlwZS5uZWVkc0JvdW5kYXJpZXMgPSB0cnVlO1xuXG5jbGFzcyBFeHBvcnROYW1lZERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIERvIG5vdCBiaW5kIHNwZWNpZmllcnNcbiAgICAgICAgaWYgKHRoaXMuZGVjbGFyYXRpb24gIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLmJpbmQoKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uICE9PSBudWxsICYmIHRoaXMuZGVjbGFyYXRpb24uaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIG5vZGVSZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gbm9kZVJlbmRlck9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLmRlY2xhcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHRoaXMuZGVjbGFyYXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbi5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBlbmQsIHN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuRXhwb3J0TmFtZWREZWNsYXJhdGlvbi5wcm90b3R5cGUubmVlZHNCb3VuZGFyaWVzID0gdHJ1ZTtcblxuY2xhc3MgRXhwb3J0U3BlY2lmaWVyIGV4dGVuZHMgTm9kZUJhc2Uge1xufVxuXG5jbGFzcyBGb3JJblN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBpZiAoKHRoaXMubGVmdCAmJlxuICAgICAgICAgICAgKHRoaXMubGVmdC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgoRU1QVFlfUEFUSCwgY29udGV4dCkpKSB8fFxuICAgICAgICAgICAgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5oYXNFZmZlY3RzKGNvbnRleHQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3csIGlnbm9yZTogeyBicmVha3MsIGNvbnRpbnVlcyB9IH0gPSBjb250ZXh0O1xuICAgICAgICBjb250ZXh0Lmlnbm9yZS5icmVha3MgPSB0cnVlO1xuICAgICAgICBjb250ZXh0Lmlnbm9yZS5jb250aW51ZXMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ib2R5Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuYnJlYWtzID0gYnJlYWtzO1xuICAgICAgICBjb250ZXh0Lmlnbm9yZS5jb250aW51ZXMgPSBjb250aW51ZXM7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxlZnQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCB0cnVlKTtcbiAgICAgICAgdGhpcy5yaWdodC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sZWZ0LnJlbmRlcihjb2RlLCBvcHRpb25zLCBOT19TRU1JQ09MT04pO1xuICAgICAgICB0aGlzLnJpZ2h0LnJlbmRlcihjb2RlLCBvcHRpb25zLCBOT19TRU1JQ09MT04pO1xuICAgICAgICAvLyBoYW5kbGUgbm8gc3BhY2UgYmV0d2VlbiBcImluXCIgYW5kIHRoZSByaWdodCBzaWRlXG4gICAgICAgIGlmIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5yaWdodC5zdGFydCAtIDEpID09PSAxMTAgLyogbiAqLykge1xuICAgICAgICAgICAgY29kZS5wcmVwZW5kTGVmdCh0aGlzLnJpZ2h0LnN0YXJ0LCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm9keS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY2xhc3MgRm9yT2ZTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBCbG9ja1Njb3BlKHBhcmVudFNjb3BlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICAvLyBQbGFjZWhvbGRlciB1bnRpbCBwcm9wZXIgU3ltYm9sLkl0ZXJhdG9yIHN1cHBvcnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucmlnaHQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5ib2R5LmluY2x1ZGVBc1NpbmdsZVN0YXRlbWVudChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVmdC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgdGhpcy5yaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgLy8gaGFuZGxlIG5vIHNwYWNlIGJldHdlZW4gXCJvZlwiIGFuZCB0aGUgcmlnaHQgc2lkZVxuICAgICAgICBpZiAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMucmlnaHQuc3RhcnQgLSAxKSA9PT0gMTAyIC8qIGYgKi8pIHtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5yaWdodC5zdGFydCwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVmdC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG59XG5cbmNsYXNzIEZvclN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCh0aGlzLmluaXQgJiYgdGhpcy5pbml0Lmhhc0VmZmVjdHMoY29udGV4dCkpIHx8XG4gICAgICAgICAgICAodGhpcy50ZXN0ICYmIHRoaXMudGVzdC5oYXNFZmZlY3RzKGNvbnRleHQpKSB8fFxuICAgICAgICAgICAgKHRoaXMudXBkYXRlICYmIHRoaXMudXBkYXRlLmhhc0VmZmVjdHMoY29udGV4dCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdywgaWdub3JlOiB7IGJyZWFrcywgY29udGludWVzIH0gfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmJyZWFrcyA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmNvbnRpbnVlcyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmJvZHkuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb250ZXh0Lmlnbm9yZS5icmVha3MgPSBicmVha3M7XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmNvbnRpbnVlcyA9IGNvbnRpbnVlcztcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pbml0KVxuICAgICAgICAgICAgdGhpcy5pbml0LmluY2x1ZGVBc1NpbmdsZVN0YXRlbWVudChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmICh0aGlzLnRlc3QpXG4gICAgICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIHRoaXMuYm9keS5pbmNsdWRlQXNTaW5nbGVTdGF0ZW1lbnQoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pbml0KVxuICAgICAgICAgICAgdGhpcy5pbml0LnJlbmRlcihjb2RlLCBvcHRpb25zLCBOT19TRU1JQ09MT04pO1xuICAgICAgICBpZiAodGhpcy50ZXN0KVxuICAgICAgICAgICAgdGhpcy50ZXN0LnJlbmRlcihjb2RlLCBvcHRpb25zLCBOT19TRU1JQ09MT04pO1xuICAgICAgICBpZiAodGhpcy51cGRhdGUpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgdGhpcy5ib2R5LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uRXhwcmVzc2lvbiBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSA9IEJMQU5LKSB7XG4gICAgICAgIHN1cGVyLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBFeHByZXNzaW9uU3RhdGVtZW50JDEpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5lbmQsICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFRyYWNraW5nU2NvcGUgZXh0ZW5kcyBCbG9ja1Njb3BlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ob2lzdGVkRGVjbGFyYXRpb25zID0gW107XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGlzSG9pc3RlZCkge1xuICAgICAgICB0aGlzLmhvaXN0ZWREZWNsYXJhdGlvbnMucHVzaChpZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGlzSG9pc3RlZCk7XG4gICAgfVxufVxuXG5jb25zdCB1bnNldCA9IFN5bWJvbCgndW5zZXQnKTtcbmNsYXNzIElmU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRlc3RWYWx1ZSA9IHVuc2V0O1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMudGVzdFZhbHVlID0gVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdC5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSB0aGlzLmdldFRlc3RWYWx1ZSgpO1xuICAgICAgICBpZiAodGVzdFZhbHVlID09PSBVbmtub3duVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnNlcXVlbnQuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnNlcXVlbnRCcm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93O1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9XG4gICAgICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93IDwgY29uc2VxdWVudEJyb2tlbkZsb3cgPyBjb250ZXh0LmJyb2tlbkZsb3cgOiBjb25zZXF1ZW50QnJva2VuRmxvdztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVzdFZhbHVlXG4gICAgICAgICAgICA/IHRoaXMuY29uc2VxdWVudC5oYXNFZmZlY3RzKGNvbnRleHQpXG4gICAgICAgICAgICA6IHRoaXMuYWx0ZXJuYXRlICE9PSBudWxsICYmIHRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlUmVjdXJzaXZlbHkoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gdGhpcy5nZXRUZXN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPT09IFVua25vd25WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jbHVkZVVua25vd25UZXN0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlS25vd25UZXN0KGNvbnRleHQsIHRlc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VOb2RlKGVzVHJlZU5vZGUpIHtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50U2NvcGUgPSBuZXcgVHJhY2tpbmdTY29wZSh0aGlzLnNjb3BlKTtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gbmV3ICh0aGlzLmNvbnRleHQuZ2V0Tm9kZUNvbnN0cnVjdG9yKGVzVHJlZU5vZGUuY29uc2VxdWVudC50eXBlKSkoZXNUcmVlTm9kZS5jb25zZXF1ZW50LCB0aGlzLCB0aGlzLmNvbnNlcXVlbnRTY29wZSk7XG4gICAgICAgIGlmIChlc1RyZWVOb2RlLmFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGVTY29wZSA9IG5ldyBUcmFja2luZ1Njb3BlKHRoaXMuc2NvcGUpO1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBuZXcgKHRoaXMuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IoZXNUcmVlTm9kZS5hbHRlcm5hdGUudHlwZSkpKGVzVHJlZU5vZGUuYWx0ZXJuYXRlLCB0aGlzLCB0aGlzLmFsdGVybmF0ZVNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gTm90ZSB0aGF0IHVua25vd24gdGVzdCB2YWx1ZXMgYXJlIGFsd2F5cyBpbmNsdWRlZFxuICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSB0aGlzLmdldFRlc3RWYWx1ZSgpO1xuICAgICAgICBjb25zdCBob2lzdGVkRGVjbGFyYXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IGluY2x1ZGVzSWZFbHNlID0gdGhpcy50ZXN0LmluY2x1ZGVkO1xuICAgICAgICBjb25zdCBub1RyZWVzaGFrZSA9ICF0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2U7XG4gICAgICAgIGlmIChpbmNsdWRlc0lmRWxzZSkge1xuICAgICAgICAgICAgdGhpcy50ZXN0LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHRoaXMuY29uc2VxdWVudC5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uc2VxdWVudC5pbmNsdWRlZCAmJiAobm9UcmVlc2hha2UgfHwgdGVzdFZhbHVlID09PSBVbmtub3duVmFsdWUgfHwgdGVzdFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuY29uc2VxdWVudC5zdGFydCwgdGhpcy5jb25zZXF1ZW50LmVuZCwgaW5jbHVkZXNJZkVsc2UgPyAnOycgOiAnJyk7XG4gICAgICAgICAgICBob2lzdGVkRGVjbGFyYXRpb25zLnB1c2goLi4udGhpcy5jb25zZXF1ZW50U2NvcGUuaG9pc3RlZERlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUuaW5jbHVkZWQgJiYgKG5vVHJlZXNoYWtlIHx8IHRlc3RWYWx1ZSA9PT0gVW5rbm93blZhbHVlIHx8ICF0ZXN0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzSWZFbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5hbHRlcm5hdGUuc3RhcnQgLSAxKSA9PT0gMTAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuYWx0ZXJuYXRlLnN0YXJ0LCAnICcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLmNvbnNlcXVlbnQuZW5kLCB0aGlzLmFsdGVybmF0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlc0lmRWxzZSAmJiB0aGlzLnNob3VsZEtlZXBBbHRlcm5hdGVCcmFuY2goKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmFsdGVybmF0ZS5zdGFydCwgdGhpcy5lbmQsICc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLmNvbnNlcXVlbnQuZW5kLCB0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvaXN0ZWREZWNsYXJhdGlvbnMucHVzaCguLi50aGlzLmFsdGVybmF0ZVNjb3BlLmhvaXN0ZWREZWNsYXJhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVySG9pc3RlZERlY2xhcmF0aW9ucyhob2lzdGVkRGVjbGFyYXRpb25zLCBjb2RlLCBnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgfVxuICAgIGdldFRlc3RWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdFZhbHVlID09PSB1bnNldCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnRlc3RWYWx1ZSA9IHRoaXMudGVzdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdFZhbHVlO1xuICAgIH1cbiAgICBpbmNsdWRlS25vd25UZXN0KGNvbnRleHQsIHRlc3RWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50ZXN0LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVzdFZhbHVlICYmIHRoaXMuY29uc2VxdWVudC5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUgIT09IG51bGwgJiYgIXRlc3RWYWx1ZSAmJiB0aGlzLmFsdGVybmF0ZS5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5pbmNsdWRlQXNTaW5nbGVTdGF0ZW1lbnQoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVSZWN1cnNpdmVseShpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIHRoaXMuY29uc2VxdWVudC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlVW5rbm93blRlc3QoY29udGV4dCkge1xuICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGNvbnNlcXVlbnRCcm9rZW5GbG93ID0gQlJPS0VOX0ZMT1dfTk9ORTtcbiAgICAgICAgaWYgKHRoaXMuY29uc2VxdWVudC5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnRCcm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93O1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUgIT09IG51bGwgJiYgdGhpcy5hbHRlcm5hdGUuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9XG4gICAgICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93IDwgY29uc2VxdWVudEJyb2tlbkZsb3cgPyBjb250ZXh0LmJyb2tlbkZsb3cgOiBjb25zZXF1ZW50QnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJIb2lzdGVkRGVjbGFyYXRpb25zKGhvaXN0ZWREZWNsYXJhdGlvbnMsIGNvZGUsIGdldFByb3BlcnR5QWNjZXNzKSB7XG4gICAgICAgIGNvbnN0IGhvaXN0ZWRWYXJzID0gW1xuICAgICAgICAgICAgLi4ubmV3IFNldChob2lzdGVkRGVjbGFyYXRpb25zLm1hcChpZGVudGlmaWVyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGlkZW50aWZpZXIudmFyaWFibGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLmluY2x1ZGVkID8gdmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcykgOiAnJztcbiAgICAgICAgICAgIH0pKVxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgaWYgKGhvaXN0ZWRWYXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gdGhpcy5wYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzQnJhY2VzID0gcGFyZW50VHlwZSAhPT0gUHJvZ3JhbSQxICYmIHBhcmVudFR5cGUgIT09IEJsb2NrU3RhdGVtZW50JDE7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodCh0aGlzLnN0YXJ0LCBgJHtuZWVkc0JyYWNlcyA/ICd7ICcgOiAnJ312YXIgJHtob2lzdGVkVmFyc307IGApO1xuICAgICAgICAgICAgaWYgKG5lZWRzQnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCBgIH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRLZWVwQWx0ZXJuYXRlQnJhbmNoKCkge1xuICAgICAgICBsZXQgY3VycmVudFBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCBpbnN0YW5jZW9mIElmU3RhdGVtZW50ICYmIGN1cnJlbnRQYXJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCBpbnN0YW5jZW9mIEJsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgSW1wb3J0RGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgLy8gRG8gbm90IGJpbmQgc3BlY2lmaWVyc1xuICAgIGJpbmQoKSB7IH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRJbXBvcnQodGhpcyk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBfb3B0aW9ucywgbm9kZVJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29kZS5yZW1vdmUobm9kZVJlbmRlck9wdGlvbnMuc3RhcnQsIG5vZGVSZW5kZXJPcHRpb25zLmVuZCk7XG4gICAgfVxufVxuSW1wb3J0RGVjbGFyYXRpb24ucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcyA9IHRydWU7XG5cbmNsYXNzIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNvbnN0IElOVEVST1BfREVGQVVMVF9WQVJJQUJMRSA9ICdfaW50ZXJvcERlZmF1bHQnO1xuY29uc3QgSU5URVJPUF9ERUZBVUxUX0xFR0FDWV9WQVJJQUJMRSA9ICdfaW50ZXJvcERlZmF1bHRMZWdhY3knO1xuY29uc3QgSU5URVJPUF9OQU1FU1BBQ0VfVkFSSUFCTEUgPSAnX2ludGVyb3BOYW1lc3BhY2UnO1xuY29uc3QgSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRSA9ICdfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQnO1xuY29uc3QgSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9PTkxZX1ZBUklBQkxFID0gJ19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdE9ubHknO1xuY29uc3QgTUVSR0VfTkFNRVNQQUNFU19WQVJJQUJMRSA9ICdfbWVyZ2VOYW1lc3BhY2VzJztcbmNvbnN0IGRlZmF1bHRJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGUgPSB7XG4gICAgYXV0bzogSU5URVJPUF9ERUZBVUxUX1ZBUklBQkxFLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgZGVmYXVsdE9ubHk6IG51bGwsXG4gICAgZXNNb2R1bGU6IG51bGwsXG4gICAgZmFsc2U6IG51bGwsXG4gICAgdHJ1ZTogSU5URVJPUF9ERUZBVUxUX0xFR0FDWV9WQVJJQUJMRVxufTtcbmNvbnN0IGlzRGVmYXVsdEFQcm9wZXJ0eSA9IChpbnRlcm9wVHlwZSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MpID0+IGludGVyb3BUeXBlID09PSAnZXNNb2R1bGUnIHx8XG4gICAgKGV4dGVybmFsTGl2ZUJpbmRpbmdzICYmIChpbnRlcm9wVHlwZSA9PT0gJ2F1dG8nIHx8IGludGVyb3BUeXBlID09PSAndHJ1ZScpKTtcbmNvbnN0IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZSA9IHtcbiAgICBhdXRvOiBJTlRFUk9QX05BTUVTUEFDRV9WQVJJQUJMRSxcbiAgICBkZWZhdWx0OiBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFLFxuICAgIGRlZmF1bHRPbmx5OiBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX09OTFlfVkFSSUFCTEUsXG4gICAgZXNNb2R1bGU6IG51bGwsXG4gICAgZmFsc2U6IG51bGwsXG4gICAgdHJ1ZTogSU5URVJPUF9OQU1FU1BBQ0VfVkFSSUFCTEVcbn07XG5jb25zdCBjYW5EZWZhdWx0QmVUYWtlbkZyb21OYW1lc3BhY2UgPSAoaW50ZXJvcFR5cGUsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKSA9PiBpc0RlZmF1bHRBUHJvcGVydHkoaW50ZXJvcFR5cGUsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKSAmJlxuICAgIGRlZmF1bHRJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbaW50ZXJvcFR5cGVdID09PSBJTlRFUk9QX0RFRkFVTFRfVkFSSUFCTEU7XG5jb25zdCBnZXRIZWxwZXJzQmxvY2sgPSAoYWRkaXRpb25hbEhlbHBlcnMsIGFjY2Vzc2VkR2xvYmFscywgaW5kZW50LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKSA9PiB7XG4gICAgY29uc3QgdXNlZEhlbHBlcnMgPSBuZXcgU2V0KGFkZGl0aW9uYWxIZWxwZXJzKTtcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIEhFTFBFUl9OQU1FUykge1xuICAgICAgICBpZiAoYWNjZXNzZWRHbG9iYWxzLmhhcyh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHVzZWRIZWxwZXJzLmFkZCh2YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEhFTFBFUl9OQU1FUy5tYXAodmFyaWFibGUgPT4gdXNlZEhlbHBlcnMuaGFzKHZhcmlhYmxlKVxuICAgICAgICA/IEhFTFBFUl9HRU5FUkFUT1JTW3ZhcmlhYmxlXShpbmRlbnQsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIHVzZWRIZWxwZXJzKVxuICAgICAgICA6ICcnKS5qb2luKCcnKTtcbn07XG5jb25zdCBIRUxQRVJfR0VORVJBVE9SUyA9IHtcbiAgICBbSU5URVJPUF9ERUZBVUxUX0xFR0FDWV9WQVJJQUJMRV0oX3QsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MpIHtcbiAgICAgICAgY29uc3QgeyBfLCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbJ2UnXSwge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBJTlRFUk9QX0RFRkFVTFRfTEVHQUNZX1ZBUklBQkxFXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGAke2xlZnR9ZSR7X30mJiR7X310eXBlb2YgZSR7X309PT0ke199J29iamVjdCcke199JiYke199J2RlZmF1bHQnJHtffWluIGUke199PyR7X31gICtcbiAgICAgICAgICAgIGAke2xpdmVCaW5kaW5ncyA/IGdldERlZmF1bHRMaXZlQmluZGluZyhzbmlwcGV0cykgOiBnZXREZWZhdWx0U3RhdGljKHNuaXBwZXRzKX0ke3JpZ2h0fSR7bn0ke259YCk7XG4gICAgfSxcbiAgICBbSU5URVJPUF9ERUZBVUxUX1ZBUklBQkxFXShfdCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncykge1xuICAgICAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnZSddLCB7XG4gICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IElOVEVST1BfREVGQVVMVF9WQVJJQUJMRVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChgJHtsZWZ0fWUke199JiYke199ZS5fX2VzTW9kdWxlJHtffT8ke199YCArXG4gICAgICAgICAgICBgJHtsaXZlQmluZGluZ3MgPyBnZXREZWZhdWx0TGl2ZUJpbmRpbmcoc25pcHBldHMpIDogZ2V0RGVmYXVsdFN0YXRpYyhzbmlwcGV0cyl9JHtyaWdodH0ke259JHtufWApO1xuICAgIH0sXG4gICAgW0lOVEVST1BfTkFNRVNQQUNFX0RFRkFVTFRfT05MWV9WQVJJQUJMRV0oX3QsIHNuaXBwZXRzLCBfbGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKSB7XG4gICAgICAgIGNvbnN0IHsgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIGdldE9iamVjdCwgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbJ2UnXSwge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX09OTFlfVkFSSUFCTEVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBgJHtsZWZ0fSR7Z2V0RnJvemVuKGZyZWV6ZSwgZ2V0V2l0aFRvU3RyaW5nVGFnKG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBnZXRPYmplY3QoW1xuICAgICAgICAgICAgWydfX3Byb3RvX18nLCAnbnVsbCddLFxuICAgICAgICAgICAgWydkZWZhdWx0JywgJ2UnXVxuICAgICAgICBdLCB7IGxpbmVCcmVha0luZGVudDogbnVsbCB9KSwgc25pcHBldHMpKX0ke3JpZ2h0fSR7bn0ke259YDtcbiAgICB9LFxuICAgIFtJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFXSh0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKSB7XG4gICAgICAgIGNvbnN0IHsgXywgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIHJldHVybiAoYGZ1bmN0aW9uICR7SU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRX0oZSkke199eyR7bn1gICtcbiAgICAgICAgICAgIGNyZWF0ZU5hbWVzcGFjZU9iamVjdCh0LCB0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKSArXG4gICAgICAgICAgICBgfSR7bn0ke259YCk7XG4gICAgfSxcbiAgICBbSU5URVJPUF9OQU1FU1BBQ0VfVkFSSUFCTEVdKHQsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIHVzZWRIZWxwZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgXywgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIG4gfSA9IHNuaXBwZXRzO1xuICAgICAgICBpZiAodXNlZEhlbHBlcnMuaGFzKElOVEVST1BfTkFNRVNQQUNFX0RFRkFVTFRfVkFSSUFCTEUpKSB7XG4gICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oWydlJ10sIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogSU5URVJPUF9OQU1FU1BBQ0VfVkFSSUFCTEVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGAke2xlZnR9ZSR7X30mJiR7X31lLl9fZXNNb2R1bGUke199PyR7X31lJHtffToke199JHtJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFfShlKSR7cmlnaHR9JHtufSR7bn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYGZ1bmN0aW9uICR7SU5URVJPUF9OQU1FU1BBQ0VfVkFSSUFCTEV9KGUpJHtffXske259YCArXG4gICAgICAgICAgICBgJHt0fWlmJHtffShlJHtffSYmJHtffWUuX19lc01vZHVsZSkke199cmV0dXJuIGU7JHtufWAgK1xuICAgICAgICAgICAgY3JlYXRlTmFtZXNwYWNlT2JqZWN0KHQsIHQsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcpICtcbiAgICAgICAgICAgIGB9JHtufSR7bn1gKTtcbiAgICB9LFxuICAgIFtNRVJHRV9OQU1FU1BBQ0VTX1ZBUklBQkxFXSh0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKSB7XG4gICAgICAgIGNvbnN0IHsgXywgY25zdCwgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIGNvbnN0IHVzZUZvckVhY2ggPSBjbnN0ID09PSAndmFyJyAmJiBsaXZlQmluZGluZ3M7XG4gICAgICAgIHJldHVybiAoYGZ1bmN0aW9uICR7TUVSR0VfTkFNRVNQQUNFU19WQVJJQUJMRX0obiwgbSkke199eyR7bn1gICtcbiAgICAgICAgICAgIGAke3R9JHtsb29wT3Zlck5hbWVzcGFjZXMoYHske259YCArXG4gICAgICAgICAgICAgICAgYCR7dH0ke3R9JHt0fWlmJHtffShrJHtffSE9PSR7X30nZGVmYXVsdCcke199JiYke199IShrIGluIG4pKSR7X317JHtufWAgK1xuICAgICAgICAgICAgICAgIChsaXZlQmluZGluZ3NcbiAgICAgICAgICAgICAgICAgICAgPyB1c2VGb3JFYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvcHlPd25Qcm9wZXJ0eUxpdmVCaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvcHlQcm9wZXJ0eUxpdmVCaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIDogY29weVByb3BlcnR5U3RhdGljKSh0LCB0ICsgdCArIHQgKyB0LCBzbmlwcGV0cykgK1xuICAgICAgICAgICAgICAgIGAke3R9JHt0fSR7dH19JHtufWAgK1xuICAgICAgICAgICAgICAgIGAke3R9JHt0fX1gLCB1c2VGb3JFYWNoLCB0LCBzbmlwcGV0cyl9JHtufWAgK1xuICAgICAgICAgICAgYCR7dH1yZXR1cm4gJHtnZXRGcm96ZW4oZnJlZXplLCBnZXRXaXRoVG9TdHJpbmdUYWcobmFtZXNwYWNlVG9TdHJpbmdUYWcsICduJywgc25pcHBldHMpKX07JHtufWAgK1xuICAgICAgICAgICAgYH0ke259JHtufWApO1xuICAgIH1cbn07XG5jb25zdCBnZXREZWZhdWx0TGl2ZUJpbmRpbmcgPSAoeyBfLCBnZXRPYmplY3QgfSkgPT4gYGUke199OiR7X30ke2dldE9iamVjdChbWydkZWZhdWx0JywgJ2UnXV0sIHsgbGluZUJyZWFrSW5kZW50OiBudWxsIH0pfWA7XG5jb25zdCBnZXREZWZhdWx0U3RhdGljID0gKHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MgfSkgPT4gYGUke2dldFByb3BlcnR5QWNjZXNzKCdkZWZhdWx0Jyl9JHtffToke199ZWA7XG5jb25zdCBjcmVhdGVOYW1lc3BhY2VPYmplY3QgPSAodCwgaSwgc25pcHBldHMsIGxpdmVCaW5kaW5ncywgZnJlZXplLCBuYW1lc3BhY2VUb1N0cmluZ1RhZykgPT4ge1xuICAgIGNvbnN0IHsgXywgY25zdCwgZ2V0T2JqZWN0LCBnZXRQcm9wZXJ0eUFjY2VzcywgbiwgcyB9ID0gc25pcHBldHM7XG4gICAgY29uc3QgY29weVByb3BlcnR5ID0gYHske259YCArXG4gICAgICAgIChsaXZlQmluZGluZ3MgPyBjb3B5Tm9uRGVmYXVsdE93blByb3BlcnR5TGl2ZUJpbmRpbmcgOiBjb3B5UHJvcGVydHlTdGF0aWMpKHQsIGkgKyB0ICsgdCwgc25pcHBldHMpICtcbiAgICAgICAgYCR7aX0ke3R9fWA7XG4gICAgcmV0dXJuIChgJHtpfSR7Y25zdH0gbiR7X309JHtffU9iamVjdC5jcmVhdGUobnVsbCR7bmFtZXNwYWNlVG9TdHJpbmdUYWdcbiAgICAgICAgPyBgLCR7X317JHtffVtTeW1ib2wudG9TdHJpbmdUYWddOiR7X30ke2dldFRvU3RyaW5nVGFnVmFsdWUoZ2V0T2JqZWN0KX0ke199fWBcbiAgICAgICAgOiAnJ30pOyR7bn1gICtcbiAgICAgICAgYCR7aX1pZiR7X30oZSkke199eyR7bn1gICtcbiAgICAgICAgYCR7aX0ke3R9JHtsb29wT3ZlcktleXMoY29weVByb3BlcnR5LCAhbGl2ZUJpbmRpbmdzLCBzbmlwcGV0cyl9JHtufWAgK1xuICAgICAgICBgJHtpfX0ke259YCArXG4gICAgICAgIGAke2l9biR7Z2V0UHJvcGVydHlBY2Nlc3MoJ2RlZmF1bHQnKX0ke199PSR7X31lOyR7bn1gICtcbiAgICAgICAgYCR7aX1yZXR1cm4gJHtnZXRGcm96ZW4oZnJlZXplLCAnbicpfSR7c30ke259YCk7XG59O1xuY29uc3QgbG9vcE92ZXJLZXlzID0gKGJvZHksIGFsbG93VmFyTG9vcFZhcmlhYmxlLCB7IF8sIGNuc3QsIGdldEZ1bmN0aW9uSW50cm8sIHMgfSkgPT4gY25zdCAhPT0gJ3ZhcicgfHwgYWxsb3dWYXJMb29wVmFyaWFibGVcbiAgICA/IGBmb3Ike199KCR7Y25zdH0gayBpbiBlKSR7X30ke2JvZHl9YFxuICAgIDogYE9iamVjdC5rZXlzKGUpLmZvckVhY2goJHtnZXRGdW5jdGlvbkludHJvKFsnayddLCB7XG4gICAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgfSl9JHtib2R5fSkke3N9YDtcbmNvbnN0IGxvb3BPdmVyTmFtZXNwYWNlcyA9IChib2R5LCB1c2VGb3JFYWNoLCB0LCB7IF8sIGNuc3QsIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBnZXRGdW5jdGlvbkludHJvLCBuIH0pID0+IHtcbiAgICBpZiAodXNlRm9yRWFjaCkge1xuICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oWydlJ10sIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiBmYWxzZSxcbiAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogeyBiYXNlOiB0LCB0IH0sXG4gICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGBtLmZvckVhY2goJHtsZWZ0fWAgK1xuICAgICAgICAgICAgYGUke199JiYke199dHlwZW9mIGUke199IT09JHtffSdzdHJpbmcnJHtffSYmJHtffSFBcnJheS5pc0FycmF5KGUpJHtffSYmJHtffU9iamVjdC5rZXlzKGUpLmZvckVhY2goJHtnZXRGdW5jdGlvbkludHJvKFsnayddLCB7XG4gICAgICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgfSl9JHtib2R5fSkke3JpZ2h0fSk7YCk7XG4gICAgfVxuICAgIHJldHVybiAoYGZvciR7X30odmFyIGkke199PSR7X30wOyR7X31pJHtffTwke199bS5sZW5ndGg7JHtffWkrKykke199eyR7bn1gICtcbiAgICAgICAgYCR7dH0ke3R9JHtjbnN0fSBlJHtffT0ke199bVtpXTske259YCArXG4gICAgICAgIGAke3R9JHt0fWlmJHtffSh0eXBlb2YgZSR7X30hPT0ke199J3N0cmluZycke199JiYke199IUFycmF5LmlzQXJyYXkoZSkpJHtffXske199Zm9yJHtffSgke2Nuc3R9IGsgaW4gZSkke199JHtib2R5fSR7X319JHtufSR7dH19YCk7XG59O1xuY29uc3QgY29weU5vbkRlZmF1bHRPd25Qcm9wZXJ0eUxpdmVCaW5kaW5nID0gKHQsIGksIHNuaXBwZXRzKSA9PiB7XG4gICAgY29uc3QgeyBfLCBuIH0gPSBzbmlwcGV0cztcbiAgICByZXR1cm4gKGAke2l9aWYke199KGske199IT09JHtffSdkZWZhdWx0Jykke199eyR7bn1gICtcbiAgICAgICAgY29weU93blByb3BlcnR5TGl2ZUJpbmRpbmcodCwgaSArIHQsIHNuaXBwZXRzKSArXG4gICAgICAgIGAke2l9fSR7bn1gKTtcbn07XG5jb25zdCBjb3B5T3duUHJvcGVydHlMaXZlQmluZGluZyA9ICh0LCBpLCB7IF8sIGNuc3QsIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0pID0+IHtcbiAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oW10sIHtcbiAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoYCR7aX0ke2Nuc3R9IGQke199PSR7X31PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsJHtffWspOyR7bn1gICtcbiAgICAgICAgYCR7aX1PYmplY3QuZGVmaW5lUHJvcGVydHkobiwke199aywke199ZC5nZXQke199PyR7X31kJHtffToke199eyR7bn1gICtcbiAgICAgICAgYCR7aX0ke3R9ZW51bWVyYWJsZToke199dHJ1ZSwke259YCArXG4gICAgICAgIGAke2l9JHt0fWdldDoke199JHtsZWZ0fWVba10ke3JpZ2h0fSR7bn1gICtcbiAgICAgICAgYCR7aX19KTske259YCk7XG59O1xuY29uc3QgY29weVByb3BlcnR5TGl2ZUJpbmRpbmcgPSAodCwgaSwgeyBfLCBjbnN0LCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgbiB9KSA9PiB7XG4gICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gKGAke2l9JHtjbnN0fSBkJHtffT0ke199T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCR7X31rKTske259YCArXG4gICAgICAgIGAke2l9aWYke199KGQpJHtffXske259YCArXG4gICAgICAgIGAke2l9JHt0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCR7X31rLCR7X31kLmdldCR7X30/JHtffWQke199OiR7X317JHtufWAgK1xuICAgICAgICBgJHtpfSR7dH0ke3R9ZW51bWVyYWJsZToke199dHJ1ZSwke259YCArXG4gICAgICAgIGAke2l9JHt0fSR7dH1nZXQ6JHtffSR7bGVmdH1lW2tdJHtyaWdodH0ke259YCArXG4gICAgICAgIGAke2l9JHt0fX0pOyR7bn1gICtcbiAgICAgICAgYCR7aX19JHtufWApO1xufTtcbmNvbnN0IGNvcHlQcm9wZXJ0eVN0YXRpYyA9IChfdCwgaSwgeyBfLCBuIH0pID0+IGAke2l9bltrXSR7X309JHtffWVba107JHtufWA7XG5jb25zdCBnZXRGcm96ZW4gPSAoZnJlZXplLCBmcmFnbWVudCkgPT4gZnJlZXplID8gYE9iamVjdC5mcmVlemUoJHtmcmFnbWVudH0pYCA6IGZyYWdtZW50O1xuY29uc3QgZ2V0V2l0aFRvU3RyaW5nVGFnID0gKG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBmcmFnbWVudCwgeyBfLCBnZXRPYmplY3QgfSkgPT4gbmFtZXNwYWNlVG9TdHJpbmdUYWdcbiAgICA/IGBPYmplY3QuZGVmaW5lUHJvcGVydHkoJHtmcmFnbWVudH0sJHtffVN5bWJvbC50b1N0cmluZ1RhZywke199JHtnZXRUb1N0cmluZ1RhZ1ZhbHVlKGdldE9iamVjdCl9KWBcbiAgICA6IGZyYWdtZW50O1xuY29uc3QgSEVMUEVSX05BTUVTID0gT2JqZWN0LmtleXMoSEVMUEVSX0dFTkVSQVRPUlMpO1xuZnVuY3Rpb24gZ2V0VG9TdHJpbmdUYWdWYWx1ZShnZXRPYmplY3QpIHtcbiAgICByZXR1cm4gZ2V0T2JqZWN0KFtbJ3ZhbHVlJywgXCInTW9kdWxlJ1wiXV0sIHtcbiAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsXG4gICAgfSk7XG59XG5cbmNsYXNzIEltcG9ydEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaW5saW5lTmFtZXNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWNoYW5pc20gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBudWxsO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluY2x1ZGVEeW5hbWljSW1wb3J0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY29wZS5hZGRBY2Nlc3NlZER5bmFtaWNJbXBvcnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGREeW5hbWljSW1wb3J0KHRoaXMpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pbmxpbmVOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc25pcHBldHM6IHsgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIGdldFByb3BlcnR5QWNjZXNzIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oW10sIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgYFByb21pc2UucmVzb2x2ZSgpLnRoZW4oJHtsZWZ0fSR7dGhpcy5pbmxpbmVOYW1lc3BhY2UuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyl9JHtyaWdodH0pYCwgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZWNoYW5pc20pIHtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnKCcsIHRoaXMuc3RhcnQgKyA2KSArIDEsIHRoaXMubWVjaGFuaXNtLmxlZnQsIHsgY29udGVudE9ubHk6IHRydWUgfSk7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmVuZCAtIDEsIHRoaXMuZW5kLCB0aGlzLm1lY2hhbmlzbS5yaWdodCwgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJlbmRlckZpbmFsUmVzb2x1dGlvbihjb2RlLCByZXNvbHV0aW9uLCBuYW1lc3BhY2VFeHBvcnROYW1lLCB7IGdldERpcmVjdFJldHVybkZ1bmN0aW9uIH0pIHtcbiAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zb3VyY2Uuc3RhcnQsIHRoaXMuc291cmNlLmVuZCwgcmVzb2x1dGlvbik7XG4gICAgICAgIGlmIChuYW1lc3BhY2VFeHBvcnROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oWyduJ10sIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuZW5kLCBgLnRoZW4oJHtsZWZ0fW4uJHtuYW1lc3BhY2VFeHBvcnROYW1lfSR7cmlnaHR9KWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVybmFsUmVzb2x1dGlvbihleHBvcnRNb2RlLCByZXNvbHV0aW9uLCBvcHRpb25zLCBzbmlwcGV0cywgcGx1Z2luRHJpdmVyLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBjb25zdCBhY2Nlc3NlZEdsb2JhbHMgPSBbLi4uKGFjY2Vzc2VkSW1wb3J0R2xvYmFsc1tmb3JtYXRdIHx8IFtdKV07XG4gICAgICAgIGxldCBoZWxwZXI7XG4gICAgICAgICh7IGhlbHBlciwgbWVjaGFuaXNtOiB0aGlzLm1lY2hhbmlzbSB9ID0gdGhpcy5nZXREeW5hbWljSW1wb3J0TWVjaGFuaXNtQW5kSGVscGVyKHJlc29sdXRpb24sIGV4cG9ydE1vZGUsIG9wdGlvbnMsIHNuaXBwZXRzLCBwbHVnaW5Ecml2ZXIpKTtcbiAgICAgICAgaWYgKGhlbHBlcikge1xuICAgICAgICAgICAgYWNjZXNzZWRHbG9iYWxzLnB1c2goaGVscGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjZXNzZWRHbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuYWRkQWNjZXNzZWRHbG9iYWxzKGFjY2Vzc2VkR2xvYmFscywgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SW50ZXJuYWxSZXNvbHV0aW9uKGlubGluZU5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLmlubGluZU5hbWVzcGFjZSA9IGlubGluZU5hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0RHluYW1pY0ltcG9ydE1lY2hhbmlzbUFuZEhlbHBlcihyZXNvbHV0aW9uLCBleHBvcnRNb2RlLCB7IGNvbXBhY3QsIGR5bmFtaWNJbXBvcnRGdW5jdGlvbiwgZm9ybWF0LCBnZW5lcmF0ZWRDb2RlOiB7IGFycm93RnVuY3Rpb25zIH0sIGludGVyb3AgfSwgeyBfLCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQgfSwgcGx1Z2luRHJpdmVyKSB7XG4gICAgICAgIGNvbnN0IG1lY2hhbmlzbSA9IHBsdWdpbkRyaXZlci5ob29rRmlyc3RTeW5jKCdyZW5kZXJEeW5hbWljSW1wb3J0JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN1c3RvbVJlc29sdXRpb246IHR5cGVvZiB0aGlzLnJlc29sdXRpb24gPT09ICdzdHJpbmcnID8gdGhpcy5yZXNvbHV0aW9uIDogbnVsbCxcbiAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IHRoaXMuY29udGV4dC5tb2R1bGUuaWQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TW9kdWxlSWQ6IHRoaXMucmVzb2x1dGlvbiAmJiB0eXBlb2YgdGhpcy5yZXNvbHV0aW9uICE9PSAnc3RyaW5nJyA/IHRoaXMucmVzb2x1dGlvbi5pZCA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChtZWNoYW5pc20pIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhlbHBlcjogbnVsbCwgbWVjaGFuaXNtIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzRHluYW1pY1RhcmdldCA9ICF0aGlzLnJlc29sdXRpb24gfHwgdHlwZW9mIHRoaXMucmVzb2x1dGlvbiA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdjanMnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVscGVyID0gZ2V0SW50ZXJvcEhlbHBlcihyZXNvbHV0aW9uLCBleHBvcnRNb2RlLCBpbnRlcm9wKTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IGByZXF1aXJlKGA7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gYClgO1xuICAgICAgICAgICAgICAgIGlmIChoZWxwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGAvKiNfX1BVUkVfXyovJHtoZWxwZXJ9KCR7bGVmdH1gO1xuICAgICAgICAgICAgICAgICAgICByaWdodCArPSAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtmdW5jdGlvbkxlZnQsIGZ1bmN0aW9uUmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oW10sIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigke2Z1bmN0aW9uTGVmdH0ke2xlZnR9YDtcbiAgICAgICAgICAgICAgICByaWdodCArPSBgJHtmdW5jdGlvblJpZ2h0fSlgO1xuICAgICAgICAgICAgICAgIGlmICghYXJyb3dGdW5jdGlvbnMgJiYgaGFzRHluYW1pY1RhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQoWyd0J10sIGAke2xlZnR9dCR7cmlnaHR9YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNBcnJvd1JldHVyblBhcmVuczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1dyYXBwZWRGdW5jdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcixcbiAgICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7IGxlZnQsIHJpZ2h0IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYW1kJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSBjb21wYWN0ID8gJ2MnIDogJ3Jlc29sdmUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdCA9IGNvbXBhY3QgPyAnZScgOiAncmVqZWN0JztcbiAgICAgICAgICAgICAgICBjb25zdCBoZWxwZXIgPSBnZXRJbnRlcm9wSGVscGVyKHJlc29sdXRpb24sIGV4cG9ydE1vZGUsIGludGVyb3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlTGVmdCwgcmVzb2x2ZVJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnbSddLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZU5hbWVzcGFjZSA9IGhlbHBlclxuICAgICAgICAgICAgICAgICAgICA/IGAke3Jlc29sdmVMZWZ0fSR7cmVzb2x2ZX0oLyojX19QVVJFX18qLyR7aGVscGVyfShtKSkke3Jlc29sdmVSaWdodH1gXG4gICAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbaGFuZGxlckxlZnQsIGhhbmRsZXJSaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbcmVzb2x2ZSwgcmVqZWN0XSwge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gYG5ldyBQcm9taXNlKCR7aGFuZGxlckxlZnR9cmVxdWlyZShbYDtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSBgXSwke199JHtyZXNvbHZlTmFtZXNwYWNlfSwke199JHtyZWplY3R9KSR7aGFuZGxlclJpZ2h0fSlgO1xuICAgICAgICAgICAgICAgIGlmICghYXJyb3dGdW5jdGlvbnMgJiYgaGFzRHluYW1pY1RhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQoWyd0J10sIGAke2xlZnR9dCR7cmlnaHR9YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNBcnJvd1JldHVyblBhcmVuczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1dyYXBwZWRGdW5jdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcixcbiAgICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7IGxlZnQsIHJpZ2h0IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3lzdGVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJ21vZHVsZS5pbXBvcnQoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnKSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdlcyc6XG4gICAgICAgICAgICAgICAgaWYgKGR5bmFtaWNJbXBvcnRGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7ZHluYW1pY0ltcG9ydEZ1bmN0aW9ufShgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGVscGVyOiBudWxsLCBtZWNoYW5pc206IG51bGwgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcm9wSGVscGVyKHJlc29sdXRpb24sIGV4cG9ydE1vZGUsIGludGVyb3ApIHtcbiAgICByZXR1cm4gZXhwb3J0TW9kZSA9PT0gJ2V4dGVybmFsJ1xuICAgICAgICA/IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVtTdHJpbmcoaW50ZXJvcChyZXNvbHV0aW9uIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUgPyByZXNvbHV0aW9uLmlkIDogbnVsbCkpXVxuICAgICAgICA6IGV4cG9ydE1vZGUgPT09ICdkZWZhdWx0J1xuICAgICAgICAgICAgPyBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX09OTFlfVkFSSUFCTEVcbiAgICAgICAgICAgIDogbnVsbDtcbn1cbmNvbnN0IGFjY2Vzc2VkSW1wb3J0R2xvYmFscyA9IHtcbiAgICBhbWQ6IFsncmVxdWlyZSddLFxuICAgIGNqczogWydyZXF1aXJlJ10sXG4gICAgc3lzdGVtOiBbJ21vZHVsZSddXG59O1xuXG5jbGFzcyBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIEltcG9ydFNwZWNpZmllciBleHRlbmRzIE5vZGVCYXNlIHtcbn1cblxuY2xhc3MgTGFiZWxlZFN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYnJva2VuRmxvdyA9IGNvbnRleHQuYnJva2VuRmxvdztcbiAgICAgICAgY29udGV4dC5pZ25vcmUubGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICBpZiAodGhpcy5ib2R5Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUubGFiZWxzLmRlbGV0ZSh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICBpZiAoY29udGV4dC5pbmNsdWRlZExhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSkge1xuICAgICAgICAgICAgY29udGV4dC5pbmNsdWRlZExhYmVscy5kZWxldGUodGhpcy5sYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBicm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93O1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmhhcyh0aGlzLmxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLmluY2x1ZGUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuZGVsZXRlKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIGZpbmROb25XaGl0ZVNwYWNlKGNvZGUub3JpZ2luYWwsIGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnOicsIHRoaXMubGFiZWwuZW5kKSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgTG9naWNhbEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIFdlIGNvbGxlY3QgZGVvcHRpbWl6YXRpb24gaW5mb3JtYXRpb24gaWYgdXNlZEJyYW5jaCAhPT0gbnVsbFxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gW107XG4gICAgICAgIHRoaXMuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkQnJhbmNoID0gbnVsbDtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICBpZiAodGhpcy51c2VkQnJhbmNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB1bnVzZWRCcmFuY2ggPSB0aGlzLnVzZWRCcmFuY2ggPT09IHRoaXMubGVmdCA/IHRoaXMucmlnaHQgOiB0aGlzLmxlZnQ7XG4gICAgICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPSBudWxsO1xuICAgICAgICAgICAgdW51c2VkQnJhbmNoLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlZEJyYW5jaC5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5sZWZ0LmRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgIHRoaXMucmlnaHQuZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2ggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pLFxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0Lmhhc0VmZmVjdHMoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldFVzZWRCcmFuY2goKSAhPT0gdGhpcy5sZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlZEJyYW5jaC5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmICh1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fFxuICAgICAgICAgICAgKHVzZWRCcmFuY2ggPT09IHRoaXMucmlnaHQgJiYgdGhpcy5sZWZ0LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHx8XG4gICAgICAgICAgICB1c2VkQnJhbmNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlZEJyYW5jaC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsIHByZXZlbnRBU0ksIHJlbmRlcmVkUGFyZW50VHlwZSwgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSA9IEJMQU5LKSB7XG4gICAgICAgIGlmICghdGhpcy5sZWZ0LmluY2x1ZGVkIHx8ICF0aGlzLnJpZ2h0LmluY2x1ZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvclBvcyA9IGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCB0aGlzLm9wZXJhdG9yLCB0aGlzLmxlZnQuZW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0LmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlUG9zID0gZmluZE5vbldoaXRlU3BhY2UoY29kZS5vcmlnaW5hbCwgb3BlcmF0b3JQb3MgKyAyKTtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCByZW1vdmVQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QVNJKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpbmVCcmVha3MoY29kZSwgcmVtb3ZlUG9zLCB0aGlzLnJpZ2h0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShvcGVyYXRvclBvcywgdGhpcy5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQW5ub3RhdGlvbnModGhpcywgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmdldFVzZWRCcmFuY2goKS5yZW5kZXIoY29kZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCxcbiAgICAgICAgICAgICAgICBwcmV2ZW50QVNJLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkUGFyZW50VHlwZTogcmVuZGVyZWRQYXJlbnRUeXBlIHx8IHRoaXMucGFyZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IHx8IHRoaXMucGFyZW50LnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZWZ0LnJlbmRlcihjb2RlLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgcHJldmVudEFTSSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVc2VkQnJhbmNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdFZhbHVlID0gdGhpcy5sZWZ0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZSA9PT0gVW5rbm93blZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPVxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcGVyYXRvciA9PT0gJ3x8JyAmJiBsZWZ0VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5vcGVyYXRvciA9PT0gJyYmJyAmJiAhbGVmdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc/PycgJiYgbGVmdFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVzZWRCcmFuY2g7XG4gICAgfVxufVxuXG5jb25zdCBBU1NFVF9QUkVGSVggPSAnUk9MTFVQX0FTU0VUX1VSTF8nO1xuY29uc3QgQ0hVTktfUFJFRklYID0gJ1JPTExVUF9DSFVOS19VUkxfJztcbmNvbnN0IEZJTEVfUFJFRklYID0gJ1JPTExVUF9GSUxFX1VSTF8nO1xuY2xhc3MgTWV0YVByb3BlcnR5IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGFkZEFjY2Vzc2VkR2xvYmFscyhmb3JtYXQsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgY29uc3QgbWV0YVByb3BlcnR5ID0gdGhpcy5tZXRhUHJvcGVydHk7XG4gICAgICAgIGNvbnN0IGFjY2Vzc2VkR2xvYmFscyA9IChtZXRhUHJvcGVydHkgJiZcbiAgICAgICAgICAgIChtZXRhUHJvcGVydHkuc3RhcnRzV2l0aChGSUxFX1BSRUZJWCkgfHxcbiAgICAgICAgICAgICAgICBtZXRhUHJvcGVydHkuc3RhcnRzV2l0aChBU1NFVF9QUkVGSVgpIHx8XG4gICAgICAgICAgICAgICAgbWV0YVByb3BlcnR5LnN0YXJ0c1dpdGgoQ0hVTktfUFJFRklYKSlcbiAgICAgICAgICAgID8gYWNjZXNzZWRGaWxlVXJsR2xvYmFsc1xuICAgICAgICAgICAgOiBhY2Nlc3NlZE1ldGFVcmxHbG9iYWxzKVtmb3JtYXRdO1xuICAgICAgICBpZiAoYWNjZXNzZWRHbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuYWRkQWNjZXNzZWRHbG9iYWxzKGFjY2Vzc2VkR2xvYmFscywgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlZEZpbGVOYW1lKG91dHB1dFBsdWdpbkRyaXZlcikge1xuICAgICAgICBjb25zdCBtZXRhUHJvcGVydHkgPSB0aGlzLm1ldGFQcm9wZXJ0eTtcbiAgICAgICAgaWYgKG1ldGFQcm9wZXJ0eSAmJiBtZXRhUHJvcGVydHkuc3RhcnRzV2l0aChGSUxFX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRQbHVnaW5Ecml2ZXIuZ2V0RmlsZU5hbWUobWV0YVByb3BlcnR5LnN1YnN0cmluZyhGSUxFX1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGEubmFtZSA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWRkSW1wb3J0TWV0YSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFQcm9wZXJ0eSA9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gJiYgdHlwZW9mIHBhcmVudC5wcm9wZXJ0eUtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyZW50LnByb3BlcnR5S2V5XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyRmluYWxNZWNoYW5pc20oY29kZSwgY2h1bmtJZCwgZm9ybWF0LCBzbmlwcGV0cywgb3V0cHV0UGx1Z2luRHJpdmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IG1ldGFQcm9wZXJ0eSA9IHRoaXMubWV0YVByb3BlcnR5O1xuICAgICAgICBpZiAobWV0YVByb3BlcnR5ICYmXG4gICAgICAgICAgICAobWV0YVByb3BlcnR5LnN0YXJ0c1dpdGgoRklMRV9QUkVGSVgpIHx8XG4gICAgICAgICAgICAgICAgbWV0YVByb3BlcnR5LnN0YXJ0c1dpdGgoQVNTRVRfUFJFRklYKSB8fFxuICAgICAgICAgICAgICAgIG1ldGFQcm9wZXJ0eS5zdGFydHNXaXRoKENIVU5LX1BSRUZJWCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlSWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFzc2V0UmVmZXJlbmNlSWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNodW5rUmVmZXJlbmNlSWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGZpbGVOYW1lO1xuICAgICAgICAgICAgaWYgKG1ldGFQcm9wZXJ0eS5zdGFydHNXaXRoKEZJTEVfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUlkID0gbWV0YVByb3BlcnR5LnN1YnN0cmluZyhGSUxFX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gb3V0cHV0UGx1Z2luRHJpdmVyLmdldEZpbGVOYW1lKHJlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGFQcm9wZXJ0eS5zdGFydHNXaXRoKEFTU0VUX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oYFVzaW5nIHRoZSBcIiR7QVNTRVRfUFJFRklYfVwiIHByZWZpeCB0byByZWZlcmVuY2UgZmlsZXMgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBcIiR7RklMRV9QUkVGSVh9XCIgcHJlZml4IGluc3RlYWQuYCwgdHJ1ZSwgdGhpcy5jb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGFzc2V0UmVmZXJlbmNlSWQgPSBtZXRhUHJvcGVydHkuc3Vic3RyaW5nKEFTU0VUX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gb3V0cHV0UGx1Z2luRHJpdmVyLmdldEZpbGVOYW1lKGFzc2V0UmVmZXJlbmNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKGBVc2luZyB0aGUgXCIke0NIVU5LX1BSRUZJWH1cIiBwcmVmaXggdG8gcmVmZXJlbmNlIGZpbGVzIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgXCIke0ZJTEVfUFJFRklYfVwiIHByZWZpeCBpbnN0ZWFkLmAsIHRydWUsIHRoaXMuY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjaHVua1JlZmVyZW5jZUlkID0gbWV0YVByb3BlcnR5LnN1YnN0cmluZyhDSFVOS19QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IG91dHB1dFBsdWdpbkRyaXZlci5nZXRGaWxlTmFtZShjaHVua1JlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5vcm1hbGl6ZShyZWxhdGl2ZSQxKGRpcm5hbWUoY2h1bmtJZCksIGZpbGVOYW1lKSk7XG4gICAgICAgICAgICBsZXQgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICBpZiAoYXNzZXRSZWZlcmVuY2VJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gb3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tGaXJzdFN5bmMoJ3Jlc29sdmVBc3NldFVybCcsIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRGaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlSWQ6IHRoaXMuY29udGV4dC5tb2R1bGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUFzc2V0UGF0aDogcmVsYXRpdmVQYXRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlci5ob29rRmlyc3RTeW5jKCdyZXNvbHZlRmlsZVVybCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldFJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtSZWZlcmVuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlSWQ6IHRoaXMuY29udGV4dC5tb2R1bGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHJlZmVyZW5jZUlkIHx8IGFzc2V0UmVmZXJlbmNlSWQgfHwgY2h1bmtSZWZlcmVuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSkgfHwgcmVsYXRpdmVVcmxNZWNoYW5pc21zW2Zvcm1hdF0ocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHBhcmVudC5zdGFydCwgcGFyZW50LmVuZCwgcmVwbGFjZW1lbnQsIHsgY29udGVudE9ubHk6IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBvdXRwdXRQbHVnaW5Ecml2ZXIuaG9va0ZpcnN0U3luYygncmVzb2x2ZUltcG9ydE1ldGEnLCBbXG4gICAgICAgICAgICBtZXRhUHJvcGVydHksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IHRoaXMuY29udGV4dC5tb2R1bGUuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSkgfHwgKChfYSA9IGltcG9ydE1ldGFNZWNoYW5pc21zW2Zvcm1hdF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGltcG9ydE1ldGFNZWNoYW5pc21zLCBtZXRhUHJvcGVydHksIHsgY2h1bmtJZCwgc25pcHBldHMgfSkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShwYXJlbnQuc3RhcnQsIHBhcmVudC5lbmQsIHJlcGxhY2VtZW50LCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIHJlcGxhY2VtZW50LCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgYWNjZXNzZWRNZXRhVXJsR2xvYmFscyA9IHtcbiAgICBhbWQ6IFsnZG9jdW1lbnQnLCAnbW9kdWxlJywgJ1VSTCddLFxuICAgIGNqczogWydkb2N1bWVudCcsICdyZXF1aXJlJywgJ1VSTCddLFxuICAgIGVzOiBbXSxcbiAgICBpaWZlOiBbJ2RvY3VtZW50JywgJ1VSTCddLFxuICAgIHN5c3RlbTogWydtb2R1bGUnXSxcbiAgICB1bWQ6IFsnZG9jdW1lbnQnLCAncmVxdWlyZScsICdVUkwnXVxufTtcbmNvbnN0IGFjY2Vzc2VkRmlsZVVybEdsb2JhbHMgPSB7XG4gICAgYW1kOiBbJ2RvY3VtZW50JywgJ3JlcXVpcmUnLCAnVVJMJ10sXG4gICAgY2pzOiBbJ2RvY3VtZW50JywgJ3JlcXVpcmUnLCAnVVJMJ10sXG4gICAgZXM6IFtdLFxuICAgIGlpZmU6IFsnZG9jdW1lbnQnLCAnVVJMJ10sXG4gICAgc3lzdGVtOiBbJ21vZHVsZScsICdVUkwnXSxcbiAgICB1bWQ6IFsnZG9jdW1lbnQnLCAncmVxdWlyZScsICdVUkwnXVxufTtcbmNvbnN0IGdldFJlc29sdmVVcmwgPSAocGF0aCwgVVJMID0gJ1VSTCcpID0+IGBuZXcgJHtVUkx9KCR7cGF0aH0pLmhyZWZgO1xuY29uc3QgZ2V0UmVsYXRpdmVVcmxGcm9tRG9jdW1lbnQgPSAocmVsYXRpdmVQYXRoLCB1bWQgPSBmYWxzZSkgPT4gZ2V0UmVzb2x2ZVVybChgJyR7cmVsYXRpdmVQYXRofScsICR7dW1kID8gYHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5ocmVmIDogYCA6ICcnfWRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgZG9jdW1lbnQuYmFzZVVSSWApO1xuY29uc3QgZ2V0R2VuZXJpY0ltcG9ydE1ldGFNZWNoYW5pc20gPSAoZ2V0VXJsKSA9PiAocHJvcCwgeyBjaHVua0lkIH0pID0+IHtcbiAgICBjb25zdCB1cmxNZWNoYW5pc20gPSBnZXRVcmwoY2h1bmtJZCk7XG4gICAgcmV0dXJuIHByb3AgPT09IG51bGxcbiAgICAgICAgPyBgKHsgdXJsOiAke3VybE1lY2hhbmlzbX0gfSlgXG4gICAgICAgIDogcHJvcCA9PT0gJ3VybCdcbiAgICAgICAgICAgID8gdXJsTWVjaGFuaXNtXG4gICAgICAgICAgICA6ICd1bmRlZmluZWQnO1xufTtcbmNvbnN0IGdldFVybEZyb21Eb2N1bWVudCA9IChjaHVua0lkLCB1bWQgPSBmYWxzZSkgPT4gYCR7dW1kID8gYHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5ocmVmIDogYCA6ICcnfShkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIHx8IG5ldyBVUkwoJyR7Y2h1bmtJZH0nLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKWA7XG5jb25zdCByZWxhdGl2ZVVybE1lY2hhbmlzbXMgPSB7XG4gICAgYW1kOiByZWxhdGl2ZVBhdGggPT4ge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoWzBdICE9PSAnLicpXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSAnLi8nICsgcmVsYXRpdmVQYXRoO1xuICAgICAgICByZXR1cm4gZ2V0UmVzb2x2ZVVybChgcmVxdWlyZS50b1VybCgnJHtyZWxhdGl2ZVBhdGh9JyksIGRvY3VtZW50LmJhc2VVUklgKTtcbiAgICB9LFxuICAgIGNqczogcmVsYXRpdmVQYXRoID0+IGAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/ICR7Z2V0UmVzb2x2ZVVybChgJ2ZpbGU6JyArIF9fZGlybmFtZSArICcvJHtyZWxhdGl2ZVBhdGh9J2AsIGAocmVxdWlyZSgndScgKyAncmwnKS5VUkwpYCl9IDogJHtnZXRSZWxhdGl2ZVVybEZyb21Eb2N1bWVudChyZWxhdGl2ZVBhdGgpfSlgLFxuICAgIGVzOiByZWxhdGl2ZVBhdGggPT4gZ2V0UmVzb2x2ZVVybChgJyR7cmVsYXRpdmVQYXRofScsIGltcG9ydC5tZXRhLnVybGApLFxuICAgIGlpZmU6IHJlbGF0aXZlUGF0aCA9PiBnZXRSZWxhdGl2ZVVybEZyb21Eb2N1bWVudChyZWxhdGl2ZVBhdGgpLFxuICAgIHN5c3RlbTogcmVsYXRpdmVQYXRoID0+IGdldFJlc29sdmVVcmwoYCcke3JlbGF0aXZlUGF0aH0nLCBtb2R1bGUubWV0YS51cmxgKSxcbiAgICB1bWQ6IHJlbGF0aXZlUGF0aCA9PiBgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/ICR7Z2V0UmVzb2x2ZVVybChgJ2ZpbGU6JyArIF9fZGlybmFtZSArICcvJHtyZWxhdGl2ZVBhdGh9J2AsIGAocmVxdWlyZSgndScgKyAncmwnKS5VUkwpYCl9IDogJHtnZXRSZWxhdGl2ZVVybEZyb21Eb2N1bWVudChyZWxhdGl2ZVBhdGgsIHRydWUpfSlgXG59O1xuY29uc3QgaW1wb3J0TWV0YU1lY2hhbmlzbXMgPSB7XG4gICAgYW1kOiBnZXRHZW5lcmljSW1wb3J0TWV0YU1lY2hhbmlzbSgoKSA9PiBnZXRSZXNvbHZlVXJsKGBtb2R1bGUudXJpLCBkb2N1bWVudC5iYXNlVVJJYCkpLFxuICAgIGNqczogZ2V0R2VuZXJpY0ltcG9ydE1ldGFNZWNoYW5pc20oY2h1bmtJZCA9PiBgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAke2dldFJlc29sdmVVcmwoYCdmaWxlOicgKyBfX2ZpbGVuYW1lYCwgYChyZXF1aXJlKCd1JyArICdybCcpLlVSTClgKX0gOiAke2dldFVybEZyb21Eb2N1bWVudChjaHVua0lkKX0pYCksXG4gICAgaWlmZTogZ2V0R2VuZXJpY0ltcG9ydE1ldGFNZWNoYW5pc20oY2h1bmtJZCA9PiBnZXRVcmxGcm9tRG9jdW1lbnQoY2h1bmtJZCkpLFxuICAgIHN5c3RlbTogKHByb3AsIHsgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9KSA9PiBwcm9wID09PSBudWxsID8gYG1vZHVsZS5tZXRhYCA6IGBtb2R1bGUubWV0YSR7Z2V0UHJvcGVydHlBY2Nlc3MocHJvcCl9YCxcbiAgICB1bWQ6IGdldEdlbmVyaWNJbXBvcnRNZXRhTWVjaGFuaXNtKGNodW5rSWQgPT4gYCh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAke2dldFJlc29sdmVVcmwoYCdmaWxlOicgKyBfX2ZpbGVuYW1lYCwgYChyZXF1aXJlKCd1JyArICdybCcpLlVSTClgKX0gOiAke2dldFVybEZyb21Eb2N1bWVudChjaHVua0lkLCB0cnVlKX0pYClcbn07XG5cbmNsYXNzIE5ld0V4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiB0aGlzLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZS5hbm5vdGF0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNhbGxlZS5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLmNhbGxlZS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmNhbGxPcHRpb25zLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLmNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgYXJnczogdGhpcy5hcmd1bWVudHMsXG4gICAgICAgICAgICB0aGlzUGFyYW06IG51bGwsXG4gICAgICAgICAgICB3aXRoTmV3OiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiB0aGlzLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBhbGwgcHJvcGVydGllcyBvZiBwYXJhbWV0ZXJzIGJlaGF2ZSBhcyBcInVua25vd25cIlxuICAgICAgICAgICAgYXJndW1lbnQuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY2xhc3MgT2JqZWN0RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZGVvcHRpbWl6ZUFsbFByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNXaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGNhbGxPcHRpb25zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSA9IEJMQU5LKSB7XG4gICAgICAgIHN1cGVyLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBFeHByZXNzaW9uU3RhdGVtZW50JDEgfHxcbiAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiQxKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZFJpZ2h0KHRoaXMuc3RhcnQsICcoJyk7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuZW5kLCAnKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE9iamVjdEVudGl0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0RW50aXR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RFbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3RvdHlwZSA9IE9CSkVDVF9QUk9UT1RZUEU7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIFNwcmVhZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goeyBrZXk6IFVua25vd25LZXksIGtpbmQ6ICdpbml0JywgcHJvcGVydHkgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBwcm9wZXJ0eS5rZXkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleVZhbHVlID09PSBVbmtub3duVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHsga2V5OiBVbmtub3duS2V5LCBraW5kOiBwcm9wZXJ0eS5raW5kLCBwcm9wZXJ0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcoa2V5VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmtleSBpbnN0YW5jZW9mIElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgJiYgcHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS52YWx1ZSBpbnN0YW5jZW9mIExpdGVyYWwgJiYgcHJvcGVydHkudmFsdWUudmFsdWUgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb3BlcnR5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goeyBrZXksIGtpbmQ6IHByb3BlcnR5LmtpbmQsIHByb3BlcnR5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5vYmplY3RFbnRpdHkgPSBuZXcgT2JqZWN0RW50aXR5KHByb3BlcnRpZXMsIHByb3RvdHlwZSkpO1xuICAgIH1cbn1cblxuY2xhc3MgUHJpdmF0ZUlkZW50aWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIFByb2dyYW0gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzQ2FjaGVkRWZmZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICAvLyBXZSBhcmUgY2FjaGluZyBoZXJlIHRvIGxhdGVyIG1vcmUgZWZmaWNpZW50bHkgaWRlbnRpZnkgc2lkZS1lZmZlY3QtZnJlZSBtb2R1bGVzXG4gICAgICAgIGlmICh0aGlzLmhhc0NhY2hlZEVmZmVjdClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc0NhY2hlZEVmZmVjdCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8IG5vZGUuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlbWVudExpc3QodGhpcy5ib2R5LCBjb2RlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFByb3BlcnR5IGV4dGVuZHMgTWV0aG9kQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkluaXQgPSBudWxsO1xuICAgIH1cbiAgICBkZWNsYXJlKGtpbmQsIGluaXQpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkluaXQgPSBpbml0O1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5kZWNsYXJlKGtpbmQsIFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlXG4gICAgICAgICAgICAucHJvcGVydHlSZWFkU2lkZUVmZmVjdHM7XG4gICAgICAgIHJldHVybiAoKHRoaXMucGFyZW50LnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJyAmJiBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9PT0gJ2Fsd2F5cycpIHx8XG4gICAgICAgICAgICB0aGlzLmtleS5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmhhc0VmZmVjdHMoY29udGV4dCkpO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICB0aGlzLnZhbHVlLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNob3J0aGFuZCkge1xuICAgICAgICAgICAgdGhpcy5rZXkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgaXNTaG9ydGhhbmRQcm9wZXJ0eTogdGhpcy5zaG9ydGhhbmQgfSk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGVjbGFyYXRpb25Jbml0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uSW5pdC5kZW9wdGltaXplUGF0aChbVW5rbm93bktleSwgVW5rbm93bktleV0pO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUHJvcGVydHlEZWZpbml0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgICAgICAgICA/IHRoaXMudmFsdWUuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIDogVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgICAgICAgICA/IHRoaXMudmFsdWUuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIDogVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmtleS5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy5zdGF0aWMgJiYgdGhpcy52YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLnZhbHVlLmhhc0VmZmVjdHMoY29udGV4dCkpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlLmhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUgfHwgdGhpcy52YWx1ZS5oYXNFZmZlY3RzV2hlbkFzc2lnbmVkQXRQYXRoKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWUgfHwgdGhpcy52YWx1ZS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgfVxufVxuXG5jbGFzcyBSZXR1cm5TdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghY29udGV4dC5pZ25vcmUucmV0dXJuWWllbGQgfHxcbiAgICAgICAgICAgICh0aGlzLmFyZ3VtZW50ICE9PSBudWxsICYmIHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0cyhjb250ZXh0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gQlJPS0VOX0ZMT1dfRVJST1JfUkVUVVJOX0xBQkVMO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IEJST0tFTl9GTE9XX0VSUk9SX1JFVFVSTl9MQUJFTDtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgdGhpcy5zY29wZS5hZGRSZXR1cm5FeHByZXNzaW9uKHRoaXMuYXJndW1lbnQgfHwgVU5LTk9XTl9FWFBSRVNTSU9OKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcHJldmVudEFTSTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3VtZW50LnN0YXJ0ID09PSB0aGlzLnN0YXJ0ICsgNiAvKiAncmV0dXJuJy5sZW5ndGggKi8pIHtcbiAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuc3RhcnQgKyA2LCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTZXF1ZW5jZUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0uZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVUaGlzT25FdmVudEF0UGF0aChldmVudCwgcGF0aCwgdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0uZGVvcHRpbWl6ZVRoaXNPbkV2ZW50QXRQYXRoKGV2ZW50LCBwYXRoLCB0aGlzUGFyYW1ldGVyLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChwYXRoLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGggLSAxXS5oYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0uaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgocGF0aCwgY2FsbE9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGggLSAxXS5oYXNFZmZlY3RzV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBjYWxsT3B0aW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGxhc3RFeHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8XG4gICAgICAgICAgICAgICAgKGV4cHJlc3Npb24gPT09IGxhc3RFeHByZXNzaW9uICYmICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50KSkgfHxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyByZW5kZXJlZFBhcmVudFR5cGUsIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCwgcHJldmVudEFTSSB9ID0gQkxBTkspIHtcbiAgICAgICAgbGV0IGluY2x1ZGVkTm9kZXMgPSAwO1xuICAgICAgICBsZXQgbGFzdFNlcGFyYXRvclBvcyA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbm9kZSwgc2VwYXJhdG9yLCBzdGFydCwgZW5kIH0gb2YgZ2V0Q29tbWFTZXBhcmF0ZWROb2Rlc1dpdGhCb3VuZGFyaWVzKHRoaXMuZXhwcmVzc2lvbnMsIGNvZGUsIHRoaXMuc3RhcnQsIHRoaXMuZW5kKSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgdHJlZXNoYWtlTm9kZShub2RlLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY2x1ZGVkTm9kZXMrKztcbiAgICAgICAgICAgIGxhc3RTZXBhcmF0b3JQb3MgPSBzZXBhcmF0b3I7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZWROb2RlcyA9PT0gMSAmJiBwcmV2ZW50QVNJKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGluZUJyZWFrcyhjb2RlLCBzdGFydCwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jbHVkZWROb2RlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSByZW5kZXJlZFBhcmVudFR5cGUgfHwgdGhpcy5wYXJlbnQudHlwZTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbmRlcihjb2RlLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDogaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50ICYmIG5vZGUgPT09IGxhc3ROb2RlLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHBhcmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlcGFyYXRvclBvcykge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUobGFzdFNlcGFyYXRvclBvcywgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTdGF0aWNCbG9jayBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCBub2RlLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgbm9kZS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGVtZW50TGlzdCh0aGlzLmJvZHksIGNvZGUsIHRoaXMuc3RhcnQgKyAxLCB0aGlzLmVuZCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTdXBlciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBiaW5kKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUoJ3RoaXMnKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTd2l0Y2hDYXNlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0ICYmIHRoaXMudGVzdC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmNvbnNlcXVlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmJyb2tlbkZsb3cpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudGVzdClcbiAgICAgICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuY29uc2VxdWVudCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8IG5vZGUuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSlcbiAgICAgICAgICAgICAgICBub2RlLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCBub2RlUmVuZGVyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5jb25zZXF1ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50ZXN0ICYmIHRoaXMudGVzdC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0RW5kID0gdGhpcy50ZXN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLnRlc3QuZW5kXG4gICAgICAgICAgICAgICAgOiBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJ2RlZmF1bHQnLCB0aGlzLnN0YXJ0KSArIDc7XG4gICAgICAgICAgICBjb25zdCBjb25zZXF1ZW50U3RhcnQgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJzonLCB0ZXN0RW5kKSArIDE7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZW1lbnRMaXN0KHRoaXMuY29uc2VxdWVudCwgY29kZSwgY29uc2VxdWVudFN0YXJ0LCBub2RlUmVuZGVyT3B0aW9ucy5lbmQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuU3dpdGNoQ2FzZS5wcm90b3R5cGUubmVlZHNCb3VuZGFyaWVzID0gdHJ1ZTtcblxuY2xhc3MgU3dpdGNoU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgQmxvY2tTY29wZShwYXJlbnRTY29wZSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5kaXNjcmltaW5hbnQuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3csIGlnbm9yZTogeyBicmVha3MgfSB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IG1pbkJyb2tlbkZsb3cgPSBJbmZpbml0eTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuYnJlYWtzID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBzd2l0Y2hDYXNlIG9mIHRoaXMuY2FzZXMpIHtcbiAgICAgICAgICAgIGlmIChzd2l0Y2hDYXNlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBtaW5Ccm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93IDwgbWluQnJva2VuRmxvdyA/IGNvbnRleHQuYnJva2VuRmxvdyA6IG1pbkJyb2tlbkZsb3c7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRDYXNlICE9PSBudWxsICYmICEobWluQnJva2VuRmxvdyA9PT0gQlJPS0VOX0ZMT1dfQlJFQUtfQ09OVElOVUUpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBtaW5Ccm9rZW5GbG93O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmJyZWFrcyA9IGJyZWFrcztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmFudC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgbWluQnJva2VuRmxvdyA9IEluZmluaXR5O1xuICAgICAgICBsZXQgaXNDYXNlSW5jbHVkZWQgPSBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fFxuICAgICAgICAgICAgKHRoaXMuZGVmYXVsdENhc2UgIT09IG51bGwgJiYgdGhpcy5kZWZhdWx0Q2FzZSA8IHRoaXMuY2FzZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGNhc2VJbmRleCA9IHRoaXMuY2FzZXMubGVuZ3RoIC0gMTsgY2FzZUluZGV4ID49IDA7IGNhc2VJbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hDYXNlID0gdGhpcy5jYXNlc1tjYXNlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN3aXRjaENhc2UuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBpc0Nhc2VJbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ2FzZUluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRWZmZWN0c0NvbnRleHQgPSBjcmVhdGVIYXNFZmZlY3RzQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGhhc0VmZmVjdHNDb250ZXh0Lmlnbm9yZS5icmVha3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzQ2FzZUluY2x1ZGVkID0gc3dpdGNoQ2FzZS5oYXNFZmZlY3RzKGhhc0VmZmVjdHNDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Nhc2VJbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaENhc2UuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICAgICAgbWluQnJva2VuRmxvdyA9IG1pbkJyb2tlbkZsb3cgPCBjb250ZXh0LmJyb2tlbkZsb3cgPyBtaW5Ccm9rZW5GbG93IDogY29udGV4dC5icm9rZW5GbG93O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5Ccm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYXNlSW5jbHVkZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdENhc2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgICEobWluQnJva2VuRmxvdyA9PT0gQlJPS0VOX0ZMT1dfQlJFQUtfQ09OVElOVUUpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBtaW5Ccm9rZW5GbG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIGZvciAobGV0IGNhc2VJbmRleCA9IDA7IGNhc2VJbmRleCA8IHRoaXMuY2FzZXMubGVuZ3RoOyBjYXNlSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FzZXNbY2FzZUluZGV4XS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0Q2FzZSA9IGNhc2VJbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0Q2FzZSA9IG51bGw7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuY2FzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGVtZW50TGlzdCh0aGlzLmNhc2VzLCBjb2RlLCB0aGlzLmNhc2VzWzBdLnN0YXJ0LCB0aGlzLmVuZCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgYmluZCgpIHtcbiAgICAgICAgc3VwZXIuYmluZCgpO1xuICAgICAgICBpZiAodGhpcy50YWcudHlwZSA9PT0gSWRlbnRpZmllciQxKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy50YWcubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQud2Fybih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdDQU5OT1RfQ0FMTF9OQU1FU1BBQ0UnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNhbGwgYSBuYW1lc3BhY2UgKCcke25hbWV9JylgXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoc3VwZXIuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy50YWcuaGFzRWZmZWN0c1doZW5DYWxsZWRBdFBhdGgoRU1QVFlfUEFUSCwgdGhpcy5jYWxsT3B0aW9ucywgY29udGV4dCkpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLmNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgYXJnczogTk9fQVJHUyxcbiAgICAgICAgICAgIHRoaXNQYXJhbTogbnVsbCxcbiAgICAgICAgICAgIHdpdGhOZXc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGFnLnJlbmRlcihjb2RlLCBvcHRpb25zLCB7IGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5xdWFzaS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5jbGFzcyBUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgLy8gRG8gbm90IHRyeSB0byBiaW5kIHZhbHVlXG4gICAgYmluZCgpIHsgfVxuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlc1RyZWVOb2RlLnZhbHVlO1xuICAgICAgICBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHsgfVxufVxuXG5jbGFzcyBUZW1wbGF0ZUxpdGVyYWwgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCB8fCB0aGlzLnF1YXNpcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVhc2lzWzBdLnZhbHVlLmNvb2tlZDtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29kZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMucHVzaChbdGhpcy5zdGFydCwgdGhpcy5lbmRdKTtcbiAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgVW5kZWZpbmVkVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCd1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuY2xhc3MgRXhwb3J0RGVmYXVsdFZhcmlhYmxlIGV4dGVuZHMgTG9jYWxWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiwgZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLmRlY2xhcmF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5oYXNJZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsSWQgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVmFyaWFibGUgPSBudWxsO1xuICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbi5kZWNsYXJhdGlvbjtcbiAgICAgICAgaWYgKChkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24gfHwgZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBDbGFzc0RlY2xhcmF0aW9uKSAmJlxuICAgICAgICAgICAgZGVjbGFyYXRpb24uaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzSWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbElkID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSWQgPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UoaWRlbnRpZmllcikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzSWQpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBc3NpZ25lZFZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsSWQgJiYgdGhpcy5vcmlnaW5hbElkLm5hbWUpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldEJhc2VWYXJpYWJsZU5hbWUoKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5nZXRPcmlnaW5hbFZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChvcmlnaW5hbCA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldEJhc2VWYXJpYWJsZU5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5nZXRCYXNlVmFyaWFibGVOYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGlyZWN0T3JpZ2luYWxWYXJpYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxJZCAmJlxuICAgICAgICAgICAgKHRoaXMuaGFzSWQgfHxcbiAgICAgICAgICAgICAgICAhKHRoaXMub3JpZ2luYWxJZC5pc1Bvc3NpYmxlVERaKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbElkLnZhcmlhYmxlLmlzUmVhc3NpZ25lZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUgaW5zdGFuY2VvZiBVbmRlZmluZWRWYXJpYWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgICAgICAgICAgICAgJ3N5bnRoZXRpY05hbWVzcGFjZScgaW4gdGhpcy5vcmlnaW5hbElkLnZhcmlhYmxlKSlcbiAgICAgICAgICAgID8gdGhpcy5vcmlnaW5hbElkLnZhcmlhYmxlXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T3JpZ2luYWxWYXJpYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxWYXJpYWJsZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVmFyaWFibGU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgb3JpZ2luYWwgPSB0aGlzO1xuICAgICAgICBsZXQgY3VycmVudFZhcmlhYmxlO1xuICAgICAgICBjb25zdCBjaGVja2VkVmFyaWFibGVzID0gbmV3IFNldCgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaGVja2VkVmFyaWFibGVzLmFkZChvcmlnaW5hbCk7XG4gICAgICAgICAgICBjdXJyZW50VmFyaWFibGUgPSBvcmlnaW5hbDtcbiAgICAgICAgICAgIG9yaWdpbmFsID0gY3VycmVudFZhcmlhYmxlLmdldERpcmVjdE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgfSB3aGlsZSAob3JpZ2luYWwgaW5zdGFuY2VvZiBFeHBvcnREZWZhdWx0VmFyaWFibGUgJiYgIWNoZWNrZWRWYXJpYWJsZXMuaGFzKG9yaWdpbmFsKSk7XG4gICAgICAgIHJldHVybiAodGhpcy5vcmlnaW5hbFZhcmlhYmxlID0gb3JpZ2luYWwgfHwgY3VycmVudFZhcmlhYmxlKTtcbiAgICB9XG59XG5cbmNsYXNzIE1vZHVsZVNjb3BlIGV4dGVuZHMgQ2hpbGRTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldCgndGhpcycsIG5ldyBMb2NhbFZhcmlhYmxlKCd0aGlzJywgbnVsbCwgVU5ERUZJTkVEX0VYUFJFU1NJT04sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgYWRkRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5hbWUsIGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IG5ldyBFeHBvcnREZWZhdWx0VmFyaWFibGUobmFtZSwgZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KCdkZWZhdWx0JywgdmFyaWFibGUpO1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxuICAgIGFkZE5hbWVzcGFjZU1lbWJlckFjY2VzcygpIHsgfVxuICAgIGRlY29uZmxpY3QoZm9ybWF0LCBleHBvcnROYW1lc0J5VmFyaWFibGUsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgLy8gYWxsIG1vZHVsZSBsZXZlbCB2YXJpYWJsZXMgYXJlIGFscmVhZHkgZGVjb25mbGljdGVkIHdoZW4gZGVjb25mbGljdGluZyB0aGUgY2h1bmtcbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgc2NvcGUuZGVjb25mbGljdChmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgfVxuICAgIGZpbmRMZXhpY2FsQm91bmRhcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5kVmFyaWFibGUobmFtZSkge1xuICAgICAgICBjb25zdCBrbm93blZhcmlhYmxlID0gdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpIHx8IHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGtub3duVmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBrbm93blZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5jb250ZXh0LnRyYWNlVmFyaWFibGUobmFtZSkgfHwgdGhpcy5wYXJlbnQuZmluZFZhcmlhYmxlKG5hbWUpO1xuICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBHbG9iYWxWYXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxufVxuXG5jbGFzcyBUaGlzRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBiaW5kKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUoJ3RoaXMnKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBkZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIHRoaXNQYXJhbWV0ZXIsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZS5kZW9wdGltaXplVGhpc09uRXZlbnRBdFBhdGgoZXZlbnQsIHBhdGgsIFxuICAgICAgICAvLyBXZSByZXdyaXRlIHRoZSBwYXJhbWV0ZXIgc28gdGhhdCBhIFRoaXNWYXJpYWJsZSBjYW4gZGV0ZWN0IHNlbGYtbXV0YXRpb25zXG4gICAgICAgIHRoaXNQYXJhbWV0ZXIgPT09IHRoaXMgPyB0aGlzLnZhcmlhYmxlIDogdGhpc1BhcmFtZXRlciwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHRoaXMudmFyaWFibGUuaGFzRWZmZWN0c1doZW5BY2Nlc3NlZEF0UGF0aChwYXRoLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChwYXRoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgocGF0aCwgY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgdGhpcy5hbGlhcyA9XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmZpbmRMZXhpY2FsQm91bmRhcnkoKSBpbnN0YW5jZW9mIE1vZHVsZVNjb3BlID8gdGhpcy5jb250ZXh0Lm1vZHVsZUNvbnRleHQgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5hbGlhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC53YXJuKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnVEhJU19JU19VTkRFRklORUQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgJ3RoaXMnIGtleXdvcmQgaXMgZXF1aXZhbGVudCB0byAndW5kZWZpbmVkJyBhdCB0aGUgdG9wIGxldmVsIG9mIGFuIEVTIG1vZHVsZSwgYW5kIGhhcyBiZWVuIHJld3JpdHRlbmAsXG4gICAgICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI2Vycm9yLXRoaXMtaXMtdW5kZWZpbmVkYFxuICAgICAgICAgICAgfSwgdGhpcy5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpYXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLmFsaWFzLCB7XG4gICAgICAgICAgICAgICAgY29udGVudE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0b3JlTmFtZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFRocm93U3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBCUk9LRU5fRkxPV19FUlJPUl9SRVRVUk5fTEFCRUw7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcHJldmVudEFTSTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQuc3RhcnQgPT09IHRoaXMuc3RhcnQgKyA1IC8qICd0aHJvdycubGVuZ3RoICovKSB7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuc3RhcnQgKyA1LCAnICcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBUcnlTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGlyZWN0bHlJbmNsdWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluY2x1ZGVkTGFiZWxzQWZ0ZXJCbG9jayA9IG51bGw7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UudHJ5Q2F0Y2hEZW9wdGltaXphdGlvblxuICAgICAgICAgICAgPyB0aGlzLmJsb2NrLmJvZHkubGVuZ3RoID4gMFxuICAgICAgICAgICAgOiB0aGlzLmJsb2NrLmhhc0VmZmVjdHMoY29udGV4dCkpIHx8XG4gICAgICAgICAgICAodGhpcy5maW5hbGl6ZXIgIT09IG51bGwgJiYgdGhpcy5maW5hbGl6ZXIuaGFzRWZmZWN0cyhjb250ZXh0KSkpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvbiA9IChfYSA9IHRoaXMuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyeUNhdGNoRGVvcHRpbWl6YXRpb247XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGx5SW5jbHVkZWQgfHwgIXRyeUNhdGNoRGVvcHRpbWl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RseUluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2suaW5jbHVkZShjb250ZXh0LCB0cnlDYXRjaERlb3B0aW1pemF0aW9uID8gSU5DTFVERV9QQVJBTUVURVJTIDogaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVkTGFiZWxzQWZ0ZXJCbG9jayA9IFsuLi5jb250ZXh0LmluY2x1ZGVkTGFiZWxzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2spIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWwgb2YgdGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmFkZChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCB1bmFyeU9wZXJhdG9ycyA9IHtcbiAgICAnISc6IHZhbHVlID0+ICF2YWx1ZSxcbiAgICAnKyc6IHZhbHVlID0+ICt2YWx1ZSxcbiAgICAnLSc6IHZhbHVlID0+IC12YWx1ZSxcbiAgICBkZWxldGU6ICgpID0+IFVua25vd25WYWx1ZSxcbiAgICB0eXBlb2Y6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSxcbiAgICB2b2lkOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgJ34nOiB2YWx1ZSA9PiB+dmFsdWVcbn07XG5jbGFzcyBVbmFyeUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRWYWx1ZSA9IHRoaXMuYXJndW1lbnQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIGlmIChhcmd1bWVudFZhbHVlID09PSBVbmtub3duVmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICByZXR1cm4gdW5hcnlPcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0oYXJndW1lbnRWYWx1ZSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAndHlwZW9mJyAmJiB0aGlzLmFyZ3VtZW50IGluc3RhbmNlb2YgSWRlbnRpZmllcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChFTVBUWV9QQVRILCBjb250ZXh0KSkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzV2hlbkFjY2Vzc2VkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICd2b2lkJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFVua25vd25Ob2RlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZShjb250ZXh0LCB0cnVlKTtcbiAgICB9XG59XG5cbmNsYXNzIFVwZGF0ZUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c1doZW5Bc3NpZ25lZEF0UGF0aChFTVBUWV9QQVRILCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQWNjZXNzZWRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgZm9ybWF0LCBzbmlwcGV0czogeyBfIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXJndW1lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmFyZ3VtZW50LnZhcmlhYmxlO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0TmFtZXMgPSBleHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0TmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRFeHByZXNzaW9uKHZhcmlhYmxlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRTZXF1ZW5jZUFmdGVyRXhwcmVzc2lvbih2YXJpYWJsZSwgdGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMucGFyZW50LnR5cGUgIT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvclswXTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VCZWZvcmVFeHByZXNzaW9uKHZhcmlhYmxlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5wYXJlbnQudHlwZSAhPT0gRXhwcmVzc2lvblN0YXRlbWVudCQxLCBjb2RlLCBvcHRpb25zLCBgJHtffSR7b3BlcmF0b3J9JHtffTFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICBpZiAodGhpcy5hcmd1bWVudCBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUodGhpcy5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgIHZhcmlhYmxlLmlzUmVhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzUmVhc3NpZ25lZEV4cG9ydHNNZW1iZXIodmFyaWFibGUsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgIHJldHVybiAodmFyaWFibGUucmVuZGVyQmFzZU5hbWUgIT09IG51bGwgJiYgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh2YXJpYWJsZSkgJiYgdmFyaWFibGUuaXNSZWFzc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gYXJlQWxsRGVjbGFyYXRpb25zSW5jbHVkZWRBbmROb3RFeHBvcnRlZChkZWNsYXJhdGlvbnMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgIGZvciAoY29uc3QgZGVjbGFyYXRvciBvZiBkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNsYXJhdG9yLmlkLmluY2x1ZGVkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVjbGFyYXRvci5pZC50eXBlID09PSBJZGVudGlmaWVyJDEpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKGRlY2xhcmF0b3IuaWQudmFyaWFibGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkVmFyaWFibGVzID0gW107XG4gICAgICAgICAgICBkZWNsYXJhdG9yLmlkLmFkZEV4cG9ydGVkVmFyaWFibGVzKGV4cG9ydGVkVmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICAgICAgaWYgKGV4cG9ydGVkVmFyaWFibGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgVmFyaWFibGVEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZW9wdGltaXplUGF0aCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBkZWNsYXJhdG9yLmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0VmZmVjdHNXaGVuQXNzaWduZWRBdFBhdGgoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgZGVjbGFyYXRvci5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIGRlY2xhcmF0b3IuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0b3Igb2YgdGhpcy5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCBkZWNsYXJhdG9yLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBkZWNsYXJhdG9yLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0b3IuaWQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBkZWNsYXJhdG9yLmRlY2xhcmVEZWNsYXJhdG9yKHRoaXMua2luZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIG5vZGVSZW5kZXJPcHRpb25zID0gQkxBTkspIHtcbiAgICAgICAgaWYgKGFyZUFsbERlY2xhcmF0aW9uc0luY2x1ZGVkQW5kTm90RXhwb3J0ZWQodGhpcy5kZWNsYXJhdGlvbnMsIG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRvci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGVSZW5kZXJPcHRpb25zLmlzTm9TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQgLSAxKSAhPT0gNTkgLypcIjtcIiovKSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSZXBsYWNlZERlY2xhcmF0aW9ucyhjb2RlLCBvcHRpb25zLCBub2RlUmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyRGVjbGFyYXRpb25FbmQoY29kZSwgc2VwYXJhdG9yU3RyaW5nLCBsYXN0U2VwYXJhdG9yUG9zLCBhY3R1YWxDb250ZW50RW5kLCByZW5kZXJlZENvbnRlbnRFbmQsIHN5c3RlbVBhdHRlcm5FeHBvcnRzLCBvcHRpb25zLCBpc05vU3RhdGVtZW50KSB7XG4gICAgICAgIGlmIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQgLSAxKSA9PT0gNTkgLypcIjtcIiovKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLmVuZCAtIDEsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTm9TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvclN0cmluZyArPSAnOyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTZXBhcmF0b3JQb3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQoYWN0dWFsQ29udGVudEVuZCAtIDEpID09PSAxMCAvKlwiXFxuXCIqLyAmJlxuICAgICAgICAgICAgICAgIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQpID09PSAxMCAvKlwiXFxuXCIqLyB8fFxuICAgICAgICAgICAgICAgICAgICBjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQpID09PSAxMykgLypcIlxcclwiKi8pIHtcbiAgICAgICAgICAgICAgICBhY3R1YWxDb250ZW50RW5kLS07XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUub3JpZ2luYWwuY2hhckNvZGVBdChhY3R1YWxDb250ZW50RW5kKSA9PT0gMTMgLypcIlxcclwiKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsQ29udGVudEVuZC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3R1YWxDb250ZW50RW5kID09PSBsYXN0U2VwYXJhdG9yUG9zICsgMSkge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxhc3RTZXBhcmF0b3JQb3MsIHJlbmRlcmVkQ29udGVudEVuZCwgc2VwYXJhdG9yU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxhc3RTZXBhcmF0b3JQb3MsIGxhc3RTZXBhcmF0b3JQb3MgKyAxLCBzZXBhcmF0b3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGFjdHVhbENvbnRlbnRFbmQsIHJlbmRlcmVkQ29udGVudEVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocmVuZGVyZWRDb250ZW50RW5kLCBzZXBhcmF0b3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeXN0ZW1QYXR0ZXJuRXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocmVuZGVyZWRDb250ZW50RW5kLCBgICR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KHN5c3RlbVBhdHRlcm5FeHBvcnRzLCBvcHRpb25zKX07YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyUmVwbGFjZWREZWNsYXJhdGlvbnMoY29kZSwgb3B0aW9ucywgeyBpc05vU3RhdGVtZW50IH0pIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGVkTm9kZXMgPSBnZXRDb21tYVNlcGFyYXRlZE5vZGVzV2l0aEJvdW5kYXJpZXModGhpcy5kZWNsYXJhdGlvbnMsIGNvZGUsIHRoaXMuc3RhcnQgKyB0aGlzLmtpbmQubGVuZ3RoLCB0aGlzLmVuZCAtIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQgLSAxKSA9PT0gNTkgLypcIjtcIiovID8gMSA6IDApKTtcbiAgICAgICAgbGV0IGFjdHVhbENvbnRlbnRFbmQsIHJlbmRlcmVkQ29udGVudEVuZDtcbiAgICAgICAgcmVuZGVyZWRDb250ZW50RW5kID0gZmluZE5vbldoaXRlU3BhY2UoY29kZS5vcmlnaW5hbCwgdGhpcy5zdGFydCArIHRoaXMua2luZC5sZW5ndGgpO1xuICAgICAgICBsZXQgbGFzdFNlcGFyYXRvclBvcyA9IHJlbmRlcmVkQ29udGVudEVuZCAtIDE7XG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIGxhc3RTZXBhcmF0b3JQb3MpO1xuICAgICAgICBsZXQgaXNJbkRlY2xhcmF0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBoYXNSZW5kZXJlZENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcGFyYXRvclN0cmluZyA9ICcnLCBsZWFkaW5nU3RyaW5nLCBuZXh0U2VwYXJhdG9yU3RyaW5nO1xuICAgICAgICBjb25zdCBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cyA9IFtdO1xuICAgICAgICBjb25zdCBzaW5nbGVTeXN0ZW1FeHBvcnQgPSBnYXRoZXJTeXN0ZW1FeHBvcnRzQW5kR2V0U2luZ2xlRXhwb3J0KHNlcGFyYXRlZE5vZGVzLCBvcHRpb25zLCBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cyk7XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlLCBzdGFydCwgc2VwYXJhdG9yLCBjb250ZW50RW5kLCBlbmQgfSBvZiBzZXBhcmF0ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxlYWRpbmdTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIG5leHRTZXBhcmF0b3JTdHJpbmcgPSAnJztcbiAgICAgICAgICAgIGlmICghbm9kZS5pZC5pbmNsdWRlZCB8fFxuICAgICAgICAgICAgICAgIChub2RlLmlkIGluc3RhbmNlb2YgSWRlbnRpZmllciAmJlxuICAgICAgICAgICAgICAgICAgICBpc1JlYXNzaWduZWRFeHBvcnRzTWVtYmVyKG5vZGUuaWQudmFyaWFibGUsIG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUmVuZGVyZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvclN0cmluZyArPSAnOyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzSW5EZWNsYXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVN5c3RlbUV4cG9ydCAmJiBzaW5nbGVTeXN0ZW1FeHBvcnQgPT09IG5vZGUuaWQudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JQb3MgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJz0nLCBub2RlLmlkLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN5c3RlbUV4cG9ydEV4cHJlc3Npb24oc2luZ2xlU3lzdGVtRXhwb3J0LCBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCBvcGVyYXRvclBvcyArIDEpLCBzZXBhcmF0b3IgPT09IG51bGwgPyBjb250ZW50RW5kIDogc2VwYXJhdG9yLCBjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JTdHJpbmcgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1JlbmRlcmVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nICs9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nU3RyaW5nICs9IGAke3RoaXMua2luZH0gYDtcbiAgICAgICAgICAgICAgICAgICAgaXNJbkRlY2xhcmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRDb250ZW50RW5kID09PSBsYXN0U2VwYXJhdG9yUG9zICsgMSkge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGxhc3RTZXBhcmF0b3JQb3MsIHJlbmRlcmVkQ29udGVudEVuZCwgc2VwYXJhdG9yU3RyaW5nICsgbGVhZGluZ1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0U2VwYXJhdG9yUG9zLCBsYXN0U2VwYXJhdG9yUG9zICsgMSwgc2VwYXJhdG9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocmVuZGVyZWRDb250ZW50RW5kLCBsZWFkaW5nU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdHVhbENvbnRlbnRFbmQgPSBjb250ZW50RW5kO1xuICAgICAgICAgICAgcmVuZGVyZWRDb250ZW50RW5kID0gZW5kO1xuICAgICAgICAgICAgaGFzUmVuZGVyZWRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RTZXBhcmF0b3JQb3MgPSBzZXBhcmF0b3I7XG4gICAgICAgICAgICBzZXBhcmF0b3JTdHJpbmcgPSBuZXh0U2VwYXJhdG9yU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyRGVjbGFyYXRpb25FbmQoY29kZSwgc2VwYXJhdG9yU3RyaW5nLCBsYXN0U2VwYXJhdG9yUG9zLCBhY3R1YWxDb250ZW50RW5kLCByZW5kZXJlZENvbnRlbnRFbmQsIGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLCBvcHRpb25zLCBpc05vU3RhdGVtZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJTeXN0ZW1FeHBvcnRzQW5kR2V0U2luZ2xlRXhwb3J0KHNlcGFyYXRlZE5vZGVzLCBvcHRpb25zLCBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc2luZ2xlU3lzdGVtRXhwb3J0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdzeXN0ZW0nKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2Ygc2VwYXJhdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkIGluc3RhbmNlb2YgSWRlbnRpZmllciAmJlxuICAgICAgICAgICAgICAgIG5vZGUuaW5pdCAmJlxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSBvcHRpb25zLmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQobm9kZS5pZC52YXJpYWJsZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlU3lzdGVtRXhwb3J0ID0gbm9kZS5pZC52YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cy5wdXNoKHNpbmdsZVN5c3RlbUV4cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmlkLmFkZEV4cG9ydGVkVmFyaWFibGVzKGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLCBvcHRpb25zLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZVN5c3RlbUV4cG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2luZ2xlU3lzdGVtRXhwb3J0KSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGVTeXN0ZW1FeHBvcnQ7XG59XG5cbmNsYXNzIFZhcmlhYmxlRGVjbGFyYXRvciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZWNsYXJlRGVjbGFyYXRvcihraW5kKSB7XG4gICAgICAgIHRoaXMuaWQuZGVjbGFyZShraW5kLCB0aGlzLmluaXQgfHwgVU5ERUZJTkVEX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHRoaXMuaWQuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBjb25zdCBpbml0RWZmZWN0ID0gdGhpcy5pbml0ICE9PSBudWxsICYmIHRoaXMuaW5pdC5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgcmV0dXJuIGluaXRFZmZlY3QgfHwgdGhpcy5pZC5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pbml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaXQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZC5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCB0aGlzLmlkLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIHNuaXBwZXRzOiB7IF8gfSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVuZGVySWQgPSB0aGlzLmlkLmluY2x1ZGVkO1xuICAgICAgICBpZiAocmVuZGVySWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JQb3MgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJz0nLCB0aGlzLmlkLmVuZCk7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCBvcGVyYXRvclBvcyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaXQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHJlbmRlcklkID8gQkxBTksgOiB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiBFeHByZXNzaW9uU3RhdGVtZW50JDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pZCBpbnN0YW5jZW9mIElkZW50aWZpZXIgJiZcbiAgICAgICAgICAgIGlzUmVhc3NpZ25lZEV4cG9ydHNNZW1iZXIodGhpcy5pZC52YXJpYWJsZSwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCBgJHtffT0ke199dm9pZCAwYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFdoaWxlU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93LCBpZ25vcmU6IHsgYnJlYWtzLCBjb250aW51ZXMgfSB9ID0gY29udGV4dDtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuYnJlYWtzID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5pZ25vcmUuY29udGludWVzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnRleHQuaWdub3JlLmJyZWFrcyA9IGJyZWFrcztcbiAgICAgICAgY29udGV4dC5pZ25vcmUuY29udGludWVzID0gY29udGludWVzO1xuICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZUFzU2luZ2xlU3RhdGVtZW50KGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICB9XG59XG5cbmNsYXNzIFlpZWxkRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gKCFjb250ZXh0Lmlnbm9yZS5yZXR1cm5ZaWVsZCB8fCAodGhpcy5hcmd1bWVudCAhPT0gbnVsbCAmJiB0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkpKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcHJldmVudEFTSTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3VtZW50LnN0YXJ0ID09PSB0aGlzLnN0YXJ0ICsgNSAvKiAneWllbGQnLmxlbmd0aCAqLykge1xuICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5zdGFydCArIDUsICcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGFyZ3VtZW50IH0gPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBub2RlQ29uc3RydWN0b3JzID0ge1xuICAgIEFycmF5RXhwcmVzc2lvbixcbiAgICBBcnJheVBhdHRlcm4sXG4gICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgQXNzaWdubWVudFBhdHRlcm4sXG4gICAgQXdhaXRFeHByZXNzaW9uLFxuICAgIEJpbmFyeUV4cHJlc3Npb24sXG4gICAgQmxvY2tTdGF0ZW1lbnQsXG4gICAgQnJlYWtTdGF0ZW1lbnQsXG4gICAgQ2FsbEV4cHJlc3Npb24sXG4gICAgQ2F0Y2hDbGF1c2UsXG4gICAgQ2hhaW5FeHByZXNzaW9uLFxuICAgIENsYXNzQm9keSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uLFxuICAgIENsYXNzRXhwcmVzc2lvbixcbiAgICBDb25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgQ29udGludWVTdGF0ZW1lbnQsXG4gICAgRG9XaGlsZVN0YXRlbWVudCxcbiAgICBFbXB0eVN0YXRlbWVudCxcbiAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbixcbiAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgICBFeHBvcnRTcGVjaWZpZXIsXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICBGb3JJblN0YXRlbWVudCxcbiAgICBGb3JPZlN0YXRlbWVudCxcbiAgICBGb3JTdGF0ZW1lbnQsXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICBGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgSWRlbnRpZmllcixcbiAgICBJZlN0YXRlbWVudCxcbiAgICBJbXBvcnREZWNsYXJhdGlvbixcbiAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICAgIEltcG9ydEV4cHJlc3Npb24sXG4gICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyLFxuICAgIEltcG9ydFNwZWNpZmllcixcbiAgICBMYWJlbGVkU3RhdGVtZW50LFxuICAgIExpdGVyYWwsXG4gICAgTG9naWNhbEV4cHJlc3Npb24sXG4gICAgTWVtYmVyRXhwcmVzc2lvbixcbiAgICBNZXRhUHJvcGVydHksXG4gICAgTWV0aG9kRGVmaW5pdGlvbixcbiAgICBOZXdFeHByZXNzaW9uLFxuICAgIE9iamVjdEV4cHJlc3Npb24sXG4gICAgT2JqZWN0UGF0dGVybixcbiAgICBQcml2YXRlSWRlbnRpZmllcixcbiAgICBQcm9ncmFtLFxuICAgIFByb3BlcnR5LFxuICAgIFByb3BlcnR5RGVmaW5pdGlvbixcbiAgICBSZXN0RWxlbWVudCxcbiAgICBSZXR1cm5TdGF0ZW1lbnQsXG4gICAgU2VxdWVuY2VFeHByZXNzaW9uLFxuICAgIFNwcmVhZEVsZW1lbnQsXG4gICAgU3RhdGljQmxvY2ssXG4gICAgU3VwZXIsXG4gICAgU3dpdGNoQ2FzZSxcbiAgICBTd2l0Y2hTdGF0ZW1lbnQsXG4gICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLFxuICAgIFRlbXBsYXRlRWxlbWVudCxcbiAgICBUZW1wbGF0ZUxpdGVyYWwsXG4gICAgVGhpc0V4cHJlc3Npb24sXG4gICAgVGhyb3dTdGF0ZW1lbnQsXG4gICAgVHJ5U3RhdGVtZW50LFxuICAgIFVuYXJ5RXhwcmVzc2lvbixcbiAgICBVbmtub3duTm9kZSxcbiAgICBVcGRhdGVFeHByZXNzaW9uLFxuICAgIFZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgVmFyaWFibGVEZWNsYXJhdG9yLFxuICAgIFdoaWxlU3RhdGVtZW50LFxuICAgIFlpZWxkRXhwcmVzc2lvblxufTtcblxuY29uc3QgTUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRSA9ICdfbWlzc2luZ0V4cG9ydFNoaW0nO1xuXG5jbGFzcyBFeHBvcnRTaGltVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlKSB7XG4gICAgICAgIHN1cGVyKE1JU1NJTkdfRVhQT1JUX1NISU1fVkFSSUFCTEUpO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZSgpO1xuICAgICAgICB0aGlzLm1vZHVsZS5uZWVkc0V4cG9ydFNoaW0gPSB0cnVlO1xuICAgIH1cbn1cblxuY2xhc3MgTmFtZXNwYWNlVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0LmdldE1vZHVsZU5hbWUoKSk7XG4gICAgICAgIHRoaXMubWVtYmVyVmFyaWFibGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZWROYW1lc3BhY2VzID0gW107XG4gICAgICAgIHRoaXMucmVmZXJlbmNlZEVhcmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGNvbnRleHQubW9kdWxlO1xuICAgIH1cbiAgICBhZGRSZWZlcmVuY2UoaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucHVzaChpZGVudGlmaWVyKTtcbiAgICAgICAgdGhpcy5uYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgIH1cbiAgICBnZXRNZW1iZXJWYXJpYWJsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbWJlclZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyVmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlclZhcmlhYmxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmNvbnRleHQuZ2V0RXhwb3J0cygpLmNvbmNhdCh0aGlzLmNvbnRleHQuZ2V0UmVleHBvcnRzKCkpKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSAhPT0gJyonICYmIG5hbWUgIT09IHRoaXMubW9kdWxlLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRWYXJpYWJsZSA9IHRoaXMuY29udGV4dC50cmFjZUV4cG9ydChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJWYXJpYWJsZXNbbmFtZV0gPSBleHBvcnRlZFZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMubWVtYmVyVmFyaWFibGVzID0gbWVtYmVyVmFyaWFibGVzKTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlQWxsRXhwb3J0cygpO1xuICAgIH1cbiAgICBwcmVwYXJlKGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkTmFtZXNwYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZS5zY29wZS5hZGRBY2Nlc3NlZEdsb2JhbHMoW01FUkdFX05BTUVTUEFDRVNfVkFSSUFCTEVdLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJCbG9jayhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBmb3JtYXQsIGZyZWV6ZSwgaW5kZW50OiB0LCBuYW1lc3BhY2VUb1N0cmluZ1RhZywgc25pcHBldHM6IHsgXywgY25zdCwgZ2V0T2JqZWN0LCBnZXRQcm9wZXJ0eUFjY2VzcywgbiwgcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBtZW1iZXJWYXJpYWJsZXMgPSB0aGlzLmdldE1lbWJlclZhcmlhYmxlcygpO1xuICAgICAgICBjb25zdCBtZW1iZXJzID0gT2JqZWN0LmVudHJpZXMobWVtYmVyVmFyaWFibGVzKS5tYXAoKFtuYW1lLCBvcmlnaW5hbF0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZWRFYXJseSB8fCBvcmlnaW5hbC5pc1JlYXNzaWduZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBgZ2V0ICR7bmFtZX0ke199KCkke199eyR7X31yZXR1cm4gJHtvcmlnaW5hbC5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKX0ke3N9JHtffX1gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgb3JpZ2luYWwuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcyldO1xuICAgICAgICB9KTtcbiAgICAgICAgbWVtYmVycy51bnNoaWZ0KFtudWxsLCBgX19wcm90b19fOiR7X31udWxsYF0pO1xuICAgICAgICBsZXQgb3V0cHV0ID0gZ2V0T2JqZWN0KG1lbWJlcnMsIHsgbGluZUJyZWFrSW5kZW50OiB7IGJhc2U6ICcnLCB0IH0gfSk7XG4gICAgICAgIGlmICh0aGlzLm1lcmdlZE5hbWVzcGFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudEFyZ3MgPSB0aGlzLm1lcmdlZE5hbWVzcGFjZXMubWFwKHZhcmlhYmxlID0+IHZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpKTtcbiAgICAgICAgICAgIG91dHB1dCA9IGAvKiNfX1BVUkVfXyovJHtNRVJHRV9OQU1FU1BBQ0VTX1ZBUklBQkxFfSgke291dHB1dH0sJHtffVske2Fzc2lnbm1lbnRBcmdzLmpvaW4oYCwke199YCl9XSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGhlbHBlciB0byBtZXJnZSBuYW1lc3BhY2VzIHdpbGwgYWxzbyB0YWtlIGNhcmUgb2YgZnJlZXppbmcgYW5kIHRvU3RyaW5nVGFnXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBgLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSgke291dHB1dH0sJHtffVN5bWJvbC50b1N0cmluZ1RhZywke199JHtnZXRUb1N0cmluZ1RhZ1ZhbHVlKGdldE9iamVjdCl9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJlZXplKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gYC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKCR7b3V0cHV0fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpO1xuICAgICAgICBvdXRwdXQgPSBgJHtjbnN0fSAke25hbWV9JHtffT0ke199JHtvdXRwdXR9O2A7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdzeXN0ZW0nICYmIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXModGhpcykpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBgJHtufSR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KFt0aGlzXSwgb3B0aW9ucyl9O2A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgcmVuZGVyRmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZWRFYXJseTtcbiAgICB9XG4gICAgc2V0TWVyZ2VkTmFtZXNwYWNlcyhtZXJnZWROYW1lc3BhY2VzKSB7XG4gICAgICAgIHRoaXMubWVyZ2VkTmFtZXNwYWNlcyA9IG1lcmdlZE5hbWVzcGFjZXM7XG4gICAgICAgIGNvbnN0IG1vZHVsZUV4ZWNJbmRleCA9IHRoaXMuY29udGV4dC5nZXRNb2R1bGVFeGVjSW5kZXgoKTtcbiAgICAgICAgZm9yIChjb25zdCBpZGVudGlmaWVyIG9mIHRoaXMucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIuY29udGV4dC5nZXRNb2R1bGVFeGVjSW5kZXgoKSA8PSBtb2R1bGVFeGVjSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZWRFYXJseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5OYW1lc3BhY2VWYXJpYWJsZS5wcm90b3R5cGUuaXNOYW1lc3BhY2UgPSB0cnVlO1xuXG5jbGFzcyBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIG5hbWUsIHN5bnRoZXRpY05hbWVzcGFjZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5iYXNlVmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGNvbnRleHQubW9kdWxlO1xuICAgICAgICB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSA9IHN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0QmFzZVZhcmlhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlVmFyaWFibGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlVmFyaWFibGU7XG4gICAgICAgIGxldCBiYXNlVmFyaWFibGUgPSB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICAgICAgd2hpbGUgKGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSB8fFxuICAgICAgICAgICAgYmFzZVZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgaWYgKGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYmFzZVZhcmlhYmxlLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgPT09IGJhc2VWYXJpYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgYmFzZVZhcmlhYmxlID0gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzZVZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VWYXJpYWJsZSA9IGJhc2VWYXJpYWJsZS5zeW50aGV0aWNOYW1lc3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VWYXJpYWJsZSA9IGJhc2VWYXJpYWJsZSk7XG4gICAgfVxuICAgIGdldEJhc2VWYXJpYWJsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZS5nZXRCYXNlVmFyaWFibGVOYW1lKCk7XG4gICAgfVxuICAgIGdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc3ludGhldGljTmFtZXNwYWNlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSR7Z2V0UHJvcGVydHlBY2Nlc3ModGhpcy5uYW1lKX1gO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMuc3ludGhldGljTmFtZXNwYWNlKTtcbiAgICB9XG4gICAgc2V0UmVuZGVyTmFtZXMoYmFzZU5hbWUsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIuc2V0UmVuZGVyTmFtZXMoYmFzZU5hbWUsIG5hbWUpO1xuICAgIH1cbn1cblxudmFyIEJ1aWxkUGhhc2U7XG4oZnVuY3Rpb24gKEJ1aWxkUGhhc2UpIHtcbiAgICBCdWlsZFBoYXNlW0J1aWxkUGhhc2VbXCJMT0FEX0FORF9QQVJTRVwiXSA9IDBdID0gXCJMT0FEX0FORF9QQVJTRVwiO1xuICAgIEJ1aWxkUGhhc2VbQnVpbGRQaGFzZVtcIkFOQUxZU0VcIl0gPSAxXSA9IFwiQU5BTFlTRVwiO1xuICAgIEJ1aWxkUGhhc2VbQnVpbGRQaGFzZVtcIkdFTkVSQVRFXCJdID0gMl0gPSBcIkdFTkVSQVRFXCI7XG59KShCdWlsZFBoYXNlIHx8IChCdWlsZFBoYXNlID0ge30pKTtcblxuZnVuY3Rpb24gZ2V0SWQobSkge1xuICAgIHJldHVybiBtLmlkO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbExvY2F0aW9uKHNvdXJjZW1hcENoYWluLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IGZpbHRlcmVkU291cmNlbWFwQ2hhaW4gPSBzb3VyY2VtYXBDaGFpbi5maWx0ZXIoKHNvdXJjZW1hcCkgPT4gISFzb3VyY2VtYXAubWFwcGluZ3MpO1xuICAgIHRyYWNlU291cmNlbWFwOiB3aGlsZSAoZmlsdGVyZWRTb3VyY2VtYXBDaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZW1hcCA9IGZpbHRlcmVkU291cmNlbWFwQ2hhaW4ucG9wKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzb3VyY2VtYXAubWFwcGluZ3NbbG9jYXRpb24ubGluZSAtIDFdO1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRMaW5lID0gbGluZS5maWx0ZXIoKHNlZ21lbnQpID0+IHNlZ21lbnQubGVuZ3RoID4gMSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZpbHRlcmVkTGluZVtmaWx0ZXJlZExpbmUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgZmlsdGVyZWRMaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRbMF0gPj0gbG9jYXRpb24uY29sdW1uIHx8IHNlZ21lbnQgPT09IGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBzZWdtZW50WzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogc2VnbWVudFsyXSArIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgdHJhY2VTb3VyY2VtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlc29sdmUgb3JpZ2luYWwgbG9jYXRpb24gb2YgZXJyb3IuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYXRpb247XG59XG5cbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG5sZXQgdGltZXJzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGFiZWwobGFiZWwsIGxldmVsKSB7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYCMgJHtsYWJlbH1gO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYCMjICR7bGFiZWx9YDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGAkeycgICcucmVwZWF0KGxldmVsIC0gNCl9LSAke2xhYmVsfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGltZVN0YXJ0SW1wbChsYWJlbCwgbGV2ZWwgPSAzKSB7XG4gICAgbGFiZWwgPSBnZXRQZXJzaXN0ZWRMYWJlbChsYWJlbCwgbGV2ZWwpO1xuICAgIGNvbnN0IHN0YXJ0TWVtb3J5ID0gcHJvY2VzcyQxLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgdGltZXIgPSB0aW1lcnMuZ2V0KGxhYmVsKTtcbiAgICBpZiAodGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lcnMuc2V0KGxhYmVsLCB7XG4gICAgICAgICAgICBtZW1vcnk6IDAsXG4gICAgICAgICAgICBzdGFydE1lbW9yeSxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB0b3RhbE1lbW9yeTogMFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRpbWVyLnN0YXJ0TWVtb3J5ID0gc3RhcnRNZW1vcnk7XG4gICAgICAgIHRpbWVyLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lRW5kSW1wbChsYWJlbCwgbGV2ZWwgPSAzKSB7XG4gICAgbGFiZWwgPSBnZXRQZXJzaXN0ZWRMYWJlbChsYWJlbCwgbGV2ZWwpO1xuICAgIGNvbnN0IHRpbWVyID0gdGltZXJzLmdldChsYWJlbCk7XG4gICAgaWYgKHRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE1lbW9yeSA9IHByb2Nlc3MkMS5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgICB0aW1lci5tZW1vcnkgKz0gY3VycmVudE1lbW9yeSAtIHRpbWVyLnN0YXJ0TWVtb3J5O1xuICAgICAgICB0aW1lci50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGltZXIuc3RhcnRUaW1lO1xuICAgICAgICB0aW1lci50b3RhbE1lbW9yeSA9IE1hdGgubWF4KHRpbWVyLnRvdGFsTWVtb3J5LCBjdXJyZW50TWVtb3J5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUaW1pbmdzKCkge1xuICAgIGNvbnN0IG5ld1RpbWluZ3MgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtsYWJlbCwgeyBtZW1vcnksIHRpbWUsIHRvdGFsTWVtb3J5IH1dIG9mIHRpbWVycykge1xuICAgICAgICBuZXdUaW1pbmdzW2xhYmVsXSA9IFt0aW1lLCBtZW1vcnksIHRvdGFsTWVtb3J5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1RpbWluZ3M7XG59XG5sZXQgdGltZVN0YXJ0ID0gTk9PUDtcbmxldCB0aW1lRW5kID0gTk9PUDtcbmNvbnN0IFRJTUVEX1BMVUdJTl9IT09LUyA9IFsnbG9hZCcsICdyZXNvbHZlRHluYW1pY0ltcG9ydCcsICdyZXNvbHZlSWQnLCAndHJhbnNmb3JtJ107XG5mdW5jdGlvbiBnZXRQbHVnaW5XaXRoVGltZXJzKHBsdWdpbiwgaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGhvb2sgb2YgVElNRURfUExVR0lOX0hPT0tTKSB7XG4gICAgICAgIGlmIChob29rIGluIHBsdWdpbikge1xuICAgICAgICAgICAgbGV0IHRpbWVyTGFiZWwgPSBgcGx1Z2luICR7aW5kZXh9YDtcbiAgICAgICAgICAgIGlmIChwbHVnaW4ubmFtZSkge1xuICAgICAgICAgICAgICAgIHRpbWVyTGFiZWwgKz0gYCAoJHtwbHVnaW4ubmFtZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVyTGFiZWwgKz0gYCAtICR7aG9va31gO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHBsdWdpbltob29rXTtcbiAgICAgICAgICAgIHBsdWdpbltob29rXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgdGltZVN0YXJ0KHRpbWVyTGFiZWwsIDQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgdGltZUVuZCh0aW1lckxhYmVsLCA0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhcnQoYCR7dGltZXJMYWJlbH0gKGFzeW5jKWAsIDQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGhvb2tSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVFbmQoYCR7dGltZXJMYWJlbH0gKGFzeW5jKWAsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvb2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luO1xufVxuZnVuY3Rpb24gaW5pdGlhbGlzZVRpbWVycyhpbnB1dE9wdGlvbnMpIHtcbiAgICBpZiAoaW5wdXRPcHRpb25zLnBlcmYpIHtcbiAgICAgICAgdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aW1lU3RhcnQgPSB0aW1lU3RhcnRJbXBsO1xuICAgICAgICB0aW1lRW5kID0gdGltZUVuZEltcGw7XG4gICAgICAgIGlucHV0T3B0aW9ucy5wbHVnaW5zID0gaW5wdXRPcHRpb25zLnBsdWdpbnMubWFwKGdldFBsdWdpbldpdGhUaW1lcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGltZVN0YXJ0ID0gTk9PUDtcbiAgICAgICAgdGltZUVuZCA9IE5PT1A7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZChiYXNlTW9kdWxlKSB7XG4gICAgYmFzZU1vZHVsZS5pc0V4ZWN1dGVkID0gdHJ1ZTtcbiAgICBjb25zdCBtb2R1bGVzID0gW2Jhc2VNb2R1bGVdO1xuICAgIGNvbnN0IHZpc2l0ZWRNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIFsuLi5tb2R1bGUuZGVwZW5kZW5jaWVzLCAuLi5tb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZV0pIHtcbiAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkgJiZcbiAgICAgICAgICAgICAgICAhZGVwZW5kZW5jeS5pc0V4ZWN1dGVkICYmXG4gICAgICAgICAgICAgICAgKGRlcGVuZGVuY3kuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyB8fCBtb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5oYXMoZGVwZW5kZW5jeSkpICYmXG4gICAgICAgICAgICAgICAgIXZpc2l0ZWRNb2R1bGVzLmhhcyhkZXBlbmRlbmN5LmlkKSkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kuaXNFeGVjdXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRlZE1vZHVsZXMuYWRkKGRlcGVuZGVuY3kuaWQpO1xuICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUlTU0lOR19FWFBPUlRfU0hJTV9ERVNDUklQVElPTiA9IHtcbiAgICBpZGVudGlmaWVyOiBudWxsLFxuICAgIGxvY2FsTmFtZTogTUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRVxufTtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZVJlY3Vyc2l2ZSh0YXJnZXQsIG5hbWUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMsIGlzRXhwb3J0QWxsU2VhcmNoLCBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcyA9IG5ldyBNYXAoKSkge1xuICAgIGNvbnN0IHNlYXJjaGVkTW9kdWxlcyA9IHNlYXJjaGVkTmFtZXNBbmRNb2R1bGVzLmdldChuYW1lKTtcbiAgICBpZiAoc2VhcmNoZWRNb2R1bGVzKSB7XG4gICAgICAgIGlmIChzZWFyY2hlZE1vZHVsZXMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0V4cG9ydEFsbFNlYXJjaCA/IFtudWxsXSA6IGVycm9yKGVyckNpcmN1bGFyUmVleHBvcnQobmFtZSwgdGFyZ2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoZWRNb2R1bGVzLmFkZCh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMuc2V0KG5hbWUsIG5ldyBTZXQoW3RhcmdldF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSwge1xuICAgICAgICBpbXBvcnRlckZvclNpZGVFZmZlY3RzLFxuICAgICAgICBpc0V4cG9ydEFsbFNlYXJjaCxcbiAgICAgICAgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXNcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFuZEV4dGVuZFNpZGVFZmZlY3RNb2R1bGVzKHZhcmlhYmxlLCBtb2R1bGUpIHtcbiAgICBjb25zdCBzaWRlRWZmZWN0TW9kdWxlcyA9IGdldE9yQ3JlYXRlKG1vZHVsZS5zaWRlRWZmZWN0RGVwZW5kZW5jaWVzQnlWYXJpYWJsZSwgdmFyaWFibGUsICgpID0+IG5ldyBTZXQoKSk7XG4gICAgbGV0IGN1cnJlbnRWYXJpYWJsZSA9IHZhcmlhYmxlO1xuICAgIGNvbnN0IHJlZmVyZW5jZWRWYXJpYWJsZXMgPSBuZXcgU2V0KFtjdXJyZW50VmFyaWFibGVdKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBpbXBvcnRpbmdNb2R1bGUgPSBjdXJyZW50VmFyaWFibGUubW9kdWxlO1xuICAgICAgICBjdXJyZW50VmFyaWFibGUgPVxuICAgICAgICAgICAgY3VycmVudFZhcmlhYmxlIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdFZhcmlhYmxlXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50VmFyaWFibGUuZ2V0RGlyZWN0T3JpZ2luYWxWYXJpYWJsZSgpXG4gICAgICAgICAgICAgICAgOiBjdXJyZW50VmFyaWFibGUgaW5zdGFuY2VvZiBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFZhcmlhYmxlLnN5bnRoZXRpY05hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghY3VycmVudFZhcmlhYmxlIHx8IHJlZmVyZW5jZWRWYXJpYWJsZXMuaGFzKGN1cnJlbnRWYXJpYWJsZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlZmVyZW5jZWRWYXJpYWJsZXMuYWRkKGN1cnJlbnRWYXJpYWJsZSk7XG4gICAgICAgIHNpZGVFZmZlY3RNb2R1bGVzLmFkZChpbXBvcnRpbmdNb2R1bGUpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFNpZGVFZmZlY3RzID0gaW1wb3J0aW5nTW9kdWxlLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlLmdldChjdXJyZW50VmFyaWFibGUpO1xuICAgICAgICBpZiAob3JpZ2luYWxTaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2Ygb3JpZ2luYWxTaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgICAgIHNpZGVFZmZlY3RNb2R1bGVzLmFkZChtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaWRlRWZmZWN0TW9kdWxlcztcbn1cbmNsYXNzIE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoZ3JhcGgsIGlkLCBvcHRpb25zLCBpc0VudHJ5LCBtb2R1bGVTaWRlRWZmZWN0cywgc3ludGhldGljTmFtZWRFeHBvcnRzLCBtZXRhKSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNodW5rRmlsZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNodW5rTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jeWNsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZHluYW1pY0ltcG9ydGVycyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNJbXBvcnRzID0gW107XG4gICAgICAgIHRoaXMuZXhlY0luZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuaW1wbGljaXRseUxvYWRlZEFmdGVyID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmltcG9ydE1ldGFzID0gW107XG4gICAgICAgIHRoaXMuaW1wb3J0ZWRGcm9tTm90VHJlZXNoYWtlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmltcG9ydGVycyA9IFtdO1xuICAgICAgICB0aGlzLmltcG9ydHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaXNFeGVjdXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVXNlckRlZmluZWRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmVlZHNFeHBvcnRTaGltID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy51c2VzVG9wTGV2ZWxBd2FpdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbEV4cG9ydE5hbWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cG9ydEFsbE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRBbGxTb3VyY2VzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwb3J0U2hpbVZhcmlhYmxlID0gbmV3IEV4cG9ydFNoaW1WYXJpYWJsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5leHBvcnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZVJlZXhwb3J0c0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWxldmFudERlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ludGhldGljRXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW50aGV0aWNOYW1lc3BhY2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICB0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHMgPSBudWxsO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVGcm9tU291cmNlbWFwID0gL1xcMC8udGVzdChpZCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG9wdGlvbnMubW9kdWxlQ29udGV4dChpZCk7XG4gICAgICAgIHRoaXMucHJlc2VydmVTaWduYXR1cmUgPSB0aGlzLm9wdGlvbnMucHJlc2VydmVFbnRyeVNpZ25hdHVyZXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGR5bmFtaWNJbXBvcnRzLCBkeW5hbWljSW1wb3J0ZXJzLCBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXIsIGltcGxpY2l0bHlMb2FkZWRCZWZvcmUsIGltcG9ydGVycywgcmVleHBvcnREZXNjcmlwdGlvbnMsIHNvdXJjZXMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgICAgICAgIGFzdDogbnVsbCxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBnZXQgZHluYW1pY2FsbHlJbXBvcnRlZElkUmVzb2x1dGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNJbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHsgYXJndW1lbnQgfSkgPT4gdHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyAmJiBtb2R1bGUucmVzb2x2ZWRJZHNbYXJndW1lbnRdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBkeW5hbWljYWxseUltcG9ydGVkSWRzKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgdGhpcy5keW5hbWljRGVwZW5kZW5jaWVzIGJlY2F1c2UgdGhpcyBpcyBuZWVkZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gZHluYW1pY0RlcGVuZGVuY2llcyBhcmUgcG9wdWxhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNJbXBvcnRzLm1hcCgoeyBpZCB9KSA9PiBpZCkuZmlsdGVyKChpZCkgPT4gaWQgIT0gbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGR5bmFtaWNJbXBvcnRlcnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNJbXBvcnRlcnMuc29ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBoYXNEZWZhdWx0RXhwb3J0KCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgb25seSB2YWxpZCBhZnRlciBwYXJzaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFtb2R1bGUuYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuaGFzKCdkZWZhdWx0JykgfHwgcmVleHBvcnREZXNjcmlwdGlvbnMuaGFzKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGhhc01vZHVsZVNpZGVFZmZlY3RzKCkge1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbignQWNjZXNzaW5nIE1vZHVsZUluZm8uaGFzTW9kdWxlU2lkZUVmZmVjdHMgZnJvbSBwbHVnaW5zIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgTW9kdWxlSW5mby5tb2R1bGVTaWRlRWZmZWN0cyBpbnN0ZWFkLicsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVTaWRlRWZmZWN0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGdldCBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJPbmVPZigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpbXBsaWNpdGx5TG9hZGVkQWZ0ZXIsIGdldElkKS5zb3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGltcGxpY2l0bHlMb2FkZWRCZWZvcmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaW1wbGljaXRseUxvYWRlZEJlZm9yZSwgZ2V0SWQpLnNvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaW1wb3J0ZWRJZFJlc29sdXRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNvdXJjZXMsIHNvdXJjZSA9PiBtb2R1bGUucmVzb2x2ZWRJZHNbc291cmNlXSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBpbXBvcnRlZElkcygpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIHRoaXMuZGVwZW5kZW5jaWVzIGJlY2F1c2UgdGhpcyBpcyBuZWVkZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIGFyZSBwb3B1bGF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzb3VyY2VzLCBzb3VyY2UgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBtb2R1bGUucmVzb2x2ZWRJZHNbc291cmNlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkOyB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGltcG9ydGVycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0ZXJzLnNvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VudHJ5LFxuICAgICAgICAgICAgaXNFeHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICBnZXQgaXNJbmNsdWRlZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGgucGhhc2UgIT09IEJ1aWxkUGhhc2UuR0VORVJBVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuaXNJbmNsdWRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGE6IHsgLi4ubWV0YSB9LFxuICAgICAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgICAgICAgICBzeW50aGV0aWNOYW1lZEV4cG9ydHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSGlkZSB0aGUgZGVwcmVjYXRlZCBrZXkgc28gdGhhdCBpdCBvbmx5IHdhcm5zIHdoZW4gYWNjZXNzZWQgZXhwbGljaXRseVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pbmZvLCAnaGFzTW9kdWxlU2lkZUVmZmVjdHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmFzZW5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBiYXNlbmFtZSh0aGlzLmlkKTtcbiAgICAgICAgY29uc3QgZXh0ID0gZXh0bmFtZSh0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIG1ha2VMZWdhbChleHQgPyBiYXNlLnNsaWNlKDAsIC1leHQubGVuZ3RoKSA6IGJhc2UpO1xuICAgIH1cbiAgICBiaW5kUmVmZXJlbmNlcygpIHtcbiAgICAgICAgdGhpcy5hc3QuYmluZCgpO1xuICAgIH1cbiAgICBlcnJvcihwcm9wcywgcG9zKSB7XG4gICAgICAgIHRoaXMuYWRkTG9jYXRpb25Ub0xvZ1Byb3BzKHByb3BzLCBwb3MpO1xuICAgICAgICByZXR1cm4gZXJyb3IocHJvcHMpO1xuICAgIH1cbiAgICBnZXRBbGxFeHBvcnROYW1lcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbEV4cG9ydE5hbWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsRXhwb3J0TmFtZXMgPSBuZXcgU2V0KFsuLi50aGlzLmV4cG9ydHMua2V5cygpLCAuLi50aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLmtleXMoKV0pO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsRXhwb3J0TmFtZXMuYWRkKGAqJHttb2R1bGUuaWR9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbW9kdWxlLmdldEFsbEV4cG9ydE5hbWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbEV4cG9ydE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkbyBub3QgY291bnQgdGhlIHN5bnRoZXRpYyBuYW1lc3BhY2UgYXMgYSByZWd1bGFyIGV4cG9ydCB0byBoaWRlIGl0XG4gICAgICAgIC8vIGZyb20gZW50cnkgc2lnbmF0dXJlcyBhbmQgbmFtZXNwYWNlIG9iamVjdHNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hbGxFeHBvcnROYW1lcy5kZWxldGUodGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsRXhwb3J0TmFtZXM7XG4gICAgfVxuICAgIGdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVsZXZhbnREZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxldmFudERlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5yZWxldmFudERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbmVjZXNzYXJ5RGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5VmFyaWFibGVzID0gbmV3IFNldCh0aGlzLmltcG9ydHMpO1xuICAgICAgICBpZiAodGhpcy5pbmZvLmlzRW50cnkgfHxcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlLmluY2x1ZGVkIHx8XG4gICAgICAgICAgICB0aGlzLmltcGxpY2l0bHlMb2FkZWRBZnRlci5zaXplID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIFsuLi50aGlzLmdldFJlZXhwb3J0cygpLCAuLi50aGlzLmdldEV4cG9ydHMoKV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXhwb3J0ZWRWYXJpYWJsZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShleHBvcnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VmFyaWFibGVzLmFkZChleHBvcnRlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGUgb2YgZGVwZW5kZW5jeVZhcmlhYmxlcykge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUVmZmVjdERlcGVuZGVuY2llcyA9IHRoaXMuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChzaWRlRWZmZWN0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2Ygc2lkZUVmZmVjdERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzLmFkZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLmdldEJhc2VWYXJpYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBFeHBvcnREZWZhdWx0VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lY2Vzc2FyeURlcGVuZGVuY2llcy5hZGQodmFyaWFibGUubW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50cmVlc2hha2UgfHwgdGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzID09PSAnbm8tdHJlZXNoYWtlJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxldmFudERlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGV2YW50U2lkZUVmZmVjdERlcGVuZGVuY2llcyh0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzLCBuZWNlc3NhcnlEZXBlbmRlbmNpZXMsIGFsd2F5c0NoZWNrZWREZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBuZWNlc3NhcnlEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnREZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBnZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIHRoaXMuZ2V0QWxsRXhwb3J0TmFtZXMoKSkge1xuICAgICAgICAgICAgbGV0IFt0cmFjZWRWYXJpYWJsZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShleHBvcnROYW1lKTtcbiAgICAgICAgICAgIGlmICh0cmFjZWRWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlZFZhcmlhYmxlID0gdHJhY2VkVmFyaWFibGUuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFjZWRWYXJpYWJsZSB8fFxuICAgICAgICAgICAgICAgICEodHJhY2VkVmFyaWFibGUuaW5jbHVkZWQgfHwgdHJhY2VkVmFyaWFibGUgaW5zdGFuY2VvZiBFeHRlcm5hbFZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFeHBvcnROYW1lcyA9IGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodHJhY2VkVmFyaWFibGUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0V4cG9ydE5hbWVzLnB1c2goZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHRyYWNlZFZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUgPSBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgIH1cbiAgICBnZXRFeHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmV4cG9ydHMua2V5cygpKTtcbiAgICB9XG4gICAgZ2V0UmVleHBvcnRzKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aXZlUmVleHBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aXZlUmVleHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbiB3aGVuIHVzaW5nIGNpcmN1bGFyIGBleHBvcnQgKiBmcm9tIFhgXG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZVJlZXhwb3J0cyA9IFtdO1xuICAgICAgICBjb25zdCByZWV4cG9ydHMgPSBuZXcgU2V0KHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMua2V5cygpKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5leHBvcnRBbGxNb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICByZWV4cG9ydHMuYWRkKGAqJHttb2R1bGUuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgWy4uLm1vZHVsZS5nZXRSZWV4cG9ydHMoKSwgLi4ubW9kdWxlLmdldEV4cG9ydHMoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdkZWZhdWx0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0cy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy50cmFuc2l0aXZlUmVleHBvcnRzID0gWy4uLnJlZXhwb3J0c10pO1xuICAgIH1cbiAgICBnZXRSZW5kZXJlZEV4cG9ydHMoKSB7XG4gICAgICAgIC8vIG9ubHkgZGlyZWN0IGV4cG9ydHMgYXJlIGNvdW50ZWQgaGVyZSwgbm90IHJlZXhwb3J0cyBhdCBhbGxcbiAgICAgICAgY29uc3QgcmVuZGVyZWRFeHBvcnRzID0gW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRFeHBvcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXhwb3J0TmFtZSBvZiB0aGlzLmV4cG9ydHMua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFyaWFibGVdID0gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUoZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICAodmFyaWFibGUgJiYgdmFyaWFibGUuaW5jbHVkZWQgPyByZW5kZXJlZEV4cG9ydHMgOiByZW1vdmVkRXhwb3J0cykucHVzaChleHBvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZW1vdmVkRXhwb3J0cywgcmVuZGVyZWRFeHBvcnRzIH07XG4gICAgfVxuICAgIGdldFN5bnRoZXRpY05hbWVzcGFjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ludGhldGljTmFtZXNwYWNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIFt0aGlzLnN5bnRoZXRpY05hbWVzcGFjZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSh0eXBlb2YgdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHNcbiAgICAgICAgICAgICAgICA6ICdkZWZhdWx0JywgeyBvbmx5RXhwbGljaXQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyclN5bnRoZXRpY05hbWVkRXhwb3J0c05lZWROYW1lc3BhY2VFeHBvcnQodGhpcy5pZCwgdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKG5hbWUsIHsgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgaXNFeHBvcnRBbGxTZWFyY2gsIG9ubHlFeHBsaWNpdCwgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMgfSA9IEVNUFRZX09CSkVDVCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnKicpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJy4vb3RoZXInXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm5hbWVzcGFjZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdleHRlcm5hbCdcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQuZ2V0KG5hbWUuc2xpY2UoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUoJyonKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBvcnQgeyBmb28gfSBmcm9tICcuL290aGVyJ1xuICAgICAgICBjb25zdCByZWV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChyZWV4cG9ydERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFyaWFibGVdID0gZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lUmVjdXJzaXZlKHJlZXhwb3J0RGVjbGFyYXRpb24ubW9kdWxlLCByZWV4cG9ydERlY2xhcmF0aW9uLmxvY2FsTmFtZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgZmFsc2UsIHNlYXJjaGVkTmFtZXNBbmRNb2R1bGVzKTtcbiAgICAgICAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJNaXNzaW5nRXhwb3J0KHJlZXhwb3J0RGVjbGFyYXRpb24ubG9jYWxOYW1lLCB0aGlzLmlkLCByZWV4cG9ydERlY2xhcmF0aW9uLm1vZHVsZS5pZCksIHJlZXhwb3J0RGVjbGFyYXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcG9ydGVyRm9yU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBzZXRBbHRlcm5hdGl2ZUV4cG9ydGVySWZDeWNsaWModmFyaWFibGUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2YXJpYWJsZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmV4cG9ydHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoZXhwb3J0RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChleHBvcnREZWNsYXJhdGlvbiA9PT0gTUlTU0lOR19FWFBPUlRfU0hJTV9ERVNDUklQVElPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5leHBvcnRTaGltVmFyaWFibGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGV4cG9ydERlY2xhcmF0aW9uLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy50cmFjZVZhcmlhYmxlKG5hbWUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMpO1xuICAgICAgICAgICAgaWYgKGltcG9ydGVyRm9yU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBnZXRPckNyZWF0ZShpbXBvcnRlckZvclNpZGVFZmZlY3RzLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlLCB2YXJpYWJsZSwgKCkgPT4gbmV3IFNldCgpKS5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgc2V0QWx0ZXJuYXRpdmVFeHBvcnRlcklmQ3ljbGljKHZhcmlhYmxlLCBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdmFyaWFibGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmx5RXhwbGljaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29uc3QgZm91bmROYW1lc3BhY2VSZWV4cG9ydCA9IChfYSA9IHRoaXMubmFtZXNwYWNlUmVleHBvcnRzQnlOYW1lLmdldChuYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5nZXRWYXJpYWJsZUZyb21OYW1lc3BhY2VSZWV4cG9ydHMobmFtZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMpO1xuICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2VSZWV4cG9ydHNCeU5hbWUuc2V0KG5hbWUsIGZvdW5kTmFtZXNwYWNlUmVleHBvcnQpO1xuICAgICAgICAgICAgaWYgKGZvdW5kTmFtZXNwYWNlUmVleHBvcnRbMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmROYW1lc3BhY2VSZWV4cG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBnZXRPckNyZWF0ZSh0aGlzLnN5bnRoZXRpY0V4cG9ydHMsIG5hbWUsICgpID0+IG5ldyBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlKHRoaXMuYXN0Q29udGV4dCwgbmFtZSwgdGhpcy5nZXRTeW50aGV0aWNOYW1lc3BhY2UoKSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIHNoaW1zIHdoZW4gd2UgYXJlIGp1c3RcbiAgICAgICAgLy8gcHJvYmluZyBleHBvcnQgKiBtb2R1bGVzIGZvciBleHBvcnRzXG4gICAgICAgIGlmICghaXNFeHBvcnRBbGxTZWFyY2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hpbU1pc3NpbmdFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGltTWlzc2luZ0V4cG9ydChuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZXhwb3J0U2hpbVZhcmlhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyA9PT0gJ25vLXRyZWVzaGFrZScgfHxcbiAgICAgICAgICAgICh0aGlzLmFzdC5pbmNsdWRlZCAmJiB0aGlzLmFzdC5oYXNFZmZlY3RzKGNyZWF0ZUhhc0VmZmVjdHNDb250ZXh0KCkpKSk7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVJbmNsdXNpb25Db250ZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzdC5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgdGhpcy5hc3QuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIGluY2x1ZGVBbGxFeHBvcnRzKGluY2x1ZGVOYW1lc3BhY2VNZW1iZXJzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0V4ZWN1dGVkKSB7XG4gICAgICAgICAgICBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXhwb3J0TmFtZSBvZiB0aGlzLmV4cG9ydHMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZU5hbWVzcGFjZU1lbWJlcnMgfHwgZXhwb3J0TmFtZSAhPT0gdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUoZXhwb3J0TmFtZSlbMF07XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jbHVkZVZhcmlhYmxlKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuZ2V0UmVleHBvcnRzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YXJpYWJsZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YXJpYWJsZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVWYXJpYWJsZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIEV4dGVybmFsVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUubW9kdWxlLnJlZXhwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZU5hbWVzcGFjZU1lbWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlLnNldE1lcmdlZE5hbWVzcGFjZXModGhpcy5pbmNsdWRlQW5kR2V0QWRkaXRpb25hbE1lcmdlZE5hbWVzcGFjZXMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUFsbEluQnVuZGxlKCkge1xuICAgICAgICB0aGlzLmFzdC5pbmNsdWRlKGNyZWF0ZUluY2x1c2lvbkNvbnRleHQoKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaW5jbHVkZUFsbEV4cG9ydHMoZmFsc2UpO1xuICAgIH1cbiAgICBpc0luY2x1ZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3QuaW5jbHVkZWQgfHwgdGhpcy5uYW1lc3BhY2UuaW5jbHVkZWQgfHwgdGhpcy5pbXBvcnRlZEZyb21Ob3RUcmVlc2hha2VuO1xuICAgIH1cbiAgICBsaW5rSW1wb3J0cygpIHtcbiAgICAgICAgdGhpcy5hZGRNb2R1bGVzVG9JbXBvcnREZXNjcmlwdGlvbnModGhpcy5pbXBvcnREZXNjcmlwdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZE1vZHVsZXNUb0ltcG9ydERlc2NyaXB0aW9ucyh0aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zKTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxFeHBvcnRBbGxNb2R1bGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHRoaXMuZXhwb3J0QWxsU291cmNlcykge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5ncmFwaC5tb2R1bGVzQnlJZC5nZXQodGhpcy5yZXNvbHZlZElkc1tzb3VyY2VdLmlkKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsRXhwb3J0QWxsTW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4cG9ydEFsbE1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwb3J0QWxsTW9kdWxlcy5wdXNoKC4uLmV4dGVybmFsRXhwb3J0QWxsTW9kdWxlcyk7XG4gICAgfVxuICAgIHJlbmRlcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hZ2ljU3RyaW5nID0gdGhpcy5tYWdpY1N0cmluZy5jbG9uZSgpO1xuICAgICAgICB0aGlzLmFzdC5yZW5kZXIobWFnaWNTdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVzZXNUb3BMZXZlbEF3YWl0ID0gdGhpcy5hc3RDb250ZXh0LnVzZXNUb3BMZXZlbEF3YWl0O1xuICAgICAgICByZXR1cm4gbWFnaWNTdHJpbmc7XG4gICAgfVxuICAgIHNldFNvdXJjZSh7IGFzdCwgY29kZSwgY3VzdG9tVHJhbnNmb3JtQ2FjaGUsIG9yaWdpbmFsQ29kZSwgb3JpZ2luYWxTb3VyY2VtYXAsIHJlc29sdmVkSWRzLCBzb3VyY2VtYXBDaGFpbiwgdHJhbnNmb3JtRGVwZW5kZW5jaWVzLCB0cmFuc2Zvcm1GaWxlcywgLi4ubW9kdWxlT3B0aW9ucyB9KSB7XG4gICAgICAgIHRoaXMuaW5mby5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENvZGUgPSBvcmlnaW5hbENvZGU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTb3VyY2VtYXAgPSBvcmlnaW5hbFNvdXJjZW1hcDtcbiAgICAgICAgdGhpcy5zb3VyY2VtYXBDaGFpbiA9IHNvdXJjZW1hcENoYWluO1xuICAgICAgICBpZiAodHJhbnNmb3JtRmlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmlsZXMgPSB0cmFuc2Zvcm1GaWxlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llcyA9IHRyYW5zZm9ybURlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5jdXN0b21UcmFuc2Zvcm1DYWNoZSA9IGN1c3RvbVRyYW5zZm9ybUNhY2hlO1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMobW9kdWxlT3B0aW9ucyk7XG4gICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgYXN0JywgMyk7XG4gICAgICAgIGlmICghYXN0KSB7XG4gICAgICAgICAgICBhc3QgPSB0aGlzLnRyeVBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZUVuZCgnZ2VuZXJhdGUgYXN0JywgMyk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRJZHMgPSByZXNvbHZlZElkcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCBgaWRgIGlzIHRoZSBmaWxlIG5hbWUuIEN1c3RvbSByZXNvbHZlcnMgYW5kIGxvYWRlcnNcbiAgICAgICAgLy8gY2FuIGNoYW5nZSB0aGF0LCBidXQgaXQgbWFrZXMgc2Vuc2UgdG8gdXNlIGl0IGZvciB0aGUgc291cmNlIGZpbGUgbmFtZVxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMubWFnaWNTdHJpbmcgPSBuZXcgTWFnaWNTdHJpbmckMShjb2RlLCB7XG4gICAgICAgICAgICBmaWxlbmFtZTogKHRoaXMuZXhjbHVkZUZyb21Tb3VyY2VtYXAgPyBudWxsIDogZmlsZU5hbWUpLFxuICAgICAgICAgICAgaW5kZW50RXhjbHVzaW9uUmFuZ2VzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGltZVN0YXJ0KCdhbmFseXNlIGFzdCcsIDMpO1xuICAgICAgICB0aGlzLmFzdENvbnRleHQgPSB7XG4gICAgICAgICAgICBhZGREeW5hbWljSW1wb3J0OiB0aGlzLmFkZER5bmFtaWNJbXBvcnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZEV4cG9ydDogdGhpcy5hZGRFeHBvcnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZEltcG9ydDogdGhpcy5hZGRJbXBvcnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZEltcG9ydE1ldGE6IHRoaXMuYWRkSW1wb3J0TWV0YS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGRlb3B0aW1pemF0aW9uVHJhY2tlcjogdGhpcy5ncmFwaC5kZW9wdGltaXphdGlvblRyYWNrZXIsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBnZXRFeHBvcnRzOiB0aGlzLmdldEV4cG9ydHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldE1vZHVsZUV4ZWNJbmRleDogKCkgPT4gdGhpcy5leGVjSW5kZXgsXG4gICAgICAgICAgICBnZXRNb2R1bGVOYW1lOiB0aGlzLmJhc2VuYW1lLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXROb2RlQ29uc3RydWN0b3I6IChuYW1lKSA9PiBub2RlQ29uc3RydWN0b3JzW25hbWVdIHx8IG5vZGVDb25zdHJ1Y3RvcnMuVW5rbm93bk5vZGUsXG4gICAgICAgICAgICBnZXRSZWV4cG9ydHM6IHRoaXMuZ2V0UmVleHBvcnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpbXBvcnREZXNjcmlwdGlvbnM6IHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZUFsbEV4cG9ydHM6ICgpID0+IHRoaXMuaW5jbHVkZUFsbEV4cG9ydHModHJ1ZSksXG4gICAgICAgICAgICBpbmNsdWRlRHluYW1pY0ltcG9ydDogdGhpcy5pbmNsdWRlRHluYW1pY0ltcG9ydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGU6IHRoaXMuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nOiB0aGlzLm1hZ2ljU3RyaW5nLFxuICAgICAgICAgICAgbW9kdWxlOiB0aGlzLFxuICAgICAgICAgICAgbW9kdWxlQ29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcmVxdWVzdFRyZWVzaGFraW5nUGFzczogKCkgPT4gKHRoaXMuZ3JhcGgubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlKSxcbiAgICAgICAgICAgIHRyYWNlRXhwb3J0OiAobmFtZSkgPT4gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSlbMF0sXG4gICAgICAgICAgICB0cmFjZVZhcmlhYmxlOiB0aGlzLnRyYWNlVmFyaWFibGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVzZXNUb3BMZXZlbEF3YWl0OiBmYWxzZSxcbiAgICAgICAgICAgIHdhcm46IHRoaXMud2Fybi5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgTW9kdWxlU2NvcGUodGhpcy5ncmFwaC5zY29wZSwgdGhpcy5hc3RDb250ZXh0KTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuZXcgTmFtZXNwYWNlVmFyaWFibGUodGhpcy5hc3RDb250ZXh0KTtcbiAgICAgICAgdGhpcy5hc3QgPSBuZXcgUHJvZ3JhbShhc3QsIHsgY29udGV4dDogdGhpcy5hc3RDb250ZXh0LCB0eXBlOiAnTW9kdWxlJyB9LCB0aGlzLnNjb3BlKTtcbiAgICAgICAgdGhpcy5pbmZvLmFzdCA9IGFzdDtcbiAgICAgICAgdGltZUVuZCgnYW5hbHlzZSBhc3QnLCAzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN0OiB0aGlzLmFzdC5lc1RyZWVOb2RlLFxuICAgICAgICAgICAgY29kZTogdGhpcy5pbmZvLmNvZGUsXG4gICAgICAgICAgICBjdXN0b21UcmFuc2Zvcm1DYWNoZTogdGhpcy5jdXN0b21UcmFuc2Zvcm1DYWNoZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogQXJyYXkuZnJvbSh0aGlzLmRlcGVuZGVuY2llcywgZ2V0SWQpLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBtZXRhOiB0aGlzLmluZm8ubWV0YSxcbiAgICAgICAgICAgIG1vZHVsZVNpZGVFZmZlY3RzOiB0aGlzLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGU6IHRoaXMub3JpZ2luYWxDb2RlLFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2VtYXA6IHRoaXMub3JpZ2luYWxTb3VyY2VtYXAsXG4gICAgICAgICAgICByZXNvbHZlZElkczogdGhpcy5yZXNvbHZlZElkcyxcbiAgICAgICAgICAgIHNvdXJjZW1hcENoYWluOiB0aGlzLnNvdXJjZW1hcENoYWluLFxuICAgICAgICAgICAgc3ludGhldGljTmFtZWRFeHBvcnRzOiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzLFxuICAgICAgICAgICAgdHJhbnNmb3JtRGVwZW5kZW5jaWVzOiB0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpbGVzOiB0aGlzLnRyYW5zZm9ybUZpbGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlVmFyaWFibGUobmFtZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cykge1xuICAgICAgICBjb25zdCBsb2NhbFZhcmlhYmxlID0gdGhpcy5zY29wZS52YXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobG9jYWxWYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyaWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0RGVjbGFyYXRpb24gPSB0aGlzLmltcG9ydERlc2NyaXB0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbXBvcnREZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJNb2R1bGUgPSBpbXBvcnREZWNsYXJhdGlvbi5tb2R1bGU7XG4gICAgICAgICAgICBpZiAob3RoZXJNb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUgJiYgaW1wb3J0RGVjbGFyYXRpb24ubmFtZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyTW9kdWxlLm5hbWVzcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtkZWNsYXJhdGlvbl0gPSBvdGhlck1vZHVsZS5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUoaW1wb3J0RGVjbGFyYXRpb24ubmFtZSwge1xuICAgICAgICAgICAgICAgIGltcG9ydGVyRm9yU2lkZUVmZmVjdHM6IGltcG9ydGVyRm9yU2lkZUVmZmVjdHMgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoZXJyTWlzc2luZ0V4cG9ydChpbXBvcnREZWNsYXJhdGlvbi5uYW1lLCB0aGlzLmlkLCBvdGhlck1vZHVsZS5pZCksIGltcG9ydERlY2xhcmF0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5UGFyc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaC5jb250ZXh0UGFyc2UodGhpcy5pbmZvLmNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgvIFxcKFxcZCs6XFxkK1xcKSQvLCAnJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZC5lbmRzV2l0aCgnLmpzb24nKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJyAoTm90ZSB0aGF0IHlvdSBuZWVkIEByb2xsdXAvcGx1Z2luLWpzb24gdG8gaW1wb3J0IEpTT04gZmlsZXMpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmlkLmVuZHNXaXRoKCcuanMnKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJyAoTm90ZSB0aGF0IHlvdSBuZWVkIHBsdWdpbnMgdG8gaW1wb3J0IGZpbGVzIHRoYXQgYXJlIG5vdCBKYXZhU2NyaXB0KSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ1BBUlNFX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHBhcnNlckVycm9yOiBlcnJcbiAgICAgICAgICAgIH0sIGVyci5wb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoeyBtZXRhLCBtb2R1bGVTaWRlRWZmZWN0cywgc3ludGhldGljTmFtZWRFeHBvcnRzIH0pIHtcbiAgICAgICAgaWYgKG1vZHVsZVNpZGVFZmZlY3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyA9IG1vZHVsZVNpZGVFZmZlY3RzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW50aGV0aWNOYW1lZEV4cG9ydHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyA9IHN5bnRoZXRpY05hbWVkRXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuaW5mby5tZXRhLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXJuKHByb3BzLCBwb3MpIHtcbiAgICAgICAgdGhpcy5hZGRMb2NhdGlvblRvTG9nUHJvcHMocHJvcHMsIHBvcyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbndhcm4ocHJvcHMpO1xuICAgIH1cbiAgICBhZGREeW5hbWljSW1wb3J0KG5vZGUpIHtcbiAgICAgICAgbGV0IGFyZ3VtZW50ID0gbm9kZS5zb3VyY2U7XG4gICAgICAgIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIFRlbXBsYXRlTGl0ZXJhbCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50LnF1YXNpcy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnQucXVhc2lzWzBdLnZhbHVlLmNvb2tlZCkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gYXJndW1lbnQucXVhc2lzWzBdLnZhbHVlLmNvb2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIExpdGVyYWwgJiYgdHlwZW9mIGFyZ3VtZW50LnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXJndW1lbnQgPSBhcmd1bWVudC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR5bmFtaWNJbXBvcnRzLnB1c2goeyBhcmd1bWVudCwgaWQ6IG51bGwsIG5vZGUsIHJlc29sdXRpb246IG51bGwgfSk7XG4gICAgfVxuICAgIGFkZEV4cG9ydChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmb287XG4gICAgICAgICAgICB0aGlzLmV4cG9ydHMuc2V0KCdkZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG5vZGUudmFyaWFibGUuZ2V0QXNzaWduZWRWYXJpYWJsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWU6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEV4cG9ydEFsbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChub2RlLmV4cG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb3J0ICogYXMgbmFtZSBmcm9tICcuL290aGVyJ1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLmV4cG9ydGVkLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5zZXQobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE5hbWU6ICcqJyxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICcuL290aGVyJ1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0QWxsU291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnNvdXJjZSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7IG5hbWUgfSBmcm9tICcuL290aGVyJ1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5zb3VyY2UudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5zZXQobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE5hbWU6IHNwZWNpZmllci5sb2NhbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNwZWNpZmllci5zdGFydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIFZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgdmFyIHsgZm9vLCBiYXIgfSA9IC4uLlxuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZm9vID0gMSwgYmFyID0gMjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0b3Igb2YgZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbG9jYWxOYW1lIG9mIGV4dHJhY3RBc3NpZ25lZE5hbWVzKGRlY2xhcmF0b3IuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydHMuc2V0KGxvY2FsTmFtZSwgeyBpZGVudGlmaWVyOiBudWxsLCBsb2NhbE5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgZnVuY3Rpb24gZm9vICgpIHt9XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gZGVjbGFyYXRpb24uaWQubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydHMuc2V0KGxvY2FsTmFtZSwgeyBpZGVudGlmaWVyOiBudWxsLCBsb2NhbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgeyBmb28sIGJhciwgYmF6IH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIG5vZGUuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHNwZWNpZmllci5sb2NhbC5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkTmFtZSA9IHNwZWNpZmllci5leHBvcnRlZC5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0cy5zZXQoZXhwb3J0ZWROYW1lLCB7IGlkZW50aWZpZXI6IG51bGwsIGxvY2FsTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbXBvcnQobm9kZSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9IHNwZWNpZmllci50eXBlID09PSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyJDE7XG4gICAgICAgICAgICBjb25zdCBpc05hbWVzcGFjZSA9IHNwZWNpZmllci50eXBlID09PSBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIkMTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpc0RlZmF1bHQgPyAnZGVmYXVsdCcgOiBpc05hbWVzcGFjZSA/ICcqJyA6IHNwZWNpZmllci5pbXBvcnRlZC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5pbXBvcnREZXNjcmlwdGlvbnMuc2V0KHNwZWNpZmllci5sb2NhbC5uYW1lLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzcGVjaWZpZXIuc3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEltcG9ydE1ldGEobm9kZSkge1xuICAgICAgICB0aGlzLmltcG9ydE1ldGFzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGFkZExvY2F0aW9uVG9Mb2dQcm9wcyhwcm9wcywgcG9zKSB7XG4gICAgICAgIHByb3BzLmlkID0gdGhpcy5pZDtcbiAgICAgICAgcHJvcHMucG9zID0gcG9zO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMuaW5mby5jb2RlO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0ZShjb2RlLCBwb3MsIHsgb2Zmc2V0TGluZTogMSB9KTtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBsZXQgeyBjb2x1bW4sIGxpbmUgfSA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoeyBjb2x1bW4sIGxpbmUgfSA9IGdldE9yaWdpbmFsTG9jYXRpb24odGhpcy5zb3VyY2VtYXBDaGFpbiwgeyBjb2x1bW4sIGxpbmUgfSkpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSB0aGlzLm9yaWdpbmFsQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub253YXJuKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ1NPVVJDRU1BUF9FUlJPUicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFcnJvciB3aGVuIHVzaW5nIHNvdXJjZW1hcCBmb3IgcmVwb3J0aW5nIGFuIGVycm9yOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIHBvc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVnbWVudENvZGVMb2NhdGlvbihwcm9wcywgeyBjb2x1bW4sIGxpbmUgfSwgY29kZSwgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTW9kdWxlc1RvSW1wb3J0RGVzY3JpcHRpb25zKGltcG9ydERlc2NyaXB0aW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIGltcG9ydERlc2NyaXB0aW9uLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSB0aGlzLnJlc29sdmVkSWRzW3NwZWNpZmllci5zb3VyY2VdO1xuICAgICAgICAgICAgc3BlY2lmaWVyLm1vZHVsZSA9IHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQuZ2V0KGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRSZWxldmFudFNpZGVFZmZlY3REZXBlbmRlbmNpZXMocmVsZXZhbnREZXBlbmRlbmNpZXMsIG5lY2Vzc2FyeURlcGVuZGVuY2llcywgYWx3YXlzQ2hlY2tlZERlcGVuZGVuY2llcykge1xuICAgICAgICBjb25zdCBoYW5kbGVkRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBhZGRTaWRlRWZmZWN0RGVwZW5kZW5jaWVzID0gKHBvc3NpYmxlRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgcG9zc2libGVEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZERlcGVuZGVuY2llcy5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZWREZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgIGlmIChuZWNlc3NhcnlEZXBlbmRlbmNpZXMuaGFzKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW50RGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyB8fCBhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzLmhhcyhkZXBlbmRlbmN5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUgfHwgZGVwZW5kZW5jeS5oYXNFZmZlY3RzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnREZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkU2lkZUVmZmVjdERlcGVuZGVuY2llcyhkZXBlbmRlbmN5LmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZFNpZGVFZmZlY3REZXBlbmRlbmNpZXModGhpcy5kZXBlbmRlbmNpZXMpO1xuICAgICAgICBhZGRTaWRlRWZmZWN0RGVwZW5kZW5jaWVzKGFsd2F5c0NoZWNrZWREZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBnZXRWYXJpYWJsZUZyb21OYW1lc3BhY2VSZWV4cG9ydHMobmFtZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMpIHtcbiAgICAgICAgbGV0IGZvdW5kU3ludGhldGljRGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBmb3VuZEludGVybmFsRGVjbGFyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpIHtcbiAgICAgICAgICAgIC8vIFN5bnRoZXRpYyBuYW1lc3BhY2VzIHNob3VsZCBub3QgaGlkZSBcInJlZ3VsYXJcIiBleHBvcnRzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt2YXJpYWJsZSwgaW5kaXJlY3RFeHRlcm5hbF0gPSBnZXRWYXJpYWJsZUZvckV4cG9ydE5hbWVSZWN1cnNpdmUobW9kdWxlLCBuYW1lLCBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCB0cnVlLCBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcyk7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUgfHwgaW5kaXJlY3RFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kRXh0ZXJuYWxEZWNsYXJhdGlvbnMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICghZm91bmRTeW50aGV0aWNEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFN5bnRoZXRpY0RlY2xhcmF0aW9uID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEludGVybmFsRGVjbGFyYXRpb25zLnNldCh2YXJpYWJsZSwgbW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRJbnRlcm5hbERlY2xhcmF0aW9ucy5zaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZm91bmREZWNsYXJhdGlvbkxpc3QgPSBbLi4uZm91bmRJbnRlcm5hbERlY2xhcmF0aW9uc107XG4gICAgICAgICAgICBjb25zdCB1c2VkRGVjbGFyYXRpb24gPSBmb3VuZERlY2xhcmF0aW9uTGlzdFswXVswXTtcbiAgICAgICAgICAgIGlmIChmb3VuZERlY2xhcmF0aW9uTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VzZWREZWNsYXJhdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub253YXJuKGVyck5hbWVzcGFjZUNvbmZsaWN0KG5hbWUsIHRoaXMuaWQsIGZvdW5kRGVjbGFyYXRpb25MaXN0Lm1hcCgoWywgbW9kdWxlXSkgPT4gbW9kdWxlLmlkKSkpO1xuICAgICAgICAgICAgLy8gVE9ETyB3ZSBhcmUgcHJldGVuZGluZyBpdCB3YXMgbm90IGZvdW5kIHdoaWxlIGl0IHNob3VsZCBiZWhhdmUgbGlrZSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICByZXR1cm4gW251bGxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZERlY2xhcmF0aW9uTGlzdCA9IFsuLi5mb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zXTtcbiAgICAgICAgICAgIGNvbnN0IHVzZWREZWNsYXJhdGlvbiA9IGZvdW5kRGVjbGFyYXRpb25MaXN0WzBdO1xuICAgICAgICAgICAgaWYgKGZvdW5kRGVjbGFyYXRpb25MaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub253YXJuKGVyckFtYmlndW91c0V4dGVybmFsTmFtZXNwYWNlcyhuYW1lLCB0aGlzLmlkLCB1c2VkRGVjbGFyYXRpb24ubW9kdWxlLmlkLCBmb3VuZERlY2xhcmF0aW9uTGlzdC5tYXAoZGVjbGFyYXRpb24gPT4gZGVjbGFyYXRpb24ubW9kdWxlLmlkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt1c2VkRGVjbGFyYXRpb24sIHRydWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZFN5bnRoZXRpY0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZvdW5kU3ludGhldGljRGVjbGFyYXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGluY2x1ZGVBbmRHZXRBZGRpdGlvbmFsTWVyZ2VkTmFtZXNwYWNlcygpIHtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxOYW1lc3BhY2VzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBzeW50aGV0aWNOYW1lc3BhY2VzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBbdGhpcywgLi4udGhpcy5leHBvcnRBbGxNb2R1bGVzXSkge1xuICAgICAgICAgICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2V4dGVybmFsVmFyaWFibGVdID0gbW9kdWxlLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSgnKicpO1xuICAgICAgICAgICAgICAgIGV4dGVybmFsVmFyaWFibGUuaW5jbHVkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cy5hZGQoZXh0ZXJuYWxWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxOYW1lc3BhY2VzLmFkZChleHRlcm5hbFZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZHVsZS5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bnRoZXRpY05hbWVzcGFjZSA9IG1vZHVsZS5nZXRTeW50aGV0aWNOYW1lc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNOYW1lc3BhY2UuaW5jbHVkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cy5hZGQoc3ludGhldGljTmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNOYW1lc3BhY2VzLmFkZChzeW50aGV0aWNOYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uc3ludGhldGljTmFtZXNwYWNlcywgLi4uZXh0ZXJuYWxOYW1lc3BhY2VzXTtcbiAgICB9XG4gICAgaW5jbHVkZUR5bmFtaWNJbXBvcnQobm9kZSkge1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5keW5hbWljSW1wb3J0cy5maW5kKGR5bmFtaWNJbXBvcnQgPT4gZHluYW1pY0ltcG9ydC5ub2RlID09PSBub2RlKS5yZXNvbHV0aW9uO1xuICAgICAgICBpZiAocmVzb2x1dGlvbiBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbi5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHJlc29sdXRpb24uaW5jbHVkZUFsbEV4cG9ydHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZVZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIGlmICghdmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmluY2x1ZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVNb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgICAgICBpZiAodmFyaWFibGVNb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhcmlhYmxlTW9kdWxlLmlzRXhlY3V0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya01vZHVsZUFuZEltcHVyZURlcGVuZGVuY2llc0FzRXhlY3V0ZWQodmFyaWFibGVNb2R1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVNb2R1bGUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lkZUVmZmVjdE1vZHVsZXMgPSBnZXRBbmRFeHRlbmRTaWRlRWZmZWN0TW9kdWxlcyh2YXJpYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHNpZGVFZmZlY3RNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZS5pc0V4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya01vZHVsZUFuZEltcHVyZURlcGVuZGVuY2llc0FzRXhlY3V0ZWQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh2YXJpYWJsZSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVWYXJpYWJsZSh2YXJpYWJsZSk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlTW9kdWxlID0gdmFyaWFibGUubW9kdWxlO1xuICAgICAgICBpZiAodmFyaWFibGVNb2R1bGUgJiYgdmFyaWFibGVNb2R1bGUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0cy5hZGQodmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNoaW1NaXNzaW5nRXhwb3J0KG5hbWUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9ud2Fybih7XG4gICAgICAgICAgICBjb2RlOiAnU0hJTU1FRF9FWFBPUlQnLFxuICAgICAgICAgICAgZXhwb3J0ZXI6IHJlbGF0aXZlSWQodGhpcy5pZCksXG4gICAgICAgICAgICBleHBvcnROYW1lOiBuYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgZXhwb3J0IFwiJHtuYW1lfVwiIGhhcyBiZWVuIHNoaW1tZWQgaW4gbW9kdWxlICR7cmVsYXRpdmVJZCh0aGlzLmlkKX0uYFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leHBvcnRzLnNldChuYW1lLCBNSVNTSU5HX0VYUE9SVF9TSElNX0RFU0NSSVBUSU9OKTtcbiAgICB9XG59XG4vLyBpZiB0aGVyZSBpcyBhIGN5Y2xpYyBpbXBvcnQgaW4gdGhlIHJlZXhwb3J0IGNoYWluLCB3ZSBzaG91bGQgbm90XG4vLyBpbXBvcnQgZnJvbSB0aGUgb3JpZ2luYWwgbW9kdWxlIGJ1dCBmcm9tIHRoZSBjeWNsaWMgbW9kdWxlIHRvIG5vdFxuLy8gbWVzcyB1cCBleGVjdXRpb24gb3JkZXIuXG5mdW5jdGlvbiBzZXRBbHRlcm5hdGl2ZUV4cG9ydGVySWZDeWNsaWModmFyaWFibGUsIGltcG9ydGVyLCByZWV4cG9ydGVyKSB7XG4gICAgaWYgKHZhcmlhYmxlLm1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSAmJiB2YXJpYWJsZS5tb2R1bGUgIT09IHJlZXhwb3J0ZXIpIHtcbiAgICAgICAgY29uc3QgZXhwb3J0ZXJDeWNsZXMgPSB2YXJpYWJsZS5tb2R1bGUuY3ljbGVzO1xuICAgICAgICBpZiAoZXhwb3J0ZXJDeWNsZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVyQ3ljbGVzID0gcmVleHBvcnRlci5jeWNsZXM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN5Y2xlU3ltYm9sIG9mIGltcG9ydGVyQ3ljbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVyQ3ljbGVzLmhhcyhjeWNsZVN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZXIuYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZXMuc2V0KHZhcmlhYmxlLCByZWV4cG9ydGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVKc0V4dGVuc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuZW5kc1dpdGgoJy5qcycpID8gbmFtZS5zbGljZSgwLCAtMykgOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wbGV0ZUFtZElkKG9wdGlvbnMsIGNodW5rSWQpIHtcbiAgICBpZiAob3B0aW9ucy5hdXRvSWQpIHtcbiAgICAgICAgcmV0dXJuIGAke29wdGlvbnMuYmFzZVBhdGggPyBvcHRpb25zLmJhc2VQYXRoICsgJy8nIDogJyd9JHtyZW1vdmVKc0V4dGVuc2lvbihjaHVua0lkKX1gO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5pZCB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ2V0RXhwb3J0QmxvY2skMShleHBvcnRzLCBkZXBlbmRlbmNpZXMsIG5hbWVkRXhwb3J0c01vZGUsIGludGVyb3AsIHNuaXBwZXRzLCB0LCBleHRlcm5hbExpdmVCaW5kaW5ncywgbWVjaGFuaXNtID0gJ3JldHVybiAnKSB7XG4gICAgY29uc3QgeyBfLCBjbnN0LCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgZ2V0RnVuY3Rpb25JbnRybywgZ2V0UHJvcGVydHlBY2Nlc3MsIG4sIHMgfSA9IHNuaXBwZXRzO1xuICAgIGlmICghbmFtZWRFeHBvcnRzTW9kZSkge1xuICAgICAgICByZXR1cm4gYCR7bn0ke259JHttZWNoYW5pc219JHtnZXRTaW5nbGVEZWZhdWx0RXhwb3J0KGV4cG9ydHMsIGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGdldFByb3BlcnR5QWNjZXNzKX07YDtcbiAgICB9XG4gICAgbGV0IGV4cG9ydEJsb2NrID0gJyc7XG4gICAgZm9yIChjb25zdCB7IGRlZmF1bHRWYXJpYWJsZU5hbWUsIGlkLCBpc0NodW5rLCBuYW1lLCBuYW1lZEV4cG9ydHNNb2RlOiBkZXBOYW1lZEV4cG9ydHNNb2RlLCBuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIHJlZXhwb3J0cyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAocmVleHBvcnRzICYmIG5hbWVkRXhwb3J0c01vZGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIucmVleHBvcnRlZCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSBnZXRSZWV4cG9ydGVkSW1wb3J0TmFtZShuYW1lLCBzcGVjaWZpZXIuaW1wb3J0ZWQsIGRlcE5hbWVkRXhwb3J0c01vZGUsIGlzQ2h1bmssIGRlZmF1bHRWYXJpYWJsZU5hbWUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgaW50ZXJvcCwgaWQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEJsb2NrICs9IG47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgIT09ICcqJyAmJiBzcGVjaWZpZXIubmVlZHNMaXZlQmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJHtffScke3NwZWNpZmllci5yZWV4cG9ydGVkfScsJHtffXske259YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3R9ZW51bWVyYWJsZToke199dHJ1ZSwke259YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3R9Z2V0OiR7X30ke2xlZnR9JHtpbXBvcnROYW1lfSR7cmlnaHR9JHtufX0pO2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPSBgZXhwb3J0cyR7Z2V0UHJvcGVydHlBY2Nlc3Moc3BlY2lmaWVyLnJlZXhwb3J0ZWQpfSR7X309JHtffSR7aW1wb3J0TmFtZX07YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgZXhwb3J0ZWQsIGxvY2FsIH0gb2YgZXhwb3J0cykge1xuICAgICAgICBjb25zdCBsaHMgPSBgZXhwb3J0cyR7Z2V0UHJvcGVydHlBY2Nlc3MoZXhwb3J0ZWQpfWA7XG4gICAgICAgIGNvbnN0IHJocyA9IGxvY2FsO1xuICAgICAgICBpZiAobGhzICE9PSByaHMpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRCbG9jaylcbiAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPSBuO1xuICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz0gYCR7bGhzfSR7X309JHtffSR7cmhzfTtgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBuYW1lLCByZWV4cG9ydHMgfSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKHJlZXhwb3J0cyAmJiBuYW1lZEV4cG9ydHNNb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiByZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVyLnJlZXhwb3J0ZWQgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0QmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPSBuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5UHJvcGVydHlJZk5lY2Vzc2FyeSA9IGB7JHtufSR7dH1pZiR7X30oayR7X30hPT0ke199J2RlZmF1bHQnJHtffSYmJHtffSFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSR7X30ke2dldERlZmluZVByb3BlcnR5KG5hbWUsIHNwZWNpZmllci5uZWVkc0xpdmVCaW5kaW5nLCB0LCBzbmlwcGV0cyl9JHtzfSR7bn19YDtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNuc3QgPT09ICd2YXInICYmIHNwZWNpZmllci5uZWVkc0xpdmVCaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgT2JqZWN0LmtleXMoJHtuYW1lfSkuZm9yRWFjaCgke2dldEZ1bmN0aW9uSW50cm8oWydrJ10sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX0ke2NvcHlQcm9wZXJ0eUlmTmVjZXNzYXJ5fSk7YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYGZvciR7X30oJHtjbnN0fSBrIGluICR7bmFtZX0pJHtffSR7Y29weVByb3BlcnR5SWZOZWNlc3Nhcnl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cG9ydEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBgJHtufSR7bn0ke2V4cG9ydEJsb2NrfWA7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZURlZmF1bHRFeHBvcnQoZXhwb3J0cywgZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzWzBdLmxvY2FsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCB7IGRlZmF1bHRWYXJpYWJsZU5hbWUsIGlkLCBpc0NodW5rLCBuYW1lLCBuYW1lZEV4cG9ydHNNb2RlOiBkZXBOYW1lZEV4cG9ydHNNb2RlLCBuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIHJlZXhwb3J0cyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZWV4cG9ydGVkSW1wb3J0TmFtZShuYW1lLCByZWV4cG9ydHNbMF0uaW1wb3J0ZWQsIGRlcE5hbWVkRXhwb3J0c01vZGUsIGlzQ2h1bmssIGRlZmF1bHRWYXJpYWJsZU5hbWUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgaW50ZXJvcCwgaWQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZWV4cG9ydGVkSW1wb3J0TmFtZShtb2R1bGVWYXJpYWJsZU5hbWUsIGltcG9ydGVkLCBkZXBOYW1lZEV4cG9ydHNNb2RlLCBpc0NodW5rLCBkZWZhdWx0VmFyaWFibGVOYW1lLCBuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIGludGVyb3AsIG1vZHVsZUlkLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICBpZiAoaW1wb3J0ZWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAoIWlzQ2h1bmspIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZUludGVyb3AgPSBTdHJpbmcoaW50ZXJvcChtb2R1bGVJZCkpO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgICAgIDogbW9kdWxlVmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGlzRGVmYXVsdEFQcm9wZXJ0eShtb2R1bGVJbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncylcbiAgICAgICAgICAgICAgICA/IGAke3ZhcmlhYmxlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKCdkZWZhdWx0Jyl9YFxuICAgICAgICAgICAgICAgIDogdmFyaWFibGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBOYW1lZEV4cG9ydHNNb2RlXG4gICAgICAgICAgICA/IGAke21vZHVsZVZhcmlhYmxlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKCdkZWZhdWx0Jyl9YFxuICAgICAgICAgICAgOiBtb2R1bGVWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGlmIChpbXBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiAoaXNDaHVua1xuICAgICAgICAgICAgPyAhZGVwTmFtZWRFeHBvcnRzTW9kZVxuICAgICAgICAgICAgOiBuYW1lc3BhY2VJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbU3RyaW5nKGludGVyb3AobW9kdWxlSWQpKV0pXG4gICAgICAgICAgICA/IG5hbWVzcGFjZVZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgOiBtb2R1bGVWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBgJHttb2R1bGVWYXJpYWJsZU5hbWV9JHtnZXRQcm9wZXJ0eUFjY2VzcyhpbXBvcnRlZCl9YDtcbn1cbmZ1bmN0aW9uIGdldEVzTW9kdWxlVmFsdWUoZ2V0T2JqZWN0KSB7XG4gICAgcmV0dXJuIGdldE9iamVjdChbWyd2YWx1ZScsICd0cnVlJ11dLCB7XG4gICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0TmFtZXNwYWNlTWFya2VycyhoYXNOYW1lZEV4cG9ydHMsIGFkZEVzTW9kdWxlLCBhZGROYW1lc3BhY2VUb1N0cmluZ1RhZywgeyBfLCBnZXRPYmplY3QgfSkge1xuICAgIGlmIChoYXNOYW1lZEV4cG9ydHMpIHtcbiAgICAgICAgaWYgKGFkZEVzTW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAoYWRkTmFtZXNwYWNlVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV4cG9ydHMsJHtffSR7Z2V0T2JqZWN0KFtcbiAgICAgICAgICAgICAgICAgICAgWydfX2VzTW9kdWxlJywgZ2V0RXNNb2R1bGVWYWx1ZShnZXRPYmplY3QpXSxcbiAgICAgICAgICAgICAgICAgICAgW251bGwsIGBbU3ltYm9sLnRvU3RyaW5nVGFnXToke199JHtnZXRUb1N0cmluZ1RhZ1ZhbHVlKGdldE9iamVjdCl9YF1cbiAgICAgICAgICAgICAgICBdLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbFxuICAgICAgICAgICAgICAgIH0pfSk7YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJHtffSdfX2VzTW9kdWxlJywke199JHtnZXRFc01vZHVsZVZhbHVlKGdldE9iamVjdCl9KTtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGROYW1lc3BhY2VUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgcmV0dXJuIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywke199U3ltYm9sLnRvU3RyaW5nVGFnLCR7X30ke2dldFRvU3RyaW5nVGFnVmFsdWUoZ2V0T2JqZWN0KX0pO2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuY29uc3QgZ2V0RGVmaW5lUHJvcGVydHkgPSAobmFtZSwgbmVlZHNMaXZlQmluZGluZywgdCwgeyBfLCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgbiB9KSA9PiB7XG4gICAgaWYgKG5lZWRzTGl2ZUJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoYE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7X31rLCR7X317JHtufWAgK1xuICAgICAgICAgICAgYCR7dH0ke3R9ZW51bWVyYWJsZToke199dHJ1ZSwke259YCArXG4gICAgICAgICAgICBgJHt0fSR7dH1nZXQ6JHtffSR7bGVmdH0ke25hbWV9W2tdJHtyaWdodH0ke259JHt0fX0pYCk7XG4gICAgfVxuICAgIHJldHVybiBgZXhwb3J0c1trXSR7X309JHtffSR7bmFtZX1ba11gO1xufTtcblxuZnVuY3Rpb24gZ2V0SW50ZXJvcEJsb2NrKGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIGFjY2Vzc2VkR2xvYmFscywgaW5kZW50LCBzbmlwcGV0cykge1xuICAgIGNvbnN0IHsgXywgY25zdCwgbiB9ID0gc25pcHBldHM7XG4gICAgY29uc3QgbmVlZGVkSW50ZXJvcEhlbHBlcnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW50ZXJvcFN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCBhZGRJbnRlcm9wU3RhdGVtZW50ID0gKGhlbHBlclZhcmlhYmxlTmFtZSwgaGVscGVyLCBkZXBlbmRlbmN5VmFyaWFibGVOYW1lKSA9PiB7XG4gICAgICAgIG5lZWRlZEludGVyb3BIZWxwZXJzLmFkZChoZWxwZXIpO1xuICAgICAgICBpbnRlcm9wU3RhdGVtZW50cy5wdXNoKGAke2Nuc3R9ICR7aGVscGVyVmFyaWFibGVOYW1lfSR7X309JHtffS8qI19fUFVSRV9fKi8ke2hlbHBlcn0oJHtkZXBlbmRlbmN5VmFyaWFibGVOYW1lfSk7YCk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsgZGVmYXVsdFZhcmlhYmxlTmFtZSwgaW1wb3J0cywgaWQsIGlzQ2h1bmssIG5hbWUsIG5hbWVkRXhwb3J0c01vZGUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgcmVleHBvcnRzIH0gb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChpc0NodW5rKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW1wb3J0ZWQsIHJlZXhwb3J0ZWQgfSBvZiBbXG4gICAgICAgICAgICAgICAgLi4uKGltcG9ydHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihyZWV4cG9ydHMgfHwgW10pXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkID09PSAnKicgJiYgcmVleHBvcnRlZCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZWRFeHBvcnRzTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW50ZXJvcFN0YXRlbWVudChuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIElOVEVST1BfTkFNRVNQQUNFX0RFRkFVTFRfT05MWV9WQVJJQUJMRSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlSW50ZXJvcCA9IFN0cmluZyhpbnRlcm9wKGlkKSk7XG4gICAgICAgICAgICBsZXQgaGFzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGhhc05hbWVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGltcG9ydGVkLCByZWV4cG9ydGVkIH0gb2YgW1xuICAgICAgICAgICAgICAgIC4uLihpbXBvcnRzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVleHBvcnRzIHx8IFtdKVxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIGxldCBoZWxwZXI7XG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRWYXJpYWJsZU5hbWUgIT09IG5hbWVzcGFjZVZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IGRlZmF1bHRWYXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyID0gZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRlZCA9PT0gJyonICYmIHJlZXhwb3J0ZWQgIT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlciA9IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IG5hbWVzcGFjZVZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEludGVyb3BTdGF0ZW1lbnQodmFyaWFibGVOYW1lLCBoZWxwZXIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7Z2V0SGVscGVyc0Jsb2NrKG5lZWRlZEludGVyb3BIZWxwZXJzLCBhY2Nlc3NlZEdsb2JhbHMsIGluZGVudCwgc25pcHBldHMsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnKX0ke2ludGVyb3BTdGF0ZW1lbnRzLmxlbmd0aCA+IDAgPyBgJHtpbnRlcm9wU3RhdGVtZW50cy5qb2luKG4pfSR7bn0ke259YCA6ICcnfWA7XG59XG5cbi8vIEFNRCByZXNvbHV0aW9uIHdpbGwgb25seSByZXNwZWN0IHRoZSBBTUQgYmFzZVVybCBpZiB0aGUgLmpzIGV4dGVuc2lvbiBpcyBvbWl0dGVkLlxuLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIG1ha2VzIHNlbnNlIGZvciBhbGwgcmVsYXRpdmUgaWRzOlxuLy8gaHR0cHM6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjanNmaWxlc1xuZnVuY3Rpb24gcmVtb3ZlRXh0ZW5zaW9uRnJvbVJlbGF0aXZlQW1kSWQoaWQpIHtcbiAgICByZXR1cm4gaWRbMF0gPT09ICcuJyA/IHJlbW92ZUpzRXh0ZW5zaW9uKGlkKSA6IGlkO1xufVxuXG5jb25zdCBidWlsdGlucyA9IHtcbiAgICBhc3NlcnQ6IHRydWUsXG4gICAgYnVmZmVyOiB0cnVlLFxuICAgIGNvbnNvbGU6IHRydWUsXG4gICAgY29uc3RhbnRzOiB0cnVlLFxuICAgIGRvbWFpbjogdHJ1ZSxcbiAgICBldmVudHM6IHRydWUsXG4gICAgaHR0cDogdHJ1ZSxcbiAgICBodHRwczogdHJ1ZSxcbiAgICBvczogdHJ1ZSxcbiAgICBwYXRoOiB0cnVlLFxuICAgIHByb2Nlc3M6IHRydWUsXG4gICAgcHVueWNvZGU6IHRydWUsXG4gICAgcXVlcnlzdHJpbmc6IHRydWUsXG4gICAgc3RyZWFtOiB0cnVlLFxuICAgIHN0cmluZ19kZWNvZGVyOiB0cnVlLFxuICAgIHRpbWVyczogdHJ1ZSxcbiAgICB0dHk6IHRydWUsXG4gICAgdXJsOiB0cnVlLFxuICAgIHV0aWw6IHRydWUsXG4gICAgdm06IHRydWUsXG4gICAgemxpYjogdHJ1ZVxufTtcbmZ1bmN0aW9uIHdhcm5PbkJ1aWx0aW5zKHdhcm4sIGRlcGVuZGVuY2llcykge1xuICAgIGNvbnN0IGV4dGVybmFsQnVpbHRpbnMgPSBkZXBlbmRlbmNpZXMubWFwKCh7IGlkIH0pID0+IGlkKS5maWx0ZXIoaWQgPT4gaWQgaW4gYnVpbHRpbnMpO1xuICAgIGlmICghZXh0ZXJuYWxCdWlsdGlucy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICB3YXJuKHtcbiAgICAgICAgY29kZTogJ01JU1NJTkdfTk9ERV9CVUlMVElOUycsXG4gICAgICAgIG1lc3NhZ2U6IGBDcmVhdGluZyBhIGJyb3dzZXIgYnVuZGxlIHRoYXQgZGVwZW5kcyBvbiBOb2RlLmpzIGJ1aWx0LWluIG1vZHVsZXMgKCR7cHJpbnRRdW90ZWRTdHJpbmdMaXN0KGV4dGVybmFsQnVpbHRpbnMpfSkuIFlvdSBtaWdodCBuZWVkIHRvIGluY2x1ZGUgaHR0cHM6Ly9naXRodWIuY29tL3Nub3dwYWNranMvcm9sbHVwLXBsdWdpbi1wb2x5ZmlsbC1ub2RlYCxcbiAgICAgICAgbW9kdWxlczogZXh0ZXJuYWxCdWlsdGluc1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhbWQobWFnaWNTdHJpbmcsIHsgYWNjZXNzZWRHbG9iYWxzLCBkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIGhhc0V4cG9ydHMsIGlkLCBpbmRlbnQ6IHQsIGludHJvLCBpc0VudHJ5RmFjYWRlLCBpc01vZHVsZUZhY2FkZSwgbmFtZWRFeHBvcnRzTW9kZSwgb3V0cm8sIHNuaXBwZXRzLCB3YXJuIH0sIHsgYW1kLCBlc01vZHVsZSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgaW50ZXJvcCwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIHN0cmljdCB9KSB7XG4gICAgd2Fybk9uQnVpbHRpbnMod2FybiwgZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBkZXBzID0gZGVwZW5kZW5jaWVzLm1hcChtID0+IGAnJHtyZW1vdmVFeHRlbnNpb25Gcm9tUmVsYXRpdmVBbWRJZChtLmlkKX0nYCk7XG4gICAgY29uc3QgYXJncyA9IGRlcGVuZGVuY2llcy5tYXAobSA9PiBtLm5hbWUpO1xuICAgIGNvbnN0IHsgbiwgZ2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvLCBfIH0gPSBzbmlwcGV0cztcbiAgICBpZiAobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdChgZXhwb3J0c2ApO1xuICAgICAgICBkZXBzLnVuc2hpZnQoYCdleHBvcnRzJ2ApO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzZWRHbG9iYWxzLmhhcygncmVxdWlyZScpKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdCgncmVxdWlyZScpO1xuICAgICAgICBkZXBzLnVuc2hpZnQoYCdyZXF1aXJlJ2ApO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzZWRHbG9iYWxzLmhhcygnbW9kdWxlJykpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KCdtb2R1bGUnKTtcbiAgICAgICAgZGVwcy51bnNoaWZ0KGAnbW9kdWxlJ2ApO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZUFtZElkID0gZ2V0Q29tcGxldGVBbWRJZChhbWQsIGlkKTtcbiAgICBjb25zdCBwYXJhbXMgPSAoY29tcGxldGVBbWRJZCA/IGAnJHtjb21wbGV0ZUFtZElkfScsJHtffWAgOiBgYCkgK1xuICAgICAgICAoZGVwcy5sZW5ndGggPyBgWyR7ZGVwcy5qb2luKGAsJHtffWApfV0sJHtffWAgOiBgYCk7XG4gICAgY29uc3QgdXNlU3RyaWN0ID0gc3RyaWN0ID8gYCR7X30ndXNlIHN0cmljdCc7YCA6ICcnO1xuICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoYCR7aW50cm99JHtnZXRJbnRlcm9wQmxvY2soZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBuYW1lc3BhY2VUb1N0cmluZ1RhZywgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cyl9YCk7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayQxKGV4cG9ydHMsIGRlcGVuZGVuY2llcywgbmFtZWRFeHBvcnRzTW9kZSwgaW50ZXJvcCwgc25pcHBldHMsIHQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKTtcbiAgICBsZXQgbmFtZXNwYWNlTWFya2VycyA9IGdldE5hbWVzcGFjZU1hcmtlcnMobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzLCBpc0VudHJ5RmFjYWRlICYmIGVzTW9kdWxlLCBpc01vZHVsZUZhY2FkZSAmJiBuYW1lc3BhY2VUb1N0cmluZ1RhZywgc25pcHBldHMpO1xuICAgIGlmIChuYW1lc3BhY2VNYXJrZXJzKSB7XG4gICAgICAgIG5hbWVzcGFjZU1hcmtlcnMgPSBuICsgbiArIG5hbWVzcGFjZU1hcmtlcnM7XG4gICAgfVxuICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChgJHtleHBvcnRCbG9ja30ke25hbWVzcGFjZU1hcmtlcnN9JHtvdXRyb31gKTtcbiAgICByZXR1cm4gKG1hZ2ljU3RyaW5nXG4gICAgICAgIC5pbmRlbnQodClcbiAgICAgICAgLy8gZmFjdG9yeSBmdW5jdGlvbiBzaG91bGQgYmUgd3JhcHBlZCBieSBwYXJlbnRoZXNlcyB0byBhdm9pZCBsYXp5IHBhcnNpbmcsXG4gICAgICAgIC8vIGNmLiBodHRwczovL3Y4LmRldi9ibG9nL3ByZXBhcnNlciNwaWZlXG4gICAgICAgIC5wcmVwZW5kKGAke2FtZC5kZWZpbmV9KCR7cGFyYW1zfSgke2dldE5vbkFycm93RnVuY3Rpb25JbnRybyhhcmdzLCB7XG4gICAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgfSl9eyR7dXNlU3RyaWN0fSR7bn0ke259YClcbiAgICAgICAgLmFwcGVuZChgJHtufSR7bn19KSk7YCkpO1xufVxuXG5mdW5jdGlvbiBjanMobWFnaWNTdHJpbmcsIHsgYWNjZXNzZWRHbG9iYWxzLCBkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIGhhc0V4cG9ydHMsIGluZGVudDogdCwgaW50cm8sIGlzRW50cnlGYWNhZGUsIGlzTW9kdWxlRmFjYWRlLCBuYW1lZEV4cG9ydHNNb2RlLCBvdXRybywgc25pcHBldHMgfSwgeyBjb21wYWN0LCBlc01vZHVsZSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgaW50ZXJvcCwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIHN0cmljdCB9KSB7XG4gICAgY29uc3QgeyBfLCBuIH0gPSBzbmlwcGV0cztcbiAgICBjb25zdCB1c2VTdHJpY3QgPSBzdHJpY3QgPyBgJ3VzZSBzdHJpY3QnOyR7bn0ke259YCA6ICcnO1xuICAgIGxldCBuYW1lc3BhY2VNYXJrZXJzID0gZ2V0TmFtZXNwYWNlTWFya2VycyhuYW1lZEV4cG9ydHNNb2RlICYmIGhhc0V4cG9ydHMsIGlzRW50cnlGYWNhZGUgJiYgZXNNb2R1bGUsIGlzTW9kdWxlRmFjYWRlICYmIG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBzbmlwcGV0cyk7XG4gICAgaWYgKG5hbWVzcGFjZU1hcmtlcnMpIHtcbiAgICAgICAgbmFtZXNwYWNlTWFya2VycyArPSBuICsgbjtcbiAgICB9XG4gICAgY29uc3QgaW1wb3J0QmxvY2sgPSBnZXRJbXBvcnRCbG9jayQxKGRlcGVuZGVuY2llcywgc25pcHBldHMsIGNvbXBhY3QpO1xuICAgIGNvbnN0IGludGVyb3BCbG9jayA9IGdldEludGVyb3BCbG9jayhkZXBlbmRlbmNpZXMsIGludGVyb3AsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBhY2Nlc3NlZEdsb2JhbHMsIHQsIHNuaXBwZXRzKTtcbiAgICBtYWdpY1N0cmluZy5wcmVwZW5kKGAke3VzZVN0cmljdH0ke2ludHJvfSR7bmFtZXNwYWNlTWFya2Vyc30ke2ltcG9ydEJsb2NrfSR7aW50ZXJvcEJsb2NrfWApO1xuICAgIGNvbnN0IGV4cG9ydEJsb2NrID0gZ2V0RXhwb3J0QmxvY2skMShleHBvcnRzLCBkZXBlbmRlbmNpZXMsIG5hbWVkRXhwb3J0c01vZGUsIGludGVyb3AsIHNuaXBwZXRzLCB0LCBleHRlcm5hbExpdmVCaW5kaW5ncywgYG1vZHVsZS5leHBvcnRzJHtffT0ke199YCk7XG4gICAgcmV0dXJuIG1hZ2ljU3RyaW5nLmFwcGVuZChgJHtleHBvcnRCbG9ja30ke291dHJvfWApO1xufVxuZnVuY3Rpb24gZ2V0SW1wb3J0QmxvY2skMShkZXBlbmRlbmNpZXMsIHsgXywgY25zdCwgbiB9LCBjb21wYWN0KSB7XG4gICAgbGV0IGltcG9ydEJsb2NrID0gJyc7XG4gICAgbGV0IGRlZmluaW5nVmFyaWFibGUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHsgaWQsIG5hbWUsIHJlZXhwb3J0cywgaW1wb3J0cyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIXJlZXhwb3J0cyAmJiAhaW1wb3J0cykge1xuICAgICAgICAgICAgaWYgKGltcG9ydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sgKz0gY29tcGFjdCAmJiAhZGVmaW5pbmdWYXJpYWJsZSA/ICcsJyA6IGA7JHtufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmluZ1ZhcmlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpbXBvcnRCbG9jayArPSBgcmVxdWlyZSgnJHtpZH0nKWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbXBvcnRCbG9jayArPSBjb21wYWN0ICYmIGRlZmluaW5nVmFyaWFibGUgPyAnLCcgOiBgJHtpbXBvcnRCbG9jayA/IGA7JHtufWAgOiAnJ30ke2Nuc3R9IGA7XG4gICAgICAgICAgICBkZWZpbmluZ1ZhcmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGltcG9ydEJsb2NrICs9IGAke25hbWV9JHtffT0ke199cmVxdWlyZSgnJHtpZH0nKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltcG9ydEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBgJHtpbXBvcnRCbG9ja307JHtufSR7bn1gO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGVzKG1hZ2ljU3RyaW5nLCB7IGFjY2Vzc2VkR2xvYmFscywgaW5kZW50OiB0LCBpbnRybywgb3V0cm8sIGRlcGVuZGVuY2llcywgZXhwb3J0cywgc25pcHBldHMgfSwgeyBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBuYW1lc3BhY2VUb1N0cmluZ1RhZyB9KSB7XG4gICAgY29uc3QgeyBfLCBuIH0gPSBzbmlwcGV0cztcbiAgICBjb25zdCBpbXBvcnRCbG9jayA9IGdldEltcG9ydEJsb2NrKGRlcGVuZGVuY2llcywgXyk7XG4gICAgaWYgKGltcG9ydEJsb2NrLmxlbmd0aCA+IDApXG4gICAgICAgIGludHJvICs9IGltcG9ydEJsb2NrLmpvaW4obikgKyBuICsgbjtcbiAgICBpbnRybyArPSBnZXRIZWxwZXJzQmxvY2sobnVsbCwgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cywgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcpO1xuICAgIGlmIChpbnRybylcbiAgICAgICAgbWFnaWNTdHJpbmcucHJlcGVuZChpbnRybyk7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayhleHBvcnRzLCBzbmlwcGV0cyk7XG4gICAgaWYgKGV4cG9ydEJsb2NrLmxlbmd0aClcbiAgICAgICAgbWFnaWNTdHJpbmcuYXBwZW5kKG4gKyBuICsgZXhwb3J0QmxvY2suam9pbihuKS50cmltKCkpO1xuICAgIGlmIChvdXRybylcbiAgICAgICAgbWFnaWNTdHJpbmcuYXBwZW5kKG91dHJvKTtcbiAgICByZXR1cm4gbWFnaWNTdHJpbmcudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0SW1wb3J0QmxvY2soZGVwZW5kZW5jaWVzLCBfKSB7XG4gICAgY29uc3QgaW1wb3J0QmxvY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgaWQsIHJlZXhwb3J0cywgaW1wb3J0cywgbmFtZSB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIXJlZXhwb3J0cyAmJiAhaW1wb3J0cykge1xuICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0JHtffScke2lkfSc7YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0cykge1xuICAgICAgICAgICAgbGV0IGRlZmF1bHRJbXBvcnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHN0YXJJbXBvcnQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWROYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2YgaW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW1wb3J0ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFySW1wb3J0ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWROYW1lcy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBpbXBvcnQke199KiR7X31hcyAke3N0YXJJbXBvcnQubG9jYWx9IGZyb20ke199JyR7aWR9JztgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0SW1wb3J0ICYmIGltcG9ydGVkTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0ICR7ZGVmYXVsdEltcG9ydC5sb2NhbH0gZnJvbSR7X30nJHtpZH0nO2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wb3J0ZWROYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0ICR7ZGVmYXVsdEltcG9ydCA/IGAke2RlZmF1bHRJbXBvcnQubG9jYWx9LCR7X31gIDogJyd9eyR7X30ke2ltcG9ydGVkTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChzcGVjaWZpZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVyLmltcG9ydGVkID09PSBzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZXIuaW1wb3J0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7c3BlY2lmaWVyLmltcG9ydGVkfSBhcyAke3NwZWNpZmllci5sb2NhbH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwke199YCl9JHtffX0ke199ZnJvbSR7X30nJHtpZH0nO2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIGxldCBzdGFyRXhwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZVJlZXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbmFtZWRSZWV4cG9ydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIucmVleHBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJFeHBvcnQgPSBzcGVjaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNwZWNpZmllci5pbXBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVJlZXhwb3J0cy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lZFJlZXhwb3J0cy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBleHBvcnQke199KiR7X31mcm9tJHtffScke2lkfSc7YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlUmVleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydHMgfHxcbiAgICAgICAgICAgICAgICAgICAgIWltcG9ydHMuc29tZShzcGVjaWZpZXIgPT4gc3BlY2lmaWVyLmltcG9ydGVkID09PSAnKicgJiYgc3BlY2lmaWVyLmxvY2FsID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBpbXBvcnQke199KiR7X31hcyAke25hbWV9IGZyb20ke199JyR7aWR9JztgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2YgbmFtZXNwYWNlUmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydEJsb2NrLnB1c2goYGV4cG9ydCR7X317JHtffSR7bmFtZSA9PT0gc3BlY2lmaWVyLnJlZXhwb3J0ZWQgPyBuYW1lIDogYCR7bmFtZX0gYXMgJHtzcGVjaWZpZXIucmVleHBvcnRlZH1gfSB9O2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lZFJlZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgZXhwb3J0JHtffXske199JHtuYW1lZFJlZXhwb3J0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKHNwZWNpZmllciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09IHNwZWNpZmllci5yZWV4cG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlY2lmaWVyLmltcG9ydGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3NwZWNpZmllci5pbXBvcnRlZH0gYXMgJHtzcGVjaWZpZXIucmVleHBvcnRlZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwke199YCl9JHtffX0ke199ZnJvbSR7X30nJHtpZH0nO2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRCbG9jaztcbn1cbmZ1bmN0aW9uIGdldEV4cG9ydEJsb2NrKGV4cG9ydHMsIHsgXywgY25zdCB9KSB7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBbXTtcbiAgICBjb25zdCBleHBvcnREZWNsYXJhdGlvbiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIGV4cG9ydHMpIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICBleHBvcnRCbG9jay5wdXNoKGAke2Nuc3R9ICR7c3BlY2lmaWVyLmxvY2FsfSR7X309JHtffSR7c3BlY2lmaWVyLmV4cHJlc3Npb259O2ApO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydERlY2xhcmF0aW9uLnB1c2goc3BlY2lmaWVyLmV4cG9ydGVkID09PSBzcGVjaWZpZXIubG9jYWxcbiAgICAgICAgICAgID8gc3BlY2lmaWVyLmxvY2FsXG4gICAgICAgICAgICA6IGAke3NwZWNpZmllci5sb2NhbH0gYXMgJHtzcGVjaWZpZXIuZXhwb3J0ZWR9YCk7XG4gICAgfVxuICAgIGlmIChleHBvcnREZWNsYXJhdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgZXhwb3J0QmxvY2sucHVzaChgZXhwb3J0JHtffXske199JHtleHBvcnREZWNsYXJhdGlvbi5qb2luKGAsJHtffWApfSR7X319O2ApO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0QmxvY2s7XG59XG5cbmNvbnN0IGtleXBhdGggPSAoa2V5cGF0aCwgZ2V0UHJvcGVydHlBY2Nlc3MpID0+IGtleXBhdGguc3BsaXQoJy4nKS5tYXAoZ2V0UHJvcGVydHlBY2Nlc3MpLmpvaW4oJycpO1xuXG5mdW5jdGlvbiBzZXR1cE5hbWVzcGFjZShuYW1lLCByb290LCBnbG9iYWxzLCB7IF8sIGdldFByb3BlcnR5QWNjZXNzLCBzIH0sIGNvbXBhY3QpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICBwYXJ0c1swXSA9ICh0eXBlb2YgZ2xvYmFscyA9PT0gJ2Z1bmN0aW9uJyA/IGdsb2JhbHMocGFydHNbMF0pIDogZ2xvYmFsc1twYXJ0c1swXV0pIHx8IHBhcnRzWzBdO1xuICAgIHBhcnRzLnBvcCgpO1xuICAgIGxldCBwcm9wZXJ0eVBhdGggPSByb290O1xuICAgIHJldHVybiAocGFydHNcbiAgICAgICAgLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgcHJvcGVydHlQYXRoICs9IGdldFByb3BlcnR5QWNjZXNzKHBhcnQpO1xuICAgICAgICByZXR1cm4gYCR7cHJvcGVydHlQYXRofSR7X309JHtffSR7cHJvcGVydHlQYXRofSR7X318fCR7X317fSR7c31gO1xuICAgIH0pXG4gICAgICAgIC5qb2luKGNvbXBhY3QgPyAnLCcgOiAnXFxuJykgKyAoY29tcGFjdCAmJiBwYXJ0cy5sZW5ndGggPyAnOycgOiAnXFxuJykpO1xufVxuZnVuY3Rpb24gYXNzaWduVG9EZWVwVmFyaWFibGUoZGVlcE5hbWUsIHJvb3QsIGdsb2JhbHMsIGFzc2lnbm1lbnQsIHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MgfSkge1xuICAgIGNvbnN0IHBhcnRzID0gZGVlcE5hbWUuc3BsaXQoJy4nKTtcbiAgICBwYXJ0c1swXSA9ICh0eXBlb2YgZ2xvYmFscyA9PT0gJ2Z1bmN0aW9uJyA/IGdsb2JhbHMocGFydHNbMF0pIDogZ2xvYmFsc1twYXJ0c1swXV0pIHx8IHBhcnRzWzBdO1xuICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgICBsZXQgcHJvcGVydHlQYXRoID0gcm9vdDtcbiAgICBsZXQgZGVlcEFzc2lnbm1lbnQgPSBwYXJ0c1xuICAgICAgICAubWFwKHBhcnQgPT4ge1xuICAgICAgICBwcm9wZXJ0eVBhdGggKz0gZ2V0UHJvcGVydHlBY2Nlc3MocGFydCk7XG4gICAgICAgIHJldHVybiBgJHtwcm9wZXJ0eVBhdGh9JHtffT0ke199JHtwcm9wZXJ0eVBhdGh9JHtffXx8JHtffXt9YDtcbiAgICB9KVxuICAgICAgICAuY29uY2F0KGAke3Byb3BlcnR5UGF0aH0ke2dldFByb3BlcnR5QWNjZXNzKGxhc3QpfWApXG4gICAgICAgIC5qb2luKGAsJHtffWApICsgYCR7X309JHtffSR7YXNzaWdubWVudH1gO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZXBBc3NpZ25tZW50ID0gYCgke2RlZXBBc3NpZ25tZW50fSlgO1xuICAgIH1cbiAgICByZXR1cm4gZGVlcEFzc2lnbm1lbnQ7XG59XG5cbmZ1bmN0aW9uIHRyaW1FbXB0eUltcG9ydHMoZGVwZW5kZW5jaWVzKSB7XG4gICAgbGV0IGkgPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgeyBpbXBvcnRzLCByZWV4cG9ydHMgfSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgaWYgKGltcG9ydHMgfHwgcmVleHBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGlpZmUobWFnaWNTdHJpbmcsIHsgYWNjZXNzZWRHbG9iYWxzLCBkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIGhhc0V4cG9ydHMsIGluZGVudDogdCwgaW50cm8sIG5hbWVkRXhwb3J0c01vZGUsIG91dHJvLCBzbmlwcGV0cywgd2FybiB9LCB7IGNvbXBhY3QsIGVzTW9kdWxlLCBleHRlbmQsIGZyZWV6ZSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGdsb2JhbHMsIGludGVyb3AsIG5hbWUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBzdHJpY3QgfSkge1xuICAgIGNvbnN0IHsgXywgY25zdCwgZ2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvLCBnZXRQcm9wZXJ0eUFjY2VzcywgbiB9ID0gc25pcHBldHM7XG4gICAgY29uc3QgaXNOYW1lc3BhY2VkID0gbmFtZSAmJiBuYW1lLmluY2x1ZGVzKCcuJyk7XG4gICAgY29uc3QgdXNlVmFyaWFibGVBc3NpZ25tZW50ID0gIWV4dGVuZCAmJiAhaXNOYW1lc3BhY2VkO1xuICAgIGlmIChuYW1lICYmIHVzZVZhcmlhYmxlQXNzaWdubWVudCAmJiAhaXNMZWdhbChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogJ0lMTEVHQUxfSURFTlRJRklFUl9BU19OQU1FJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBHaXZlbiBuYW1lIFwiJHtuYW1lfVwiIGlzIG5vdCBhIGxlZ2FsIEpTIGlkZW50aWZpZXIuIElmIHlvdSBuZWVkIHRoaXMsIHlvdSBjYW4gdHJ5IFwib3V0cHV0LmV4dGVuZDogdHJ1ZVwiLmBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhcm5PbkJ1aWx0aW5zKHdhcm4sIGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgZXh0ZXJuYWwgPSB0cmltRW1wdHlJbXBvcnRzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgZGVwcyA9IGV4dGVybmFsLm1hcChkZXAgPT4gZGVwLmdsb2JhbE5hbWUgfHwgJ251bGwnKTtcbiAgICBjb25zdCBhcmdzID0gZXh0ZXJuYWwubWFwKG0gPT4gbS5uYW1lKTtcbiAgICBpZiAoaGFzRXhwb3J0cyAmJiAhbmFtZSkge1xuICAgICAgICB3YXJuKHtcbiAgICAgICAgICAgIGNvZGU6ICdNSVNTSU5HX05BTUVfT1BUSU9OX0ZPUl9JSUZFX0VYUE9SVCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgSWYgeW91IGRvIG5vdCBzdXBwbHkgXCJvdXRwdXQubmFtZVwiLCB5b3UgbWF5IG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgZXhwb3J0cyBvZiBhbiBJSUZFIGJ1bmRsZS5gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzKSB7XG4gICAgICAgIGlmIChleHRlbmQpIHtcbiAgICAgICAgICAgIGRlcHMudW5zaGlmdChgdGhpcyR7a2V5cGF0aChuYW1lLCBnZXRQcm9wZXJ0eUFjY2Vzcyl9JHtffT0ke199dGhpcyR7a2V5cGF0aChuYW1lLCBnZXRQcm9wZXJ0eUFjY2Vzcyl9JHtffXx8JHtffXt9YCk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoJ2V4cG9ydHMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHMudW5zaGlmdCgne30nKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCgnZXhwb3J0cycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZVN0cmljdCA9IHN0cmljdCA/IGAke3R9J3VzZSBzdHJpY3QnOyR7bn1gIDogJyc7XG4gICAgY29uc3QgaW50ZXJvcEJsb2NrID0gZ2V0SW50ZXJvcEJsb2NrKGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIGFjY2Vzc2VkR2xvYmFscywgdCwgc25pcHBldHMpO1xuICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoYCR7aW50cm99JHtpbnRlcm9wQmxvY2t9YCk7XG4gICAgbGV0IHdyYXBwZXJJbnRybyA9IGAoJHtnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8oYXJncywge1xuICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgIH0pfXske259JHt1c2VTdHJpY3R9JHtufWA7XG4gICAgaWYgKGhhc0V4cG9ydHMpIHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIShleHRlbmQgJiYgbmFtZWRFeHBvcnRzTW9kZSkpIHtcbiAgICAgICAgICAgIHdyYXBwZXJJbnRybyA9XG4gICAgICAgICAgICAgICAgKHVzZVZhcmlhYmxlQXNzaWdubWVudCA/IGAke2Nuc3R9ICR7bmFtZX1gIDogYHRoaXMke2tleXBhdGgobmFtZSwgZ2V0UHJvcGVydHlBY2Nlc3MpfWApICtcbiAgICAgICAgICAgICAgICAgICAgYCR7X309JHtffSR7d3JhcHBlckludHJvfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlZCkge1xuICAgICAgICAgICAgd3JhcHBlckludHJvID0gc2V0dXBOYW1lc3BhY2UobmFtZSwgJ3RoaXMnLCBnbG9iYWxzLCBzbmlwcGV0cywgY29tcGFjdCkgKyB3cmFwcGVySW50cm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdyYXBwZXJPdXRybyA9IGAke259JHtufX0pKCR7ZGVwcy5qb2luKGAsJHtffWApfSk7YDtcbiAgICBpZiAoaGFzRXhwb3J0cyAmJiAhZXh0ZW5kICYmIG5hbWVkRXhwb3J0c01vZGUpIHtcbiAgICAgICAgd3JhcHBlck91dHJvID0gYCR7bn0ke259JHt0fXJldHVybiBleHBvcnRzOyR7d3JhcHBlck91dHJvfWA7XG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydEJsb2NrID0gZ2V0RXhwb3J0QmxvY2skMShleHBvcnRzLCBkZXBlbmRlbmNpZXMsIG5hbWVkRXhwb3J0c01vZGUsIGludGVyb3AsIHNuaXBwZXRzLCB0LCBleHRlcm5hbExpdmVCaW5kaW5ncyk7XG4gICAgbGV0IG5hbWVzcGFjZU1hcmtlcnMgPSBnZXROYW1lc3BhY2VNYXJrZXJzKG5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cywgZXNNb2R1bGUsIG5hbWVzcGFjZVRvU3RyaW5nVGFnLCBzbmlwcGV0cyk7XG4gICAgaWYgKG5hbWVzcGFjZU1hcmtlcnMpIHtcbiAgICAgICAgbmFtZXNwYWNlTWFya2VycyA9IG4gKyBuICsgbmFtZXNwYWNlTWFya2VycztcbiAgICB9XG4gICAgbWFnaWNTdHJpbmcuYXBwZW5kKGAke2V4cG9ydEJsb2NrfSR7bmFtZXNwYWNlTWFya2Vyc30ke291dHJvfWApO1xuICAgIHJldHVybiBtYWdpY1N0cmluZy5pbmRlbnQodCkucHJlcGVuZCh3cmFwcGVySW50cm8pLmFwcGVuZCh3cmFwcGVyT3V0cm8pO1xufVxuXG5mdW5jdGlvbiBzeXN0ZW0obWFnaWNTdHJpbmcsIHsgYWNjZXNzZWRHbG9iYWxzLCBkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIGhhc0V4cG9ydHMsIGluZGVudDogdCwgaW50cm8sIHNuaXBwZXRzLCBvdXRybywgdXNlc1RvcExldmVsQXdhaXQgfSwgeyBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBuYW1lLCBuYW1lc3BhY2VUb1N0cmluZ1RhZywgc3RyaWN0LCBzeXN0ZW1OdWxsU2V0dGVycyB9KSB7XG4gICAgY29uc3QgeyBfLCBnZXRGdW5jdGlvbkludHJvLCBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8sIG4sIHMgfSA9IHNuaXBwZXRzO1xuICAgIGNvbnN0IHsgaW1wb3J0QmluZGluZ3MsIHNldHRlcnMsIHN0YXJFeGNsdWRlcyB9ID0gYW5hbHl6ZURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIHQsIHNuaXBwZXRzKTtcbiAgICBjb25zdCByZWdpc3RlcmVkTmFtZSA9IG5hbWUgPyBgJyR7bmFtZX0nLCR7X31gIDogJyc7XG4gICAgY29uc3Qgd3JhcHBlclBhcmFtcyA9IGFjY2Vzc2VkR2xvYmFscy5oYXMoJ21vZHVsZScpXG4gICAgICAgID8gWydleHBvcnRzJywgJ21vZHVsZSddXG4gICAgICAgIDogaGFzRXhwb3J0c1xuICAgICAgICAgICAgPyBbJ2V4cG9ydHMnXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAvLyBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHBhcmVudGhlc2VzIHRvIGF2b2lkIGxhenkgcGFyc2luZyxcbiAgICAvLyBjZi4gaHR0cHM6Ly92OC5kZXYvYmxvZy9wcmVwYXJzZXIjcGlmZVxuICAgIGxldCB3cmFwcGVyU3RhcnQgPSBgU3lzdGVtLnJlZ2lzdGVyKCR7cmVnaXN0ZXJlZE5hbWV9W2AgK1xuICAgICAgICBkZXBlbmRlbmNpZXMubWFwKCh7IGlkIH0pID0+IGAnJHtpZH0nYCkuam9pbihgLCR7X31gKSArXG4gICAgICAgIGBdLCR7X30oJHtnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8od3JhcHBlclBhcmFtcywgeyBpc0FzeW5jOiBmYWxzZSwgbmFtZTogbnVsbCB9KX17JHtufSR7dH0ke3N0cmljdCA/IFwiJ3VzZSBzdHJpY3QnO1wiIDogJyd9YCArXG4gICAgICAgIGdldFN0YXJFeGNsdWRlc0Jsb2NrKHN0YXJFeGNsdWRlcywgdCwgc25pcHBldHMpICtcbiAgICAgICAgZ2V0SW1wb3J0QmluZGluZ3NCbG9jayhpbXBvcnRCaW5kaW5ncywgdCwgc25pcHBldHMpICtcbiAgICAgICAgYCR7bn0ke3R9cmV0dXJuJHtffXske3NldHRlcnMubGVuZ3RoXG4gICAgICAgICAgICA/IGAke259JHt0fSR7dH1zZXR0ZXJzOiR7X31bJHtzZXR0ZXJzXG4gICAgICAgICAgICAgICAgLm1hcChzZXR0ZXIgPT4gc2V0dGVyXG4gICAgICAgICAgICAgICAgPyBgJHtnZXRGdW5jdGlvbkludHJvKFsnbW9kdWxlJ10sIHtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9KX17JHtufSR7dH0ke3R9JHt0fSR7c2V0dGVyfSR7bn0ke3R9JHt0fX1gXG4gICAgICAgICAgICAgICAgOiBzeXN0ZW1OdWxsU2V0dGVyc1xuICAgICAgICAgICAgICAgICAgICA/IGBudWxsYFxuICAgICAgICAgICAgICAgICAgICA6IGAke2dldEZ1bmN0aW9uSW50cm8oW10sIHsgaXNBc3luYzogZmFsc2UsIG5hbWU6IG51bGwgfSl9e31gKVxuICAgICAgICAgICAgICAgIC5qb2luKGAsJHtffWApfV0sYFxuICAgICAgICAgICAgOiAnJ30ke259YDtcbiAgICB3cmFwcGVyU3RhcnQgKz0gYCR7dH0ke3R9ZXhlY3V0ZToke199KCR7Z2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvKFtdLCB7XG4gICAgICAgIGlzQXN5bmM6IHVzZXNUb3BMZXZlbEF3YWl0LFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgfSl9eyR7bn0ke259YDtcbiAgICBjb25zdCB3cmFwcGVyRW5kID0gYCR7dH0ke3R9fSkke259JHt0fX0ke3N9JHtufX0pKTtgO1xuICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoaW50cm8gK1xuICAgICAgICBnZXRIZWxwZXJzQmxvY2sobnVsbCwgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cywgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcpICtcbiAgICAgICAgZ2V0SG9pc3RlZEV4cG9ydHNCbG9jayhleHBvcnRzLCB0LCBzbmlwcGV0cykpO1xuICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChgJHtvdXRyb30ke259JHtufWAgK1xuICAgICAgICBnZXRTeW50aGV0aWNFeHBvcnRzQmxvY2soZXhwb3J0cywgdCwgc25pcHBldHMpICtcbiAgICAgICAgZ2V0TWlzc2luZ0V4cG9ydHNCbG9jayhleHBvcnRzLCB0LCBzbmlwcGV0cykpO1xuICAgIHJldHVybiBtYWdpY1N0cmluZy5pbmRlbnQoYCR7dH0ke3R9JHt0fWApLmFwcGVuZCh3cmFwcGVyRW5kKS5wcmVwZW5kKHdyYXBwZXJTdGFydCk7XG59XG5mdW5jdGlvbiBhbmFseXplRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgZXhwb3J0cywgdCwgeyBfLCBjbnN0LCBnZXRPYmplY3QsIGdldFByb3BlcnR5QWNjZXNzLCBuIH0pIHtcbiAgICBjb25zdCBpbXBvcnRCaW5kaW5ncyA9IFtdO1xuICAgIGNvbnN0IHNldHRlcnMgPSBbXTtcbiAgICBsZXQgc3RhckV4Y2x1ZGVzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHsgaW1wb3J0cywgcmVleHBvcnRzIH0gb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGNvbnN0IHNldHRlciA9IFtdO1xuICAgICAgICBpZiAoaW1wb3J0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2YgaW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGltcG9ydEJpbmRpbmdzLnB1c2goc3BlY2lmaWVyLmxvY2FsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVyLmltcG9ydGVkID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLnB1c2goYCR7c3BlY2lmaWVyLmxvY2FsfSR7X309JHtffW1vZHVsZTtgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRlci5wdXNoKGAke3NwZWNpZmllci5sb2NhbH0ke199PSR7X31tb2R1bGUke2dldFByb3BlcnR5QWNjZXNzKHNwZWNpZmllci5pbXBvcnRlZCl9O2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVleHBvcnRzKSB7XG4gICAgICAgICAgICBjb25zdCByZWV4cG9ydGVkTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBoYXNTdGFyUmVleHBvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbXBvcnRlZCwgcmVleHBvcnRlZCB9IG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWV4cG9ydGVkID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3RhclJlZXhwb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0ZWROYW1lcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZCA9PT0gJyonID8gJ21vZHVsZScgOiBgbW9kdWxlJHtnZXRQcm9wZXJ0eUFjY2VzcyhpbXBvcnRlZCl9YFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVleHBvcnRlZE5hbWVzLmxlbmd0aCA+IDEgfHwgaGFzU3RhclJlZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0TWFwcGluZyA9IGdldE9iamVjdChyZWV4cG9ydGVkTmFtZXMsIHsgbGluZUJyZWFrSW5kZW50OiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTdGFyUmVleHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFyRXhjbHVkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJFeGNsdWRlcyA9IGdldFN0YXJFeGNsdWRlcyh7IGRlcGVuZGVuY2llcywgZXhwb3J0cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIucHVzaChgJHtjbnN0fSBzZXR0ZXIke199PSR7X30ke2V4cG9ydE1hcHBpbmd9O2AsIGBmb3Ike199KCR7Y25zdH0gbmFtZSBpbiBtb2R1bGUpJHtffXtgLCBgJHt0fWlmJHtffSghX3N0YXJFeGNsdWRlc1tuYW1lXSkke199c2V0dGVyW25hbWVdJHtffT0ke199bW9kdWxlW25hbWVdO2AsICd9JywgJ2V4cG9ydHMoc2V0dGVyKTsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRlci5wdXNoKGBleHBvcnRzKCR7ZXhwb3J0TWFwcGluZ30pO2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlZXhwb3J0ZWROYW1lc1swXTtcbiAgICAgICAgICAgICAgICBzZXR0ZXIucHVzaChgZXhwb3J0cygnJHtrZXl9Jywke199JHt2YWx1ZX0pO2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldHRlcnMucHVzaChzZXR0ZXIuam9pbihgJHtufSR7dH0ke3R9JHt0fWApKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW1wb3J0QmluZGluZ3MsIHNldHRlcnMsIHN0YXJFeGNsdWRlcyB9O1xufVxuY29uc3QgZ2V0U3RhckV4Y2x1ZGVzID0gKHsgZGVwZW5kZW5jaWVzLCBleHBvcnRzIH0pID0+IHtcbiAgICBjb25zdCBzdGFyRXhjbHVkZXMgPSBuZXcgU2V0KGV4cG9ydHMubWFwKGV4cHQgPT4gZXhwdC5leHBvcnRlZCkpO1xuICAgIHN0YXJFeGNsdWRlcy5hZGQoJ2RlZmF1bHQnKTtcbiAgICBmb3IgKGNvbnN0IHsgcmVleHBvcnRzIH0gb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVleHBvcnQgb2YgcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZXhwb3J0LnJlZXhwb3J0ZWQgIT09ICcqJylcbiAgICAgICAgICAgICAgICAgICAgc3RhckV4Y2x1ZGVzLmFkZChyZWV4cG9ydC5yZWV4cG9ydGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhckV4Y2x1ZGVzO1xufTtcbmNvbnN0IGdldFN0YXJFeGNsdWRlc0Jsb2NrID0gKHN0YXJFeGNsdWRlcywgdCwgeyBfLCBjbnN0LCBnZXRPYmplY3QsIG4gfSkgPT4gc3RhckV4Y2x1ZGVzXG4gICAgPyBgJHtufSR7dH0ke2Nuc3R9IF9zdGFyRXhjbHVkZXMke199PSR7X30ke2dldE9iamVjdChbLi4uc3RhckV4Y2x1ZGVzXS5tYXAocHJvcCA9PiBbcHJvcCwgJzEnXSksIHsgbGluZUJyZWFrSW5kZW50OiB7IGJhc2U6IHQsIHQgfSB9KX07YFxuICAgIDogJyc7XG5jb25zdCBnZXRJbXBvcnRCaW5kaW5nc0Jsb2NrID0gKGltcG9ydEJpbmRpbmdzLCB0LCB7IF8sIG4gfSkgPT4gKGltcG9ydEJpbmRpbmdzLmxlbmd0aCA/IGAke259JHt0fXZhciAke2ltcG9ydEJpbmRpbmdzLmpvaW4oYCwke199YCl9O2AgOiAnJyk7XG5jb25zdCBnZXRIb2lzdGVkRXhwb3J0c0Jsb2NrID0gKGV4cG9ydHMsIHQsIHNuaXBwZXRzKSA9PiBnZXRFeHBvcnRzQmxvY2soZXhwb3J0cy5maWx0ZXIoZXhwdCA9PiBleHB0LmhvaXN0ZWQpLm1hcChleHB0ID0+ICh7IG5hbWU6IGV4cHQuZXhwb3J0ZWQsIHZhbHVlOiBleHB0LmxvY2FsIH0pKSwgdCwgc25pcHBldHMpO1xuZnVuY3Rpb24gZ2V0RXhwb3J0c0Jsb2NrKGV4cG9ydHMsIHQsIHsgXywgbiB9KSB7XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgZXhwb3J0cygnJHtleHBvcnRzWzBdLm5hbWV9Jywke199JHtleHBvcnRzWzBdLnZhbHVlfSk7JHtufSR7bn1gO1xuICAgIH1cbiAgICByZXR1cm4gKGBleHBvcnRzKHske259YCArXG4gICAgICAgIGV4cG9ydHMubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+IGAke3R9JHtuYW1lfToke199JHt2YWx1ZX1gKS5qb2luKGAsJHtufWApICtcbiAgICAgICAgYCR7bn19KTske259JHtufWApO1xufVxuY29uc3QgZ2V0U3ludGhldGljRXhwb3J0c0Jsb2NrID0gKGV4cG9ydHMsIHQsIHNuaXBwZXRzKSA9PiBnZXRFeHBvcnRzQmxvY2soZXhwb3J0c1xuICAgIC5maWx0ZXIoZXhwdCA9PiBleHB0LmV4cHJlc3Npb24pXG4gICAgLm1hcChleHB0ID0+ICh7IG5hbWU6IGV4cHQuZXhwb3J0ZWQsIHZhbHVlOiBleHB0LmxvY2FsIH0pKSwgdCwgc25pcHBldHMpO1xuY29uc3QgZ2V0TWlzc2luZ0V4cG9ydHNCbG9jayA9IChleHBvcnRzLCB0LCBzbmlwcGV0cykgPT4gZ2V0RXhwb3J0c0Jsb2NrKGV4cG9ydHNcbiAgICAuZmlsdGVyKGV4cHQgPT4gZXhwdC5sb2NhbCA9PT0gTUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRSlcbiAgICAubWFwKGV4cHQgPT4gKHsgbmFtZTogZXhwdC5leHBvcnRlZCwgdmFsdWU6IE1JU1NJTkdfRVhQT1JUX1NISU1fVkFSSUFCTEUgfSkpLCB0LCBzbmlwcGV0cyk7XG5cbmZ1bmN0aW9uIGdsb2JhbFByb3AobmFtZSwgZ2xvYmFsVmFyLCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgIGlmICghbmFtZSlcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gYCR7Z2xvYmFsVmFyfSR7a2V5cGF0aChuYW1lLCBnZXRQcm9wZXJ0eUFjY2Vzcyl9YDtcbn1cbmZ1bmN0aW9uIHNhZmVBY2Nlc3MobmFtZSwgZ2xvYmFsVmFyLCB7IF8sIGdldFByb3BlcnR5QWNjZXNzIH0pIHtcbiAgICBsZXQgcHJvcGVydHlQYXRoID0gZ2xvYmFsVmFyO1xuICAgIHJldHVybiBuYW1lXG4gICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgIC5tYXAocGFydCA9PiAocHJvcGVydHlQYXRoICs9IGdldFByb3BlcnR5QWNjZXNzKHBhcnQpKSlcbiAgICAgICAgLmpvaW4oYCR7X30mJiR7X31gKTtcbn1cbmZ1bmN0aW9uIHVtZChtYWdpY1N0cmluZywgeyBhY2Nlc3NlZEdsb2JhbHMsIGRlcGVuZGVuY2llcywgZXhwb3J0cywgaGFzRXhwb3J0cywgaWQsIGluZGVudDogdCwgaW50cm8sIG5hbWVkRXhwb3J0c01vZGUsIG91dHJvLCBzbmlwcGV0cywgd2FybiB9LCB7IGFtZCwgY29tcGFjdCwgZXNNb2R1bGUsIGV4dGVuZCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgaW50ZXJvcCwgbmFtZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIGdsb2JhbHMsIG5vQ29uZmxpY3QsIHN0cmljdCB9KSB7XG4gICAgY29uc3QgeyBfLCBjbnN0LCBnZXRGdW5jdGlvbkludHJvLCBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8sIGdldFByb3BlcnR5QWNjZXNzLCBuLCBzIH0gPSBzbmlwcGV0cztcbiAgICBjb25zdCBmYWN0b3J5VmFyID0gY29tcGFjdCA/ICdmJyA6ICdmYWN0b3J5JztcbiAgICBjb25zdCBnbG9iYWxWYXIgPSBjb21wYWN0ID8gJ2cnIDogJ2dsb2JhbCc7XG4gICAgaWYgKGhhc0V4cG9ydHMgJiYgIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKHtcbiAgICAgICAgICAgIGNvZGU6ICdNSVNTSU5HX05BTUVfT1BUSU9OX0ZPUl9JSUZFX0VYUE9SVCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnWW91IG11c3Qgc3VwcGx5IFwib3V0cHV0Lm5hbWVcIiBmb3IgVU1EIGJ1bmRsZXMgdGhhdCBoYXZlIGV4cG9ydHMgc28gdGhhdCB0aGUgZXhwb3J0cyBhcmUgYWNjZXNzaWJsZSBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBhIG1vZHVsZSBsb2FkZXIuJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2Fybk9uQnVpbHRpbnMod2FybiwgZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBhbWREZXBzID0gZGVwZW5kZW5jaWVzLm1hcChtID0+IGAnJHtyZW1vdmVFeHRlbnNpb25Gcm9tUmVsYXRpdmVBbWRJZChtLmlkKX0nYCk7XG4gICAgY29uc3QgY2pzRGVwcyA9IGRlcGVuZGVuY2llcy5tYXAobSA9PiBgcmVxdWlyZSgnJHttLmlkfScpYCk7XG4gICAgY29uc3QgdHJpbW1lZEltcG9ydHMgPSB0cmltRW1wdHlJbXBvcnRzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgZ2xvYmFsRGVwcyA9IHRyaW1tZWRJbXBvcnRzLm1hcChtb2R1bGUgPT4gZ2xvYmFsUHJvcChtb2R1bGUuZ2xvYmFsTmFtZSwgZ2xvYmFsVmFyLCBnZXRQcm9wZXJ0eUFjY2VzcykpO1xuICAgIGNvbnN0IGZhY3RvcnlQYXJhbXMgPSB0cmltbWVkSW1wb3J0cy5tYXAobSA9PiBtLm5hbWUpO1xuICAgIGlmIChuYW1lZEV4cG9ydHNNb2RlICYmIChoYXNFeHBvcnRzIHx8IG5vQ29uZmxpY3QpKSB7XG4gICAgICAgIGFtZERlcHMudW5zaGlmdChgJ2V4cG9ydHMnYCk7XG4gICAgICAgIGNqc0RlcHMudW5zaGlmdChgZXhwb3J0c2ApO1xuICAgICAgICBnbG9iYWxEZXBzLnVuc2hpZnQoYXNzaWduVG9EZWVwVmFyaWFibGUobmFtZSwgZ2xvYmFsVmFyLCBnbG9iYWxzLCBgJHtleHRlbmQgPyBgJHtnbG9iYWxQcm9wKG5hbWUsIGdsb2JhbFZhciwgZ2V0UHJvcGVydHlBY2Nlc3MpfSR7X318fCR7X31gIDogJyd9e31gLCBzbmlwcGV0cykpO1xuICAgICAgICBmYWN0b3J5UGFyYW1zLnVuc2hpZnQoJ2V4cG9ydHMnKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGVBbWRJZCA9IGdldENvbXBsZXRlQW1kSWQoYW1kLCBpZCk7XG4gICAgY29uc3QgYW1kUGFyYW1zID0gKGNvbXBsZXRlQW1kSWQgPyBgJyR7Y29tcGxldGVBbWRJZH0nLCR7X31gIDogYGApICtcbiAgICAgICAgKGFtZERlcHMubGVuZ3RoID8gYFske2FtZERlcHMuam9pbihgLCR7X31gKX1dLCR7X31gIDogYGApO1xuICAgIGNvbnN0IGRlZmluZSA9IGFtZC5kZWZpbmU7XG4gICAgY29uc3QgY2pzRXhwb3J0ID0gIW5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cyA/IGBtb2R1bGUuZXhwb3J0cyR7X309JHtffWAgOiBgYDtcbiAgICBjb25zdCB1c2VTdHJpY3QgPSBzdHJpY3QgPyBgJHtffSd1c2Ugc3RyaWN0Jzske259YCA6IGBgO1xuICAgIGxldCBpaWZlRXhwb3J0O1xuICAgIGlmIChub0NvbmZsaWN0KSB7XG4gICAgICAgIGNvbnN0IG5vQ29uZmxpY3RFeHBvcnRzVmFyID0gY29tcGFjdCA/ICdlJyA6ICdleHBvcnRzJztcbiAgICAgICAgbGV0IGZhY3Rvcnk7XG4gICAgICAgIGlmICghbmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gYCR7Y25zdH0gJHtub0NvbmZsaWN0RXhwb3J0c1Zhcn0ke199PSR7X30ke2Fzc2lnblRvRGVlcFZhcmlhYmxlKG5hbWUsIGdsb2JhbFZhciwgZ2xvYmFscywgYCR7ZmFjdG9yeVZhcn0oJHtnbG9iYWxEZXBzLmpvaW4oYCwke199YCl9KWAsIHNuaXBwZXRzKX07YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGdsb2JhbERlcHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGZhY3RvcnkgPVxuICAgICAgICAgICAgICAgIGAke2Nuc3R9ICR7bm9Db25mbGljdEV4cG9ydHNWYXJ9JHtffT0ke199JHttb2R1bGV9OyR7bn1gICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dH0ke3R9JHtmYWN0b3J5VmFyfSgke1tub0NvbmZsaWN0RXhwb3J0c1Zhcl0uY29uY2F0KGdsb2JhbERlcHMpLmpvaW4oYCwke199YCl9KTtgO1xuICAgICAgICB9XG4gICAgICAgIGlpZmVFeHBvcnQgPVxuICAgICAgICAgICAgYCgke2dldEZ1bmN0aW9uSW50cm8oW10sIHsgaXNBc3luYzogZmFsc2UsIG5hbWU6IG51bGwgfSl9eyR7bn1gICtcbiAgICAgICAgICAgICAgICBgJHt0fSR7dH0ke2Nuc3R9IGN1cnJlbnQke199PSR7X30ke3NhZmVBY2Nlc3MobmFtZSwgZ2xvYmFsVmFyLCBzbmlwcGV0cyl9OyR7bn1gICtcbiAgICAgICAgICAgICAgICBgJHt0fSR7dH0ke2ZhY3Rvcnl9JHtufWAgK1xuICAgICAgICAgICAgICAgIGAke3R9JHt0fSR7bm9Db25mbGljdEV4cG9ydHNWYXJ9Lm5vQ29uZmxpY3Qke199PSR7X30ke2dldEZ1bmN0aW9uSW50cm8oW10sIHtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9KX17JHtffWAgK1xuICAgICAgICAgICAgICAgIGAke2dsb2JhbFByb3AobmFtZSwgZ2xvYmFsVmFyLCBnZXRQcm9wZXJ0eUFjY2Vzcyl9JHtffT0ke199Y3VycmVudDske199cmV0dXJuICR7bm9Db25mbGljdEV4cG9ydHNWYXJ9JHtzfSR7X319OyR7bn1gICtcbiAgICAgICAgICAgICAgICBgJHt0fX0pKClgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWlmZUV4cG9ydCA9IGAke2ZhY3RvcnlWYXJ9KCR7Z2xvYmFsRGVwcy5qb2luKGAsJHtffWApfSlgO1xuICAgICAgICBpZiAoIW5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cykge1xuICAgICAgICAgICAgaWlmZUV4cG9ydCA9IGFzc2lnblRvRGVlcFZhcmlhYmxlKG5hbWUsIGdsb2JhbFZhciwgZ2xvYmFscywgaWlmZUV4cG9ydCwgc25pcHBldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlpZmVOZWVkc0dsb2JhbCA9IGhhc0V4cG9ydHMgfHwgKG5vQ29uZmxpY3QgJiYgbmFtZWRFeHBvcnRzTW9kZSkgfHwgZ2xvYmFsRGVwcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHdyYXBwZXJQYXJhbXMgPSBbZmFjdG9yeVZhcl07XG4gICAgaWYgKGlpZmVOZWVkc0dsb2JhbCkge1xuICAgICAgICB3cmFwcGVyUGFyYW1zLnVuc2hpZnQoZ2xvYmFsVmFyKTtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFsQXJnID0gaWlmZU5lZWRzR2xvYmFsID8gYHRoaXMsJHtffWAgOiAnJztcbiAgICBjb25zdCBpaWZlU3RhcnQgPSBpaWZlTmVlZHNHbG9iYWxcbiAgICAgICAgPyBgKCR7Z2xvYmFsVmFyfSR7X309JHtffXR5cGVvZiBnbG9iYWxUaGlzJHtffSE9PSR7X30ndW5kZWZpbmVkJyR7X30/JHtffWdsb2JhbFRoaXMke199OiR7X30ke2dsb2JhbFZhcn0ke199fHwke199c2VsZiwke199YFxuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGlpZmVFbmQgPSBpaWZlTmVlZHNHbG9iYWwgPyAnKScgOiAnJztcbiAgICBjb25zdCBjanNJbnRybyA9IGlpZmVOZWVkc0dsb2JhbFxuICAgICAgICA/IGAke3R9dHlwZW9mIGV4cG9ydHMke199PT09JHtffSdvYmplY3QnJHtffSYmJHtffXR5cGVvZiBtb2R1bGUke199IT09JHtffSd1bmRlZmluZWQnJHtffT9gICtcbiAgICAgICAgICAgIGAke199JHtjanNFeHBvcnR9JHtmYWN0b3J5VmFyfSgke2Nqc0RlcHMuam9pbihgLCR7X31gKX0pJHtffToke259YFxuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IHdyYXBwZXJJbnRybyA9IGAoJHtnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8od3JhcHBlclBhcmFtcywgeyBpc0FzeW5jOiBmYWxzZSwgbmFtZTogbnVsbCB9KX17JHtufWAgK1xuICAgICAgICBjanNJbnRybyArXG4gICAgICAgIGAke3R9dHlwZW9mICR7ZGVmaW5lfSR7X309PT0ke199J2Z1bmN0aW9uJyR7X30mJiR7X30ke2RlZmluZX0uYW1kJHtffT8ke199JHtkZWZpbmV9KCR7YW1kUGFyYW1zfSR7ZmFjdG9yeVZhcn0pJHtffToke259YCArXG4gICAgICAgIGAke3R9JHtpaWZlU3RhcnR9JHtpaWZlRXhwb3J0fSR7aWlmZUVuZH07JHtufWAgK1xuICAgICAgICAvLyBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHBhcmVudGhlc2VzIHRvIGF2b2lkIGxhenkgcGFyc2luZyxcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vdjguZGV2L2Jsb2cvcHJlcGFyc2VyI3BpZmVcbiAgICAgICAgYH0pKCR7Z2xvYmFsQXJnfSgke2dldE5vbkFycm93RnVuY3Rpb25JbnRybyhmYWN0b3J5UGFyYW1zLCB7XG4gICAgICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfSl9eyR7dXNlU3RyaWN0fSR7bn1gO1xuICAgIGNvbnN0IHdyYXBwZXJPdXRybyA9IG4gKyBuICsgJ30pKTsnO1xuICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoYCR7aW50cm99JHtnZXRJbnRlcm9wQmxvY2soZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBuYW1lc3BhY2VUb1N0cmluZ1RhZywgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cyl9YCk7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayQxKGV4cG9ydHMsIGRlcGVuZGVuY2llcywgbmFtZWRFeHBvcnRzTW9kZSwgaW50ZXJvcCwgc25pcHBldHMsIHQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKTtcbiAgICBsZXQgbmFtZXNwYWNlTWFya2VycyA9IGdldE5hbWVzcGFjZU1hcmtlcnMobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzLCBlc01vZHVsZSwgbmFtZXNwYWNlVG9TdHJpbmdUYWcsIHNuaXBwZXRzKTtcbiAgICBpZiAobmFtZXNwYWNlTWFya2Vycykge1xuICAgICAgICBuYW1lc3BhY2VNYXJrZXJzID0gbiArIG4gKyBuYW1lc3BhY2VNYXJrZXJzO1xuICAgIH1cbiAgICBtYWdpY1N0cmluZy5hcHBlbmQoYCR7ZXhwb3J0QmxvY2t9JHtuYW1lc3BhY2VNYXJrZXJzfSR7b3V0cm99YCk7XG4gICAgcmV0dXJuIG1hZ2ljU3RyaW5nLnRyaW0oKS5pbmRlbnQodCkuYXBwZW5kKHdyYXBwZXJPdXRybykucHJlcGVuZCh3cmFwcGVySW50cm8pO1xufVxuXG5jb25zdCBmaW5hbGlzZXJzID0geyBhbWQsIGNqcywgZXMsIGlpZmUsIHN5c3RlbSwgdW1kIH07XG5cbmNsYXNzIFNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoZmlsZW5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5pc09yaWdpbmFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0cmFjZVNlZ21lbnQobGluZSwgY29sdW1uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgbmFtZSwgc291cmNlOiB0aGlzIH07XG4gICAgfVxufVxuY2xhc3MgTGluayB7XG4gICAgY29uc3RydWN0b3IobWFwLCBzb3VyY2VzKSB7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgIHRoaXMubmFtZXMgPSBtYXAubmFtZXM7XG4gICAgICAgIHRoaXMubWFwcGluZ3MgPSBtYXAubWFwcGluZ3M7XG4gICAgfVxuICAgIHRyYWNlTWFwcGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc291cmNlSW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICAgIGNvbnN0IG5hbWVJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMubWFwcGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlZExpbmUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2VnbWVudFsxXV07XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlZCA9IHNvdXJjZS50cmFjZVNlZ21lbnQoc2VnbWVudFsyXSwgc2VnbWVudFszXSwgc2VnbWVudC5sZW5ndGggPT09IDUgPyB0aGlzLm5hbWVzW3NlZ21lbnRbNF1dIDogJycpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2x1bW4sIGxpbmUsIG5hbWUsIHNvdXJjZTogeyBjb250ZW50LCBmaWxlbmFtZSB9IH0gPSB0cmFjZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJbmRleCA9IHNvdXJjZUluZGV4TWFwLmdldChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJbmRleCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4TWFwLnNldChmaWxlbmFtZSwgc291cmNlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc0NvbnRlbnRbc291cmNlSW5kZXhdID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VzQ29udGVudFtzb3VyY2VJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc0NvbnRlbnRbc291cmNlSW5kZXhdID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50ICE9IG51bGwgJiYgc291cmNlc0NvbnRlbnRbc291cmNlSW5kZXhdICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNdWx0aXBsZSBjb25mbGljdGluZyBjb250ZW50cyBmb3Igc291cmNlbWFwIHNvdXJjZSAke2ZpbGVuYW1lfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlZFNlZ21lbnQgPSBbc2VnbWVudFswXSwgc291cmNlSW5kZXgsIGxpbmUsIGNvbHVtbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZUluZGV4ID0gbmFtZUluZGV4TWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleCA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleE1hcC5zZXQobmFtZSwgbmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlZFNlZ21lbnRbNF0gPSBuYW1lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2VkTGluZS5wdXNoKHRyYWNlZFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2godHJhY2VkTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGluZ3MsIG5hbWVzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9O1xuICAgIH1cbiAgICB0cmFjZVNlZ21lbnQobGluZSwgY29sdW1uLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5tYXBwaW5nc1tsaW5lXTtcbiAgICAgICAgaWYgKCFzZWdtZW50cylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIHRocm91Z2ggc2VnbWVudHMgZm9yIHRoZSBnaXZlbiBjb2x1bW5cbiAgICAgICAgbGV0IHNlYXJjaFN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IHNlYXJjaEVuZCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChzZWFyY2hTdGFydCA8PSBzZWFyY2hFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoc2VhcmNoU3RhcnQgKyBzZWFyY2hFbmQpID4+IDE7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbbV07XG4gICAgICAgICAgICAvLyBJZiBhIHNvdXJjZW1hcCBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcmVzb2x1dGlvbiB0byBjb250YWluIGFcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBtYXBwaW5nLCBlLmcuIGJlY2F1c2UgaXQgb25seSBjb250YWlucyBsaW5lIGluZm9ybWF0aW9uLCB3ZVxuICAgICAgICAgICAgLy8gdXNlIHRoZSBiZXN0IGFwcHJveGltYXRpb24gd2UgY291bGQgZmluZFxuICAgICAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09IGNvbHVtbiB8fCBzZWFyY2hTdGFydCA9PT0gc2VhcmNoRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlc1tzZWdtZW50WzFdXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS50cmFjZVNlZ21lbnQoc2VnbWVudFsyXSwgc2VnbWVudFszXSwgc2VnbWVudC5sZW5ndGggPT09IDUgPyB0aGlzLm5hbWVzW3NlZ21lbnRbNF1dIDogbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudFswXSA+IGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHNlYXJjaEVuZCA9IG0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRMaW5rTWFwKHdhcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbGlua01hcChzb3VyY2UsIG1hcCkge1xuICAgICAgICBpZiAobWFwLm1hcHBpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmsobWFwLCBbc291cmNlXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2Fybih7XG4gICAgICAgICAgICBjb2RlOiAnU09VUkNFTUFQX0JST0tFTicsXG4gICAgICAgICAgICBtZXNzYWdlOiBgU291cmNlbWFwIGlzIGxpa2VseSB0byBiZSBpbmNvcnJlY3Q6IGEgcGx1Z2luICgke21hcC5wbHVnaW59KSB3YXMgdXNlZCB0byB0cmFuc2Zvcm0gYCArXG4gICAgICAgICAgICAgICAgXCJmaWxlcywgYnV0IGRpZG4ndCBnZW5lcmF0ZSBhIHNvdXJjZW1hcCBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uLiBDb25zdWx0IHRoZSBwbHVnaW4gXCIgK1xuICAgICAgICAgICAgICAgICdkb2N1bWVudGF0aW9uIGZvciBoZWxwJyxcbiAgICAgICAgICAgIHBsdWdpbjogbWFwLnBsdWdpbixcbiAgICAgICAgICAgIHVybDogYGh0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyN3YXJuaW5nLXNvdXJjZW1hcC1pcy1saWtlbHktdG8tYmUtaW5jb3JyZWN0YFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiBbXSxcbiAgICAgICAgICAgIG5hbWVzOiBbXVxuICAgICAgICB9LCBbc291cmNlXSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbGxhcHNlZFNvdXJjZW1hcChpZCwgb3JpZ2luYWxDb2RlLCBvcmlnaW5hbFNvdXJjZW1hcCwgc291cmNlbWFwQ2hhaW4sIGxpbmtNYXApIHtcbiAgICBsZXQgc291cmNlO1xuICAgIGlmICghb3JpZ2luYWxTb3VyY2VtYXApIHtcbiAgICAgICAgc291cmNlID0gbmV3IFNvdXJjZShpZCwgb3JpZ2luYWxDb2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBvcmlnaW5hbFNvdXJjZW1hcC5zb3VyY2VzO1xuICAgICAgICBjb25zdCBzb3VyY2VzQ29udGVudCA9IG9yaWdpbmFsU291cmNlbWFwLnNvdXJjZXNDb250ZW50IHx8IFtdO1xuICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSBkaXJuYW1lKGlkKSB8fCAnLic7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJvb3QgPSBvcmlnaW5hbFNvdXJjZW1hcC5zb3VyY2VSb290IHx8ICcuJztcbiAgICAgICAgY29uc3QgYmFzZVNvdXJjZXMgPSBzb3VyY2VzLm1hcCgoc291cmNlLCBpKSA9PiBuZXcgU291cmNlKHJlc29sdmUoZGlyZWN0b3J5LCBzb3VyY2VSb290LCBzb3VyY2UpLCBzb3VyY2VzQ29udGVudFtpXSkpO1xuICAgICAgICBzb3VyY2UgPSBuZXcgTGluayhvcmlnaW5hbFNvdXJjZW1hcCwgYmFzZVNvdXJjZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlbWFwQ2hhaW4ucmVkdWNlKGxpbmtNYXAsIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb2xsYXBzZVNvdXJjZW1hcHMoZmlsZSwgbWFwLCBtb2R1bGVzLCBidW5kbGVTb3VyY2VtYXBDaGFpbiwgZXhjbHVkZUNvbnRlbnQsIHdhcm4pIHtcbiAgICBjb25zdCBsaW5rTWFwID0gZ2V0TGlua01hcCh3YXJuKTtcbiAgICBjb25zdCBtb2R1bGVTb3VyY2VzID0gbW9kdWxlc1xuICAgICAgICAuZmlsdGVyKG1vZHVsZSA9PiAhbW9kdWxlLmV4Y2x1ZGVGcm9tU291cmNlbWFwKVxuICAgICAgICAubWFwKG1vZHVsZSA9PiBnZXRDb2xsYXBzZWRTb3VyY2VtYXAobW9kdWxlLmlkLCBtb2R1bGUub3JpZ2luYWxDb2RlLCBtb2R1bGUub3JpZ2luYWxTb3VyY2VtYXAsIG1vZHVsZS5zb3VyY2VtYXBDaGFpbiwgbGlua01hcCkpO1xuICAgIGNvbnN0IGxpbmsgPSBuZXcgTGluayhtYXAsIG1vZHVsZVNvdXJjZXMpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGJ1bmRsZVNvdXJjZW1hcENoYWluLnJlZHVjZShsaW5rTWFwLCBsaW5rKTtcbiAgICBsZXQgeyBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIG1hcHBpbmdzIH0gPSBzb3VyY2UudHJhY2VNYXBwaW5ncygpO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeSA9IGRpcm5hbWUoZmlsZSk7XG4gICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzLm1hcCgoc291cmNlKSA9PiByZWxhdGl2ZSQxKGRpcmVjdG9yeSwgc291cmNlKSk7XG4gICAgICAgIGZpbGUgPSBiYXNlbmFtZShmaWxlKTtcbiAgICB9XG4gICAgc291cmNlc0NvbnRlbnQgPSAoZXhjbHVkZUNvbnRlbnQgPyBudWxsIDogc291cmNlc0NvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgU291cmNlTWFwKHsgZmlsZSwgbWFwcGluZ3MsIG5hbWVzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9KTtcbn1cbmZ1bmN0aW9uIGNvbGxhcHNlU291cmNlbWFwKGlkLCBvcmlnaW5hbENvZGUsIG9yaWdpbmFsU291cmNlbWFwLCBzb3VyY2VtYXBDaGFpbiwgd2Fybikge1xuICAgIGlmICghc291cmNlbWFwQ2hhaW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNvdXJjZW1hcDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gZ2V0Q29sbGFwc2VkU291cmNlbWFwKGlkLCBvcmlnaW5hbENvZGUsIG9yaWdpbmFsU291cmNlbWFwLCBzb3VyY2VtYXBDaGFpbiwgZ2V0TGlua01hcCh3YXJuKSk7XG4gICAgY29uc3QgbWFwID0gc291cmNlLnRyYWNlTWFwcGluZ3MoKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uOiAzLCAuLi5tYXAgfTtcbn1cblxuY29uc3QgY3JlYXRlSGFzaCA9ICgpID0+IGNyZWF0ZUhhc2gkMSgnc2hhMjU2Jyk7XG5cbmNvbnN0IERFQ09ORkxJQ1RfSU1QT1JURURfVkFSSUFCTEVTX0JZX0ZPUk1BVCA9IHtcbiAgICBhbWQ6IGRlY29uZmxpY3RJbXBvcnRzT3RoZXIsXG4gICAgY2pzOiBkZWNvbmZsaWN0SW1wb3J0c090aGVyLFxuICAgIGVzOiBkZWNvbmZsaWN0SW1wb3J0c0VzbU9yU3lzdGVtLFxuICAgIGlpZmU6IGRlY29uZmxpY3RJbXBvcnRzT3RoZXIsXG4gICAgc3lzdGVtOiBkZWNvbmZsaWN0SW1wb3J0c0VzbU9yU3lzdGVtLFxuICAgIHVtZDogZGVjb25mbGljdEltcG9ydHNPdGhlclxufTtcbmZ1bmN0aW9uIGRlY29uZmxpY3RDaHVuayhtb2R1bGVzLCBkZXBlbmRlbmNpZXNUb0JlRGVjb25mbGljdGVkLCBpbXBvcnRzLCB1c2VkTmFtZXMsIGZvcm1hdCwgaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBleHRlcm5hbExpdmVCaW5kaW5ncywgY2h1bmtCeU1vZHVsZSwgc3ludGhldGljRXhwb3J0cywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBpbmNsdWRlZE5hbWVzcGFjZXMpIHtcbiAgICBjb25zdCByZXZlcnNlZE1vZHVsZXMgPSBtb2R1bGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHJldmVyc2VkTW9kdWxlcykge1xuICAgICAgICBtb2R1bGUuc2NvcGUuYWRkVXNlZE91dHNpZGVOYW1lcyh1c2VkTmFtZXMsIGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICB9XG4gICAgZGVjb25mbGljdFRvcExldmVsVmFyaWFibGVzKHVzZWROYW1lcywgcmV2ZXJzZWRNb2R1bGVzLCBpbmNsdWRlZE5hbWVzcGFjZXMpO1xuICAgIERFQ09ORkxJQ1RfSU1QT1JURURfVkFSSUFCTEVTX0JZX0ZPUk1BVFtmb3JtYXRdKHVzZWROYW1lcywgaW1wb3J0cywgZGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZCwgaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBleHRlcm5hbExpdmVCaW5kaW5ncywgY2h1bmtCeU1vZHVsZSwgc3ludGhldGljRXhwb3J0cyk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgcmV2ZXJzZWRNb2R1bGVzKSB7XG4gICAgICAgIG1vZHVsZS5zY29wZS5kZWNvbmZsaWN0KGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvbmZsaWN0SW1wb3J0c0VzbU9yU3lzdGVtKHVzZWROYW1lcywgaW1wb3J0cywgZGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZCwgX2ludGVyb3AsIHByZXNlcnZlTW9kdWxlcywgX2V4dGVybmFsTGl2ZUJpbmRpbmdzLCBjaHVua0J5TW9kdWxlLCBzeW50aGV0aWNFeHBvcnRzKSB7XG4gICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZSByZWV4cG9ydHNcbiAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlTW9kdWxlcyB8fCBkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY3kudmFyaWFibGVOYW1lID0gZ2V0U2FmZU5hbWUoZGVwZW5kZW5jeS5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUsIHVzZWROYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBpbXBvcnRzKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgIGlmICh2YXJpYWJsZS5pc05hbWVzcGFjZSAmJiAocHJlc2VydmVNb2R1bGVzIHx8IG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSkge1xuICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgKG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlID8gbW9kdWxlIDogY2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKSkudmFyaWFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSAmJiBuYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGdldFNhZmVOYW1lKFsuLi5tb2R1bGUuZXhwb3J0ZWRWYXJpYWJsZXNdLnNvbWUoKFtleHBvcnRlZFZhcmlhYmxlLCBleHBvcnRlZE5hbWVdKSA9PiBleHBvcnRlZE5hbWUgPT09ICcqJyAmJiBleHBvcnRlZFZhcmlhYmxlLmluY2x1ZGVkKVxuICAgICAgICAgICAgICAgID8gbW9kdWxlLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZSArICdfX2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgOiBtb2R1bGUuc3VnZ2VzdGVkVmFyaWFibGVOYW1lLCB1c2VkTmFtZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGdldFNhZmVOYW1lKG5hbWUsIHVzZWROYW1lcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2Ygc3ludGhldGljRXhwb3J0cykge1xuICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBnZXRTYWZlTmFtZSh2YXJpYWJsZS5uYW1lLCB1c2VkTmFtZXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvbmZsaWN0SW1wb3J0c090aGVyKHVzZWROYW1lcywgaW1wb3J0cywgeyBkZWNvbmZsaWN0ZWREZWZhdWx0LCBkZWNvbmZsaWN0ZWROYW1lc3BhY2UsIGRlcGVuZGVuY2llcyB9LCBpbnRlcm9wLCBwcmVzZXJ2ZU1vZHVsZXMsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBjaHVua0J5TW9kdWxlKSB7XG4gICAgZm9yIChjb25zdCBjaHVua09yRXh0ZXJuYWxNb2R1bGUgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGNodW5rT3JFeHRlcm5hbE1vZHVsZS52YXJpYWJsZU5hbWUgPSBnZXRTYWZlTmFtZShjaHVua09yRXh0ZXJuYWxNb2R1bGUuc3VnZ2VzdGVkVmFyaWFibGVOYW1lLCB1c2VkTmFtZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dGVybmFsTW9kdWxlT3JDaHVuayBvZiBkZWNvbmZsaWN0ZWROYW1lc3BhY2UpIHtcbiAgICAgICAgZXh0ZXJuYWxNb2R1bGVPckNodW5rLm5hbWVzcGFjZVZhcmlhYmxlTmFtZSA9IGdldFNhZmVOYW1lKGAke2V4dGVybmFsTW9kdWxlT3JDaHVuay5zdWdnZXN0ZWRWYXJpYWJsZU5hbWV9X19uYW1lc3BhY2VgLCB1c2VkTmFtZXMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dGVybmFsTW9kdWxlIG9mIGRlY29uZmxpY3RlZERlZmF1bHQpIHtcbiAgICAgICAgaWYgKGRlY29uZmxpY3RlZE5hbWVzcGFjZS5oYXMoZXh0ZXJuYWxNb2R1bGUpICYmXG4gICAgICAgICAgICBjYW5EZWZhdWx0QmVUYWtlbkZyb21OYW1lc3BhY2UoU3RyaW5nKGludGVyb3AoZXh0ZXJuYWxNb2R1bGUuaWQpKSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MpKSB7XG4gICAgICAgICAgICBleHRlcm5hbE1vZHVsZS5kZWZhdWx0VmFyaWFibGVOYW1lID0gZXh0ZXJuYWxNb2R1bGUubmFtZXNwYWNlVmFyaWFibGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0ZXJuYWxNb2R1bGUuZGVmYXVsdFZhcmlhYmxlTmFtZSA9IGdldFNhZmVOYW1lKGAke2V4dGVybmFsTW9kdWxlLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZX1fX2RlZmF1bHRgLCB1c2VkTmFtZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgaW1wb3J0cykge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlSW50ZXJvcCA9IFN0cmluZyhpbnRlcm9wKG1vZHVsZS5pZCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGRlZmF1bHRJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbbW9kdWxlSW50ZXJvcF1cbiAgICAgICAgICAgICAgICAgICAgPyBtb2R1bGUuZGVmYXVsdFZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IG1vZHVsZS52YXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmYXVsdEFQcm9wZXJ0eShtb2R1bGVJbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXModmFyaWFibGVOYW1lLCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgdmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBuYW1lc3BhY2VJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbU3RyaW5nKGludGVyb3AobW9kdWxlLmlkKSldXG4gICAgICAgICAgICAgICAgICAgID8gbW9kdWxlLm5hbWVzcGFjZVZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IG1vZHVsZS52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYG51bGxgLCBpdCB1c2VzIGl0cyBcIm5hbWVcIiBmb3IgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhtb2R1bGUudmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKTtcbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZU1vZHVsZXMgJiYgdmFyaWFibGUuaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBjaHVuay5leHBvcnRNb2RlID09PSAnZGVmYXVsdCcgPyBjaHVuay5uYW1lc3BhY2VWYXJpYWJsZU5hbWUgOiBjaHVuay52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsuZXhwb3J0TW9kZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgY2h1bmsudmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKGNodW5rLnZhcmlhYmxlTmFtZSwgY2h1bmsuZ2V0VmFyaWFibGVFeHBvcnROYW1lKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvbmZsaWN0VG9wTGV2ZWxWYXJpYWJsZXModXNlZE5hbWVzLCBtb2R1bGVzLCBpbmNsdWRlZE5hbWVzcGFjZXMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgbW9kdWxlLnNjb3BlLnZhcmlhYmxlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmluY2x1ZGVkICYmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG9ubHkgaGFwcGVuIGZvciBleHBvcnRzIGluIHNvbWUgZm9ybWF0c1xuICAgICAgICAgICAgICAgICEodmFyaWFibGUucmVuZGVyQmFzZU5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKHZhcmlhYmxlIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdFZhcmlhYmxlICYmIHZhcmlhYmxlLmdldE9yaWdpbmFsVmFyaWFibGUoKSAhPT0gdmFyaWFibGUpKSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGdldFNhZmVOYW1lKHZhcmlhYmxlLm5hbWUsIHVzZWROYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG1vZHVsZS5uYW1lc3BhY2U7XG4gICAgICAgICAgICBuYW1lc3BhY2Uuc2V0UmVuZGVyTmFtZXMobnVsbCwgZ2V0U2FmZU5hbWUobmFtZXNwYWNlLm5hbWUsIHVzZWROYW1lcykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBuZWVkc0VzY2FwZVJlZ0V4ID0gL1tcXFxcJ1xcclxcblxcdTIwMjhcXHUyMDI5XS87XG5jb25zdCBxdW90ZU5ld2xpbmVSZWdFeCA9IC8oWydcXHJcXG5cXHUyMDI4XFx1MjAyOV0pL2c7XG5jb25zdCBiYWNrU2xhc2hSZWdFeCA9IC9cXFxcL2c7XG5mdW5jdGlvbiBlc2NhcGVJZChpZCkge1xuICAgIGlmICghaWQubWF0Y2gobmVlZHNFc2NhcGVSZWdFeCkpXG4gICAgICAgIHJldHVybiBpZDtcbiAgICByZXR1cm4gaWQucmVwbGFjZShiYWNrU2xhc2hSZWdFeCwgJ1xcXFxcXFxcJykucmVwbGFjZShxdW90ZU5ld2xpbmVSZWdFeCwgJ1xcXFwkMScpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25FeHBvcnRzVG9NYW5nbGVkTmFtZXMoZXhwb3J0cywgZXhwb3J0c0J5TmFtZSwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgbGV0IG5hbWVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBleHBvcnRzKSB7XG4gICAgICAgIGxldCBbZXhwb3J0TmFtZV0gPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgICBpZiAoZXhwb3J0c0J5TmFtZS5oYXMoZXhwb3J0TmFtZSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gdG9CYXNlNjQoKytuYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgcGFzdCBsZWFkaW5nIG51bWJlciBpZGVudGlmaWVyc1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnROYW1lLmNoYXJDb2RlQXQoMCkgPT09IDQ5IC8qICcxJyAqLykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lSW5kZXggKz0gOSAqIDY0ICoqIChleHBvcnROYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gdG9CYXNlNjQobmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChSRVNFUlZFRF9OQU1FUyQxLmhhcyhleHBvcnROYW1lKSB8fCBleHBvcnRzQnlOYW1lLmhhcyhleHBvcnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0c0J5TmFtZS5zZXQoZXhwb3J0TmFtZSwgdmFyaWFibGUpO1xuICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV4cG9ydHNUb05hbWVzKGV4cG9ydHMsIGV4cG9ydHNCeU5hbWUsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgZXhwb3J0cykge1xuICAgICAgICBsZXQgbmFtZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IGV4cG9ydE5hbWUgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgICB3aGlsZSAoZXhwb3J0c0J5TmFtZS5oYXMoZXhwb3J0TmFtZSkpIHtcbiAgICAgICAgICAgIGV4cG9ydE5hbWUgPSB2YXJpYWJsZS5uYW1lICsgJyQnICsgKytuYW1lSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0c0J5TmFtZS5zZXQoZXhwb3J0TmFtZSwgdmFyaWFibGUpO1xuICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXhwb3J0TW9kZShjaHVuaywgeyBleHBvcnRzOiBleHBvcnRNb2RlLCBuYW1lLCBmb3JtYXQgfSwgdW5zZXRPcHRpb25zLCBmYWNhZGVNb2R1bGVJZCwgd2Fybikge1xuICAgIGNvbnN0IGV4cG9ydEtleXMgPSBjaHVuay5nZXRFeHBvcnROYW1lcygpO1xuICAgIGlmIChleHBvcnRNb2RlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgaWYgKGV4cG9ydEtleXMubGVuZ3RoICE9PSAxIHx8IGV4cG9ydEtleXNbMF0gIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckluY29tcGF0aWJsZUV4cG9ydE9wdGlvblZhbHVlKCdkZWZhdWx0JywgZXhwb3J0S2V5cywgZmFjYWRlTW9kdWxlSWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRNb2RlID09PSAnbm9uZScgJiYgZXhwb3J0S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckluY29tcGF0aWJsZUV4cG9ydE9wdGlvblZhbHVlKCdub25lJywgZXhwb3J0S2V5cywgZmFjYWRlTW9kdWxlSWQpKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydE1vZGUgPT09ICdhdXRvJykge1xuICAgICAgICBpZiAoZXhwb3J0S2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGV4cG9ydE1vZGUgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwb3J0S2V5cy5sZW5ndGggPT09IDEgJiYgZXhwb3J0S2V5c1swXSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnY2pzJyAmJiB1bnNldE9wdGlvbnMuaGFzKCdleHBvcnRzJykpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGVyclByZWZlck5hbWVkRXhwb3J0cyhmYWNhZGVNb2R1bGVJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0TW9kZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdlcycgJiYgZm9ybWF0ICE9PSAnc3lzdGVtJyAmJiBleHBvcnRLZXlzLmluY2x1ZGVzKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGVyck1peGVkRXhwb3J0KGZhY2FkZU1vZHVsZUlkLCBuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRNb2RlID0gJ25hbWVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0TW9kZTtcbn1cblxuZnVuY3Rpb24gZ3Vlc3NJbmRlbnRTdHJpbmcoY29kZSkge1xuICAgIGNvbnN0IGxpbmVzID0gY29kZS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgdGFiYmVkID0gbGluZXMuZmlsdGVyKGxpbmUgPT4gL15cXHQrLy50ZXN0KGxpbmUpKTtcbiAgICBjb25zdCBzcGFjZWQgPSBsaW5lcy5maWx0ZXIobGluZSA9PiAvXiB7Mix9Ly50ZXN0KGxpbmUpKTtcbiAgICBpZiAodGFiYmVkLmxlbmd0aCA9PT0gMCAmJiBzcGFjZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNb3JlIGxpbmVzIHRhYmJlZCB0aGFuIHNwYWNlZD8gQXNzdW1lIHRhYnMsIGFuZFxuICAgIC8vIGRlZmF1bHQgdG8gdGFicyBpbiB0aGUgY2FzZSBvZiBhIHRpZSAob3Igbm90aGluZ1xuICAgIC8vIHRvIGdvIG9uKVxuICAgIGlmICh0YWJiZWQubGVuZ3RoID49IHNwYWNlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICdcXHQnO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gZ3Vlc3MgdGhlIG11bHRpcGxlXG4gICAgY29uc3QgbWluID0gc3BhY2VkLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbnVtU3BhY2VzID0gL14gKy8uZXhlYyhjdXJyZW50KVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihudW1TcGFjZXMsIHByZXZpb3VzKTtcbiAgICB9LCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIG5ldyBBcnJheShtaW4gKyAxKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBnZXRJbmRlbnRTdHJpbmcobW9kdWxlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmluZGVudCAhPT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW5kZW50O1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gZ3Vlc3NJbmRlbnRTdHJpbmcobW9kdWxlLm9yaWdpbmFsQ29kZSk7XG4gICAgICAgIGlmIChpbmRlbnQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gaW5kZW50O1xuICAgIH1cbiAgICByZXR1cm4gJ1xcdCc7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRpY0RlcGVuZGVuY2llcyhjaHVuaywgb3JkZXJlZE1vZHVsZXMsIGNodW5rQnlNb2R1bGUpIHtcbiAgICBjb25zdCBzdGF0aWNEZXBlbmRlbmN5QmxvY2tzID0gW107XG4gICAgY29uc3QgaGFuZGxlZERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBtb2R1bGVQb3MgPSBvcmRlcmVkTW9kdWxlcy5sZW5ndGggLSAxOyBtb2R1bGVQb3MgPj0gMDsgbW9kdWxlUG9zLS0pIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gb3JkZXJlZE1vZHVsZXNbbW9kdWxlUG9zXTtcbiAgICAgICAgaWYgKCFoYW5kbGVkRGVwZW5kZW5jaWVzLmhhcyhtb2R1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNEZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICAgIGFkZFN0YXRpY0RlcGVuZGVuY2llcyhtb2R1bGUsIHN0YXRpY0RlcGVuZGVuY2llcywgaGFuZGxlZERlcGVuZGVuY2llcywgY2h1bmssIGNodW5rQnlNb2R1bGUpO1xuICAgICAgICAgICAgc3RhdGljRGVwZW5kZW5jeUJsb2Nrcy51bnNoaWZ0KHN0YXRpY0RlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2Ygc3RhdGljRGVwZW5kZW5jeUJsb2Nrcykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgYmxvY2spIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn1cbmZ1bmN0aW9uIGFkZFN0YXRpY0RlcGVuZGVuY2llcyhtb2R1bGUsIHN0YXRpY0RlcGVuZGVuY2llcywgaGFuZGxlZE1vZHVsZXMsIGNodW5rLCBjaHVua0J5TW9kdWxlKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbW9kdWxlLmdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpO1xuICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgc3RhdGljRGVwZW5kZW5jaWVzLnB1c2goZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXBlbmRlbmN5Q2h1bmsgPSBjaHVua0J5TW9kdWxlLmdldChkZXBlbmRlbmN5KTtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3lDaHVuayAhPT0gY2h1bmspIHtcbiAgICAgICAgICAgIHN0YXRpY0RlcGVuZGVuY2llcy5wdXNoKGRlcGVuZGVuY3lDaHVuayk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZWRNb2R1bGVzLmhhcyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgaGFuZGxlZE1vZHVsZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgYWRkU3RhdGljRGVwZW5kZW5jaWVzKGRlcGVuZGVuY3ksIHN0YXRpY0RlcGVuZGVuY2llcywgaGFuZGxlZE1vZHVsZXMsIGNodW5rLCBjaHVua0J5TW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlZFNvdXJjZW1hcChtYXApIHtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcCA9IEpTT04ucGFyc2UobWFwKTtcbiAgICB9XG4gICAgaWYgKG1hcC5tYXBwaW5ncyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiBbXSxcbiAgICAgICAgICAgIG5hbWVzOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgICAgICAgdmVyc2lvbjogM1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBtYXBwaW5ncyA9IHR5cGVvZiBtYXAubWFwcGluZ3MgPT09ICdzdHJpbmcnID8gZGVjb2RlKG1hcC5tYXBwaW5ncykgOiBtYXAubWFwcGluZ3M7XG4gICAgcmV0dXJuIHsgLi4ubWFwLCBtYXBwaW5ncyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJDaHVuayh7IGNvZGUsIG9wdGlvbnMsIG91dHB1dFBsdWdpbkRyaXZlciwgcmVuZGVyQ2h1bmssIHNvdXJjZW1hcENoYWluIH0pIHtcbiAgICBjb25zdCByZW5kZXJDaHVua1JlZHVjZXIgPSAoY29kZSwgcmVzdWx0LCBwbHVnaW4pID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgbWFwOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIHN0cmljdCBudWxsIGNoZWNrIGFsbG93cyAnbnVsbCcgbWFwcyB0byBub3QgYmUgcHVzaGVkIHRvIHRoZSBjaGFpbiwgd2hpbGUgJ3VuZGVmaW5lZCcgZ2V0cyB0aGUgbWlzc2luZyBtYXAgd2FybmluZ1xuICAgICAgICBpZiAocmVzdWx0Lm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gZGVjb2RlZFNvdXJjZW1hcChyZXN1bHQubWFwKTtcbiAgICAgICAgICAgIHNvdXJjZW1hcENoYWluLnB1c2gobWFwIHx8IHsgbWlzc2luZzogdHJ1ZSwgcGx1Z2luOiBwbHVnaW4ubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvZGU7XG4gICAgfTtcbiAgICByZXR1cm4gb3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tSZWR1Y2VBcmcwKCdyZW5kZXJDaHVuaycsIFtjb2RlLCByZW5kZXJDaHVuaywgb3B0aW9uc10sIHJlbmRlckNodW5rUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5hbWVQYXR0ZXJuKHBhdHRlcm4sIHBhdHRlcm5OYW1lLCByZXBsYWNlbWVudHMpIHtcbiAgICBpZiAoaXNQYXRoRnJhZ21lbnQocGF0dGVybikpXG4gICAgICAgIHJldHVybiBlcnJvcihlcnJGYWlsZWRWYWxpZGF0aW9uKGBJbnZhbGlkIHBhdHRlcm4gXCIke3BhdHRlcm59XCIgZm9yIFwiJHtwYXR0ZXJuTmFtZX1cIiwgcGF0dGVybnMgY2FuIGJlIG5laXRoZXIgYWJzb2x1dGUgbm9yIHJlbGF0aXZlIHBhdGhzLmApKTtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgKF9tYXRjaCwgdHlwZSkgPT4ge1xuICAgICAgICBpZiAoIXJlcGxhY2VtZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckZhaWxlZFZhbGlkYXRpb24oYFwiWyR7dHlwZX1dXCIgaXMgbm90IGEgdmFsaWQgcGxhY2Vob2xkZXIgaW4gXCIke3BhdHRlcm5OYW1lfVwiIHBhdHRlcm4uYCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnRzW3R5cGVdKCk7XG4gICAgICAgIGlmIChpc1BhdGhGcmFnbWVudChyZXBsYWNlbWVudCkpXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJyRmFpbGVkVmFsaWRhdGlvbihgSW52YWxpZCBzdWJzdGl0dXRpb24gXCIke3JlcGxhY2VtZW50fVwiIGZvciBwbGFjZWhvbGRlciBcIlske3R5cGV9XVwiIGluIFwiJHtwYXR0ZXJuTmFtZX1cIiBwYXR0ZXJuLCBjYW4gYmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aC5gKSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VVbmlxdWUobmFtZSwgZXhpc3RpbmdOYW1lcykge1xuICAgIGNvbnN0IGV4aXN0aW5nTmFtZXNMb3dlcmNhc2UgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGV4aXN0aW5nTmFtZXMpLm1hcChrZXkgPT4ga2V5LnRvTG93ZXJDYXNlKCkpKTtcbiAgICBpZiAoIWV4aXN0aW5nTmFtZXNMb3dlcmNhc2UuaGFzKG5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSkpXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IGV4dCA9IGV4dG5hbWUobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gICAgbGV0IHVuaXF1ZU5hbWUsIHVuaXF1ZUluZGV4ID0gMTtcbiAgICB3aGlsZSAoZXhpc3RpbmdOYW1lc0xvd2VyY2FzZS5oYXMoKHVuaXF1ZU5hbWUgPSBuYW1lICsgKyt1bmlxdWVJbmRleCArIGV4dCkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIDtcbiAgICByZXR1cm4gdW5pcXVlTmFtZTtcbn1cblxuY29uc3QgTk9OX0FTU0VUX0VYVEVOU0lPTlMgPSBbJy5qcycsICcuanN4JywgJy50cycsICcudHN4J107XG5mdW5jdGlvbiBnZXRHbG9iYWxOYW1lKG1vZHVsZSwgZ2xvYmFscywgaGFzRXhwb3J0cywgd2Fybikge1xuICAgIGNvbnN0IGdsb2JhbE5hbWUgPSB0eXBlb2YgZ2xvYmFscyA9PT0gJ2Z1bmN0aW9uJyA/IGdsb2JhbHMobW9kdWxlLmlkKSA6IGdsb2JhbHNbbW9kdWxlLmlkXTtcbiAgICBpZiAoZ2xvYmFsTmFtZSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsTmFtZTtcbiAgICB9XG4gICAgaWYgKGhhc0V4cG9ydHMpIHtcbiAgICAgICAgd2Fybih7XG4gICAgICAgICAgICBjb2RlOiAnTUlTU0lOR19HTE9CQUxfTkFNRScsXG4gICAgICAgICAgICBndWVzczogbW9kdWxlLnZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBuYW1lIHdhcyBwcm92aWRlZCBmb3IgZXh0ZXJuYWwgbW9kdWxlICcke21vZHVsZS5pZH0nIGluIG91dHB1dC5nbG9iYWxzIFx1MjAxMyBndWVzc2luZyAnJHttb2R1bGUudmFyaWFibGVOYW1lfSdgLFxuICAgICAgICAgICAgc291cmNlOiBtb2R1bGUuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2R1bGUudmFyaWFibGVOYW1lO1xuICAgIH1cbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkTW9kdWxlcywgaW5wdXRPcHRpb25zLCBvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgbW9kdWxlc0J5SWQsIGNodW5rQnlNb2R1bGUsIGZhY2FkZUNodW5rQnlNb2R1bGUsIGluY2x1ZGVkTmFtZXNwYWNlcywgbWFudWFsQ2h1bmtBbGlhcykge1xuICAgICAgICB0aGlzLm9yZGVyZWRNb2R1bGVzID0gb3JkZXJlZE1vZHVsZXM7XG4gICAgICAgIHRoaXMuaW5wdXRPcHRpb25zID0gaW5wdXRPcHRpb25zO1xuICAgICAgICB0aGlzLm91dHB1dE9wdGlvbnMgPSBvdXRwdXRPcHRpb25zO1xuICAgICAgICB0aGlzLnVuc2V0T3B0aW9ucyA9IHVuc2V0T3B0aW9ucztcbiAgICAgICAgdGhpcy5wbHVnaW5Ecml2ZXIgPSBwbHVnaW5Ecml2ZXI7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWQgPSBtb2R1bGVzQnlJZDtcbiAgICAgICAgdGhpcy5jaHVua0J5TW9kdWxlID0gY2h1bmtCeU1vZHVsZTtcbiAgICAgICAgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlID0gZmFjYWRlQ2h1bmtCeU1vZHVsZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMgPSBpbmNsdWRlZE5hbWVzcGFjZXM7XG4gICAgICAgIHRoaXMubWFudWFsQ2h1bmtBbGlhcyA9IG1hbnVhbENodW5rQWxpYXM7XG4gICAgICAgIHRoaXMuZW50cnlNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0TW9kZSA9ICduYW1lZCc7XG4gICAgICAgIHRoaXMuZmFjYWRlTW9kdWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlVmFyaWFibGVOYW1lID0gJyc7XG4gICAgICAgIHRoaXMubmVlZHNFeHBvcnRzU2hpbSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZSA9ICcnO1xuICAgICAgICB0aGlzLmFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZHluYW1pY0VudHJ5TW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZXhwb3J0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnRzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbmRlbnRTdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoaXMgbWF5IG9ubHkgYmUgdXBkYXRlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWRFeHBvcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEhhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVuZGVyZWRNb2R1bGVTb3VyY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkTW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLnNvcnRlZEV4cG9ydE5hbWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdHJpY3RGYWNhZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkTW9kdWxlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5leGVjSW5kZXggPSBvcmRlcmVkTW9kdWxlcy5sZW5ndGggPiAwID8gb3JkZXJlZE1vZHVsZXNbMF0uZXhlY0luZGV4IDogSW5maW5pdHk7XG4gICAgICAgIGNvbnN0IGNodW5rTW9kdWxlcyA9IG5ldyBTZXQob3JkZXJlZE1vZHVsZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBvcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5uYW1lc3BhY2UuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlZE5hbWVzcGFjZXMuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtcHR5ICYmIG1vZHVsZS5pc0luY2x1ZGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5pc0VudHJ5IHx8IG91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyeU1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpbXBvcnRlciBvZiBtb2R1bGUuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaHVua01vZHVsZXMuaGFzKGltcG9ydGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb2R1bGVzIHdpdGggc3ludGhldGljIGV4cG9ydHMgbmVlZCBhbiBhcnRpZmljaWFsIG5hbWVzcGFjZSBmb3IgZHluYW1pYyBpbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMgJiYgIW91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZE5hbWVzcGFjZXMuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydHMuYWRkKG1vZHVsZS5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZSA9IG1ha2VMZWdhbCh0aGlzLmdlbmVyYXRlVmFyaWFibGVOYW1lKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVGYWNhZGUoaW5wdXRPcHRpb25zLCBvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgbW9kdWxlc0J5SWQsIGNodW5rQnlNb2R1bGUsIGZhY2FkZUNodW5rQnlNb2R1bGUsIGluY2x1ZGVkTmFtZXNwYWNlcywgZmFjYWRlZE1vZHVsZSwgZmFjYWRlTmFtZSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBDaHVuayhbXSwgaW5wdXRPcHRpb25zLCBvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgbW9kdWxlc0J5SWQsIGNodW5rQnlNb2R1bGUsIGZhY2FkZUNodW5rQnlNb2R1bGUsIGluY2x1ZGVkTmFtZXNwYWNlcywgbnVsbCk7XG4gICAgICAgIGNodW5rLmFzc2lnbkZhY2FkZU5hbWUoZmFjYWRlTmFtZSwgZmFjYWRlZE1vZHVsZSk7XG4gICAgICAgIGlmICghZmFjYWRlQ2h1bmtCeU1vZHVsZS5oYXMoZmFjYWRlZE1vZHVsZSkpIHtcbiAgICAgICAgICAgIGZhY2FkZUNodW5rQnlNb2R1bGUuc2V0KGZhY2FkZWRNb2R1bGUsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZmFjYWRlZE1vZHVsZS5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKSkge1xuICAgICAgICAgICAgY2h1bmsuZGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5IGluc3RhbmNlb2YgTW9kdWxlID8gY2h1bmtCeU1vZHVsZS5nZXQoZGVwZW5kZW5jeSkgOiBkZXBlbmRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNodW5rLmRlcGVuZGVuY2llcy5oYXMoY2h1bmtCeU1vZHVsZS5nZXQoZmFjYWRlZE1vZHVsZSkpICYmXG4gICAgICAgICAgICBmYWNhZGVkTW9kdWxlLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIGZhY2FkZWRNb2R1bGUuaGFzRWZmZWN0cygpKSB7XG4gICAgICAgICAgICBjaHVuay5kZXBlbmRlbmNpZXMuYWRkKGNodW5rQnlNb2R1bGUuZ2V0KGZhY2FkZWRNb2R1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjaHVuay5lbnN1cmVSZWV4cG9ydHNBcmVBdmFpbGFibGVGb3JNb2R1bGUoZmFjYWRlZE1vZHVsZSk7XG4gICAgICAgIGNodW5rLmZhY2FkZU1vZHVsZSA9IGZhY2FkZWRNb2R1bGU7XG4gICAgICAgIGNodW5rLnN0cmljdEZhY2FkZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgY2FuTW9kdWxlQmVGYWNhZGUobW9kdWxlLCBleHBvc2VkVmFyaWFibGVzKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZUV4cG9ydE5hbWVzQnlWYXJpYWJsZSA9IG1vZHVsZS5nZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKTtcbiAgICAgICAgZm9yIChjb25zdCBleHBvc2VkVmFyaWFibGUgb2YgdGhpcy5leHBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZUV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXMoZXhwb3NlZFZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnROYW1lc0J5VmFyaWFibGUuc2l6ZSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLnByZXNlcnZlU2lnbmF0dXJlID09PSAnc3RyaWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc2V0T3B0aW9ucy5oYXMoJ3ByZXNlcnZlRW50cnlTaWduYXR1cmVzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMub253YXJuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICdFTVBUWV9GQUNBREUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUbyBwcmVzZXJ2ZSB0aGUgZXhwb3J0IHNpZ25hdHVyZSBvZiB0aGUgZW50cnkgbW9kdWxlIFwiJHtyZWxhdGl2ZUlkKG1vZHVsZS5pZCl9XCIsIGFuIGVtcHR5IGZhY2FkZSBjaHVuayB3YXMgY3JlYXRlZC4gVGhpcyBvZnRlbiBoYXBwZW5zIHdoZW4gY3JlYXRpbmcgYSBidW5kbGUgZm9yIGEgd2ViIGFwcCB3aGVyZSBjaHVua3MgYXJlIHBsYWNlZCBpbiBzY3JpcHQgdGFncyBhbmQgZXhwb3J0cyBhcmUgaWdub3JlZC4gSW4gdGhpcyBjYXNlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBcInByZXNlcnZlRW50cnlTaWduYXR1cmVzOiBmYWxzZVwiIHRvIGF2b2lkIHRoaXMgYW5kIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGNodW5rcy4gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgaW50ZW50aW9uYWwsIHNldCBcInByZXNlcnZlRW50cnlTaWduYXR1cmVzOiAnc3RyaWN0J1wiIGV4cGxpY2l0bHkgdG8gc2lsZW5jZSB0aGlzIHdhcm5pbmcuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyNwcmVzZXJ2ZWVudHJ5c2lnbmF0dXJlcydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV4cG9zZWRWYXJpYWJsZSBvZiBleHBvc2VkVmFyaWFibGVzKSB7XG4gICAgICAgICAgICBpZiAoIShtb2R1bGVFeHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKGV4cG9zZWRWYXJpYWJsZSkgfHwgZXhwb3NlZFZhcmlhYmxlLm1vZHVsZSA9PT0gbW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGVFeHBvcnRzKCkge1xuICAgICAgICB0aGlzLnNvcnRlZEV4cG9ydE5hbWVzID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nRXhwb3J0cyA9IG5ldyBTZXQodGhpcy5leHBvcnRzKTtcbiAgICAgICAgaWYgKHRoaXMuZmFjYWRlTW9kdWxlICE9PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5mYWNhZGVNb2R1bGUucHJlc2VydmVTaWduYXR1cmUgIT09IGZhbHNlIHx8IHRoaXMuc3RyaWN0RmFjYWRlKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0TmFtZXNCeVZhcmlhYmxlID0gdGhpcy5mYWNhZGVNb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFt2YXJpYWJsZSwgZXhwb3J0TmFtZXNdIG9mIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLnNldCh2YXJpYWJsZSwgWy4uLmV4cG9ydE5hbWVzXSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIGV4cG9ydE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0c0J5TmFtZS5zZXQoZXhwb3J0TmFtZSwgdmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1haW5pbmdFeHBvcnRzLmRlbGV0ZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0T3B0aW9ucy5taW5pZnlJbnRlcm5hbEV4cG9ydHMpIHtcbiAgICAgICAgICAgIGFzc2lnbkV4cG9ydHNUb01hbmdsZWROYW1lcyhyZW1haW5pbmdFeHBvcnRzLCB0aGlzLmV4cG9ydHNCeU5hbWUsIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbkV4cG9ydHNUb05hbWVzKHJlbWFpbmluZ0V4cG9ydHMsIHRoaXMuZXhwb3J0c0J5TmFtZSwgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzIHx8ICh0aGlzLmZhY2FkZU1vZHVsZSAmJiB0aGlzLmZhY2FkZU1vZHVsZS5pbmZvLmlzRW50cnkpKVxuICAgICAgICAgICAgdGhpcy5leHBvcnRNb2RlID0gZ2V0RXhwb3J0TW9kZSh0aGlzLCB0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMudW5zZXRPcHRpb25zLCB0aGlzLmZhY2FkZU1vZHVsZS5pZCwgdGhpcy5pbnB1dE9wdGlvbnMub253YXJuKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGYWNhZGVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZhY2FkZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZW50cnlNb2R1bGVzID0gbmV3IFNldChbLi4udGhpcy5lbnRyeU1vZHVsZXMsIC4uLnRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXNdKTtcbiAgICAgICAgY29uc3QgZXhwb3NlZFZhcmlhYmxlcyA9IG5ldyBTZXQodGhpcy5keW5hbWljRW50cnlNb2R1bGVzLm1hcCgoeyBuYW1lc3BhY2UgfSkgPT4gbmFtZXNwYWNlKSk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIGVudHJ5TW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhwb3J0ZWRWYXJpYWJsZSBvZiBtb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCkua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRWYXJpYWJsZXMuYWRkKGV4cG9ydGVkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBlbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkRmFjYWRlcyA9IEFycmF5LmZyb20obmV3IFNldChtb2R1bGUuY2h1bmtOYW1lcy5maWx0ZXIoKHsgaXNVc2VyRGVmaW5lZCB9KSA9PiBpc1VzZXJEZWZpbmVkKS5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSksIFxuICAgICAgICAgICAgLy8gbWFwcGluZyBtdXN0IHJ1biBhZnRlciBTZXQgJ25hbWUnIGRlZHVwZVxuICAgICAgICAgICAgbmFtZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEZhY2FkZXMubGVuZ3RoID09PSAwICYmIG1vZHVsZS5pc1VzZXJEZWZpbmVkRW50cnlQb2ludCkge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkRmFjYWRlcy5wdXNoKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVpcmVkRmFjYWRlcy5wdXNoKC4uLkFycmF5LmZyb20obW9kdWxlLmNodW5rRmlsZU5hbWVzLCBmaWxlTmFtZSA9PiAoeyBmaWxlTmFtZSB9KSkpO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkRmFjYWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEZhY2FkZXMucHVzaCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmFjYWRlTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVlZHNTdHJpY3RGYWNhZGUgPSBtb2R1bGUucHJlc2VydmVTaWduYXR1cmUgPT09ICdzdHJpY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgIChtb2R1bGUucHJlc2VydmVTaWduYXR1cmUgPT09ICdleHBvcnRzLW9ubHknICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCkuc2l6ZSAhPT0gMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc1N0cmljdEZhY2FkZSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuTW9kdWxlQmVGYWNhZGUobW9kdWxlLCBleHBvc2VkVmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2FkZU1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLnNldChtb2R1bGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLnByZXNlcnZlU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IG5lZWRzU3RyaWN0RmFjYWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduRmFjYWRlTmFtZShyZXF1aXJlZEZhY2FkZXMuc2hpZnQoKSwgbW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZhY2FkZU5hbWUgb2YgcmVxdWlyZWRGYWNhZGVzKSB7XG4gICAgICAgICAgICAgICAgZmFjYWRlcy5wdXNoKENodW5rLmdlbmVyYXRlRmFjYWRlKHRoaXMuaW5wdXRPcHRpb25zLCB0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMudW5zZXRPcHRpb25zLCB0aGlzLnBsdWdpbkRyaXZlciwgdGhpcy5tb2R1bGVzQnlJZCwgdGhpcy5jaHVua0J5TW9kdWxlLCB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUsIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLCBtb2R1bGUsIGZhY2FkZU5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmFjYWRlTW9kdWxlICYmIHRoaXMuY2FuTW9kdWxlQmVGYWNhZGUobW9kdWxlLCBleHBvc2VkVmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjYWRlTW9kdWxlID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5zZXQobW9kdWxlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljTmFtZSA9IGdldENodW5rTmFtZUZyb21Nb2R1bGUobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZmFjYWRlTW9kdWxlID09PSBtb2R1bGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5zdHJpY3RGYWNhZGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNhbk1vZHVsZUJlRmFjYWRlKG1vZHVsZSwgZXhwb3NlZFZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKChfYSA9IHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0cmljdEZhY2FkZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5hZGQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydHMuYWRkKG1vZHVsZS5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNhZGVzO1xuICAgIH1cbiAgICBnZW5lcmF0ZUlkKGFkZG9ucywgb3B0aW9ucywgZXhpc3RpbmdOYW1lcywgaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtwYXR0ZXJuLCBwYXR0ZXJuTmFtZV0gPSB0aGlzLmZhY2FkZU1vZHVsZSAmJiB0aGlzLmZhY2FkZU1vZHVsZS5pc1VzZXJEZWZpbmVkRW50cnlQb2ludFxuICAgICAgICAgICAgPyBbb3B0aW9ucy5lbnRyeUZpbGVOYW1lcywgJ291dHB1dC5lbnRyeUZpbGVOYW1lcyddXG4gICAgICAgICAgICA6IFtvcHRpb25zLmNodW5rRmlsZU5hbWVzLCAnb3V0cHV0LmNodW5rRmlsZU5hbWVzJ107XG4gICAgICAgIHJldHVybiBtYWtlVW5pcXVlKHJlbmRlck5hbWVQYXR0ZXJuKHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nID8gcGF0dGVybih0aGlzLmdldENodW5rSW5mbygpKSA6IHBhdHRlcm4sIHBhdHRlcm5OYW1lLCB7XG4gICAgICAgICAgICBmb3JtYXQ6ICgpID0+IG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgaGFzaDogKCkgPT4gaW5jbHVkZUhhc2hcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29tcHV0ZUNvbnRlbnRIYXNoV2l0aERlcGVuZGVuY2llcyhhZGRvbnMsIG9wdGlvbnMsIGV4aXN0aW5nTmFtZXMpXG4gICAgICAgICAgICAgICAgOiAnW2hhc2hdJyxcbiAgICAgICAgICAgIG5hbWU6ICgpID0+IHRoaXMuZ2V0Q2h1bmtOYW1lKClcbiAgICAgICAgfSksIGV4aXN0aW5nTmFtZXMpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUlkUHJlc2VydmVNb2R1bGVzKHByZXNlcnZlTW9kdWxlc1JlbGF0aXZlRGlyLCBvcHRpb25zLCBleGlzdGluZ05hbWVzLCB1bnNldE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW3sgaWQgfV0gPSB0aGlzLm9yZGVyZWRNb2R1bGVzO1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRJZCA9IHRoaXMub3V0cHV0T3B0aW9ucy5zYW5pdGl6ZUZpbGVOYW1lKGlkLnNwbGl0KFFVRVJZX0hBU0hfUkVHRVgsIDEpWzBdKTtcbiAgICAgICAgbGV0IHBhdGg7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5PcHQgPSB1bnNldE9wdGlvbnMuaGFzKCdlbnRyeUZpbGVOYW1lcycpXG4gICAgICAgICAgICA/ICdbbmFtZV1bYXNzZXRFeHRuYW1lXS5qcydcbiAgICAgICAgICAgIDogb3B0aW9ucy5lbnRyeUZpbGVOYW1lcztcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuT3B0ID09PSAnZnVuY3Rpb24nID8gcGF0dGVybk9wdCh0aGlzLmdldENodW5rSW5mbygpKSA6IHBhdHRlcm5PcHQ7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKHNhbml0aXplZElkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERpciA9IGRpcm5hbWUoc2FuaXRpemVkSWQpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZXh0bmFtZShzYW5pdGl6ZWRJZCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHJlbmRlck5hbWVQYXR0ZXJuKHBhdHRlcm4sICdvdXRwdXQuZW50cnlGaWxlTmFtZXMnLCB7XG4gICAgICAgICAgICAgICAgYXNzZXRFeHRuYW1lOiAoKSA9PiAoTk9OX0FTU0VUX0VYVEVOU0lPTlMuaW5jbHVkZXMoZXh0ZW5zaW9uKSA/ICcnIDogZXh0ZW5zaW9uKSxcbiAgICAgICAgICAgICAgICBleHQ6ICgpID0+IGV4dGVuc2lvbi5zdWJzdHJpbmcoMSksXG4gICAgICAgICAgICAgICAgZXh0bmFtZTogKCkgPT4gZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogKCkgPT4gb3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgICAgICAgbmFtZTogKCkgPT4gdGhpcy5nZXRDaHVua05hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IGAke2N1cnJlbnREaXJ9LyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJlc2VydmVNb2R1bGVzUm9vdCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZU1vZHVsZXNSb290ICYmIGN1cnJlbnRQYXRoLnN0YXJ0c1dpdGgocHJlc2VydmVNb2R1bGVzUm9vdCkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gY3VycmVudFBhdGguc2xpY2UocHJlc2VydmVNb2R1bGVzUm9vdC5sZW5ndGgpLnJlcGxhY2UoL15bXFxcXC9dLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHJlbGF0aXZlKHByZXNlcnZlTW9kdWxlc1JlbGF0aXZlRGlyLCBjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRuYW1lKHNhbml0aXplZElkKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVuZGVyTmFtZVBhdHRlcm4ocGF0dGVybiwgJ291dHB1dC5lbnRyeUZpbGVOYW1lcycsIHtcbiAgICAgICAgICAgICAgICBhc3NldEV4dG5hbWU6ICgpID0+IChOT05fQVNTRVRfRVhURU5TSU9OUy5pbmNsdWRlcyhleHRlbnNpb24pID8gJycgOiBleHRlbnNpb24pLFxuICAgICAgICAgICAgICAgIGV4dDogKCkgPT4gZXh0ZW5zaW9uLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgICAgICBleHRuYW1lOiAoKSA9PiBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAoKSA9PiBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgICAgICBuYW1lOiAoKSA9PiBnZXRBbGlhc05hbWUoc2FuaXRpemVkSWQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhdGggPSBgX3ZpcnR1YWwvJHtmaWxlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlVW5pcXVlKG5vcm1hbGl6ZShwYXRoKSwgZXhpc3RpbmdOYW1lcyk7XG4gICAgfVxuICAgIGdldENodW5rSW5mbygpIHtcbiAgICAgICAgY29uc3QgZmFjYWRlTW9kdWxlID0gdGhpcy5mYWNhZGVNb2R1bGU7XG4gICAgICAgIGNvbnN0IGdldENodW5rTmFtZSA9IHRoaXMuZ2V0Q2h1bmtOYW1lLmJpbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHBvcnRzOiB0aGlzLmdldEV4cG9ydE5hbWVzKCksXG4gICAgICAgICAgICBmYWNhZGVNb2R1bGVJZDogZmFjYWRlTW9kdWxlICYmIGZhY2FkZU1vZHVsZS5pZCxcbiAgICAgICAgICAgIGlzRHluYW1pY0VudHJ5OiB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGlzRW50cnk6IGZhY2FkZU1vZHVsZSAhPT0gbnVsbCAmJiBmYWNhZGVNb2R1bGUuaW5mby5pc0VudHJ5LFxuICAgICAgICAgICAgaXNJbXBsaWNpdEVudHJ5OiB0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBtb2R1bGVzOiB0aGlzLnJlbmRlcmVkTW9kdWxlcyxcbiAgICAgICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaHVua05hbWUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnY2h1bmsnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENodW5rSW5mb1dpdGhGaWxlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuZ2V0Q2h1bmtJbmZvKCksIHtcbiAgICAgICAgICAgIGNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzOiBBcnJheS5mcm9tKHRoaXMuZHluYW1pY0RlcGVuZGVuY2llcywgZ2V0SWQpLFxuICAgICAgICAgICAgZmlsZU5hbWU6IHRoaXMuaWQsXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOiBBcnJheS5mcm9tKHRoaXMuaW1wbGljaXRseUxvYWRlZEJlZm9yZSwgZ2V0SWQpLFxuICAgICAgICAgICAgaW1wb3J0ZWRCaW5kaW5nczogdGhpcy5nZXRJbXBvcnRlZEJpbmRpbmdzUGVyRGVwZW5kZW5jeSgpLFxuICAgICAgICAgICAgaW1wb3J0czogQXJyYXkuZnJvbSh0aGlzLmRlcGVuZGVuY2llcywgZ2V0SWQpLFxuICAgICAgICAgICAgbWFwOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWZlcmVuY2VkRmlsZXM6IHRoaXMuZ2V0UmVmZXJlbmNlZEZpbGVzKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENodW5rTmFtZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMubmFtZSA9IHRoaXMub3V0cHV0T3B0aW9ucy5zYW5pdGl6ZUZpbGVOYW1lKHRoaXMuZ2V0RmFsbGJhY2tDaHVua05hbWUoKSkpKTtcbiAgICB9XG4gICAgZ2V0RXhwb3J0TmFtZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLnNvcnRlZEV4cG9ydE5hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5zb3J0ZWRFeHBvcnROYW1lcyA9IEFycmF5LmZyb20odGhpcy5leHBvcnRzQnlOYW1lLmtleXMoKSkuc29ydCgpKSk7XG4gICAgfVxuICAgIGdldFJlbmRlcmVkSGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRIYXNoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRIYXNoO1xuICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgpO1xuICAgICAgICBjb25zdCBoYXNoQXVnbWVudGF0aW9uID0gdGhpcy5wbHVnaW5Ecml2ZXIuaG9va1JlZHVjZVZhbHVlU3luYygnYXVnbWVudENodW5rSGFzaCcsICcnLCBbdGhpcy5nZXRDaHVua0luZm8oKV0sIChhdWdtZW50YXRpb24sIHBsdWdpbkhhc2gpID0+IHtcbiAgICAgICAgICAgIGlmIChwbHVnaW5IYXNoKSB7XG4gICAgICAgICAgICAgICAgYXVnbWVudGF0aW9uICs9IHBsdWdpbkhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXVnbWVudGF0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFzaC51cGRhdGUoaGFzaEF1Z21lbnRhdGlvbik7XG4gICAgICAgIGhhc2gudXBkYXRlKHRoaXMucmVuZGVyZWRTb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgICAgIGhhc2gudXBkYXRlKHRoaXMuZ2V0RXhwb3J0TmFtZXMoKVxuICAgICAgICAgICAgLm1hcChleHBvcnROYW1lID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5leHBvcnRzQnlOYW1lLmdldChleHBvcnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtyZWxhdGl2ZUlkKHZhcmlhYmxlLm1vZHVsZS5pZCkucmVwbGFjZSgvXFxcXC9nLCAnLycpfToke3ZhcmlhYmxlLm5hbWV9OiR7ZXhwb3J0TmFtZX1gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywnKSk7XG4gICAgICAgIHJldHVybiAodGhpcy5yZW5kZXJlZEhhc2ggPSBoYXNoLmRpZ2VzdCgnaGV4JykpO1xuICAgIH1cbiAgICBnZXRWYXJpYWJsZUV4cG9ydE5hbWUodmFyaWFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMgJiYgdmFyaWFibGUgaW5zdGFuY2VvZiBOYW1lc3BhY2VWYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKVswXTtcbiAgICB9XG4gICAgbGluaygpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBnZXRTdGF0aWNEZXBlbmRlbmNpZXModGhpcywgdGhpcy5vcmRlcmVkTW9kdWxlcywgdGhpcy5jaHVua0J5TW9kdWxlKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgdGhpcy5hZGREZXBlbmRlbmNpZXNUb0NodW5rKG1vZHVsZS5keW5hbWljRGVwZW5kZW5jaWVzLCB0aGlzLmR5bmFtaWNEZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGREZXBlbmRlbmNpZXNUb0NodW5rKG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlLCB0aGlzLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUpO1xuICAgICAgICAgICAgdGhpcy5zZXRVcENodW5rSW1wb3J0c0FuZEV4cG9ydHNGb3JNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBwcmVyZW5kZXIgYWxsb3dzIGNodW5rIGhhc2hlcyBhbmQgbmFtZXMgdG8gYmUgZ2VuZXJhdGVkIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgcHJlUmVuZGVyKG9wdGlvbnMsIGlucHV0QmFzZSwgc25pcHBldHMpIHtcbiAgICAgICAgY29uc3QgeyBfLCBnZXRQcm9wZXJ0eUFjY2VzcywgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIGNvbnN0IG1hZ2ljU3RyaW5nID0gbmV3IEJ1bmRsZSQxKHsgc2VwYXJhdG9yOiBgJHtufSR7bn1gIH0pO1xuICAgICAgICB0aGlzLnVzZWRNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuaW5kZW50U3RyaW5nID0gZ2V0SW5kZW50U3RyaW5nKHRoaXMub3JkZXJlZE1vZHVsZXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZW5kZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgZHluYW1pY0ltcG9ydEZ1bmN0aW9uOiBvcHRpb25zLmR5bmFtaWNJbXBvcnRGdW5jdGlvbixcbiAgICAgICAgICAgIGV4cG9ydE5hbWVzQnlWYXJpYWJsZTogdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUsXG4gICAgICAgICAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgZnJlZXplOiBvcHRpb25zLmZyZWV6ZSxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnRTdHJpbmcsXG4gICAgICAgICAgICBuYW1lc3BhY2VUb1N0cmluZ1RhZzogb3B0aW9ucy5uYW1lc3BhY2VUb1N0cmluZ1RhZyxcbiAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlcjogdGhpcy5wbHVnaW5Ecml2ZXIsXG4gICAgICAgICAgICBzbmlwcGV0c1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3Igc3RhdGljIGFuZCBkeW5hbWljIGVudHJ5IHBvaW50cywgaW5saW5lIHRoZSBleGVjdXRpb24gbGlzdCB0byBhdm9pZCBsb2FkaW5nIGxhdGVuY3lcbiAgICAgICAgaWYgKG9wdGlvbnMuaG9pc3RUcmFuc2l0aXZlSW1wb3J0cyAmJlxuICAgICAgICAgICAgIXRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMgJiZcbiAgICAgICAgICAgIHRoaXMuZmFjYWRlTW9kdWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBDaHVuaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVDaHVua0RlcGVuZGVuY2llcyhkZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZU1vZHVsZXNGb3JSZW5kZXJpbmcoc25pcHBldHMpO1xuICAgICAgICB0aGlzLnNldElkZW50aWZpZXJSZW5kZXJSZXNvbHV0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGhvaXN0ZWRTb3VyY2UgPSAnJztcbiAgICAgICAgY29uc3QgcmVuZGVyZWRNb2R1bGVzID0gdGhpcy5yZW5kZXJlZE1vZHVsZXM7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMub3JkZXJlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGxldCByZW5kZXJlZExlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmlzSW5jbHVkZWQoKSB8fCB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5oYXMobW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG1vZHVsZS5yZW5kZXIocmVuZGVyT3B0aW9ucykudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkTGVuZ3RoID0gc291cmNlLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb21wYWN0ICYmIHNvdXJjZS5sYXN0TGluZSgpLmluY2x1ZGVzKCcvLycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmFwcGVuZCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRNb2R1bGVTb3VyY2VzLnNldChtb2R1bGUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hZ2ljU3RyaW5nLmFkZFNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZWRNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gbW9kdWxlLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkgJiYgIXRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSBuYW1lc3BhY2UucmVuZGVyQmxvY2socmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2UucmVuZGVyRmlyc3QoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0ZWRTb3VyY2UgKz0gbiArIHJlbmRlcmVkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWdpY1N0cmluZy5hZGRTb3VyY2UobmV3IE1hZ2ljU3RyaW5nJDEocmVuZGVyZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlbmRlcmVkRXhwb3J0cywgcmVtb3ZlZEV4cG9ydHMgfSA9IG1vZHVsZS5nZXRSZW5kZXJlZEV4cG9ydHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVuZGVyZWRNb2R1bGVTb3VyY2VzIH0gPSB0aGlzO1xuICAgICAgICAgICAgcmVuZGVyZWRNb2R1bGVzW21vZHVsZS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSByZW5kZXJlZE1vZHVsZVNvdXJjZXMuZ2V0KG1vZHVsZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMZW5ndGg6IG1vZHVsZS5vcmlnaW5hbENvZGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJlbW92ZWRFeHBvcnRzLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRXhwb3J0cyxcbiAgICAgICAgICAgICAgICByZW5kZXJlZExlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9pc3RlZFNvdXJjZSlcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoaG9pc3RlZFNvdXJjZSArIG4gKyBuKTtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNFeHBvcnRzU2hpbSkge1xuICAgICAgICAgICAgbWFnaWNTdHJpbmcucHJlcGVuZChgJHtufSR7c25pcHBldHMuY25zdH0gJHtNSVNTSU5HX0VYUE9SVF9TSElNX1ZBUklBQkxFfSR7X309JHtffXZvaWQgMDske259JHtufWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXBhY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRTb3VyY2UgPSBtYWdpY1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRTb3VyY2UgPSBtYWdpY1N0cmluZy50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlZEhhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkgJiYgdGhpcy5nZXRFeHBvcnROYW1lcygpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmRlcGVuZGVuY2llcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVua05hbWUgPSB0aGlzLmdldENodW5rTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMub253YXJuKHtcbiAgICAgICAgICAgICAgICBjaHVua05hbWUsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VNUFRZX0JVTkRMRScsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEdlbmVyYXRlZCBhbiBlbXB0eSBjaHVuazogXCIke2NodW5rTmFtZX1cImBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RXh0ZXJuYWxSZW5kZXJQYXRocyhvcHRpb25zLCBpbnB1dEJhc2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzID0gdGhpcy5nZXRDaHVua0RlcGVuZGVuY3lEZWNsYXJhdGlvbnMob3B0aW9ucywgZ2V0UHJvcGVydHlBY2Nlc3MpO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRXhwb3J0cyA9XG4gICAgICAgICAgICB0aGlzLmV4cG9ydE1vZGUgPT09ICdub25lJ1xuICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0Q2h1bmtFeHBvcnREZWNsYXJhdGlvbnMob3B0aW9ucy5mb3JtYXQsIGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICB9XG4gICAgYXN5bmMgcmVuZGVyKG9wdGlvbnMsIGFkZG9ucywgb3V0cHV0Q2h1bmssIHNuaXBwZXRzKSB7XG4gICAgICAgIHRpbWVTdGFydCgncmVuZGVyIGZvcm1hdCcsIDIpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgY29uc3QgZmluYWxpc2UgPSBmaW5hbGlzZXJzW2Zvcm1hdF07XG4gICAgICAgIGlmIChvcHRpb25zLmR5bmFtaWNJbXBvcnRGdW5jdGlvbiAmJiBmb3JtYXQgIT09ICdlcycpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRPcHRpb25zLm9ud2FybihlcnJJbnZhbGlkT3B0aW9uKCdvdXRwdXQuZHluYW1pY0ltcG9ydEZ1bmN0aW9uJywgJ291dHB1dGR5bmFtaWNJbXBvcnRGdW5jdGlvbicsICd0aGlzIG9wdGlvbiBpcyBpZ25vcmVkIGZvciBmb3JtYXRzIG90aGVyIHRoYW4gXCJlc1wiJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBvcHVsYXRlIGlkcyBpbiB0aGUgcmVuZGVyZWQgZGVjbGFyYXRpb25zIG9ubHkgaGVyZVxuICAgICAgICAvLyBhcyBjaHVuayBpZHMga25vd24gb25seSBhZnRlciBwcmVyZW5kZXJcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZERlcGVuZGVuY3kgPSB0aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzLmdldChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbElkID0gZGVwZW5kZW5jeS5yZW5kZXJQYXRoO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkRGVwZW5kZW5jeS5pZCA9IGVzY2FwZUlkKGRlcGVuZGVuY3kucmVub3JtYWxpemVSZW5kZXJQYXRoXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0SW1wb3J0UGF0aCh0aGlzLmlkLCBvcmlnaW5hbElkLCBmYWxzZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIDogb3JpZ2luYWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZERlcGVuZGVuY3kubmFtZWRFeHBvcnRzTW9kZSA9IGRlcGVuZGVuY3kuZXhwb3J0TW9kZSAhPT0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkRGVwZW5kZW5jeS5pZCA9IGVzY2FwZUlkKGdldEltcG9ydFBhdGgodGhpcy5pZCwgZGVwZW5kZW5jeS5pZCwgZmFsc2UsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXNlRHluYW1pY0ltcG9ydHMob3B0aW9ucywgc25pcHBldHMpO1xuICAgICAgICB0aGlzLmZpbmFsaXNlSW1wb3J0TWV0YXMoZm9ybWF0LCBzbmlwcGV0cyk7XG4gICAgICAgIGNvbnN0IGhhc0V4cG9ydHMgPSB0aGlzLnJlbmRlcmVkRXhwb3J0cy5sZW5ndGggIT09IDAgfHxcbiAgICAgICAgICAgIFsuLi50aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzLnZhbHVlcygpXS5zb21lKGRlcCA9PiAoZGVwLnJlZXhwb3J0cyAmJiBkZXAucmVleHBvcnRzLmxlbmd0aCAhPT0gMCkpO1xuICAgICAgICBsZXQgdG9wTGV2ZWxBd2FpdE1vZHVsZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFjY2Vzc2VkR2xvYmFscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS51c2VzVG9wTGV2ZWxBd2FpdCkge1xuICAgICAgICAgICAgICAgIHRvcExldmVsQXdhaXRNb2R1bGUgPSBtb2R1bGUuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NlZEdsb2JhbFZhcmlhYmxlcyA9IHRoaXMuYWNjZXNzZWRHbG9iYWxzQnlTY29wZS5nZXQobW9kdWxlLnNjb3BlKTtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NlZEdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhY2Nlc3NlZEdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NlZEdsb2JhbHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wTGV2ZWxBd2FpdE1vZHVsZSAhPT0gbnVsbCAmJiBmb3JtYXQgIT09ICdlcycgJiYgZm9ybWF0ICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnSU5WQUxJRF9UTEFfRk9STUFUJyxcbiAgICAgICAgICAgICAgICBpZDogdG9wTGV2ZWxBd2FpdE1vZHVsZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTW9kdWxlIGZvcm1hdCAke2Zvcm1hdH0gZG9lcyBub3Qgc3VwcG9ydCB0b3AtbGV2ZWwgYXdhaXQuIFVzZSB0aGUgXCJlc1wiIG9yIFwic3lzdGVtXCIgb3V0cHV0IGZvcm1hdHMgcmF0aGVyLmBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFcnJvcjogZXhwZWN0aW5nIGNodW5rIGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFnaWNTdHJpbmcgPSBmaW5hbGlzZSh0aGlzLnJlbmRlcmVkU291cmNlLCB7XG4gICAgICAgICAgICBhY2Nlc3NlZEdsb2JhbHMsXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFsuLi50aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzLnZhbHVlcygpXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IHRoaXMucmVuZGVyZWRFeHBvcnRzLFxuICAgICAgICAgICAgaGFzRXhwb3J0cyxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudFN0cmluZyxcbiAgICAgICAgICAgIGludHJvOiBhZGRvbnMuaW50cm8sXG4gICAgICAgICAgICBpc0VudHJ5RmFjYWRlOiB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuZmFjYWRlTW9kdWxlICE9PSBudWxsICYmIHRoaXMuZmFjYWRlTW9kdWxlLmluZm8uaXNFbnRyeSksXG4gICAgICAgICAgICBpc01vZHVsZUZhY2FkZTogdGhpcy5mYWNhZGVNb2R1bGUgIT09IG51bGwsXG4gICAgICAgICAgICBuYW1lZEV4cG9ydHNNb2RlOiB0aGlzLmV4cG9ydE1vZGUgIT09ICdkZWZhdWx0JyxcbiAgICAgICAgICAgIG91dHJvOiBhZGRvbnMub3V0cm8sXG4gICAgICAgICAgICBzbmlwcGV0cyxcbiAgICAgICAgICAgIHVzZXNUb3BMZXZlbEF3YWl0OiB0b3BMZXZlbEF3YWl0TW9kdWxlICE9PSBudWxsLFxuICAgICAgICAgICAgd2FybjogdGhpcy5pbnB1dE9wdGlvbnMub253YXJuXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoYWRkb25zLmJhbm5lcilcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoYWRkb25zLmJhbm5lcik7XG4gICAgICAgIGlmIChhZGRvbnMuZm9vdGVyKVxuICAgICAgICAgICAgbWFnaWNTdHJpbmcuYXBwZW5kKGFkZG9ucy5mb290ZXIpO1xuICAgICAgICBjb25zdCBwcmV2Q29kZSA9IG1hZ2ljU3RyaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgIHRpbWVFbmQoJ3JlbmRlciBmb3JtYXQnLCAyKTtcbiAgICAgICAgbGV0IG1hcCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNodW5rU291cmNlbWFwQ2hhaW4gPSBbXTtcbiAgICAgICAgbGV0IGNvZGUgPSBhd2FpdCByZW5kZXJDaHVuayh7XG4gICAgICAgICAgICBjb2RlOiBwcmV2Q29kZSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvdXRwdXRQbHVnaW5Ecml2ZXI6IHRoaXMucGx1Z2luRHJpdmVyLFxuICAgICAgICAgICAgcmVuZGVyQ2h1bms6IG91dHB1dENodW5rLFxuICAgICAgICAgICAgc291cmNlbWFwQ2hhaW46IGNodW5rU291cmNlbWFwQ2hhaW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZW1hcCkge1xuICAgICAgICAgICAgdGltZVN0YXJ0KCdzb3VyY2VtYXAnLCAyKTtcbiAgICAgICAgICAgIGxldCBmaWxlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsZSlcbiAgICAgICAgICAgICAgICBmaWxlID0gcmVzb2x2ZShvcHRpb25zLnNvdXJjZW1hcEZpbGUgfHwgb3B0aW9ucy5maWxlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZGlyKVxuICAgICAgICAgICAgICAgIGZpbGUgPSByZXNvbHZlKG9wdGlvbnMuZGlyLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmaWxlID0gcmVzb2x2ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRNYXAgPSBtYWdpY1N0cmluZy5nZW5lcmF0ZURlY29kZWRNYXAoe30pO1xuICAgICAgICAgICAgbWFwID0gY29sbGFwc2VTb3VyY2VtYXBzKGZpbGUsIGRlY29kZWRNYXAsIHRoaXMudXNlZE1vZHVsZXMsIGNodW5rU291cmNlbWFwQ2hhaW4sIG9wdGlvbnMuc291cmNlbWFwRXhjbHVkZVNvdXJjZXMsIHRoaXMuaW5wdXRPcHRpb25zLm9ud2Fybik7XG4gICAgICAgICAgICBtYXAuc291cmNlcyA9IG1hcC5zb3VyY2VzXG4gICAgICAgICAgICAgICAgLm1hcChzb3VyY2VQYXRoID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0gfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U291cmNlUGF0aCA9IHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0oc291cmNlUGF0aCwgYCR7ZmlsZX0ubWFwYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3U291cmNlUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGVyckZhaWxlZFZhbGlkYXRpb24oYHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0gZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuYCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTb3VyY2VQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlUGF0aDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChub3JtYWxpemUpO1xuICAgICAgICAgICAgdGltZUVuZCgnc291cmNlbWFwJywgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmNvbXBhY3QgJiYgY29kZVtjb2RlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgIGNvZGUgKz0gJ1xcbic7XG4gICAgICAgIHJldHVybiB7IGNvZGUsIG1hcCB9O1xuICAgIH1cbiAgICBhZGREZXBlbmRlbmNpZXNUb0NodW5rKG1vZHVsZURlcGVuZGVuY2llcywgY2h1bmtEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rRGVwZW5kZW5jaWVzLmFkZChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtEZXBlbmRlbmNpZXMuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduRmFjYWRlTmFtZSh7IGZpbGVOYW1lLCBuYW1lIH0sIGZhY2FkZWRNb2R1bGUpIHtcbiAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuc2FuaXRpemVGaWxlTmFtZShuYW1lIHx8IGdldENodW5rTmFtZUZyb21Nb2R1bGUoZmFjYWRlZE1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQ2lyY3VsYXJEZXBlbmRlbmN5SW1wb3J0KHZhcmlhYmxlLCBpbXBvcnRpbmdNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVNb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgIGlmICh2YXJpYWJsZU1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0Q2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KHZhcmlhYmxlTW9kdWxlKTtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGUgPSBpbXBvcnRpbmdNb2R1bGUuYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZXMuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRpbmdDaHVuayA9IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQoYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRpbmdDaHVuayAmJiBleHBvcnRpbmdDaHVuayAhPT0gZXhwb3J0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRPcHRpb25zLm9ud2FybihlcnJDeWNsaWNDcm9zc0NodW5rUmVleHBvcnQodmFyaWFibGVNb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCkuZ2V0KHZhcmlhYmxlKVswXSwgdmFyaWFibGVNb2R1bGUuaWQsIGFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGUuaWQsIGltcG9ydGluZ01vZHVsZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGluZ01vZHVsZSA9IGFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUNvbnRlbnRIYXNoV2l0aERlcGVuZGVuY2llcyhhZGRvbnMsIG9wdGlvbnMsIGV4aXN0aW5nTmFtZXMpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goKTtcbiAgICAgICAgaGFzaC51cGRhdGUoW2FkZG9ucy5pbnRybywgYWRkb25zLm91dHJvLCBhZGRvbnMuYmFubmVyLCBhZGRvbnMuZm9vdGVyXS5qb2luKCc6JykpO1xuICAgICAgICBoYXNoLnVwZGF0ZShvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llc0Zvckhhc2hpbmcgPSBuZXcgU2V0KFt0aGlzXSk7XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBkZXBlbmRlbmNpZXNGb3JIYXNoaW5nKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaGFzaC51cGRhdGUoYDoke2N1cnJlbnQucmVuZGVyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc2gudXBkYXRlKGN1cnJlbnQuZ2V0UmVuZGVyZWRIYXNoKCkpO1xuICAgICAgICAgICAgICAgIGhhc2gudXBkYXRlKGN1cnJlbnQuZ2VuZXJhdGVJZChhZGRvbnMsIG9wdGlvbnMsIGV4aXN0aW5nTmFtZXMsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIFsuLi5jdXJyZW50LmRlcGVuZGVuY2llcywgLi4uY3VycmVudC5keW5hbWljRGVwZW5kZW5jaWVzXSkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llc0Zvckhhc2hpbmcuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnaGV4Jykuc3Vic3RyKDAsIDgpO1xuICAgIH1cbiAgICBlbnN1cmVSZWV4cG9ydHNBcmVBdmFpbGFibGVGb3JNb2R1bGUobW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG1vZHVsZS5nZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKTtcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnRlZFZhcmlhYmxlIG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU3ludGhldGljID0gZXhwb3J0ZWRWYXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGU7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFZhcmlhYmxlID0gaXNTeW50aGV0aWNcbiAgICAgICAgICAgICAgICA/IGV4cG9ydGVkVmFyaWFibGUuZ2V0QmFzZVZhcmlhYmxlKClcbiAgICAgICAgICAgICAgICA6IGV4cG9ydGVkVmFyaWFibGU7XG4gICAgICAgICAgICBpZiAoIShpbXBvcnRlZFZhcmlhYmxlIGluc3RhbmNlb2YgTmFtZXNwYWNlVmFyaWFibGUgJiYgdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ2lyY3VsYXJEZXBlbmRlbmN5SW1wb3J0KGltcG9ydGVkVmFyaWFibGUsIG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0aW5nTW9kdWxlID0gaW1wb3J0ZWRWYXJpYWJsZS5tb2R1bGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydGluZ01vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQoZXhwb3J0aW5nTW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5leHBvcnRzLmFkZChpbXBvcnRlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bnRoZXRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0cy5hZGQoaW1wb3J0ZWRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpc2VEeW5hbWljSW1wb3J0cyhvcHRpb25zLCBzbmlwcGV0cykge1xuICAgICAgICBjb25zdCBzdHJpcEtub3duSnNFeHRlbnNpb25zID0gb3B0aW9ucy5mb3JtYXQgPT09ICdhbWQnO1xuICAgICAgICBmb3IgKGNvbnN0IFttb2R1bGUsIGNvZGVdIG9mIHRoaXMucmVuZGVyZWRNb2R1bGVTb3VyY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgbm9kZSwgcmVzb2x1dGlvbiB9IG9mIG1vZHVsZS5keW5hbWljSW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5jaHVua0J5TW9kdWxlLmdldChyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWNhZGVDaHVuayA9IHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5nZXQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHV0aW9uIHx8ICFub2RlLmluY2x1ZGVkIHx8IGNodW5rID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZFJlc29sdXRpb24gPSByZXNvbHV0aW9uIGluc3RhbmNlb2YgTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgID8gYCcke2VzY2FwZUlkKGdldEltcG9ydFBhdGgodGhpcy5pZCwgKGZhY2FkZUNodW5rIHx8IGNodW5rKS5pZCwgc3RyaXBLbm93bkpzRXh0ZW5zaW9ucywgdHJ1ZSkpfSdgXG4gICAgICAgICAgICAgICAgICAgIDogcmVzb2x1dGlvbiBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAnJHtlc2NhcGVJZChyZXNvbHV0aW9uLnJlbm9ybWFsaXplUmVuZGVyUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0SW1wb3J0UGF0aCh0aGlzLmlkLCByZXNvbHV0aW9uLnJlbmRlclBhdGgsIHN0cmlwS25vd25Kc0V4dGVuc2lvbnMsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzb2x1dGlvbi5yZW5kZXJQYXRoKX0nYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIG5vZGUucmVuZGVyRmluYWxSZXNvbHV0aW9uKGNvZGUsIHJlbmRlcmVkUmVzb2x1dGlvbiwgcmVzb2x1dGlvbiBpbnN0YW5jZW9mIE1vZHVsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhKGZhY2FkZUNodW5rID09PSBudWxsIHx8IGZhY2FkZUNodW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWNhZGVDaHVuay5zdHJpY3RGYWNhZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGNodW5rLmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQocmVzb2x1dGlvbi5uYW1lc3BhY2UpWzBdLCBzbmlwcGV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpc2VJbXBvcnRNZXRhcyhmb3JtYXQsIHNuaXBwZXRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW21vZHVsZSwgY29kZV0gb2YgdGhpcy5yZW5kZXJlZE1vZHVsZVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1wb3J0TWV0YSBvZiBtb2R1bGUuaW1wb3J0TWV0YXMpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRNZXRhLnJlbmRlckZpbmFsTWVjaGFuaXNtKGNvZGUsIHRoaXMuaWQsIGZvcm1hdCwgc25pcHBldHMsIHRoaXMucGx1Z2luRHJpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsQ2h1bmtBbGlhcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsQ2h1bmtBbGlhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2R1bGVGb3JOYW1pbmcgPSB0aGlzLmVudHJ5TW9kdWxlc1swXSB8fFxuICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc1swXSB8fFxuICAgICAgICAgICAgdGhpcy5keW5hbWljRW50cnlNb2R1bGVzWzBdIHx8XG4gICAgICAgICAgICB0aGlzLm9yZGVyZWRNb2R1bGVzW3RoaXMub3JkZXJlZE1vZHVsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChtb2R1bGVGb3JOYW1pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDaHVua05hbWVGcm9tTW9kdWxlKG1vZHVsZUZvck5hbWluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdjaHVuayc7XG4gICAgfVxuICAgIGdldENodW5rRGVwZW5kZW5jeURlY2xhcmF0aW9ucyhvcHRpb25zLCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXJzID0gdGhpcy5nZXRJbXBvcnRTcGVjaWZpZXJzKGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICAgICAgY29uc3QgcmVleHBvcnRTcGVjaWZpZXJzID0gdGhpcy5nZXRSZWV4cG9ydFNwZWNpZmllcnMoKTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeURlY2xhcmF0aW9uID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0cyA9IGltcG9ydFNwZWNpZmllcnMuZ2V0KGRlcCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlZXhwb3J0cyA9IHJlZXhwb3J0U3BlY2lmaWVycy5nZXQoZGVwKSB8fCBudWxsO1xuICAgICAgICAgICAgY29uc3QgbmFtZWRFeHBvcnRzTW9kZSA9IGRlcCBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlIHx8IGRlcC5leHBvcnRNb2RlICE9PSAnZGVmYXVsdCc7XG4gICAgICAgICAgICBkZXBlbmRlbmN5RGVjbGFyYXRpb24uc2V0KGRlcCwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYXJpYWJsZU5hbWU6IGRlcC5kZWZhdWx0VmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWU6IChkZXAgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSAmJlxuICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5mb3JtYXQgPT09ICd1bWQnIHx8IG9wdGlvbnMuZm9ybWF0ID09PSAnaWlmZScpICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEdsb2JhbE5hbWUoZGVwLCBvcHRpb25zLmdsb2JhbHMsIChpbXBvcnRzIHx8IHJlZXhwb3J0cykgIT09IG51bGwsIHRoaXMuaW5wdXRPcHRpb25zLm9ud2FybikpLFxuICAgICAgICAgICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaW1wb3J0cyxcbiAgICAgICAgICAgICAgICBpc0NodW5rOiBkZXAgaW5zdGFuY2VvZiBDaHVuayxcbiAgICAgICAgICAgICAgICBuYW1lOiBkZXAudmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWVkRXhwb3J0c01vZGUsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlVmFyaWFibGVOYW1lOiBkZXAubmFtZXNwYWNlVmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIHJlZXhwb3J0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3lEZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgZ2V0Q2h1bmtFeHBvcnREZWNsYXJhdGlvbnMoZm9ybWF0LCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgICAgICBjb25zdCBleHBvcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXhwb3J0TmFtZSBvZiB0aGlzLmdldEV4cG9ydE5hbWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lWzBdID09PSAnKicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZXhwb3J0c0J5TmFtZS5nZXQoZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICBpZiAoISh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gdmFyaWFibGUubW9kdWxlO1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUgJiYgdGhpcy5jaHVua0J5TW9kdWxlLmdldChtb2R1bGUpICE9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBob2lzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbG9jYWwgPSB2YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIExvY2FsVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIHZhcmlhYmxlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ucGFyZW50IGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbkRlY2xhcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBsb2NhbDtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdmFyaWFibGUucmVuZGVyTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cG9ydGVkOiBleHBvcnROYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgaG9pc3RlZCxcbiAgICAgICAgICAgICAgICBsb2NhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfVxuICAgIGdldERlcGVuZGVuY2llc1RvQmVEZWNvbmZsaWN0ZWQoYWRkTm9uTmFtZXNwYWNlc0FuZEludGVyb3BIZWxwZXJzLCBhZGREZXBlbmRlbmNpZXNXaXRob3V0QmluZGluZ3MsIGludGVyb3ApIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZWNvbmZsaWN0ZWREZWZhdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZWNvbmZsaWN0ZWROYW1lc3BhY2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgWy4uLnRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmtleXMoKSwgLi4udGhpcy5pbXBvcnRzXSkge1xuICAgICAgICAgICAgaWYgKGFkZE5vbk5hbWVzcGFjZXNBbmRJbnRlcm9wSGVscGVycyB8fCB2YXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkTm9uTmFtZXNwYWNlc0FuZEludGVyb3BIZWxwZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUubmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbU3RyaW5nKGludGVyb3AobW9kdWxlLmlkKSldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29uZmxpY3RlZERlZmF1bHQuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFibGUubmFtZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVtTdHJpbmcoaW50ZXJvcChtb2R1bGUuaWQpKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb25mbGljdGVkTmFtZXNwYWNlLmFkZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuayAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkTm9uTmFtZXNwYWNlc0FuZEludGVyb3BIZWxwZXJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuZXhwb3J0TW9kZSA9PT0gJ2RlZmF1bHQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvbmZsaWN0ZWROYW1lc3BhY2UuYWRkKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkRGVwZW5kZW5jaWVzV2l0aG91dEJpbmRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRlY29uZmxpY3RlZERlZmF1bHQsIGRlY29uZmxpY3RlZE5hbWVzcGFjZSwgZGVwZW5kZW5jaWVzIH07XG4gICAgfVxuICAgIGdldEZhbGxiYWNrQ2h1bmtOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5tYW51YWxDaHVua0FsaWFzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxDaHVua0FsaWFzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsaWFzTmFtZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QWxpYXNOYW1lKHRoaXMub3JkZXJlZE1vZHVsZXNbdGhpcy5vcmRlcmVkTW9kdWxlcy5sZW5ndGggLSAxXS5pZCk7XG4gICAgfVxuICAgIGdldEltcG9ydFNwZWNpZmllcnMoZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm9wIH0gPSB0aGlzLm91dHB1dE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGltcG9ydHNCeURlcGVuZGVuY3kgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdGhpcy5pbXBvcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgICAgICBsZXQgZGVwZW5kZW5jeTtcbiAgICAgICAgICAgIGxldCBpbXBvcnRlZDtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZWQgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZCAhPT0gJ2RlZmF1bHQnICYmIGltcG9ydGVkICE9PSAnKicgJiYgaW50ZXJvcChtb2R1bGUuaWQpID09PSAnZGVmYXVsdE9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJVbmV4cGVjdGVkTmFtZWRJbXBvcnQobW9kdWxlLmlkLCBpbXBvcnRlZCwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5jaHVua0J5TW9kdWxlLmdldChtb2R1bGUpO1xuICAgICAgICAgICAgICAgIGltcG9ydGVkID0gZGVwZW5kZW5jeS5nZXRWYXJpYWJsZUV4cG9ydE5hbWUodmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0T3JDcmVhdGUoaW1wb3J0c0J5RGVwZW5kZW5jeSwgZGVwZW5kZW5jeSwgKCkgPT4gW10pLnB1c2goe1xuICAgICAgICAgICAgICAgIGltcG9ydGVkLFxuICAgICAgICAgICAgICAgIGxvY2FsOiB2YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydHNCeURlcGVuZGVuY3k7XG4gICAgfVxuICAgIGdldEltcG9ydGVkQmluZGluZ3NQZXJEZXBlbmRlbmN5KCkge1xuICAgICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2RlcGVuZGVuY3ksIGRlY2xhcmF0aW9uXSBvZiB0aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW1wb3J0ZWQgfSBvZiBkZWNsYXJhdGlvbi5pbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMuYWRkKGltcG9ydGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ucmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGltcG9ydGVkIH0gb2YgZGVjbGFyYXRpb24ucmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMuYWRkKGltcG9ydGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbXBvcnRTcGVjaWZpZXJzW2RlcGVuZGVuY3kuaWRdID0gWy4uLnNwZWNpZmllcnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRTcGVjaWZpZXJzO1xuICAgIH1cbiAgICBnZXRSZWV4cG9ydFNwZWNpZmllcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGludGVyb3AgfSA9IHRoaXMub3V0cHV0T3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVleHBvcnRTcGVjaWZpZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHBvcnROYW1lIG9mIHRoaXMuZ2V0RXhwb3J0TmFtZXMoKSkge1xuICAgICAgICAgICAgbGV0IGRlcGVuZGVuY3k7XG4gICAgICAgICAgICBsZXQgaW1wb3J0ZWQ7XG4gICAgICAgICAgICBsZXQgbmVlZHNMaXZlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWVbMF0gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZXhwb3J0TmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyb3AoaWQpID09PSAnZGVmYXVsdE9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRPcHRpb25zLm9ud2FybihlcnJVbmV4cGVjdGVkTmFtZXNwYWNlUmVleHBvcnQoaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmVlZHNMaXZlQmluZGluZyA9IGV4dGVybmFsTGl2ZUJpbmRpbmdzO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLm1vZHVsZXNCeUlkLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZWQgPSBleHBvcnROYW1lID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmV4cG9ydHNCeU5hbWUuZ2V0KGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkID0gZGVwZW5kZW5jeS5nZXRWYXJpYWJsZUV4cG9ydE5hbWUodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc0xpdmVCaW5kaW5nID0gdmFyaWFibGUuaXNSZWFzc2lnbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWQgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWQgIT09ICdkZWZhdWx0JyAmJiBpbXBvcnRlZCAhPT0gJyonICYmIGludGVyb3AobW9kdWxlLmlkKSA9PT0gJ2RlZmF1bHRPbmx5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyclVuZXhwZWN0ZWROYW1lZEltcG9ydChtb2R1bGUuaWQsIGltcG9ydGVkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmVlZHNMaXZlQmluZGluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbExpdmVCaW5kaW5ncyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbXBvcnRlZCAhPT0gJ2RlZmF1bHQnIHx8IGlzRGVmYXVsdEFQcm9wZXJ0eShTdHJpbmcoaW50ZXJvcChtb2R1bGUuaWQpKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldE9yQ3JlYXRlKHJlZXhwb3J0U3BlY2lmaWVycywgZGVwZW5kZW5jeSwgKCkgPT4gW10pLnB1c2goe1xuICAgICAgICAgICAgICAgIGltcG9ydGVkLFxuICAgICAgICAgICAgICAgIG5lZWRzTGl2ZUJpbmRpbmcsXG4gICAgICAgICAgICAgICAgcmVleHBvcnRlZDogZXhwb3J0TmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZXhwb3J0U3BlY2lmaWVycztcbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlZEZpbGVzKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VkRmlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRhIG9mIG1vZHVsZS5pbXBvcnRNZXRhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbWV0YS5nZXRSZWZlcmVuY2VkRmlsZU5hbWUodGhpcy5wbHVnaW5Ecml2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkRmlsZXMucHVzaChmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VkRmlsZXM7XG4gICAgfVxuICAgIGlubGluZUNodW5rRGVwZW5kZW5jaWVzKGNodW5rKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwIG9mIGNodW5rLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmhhcyhkZXApKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuYWRkKGRlcCk7XG4gICAgICAgICAgICBpZiAoZGVwIGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZUNodW5rRGVwZW5kZW5jaWVzKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZU1vZHVsZXNGb3JSZW5kZXJpbmcoc25pcHBldHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlID0gdGhpcy5hY2Nlc3NlZEdsb2JhbHNCeVNjb3BlO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm9yZGVyZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgbm9kZSwgcmVzb2x1dGlvbiB9IG9mIG1vZHVsZS5keW5hbWljSW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHV0aW9uIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEludGVybmFsUmVzb2x1dGlvbihyZXNvbHV0aW9uLm5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEV4dGVybmFsUmVzb2x1dGlvbigoKF9hID0gdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLmdldChyZXNvbHV0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cG9ydE1vZGUpIHx8IGNodW5rLmV4cG9ydE1vZGUsIHJlc29sdXRpb24sIHRoaXMub3V0cHV0T3B0aW9ucywgc25pcHBldHMsIHRoaXMucGx1Z2luRHJpdmVyLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RXh0ZXJuYWxSZXNvbHV0aW9uKCdleHRlcm5hbCcsIHJlc29sdXRpb24sIHRoaXMub3V0cHV0T3B0aW9ucywgc25pcHBldHMsIHRoaXMucGx1Z2luRHJpdmVyLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1wb3J0TWV0YSBvZiBtb2R1bGUuaW1wb3J0TWV0YXMpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRNZXRhLmFkZEFjY2Vzc2VkR2xvYmFscyh0aGlzLm91dHB1dE9wdGlvbnMuZm9ybWF0LCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5oYXMobW9kdWxlKSAmJiAhdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcykge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5uYW1lc3BhY2UucHJlcGFyZShhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRFeHRlcm5hbFJlbmRlclBhdGhzKG9wdGlvbnMsIGlucHV0QmFzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgWy4uLnRoaXMuZGVwZW5kZW5jaWVzLCAuLi50aGlzLmR5bmFtaWNEZXBlbmRlbmNpZXNdKSB7XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5zZXRSZW5kZXJQYXRoKG9wdGlvbnMsIGlucHV0QmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SWRlbnRpZmllclJlbmRlclJlc29sdXRpb25zKHsgZm9ybWF0LCBpbnRlcm9wLCBuYW1lc3BhY2VUb1N0cmluZ1RhZyB9KSB7XG4gICAgICAgIGNvbnN0IHN5bnRoZXRpY0V4cG9ydHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZXhwb3J0TmFtZSBvZiB0aGlzLmdldEV4cG9ydE5hbWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydFZhcmlhYmxlID0gdGhpcy5leHBvcnRzQnlOYW1lLmdldChleHBvcnROYW1lKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdlcycgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgIT09ICdzeXN0ZW0nICYmXG4gICAgICAgICAgICAgICAgZXhwb3J0VmFyaWFibGUuaXNSZWFzc2lnbmVkICYmXG4gICAgICAgICAgICAgICAgIWV4cG9ydFZhcmlhYmxlLmlzSWQpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRWYXJpYWJsZS5zZXRSZW5kZXJOYW1lcygnZXhwb3J0cycsIGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwb3J0VmFyaWFibGUgaW5zdGFuY2VvZiBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXhwb3J0cy5hZGQoZXhwb3J0VmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0VmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5uZWVkc0V4cG9ydFNoaW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzRXhwb3J0c1NoaW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZWROYW1lcyA9IG5ldyBTZXQoWydPYmplY3QnLCAnUHJvbWlzZSddKTtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNFeHBvcnRzU2hpbSkge1xuICAgICAgICAgICAgdXNlZE5hbWVzLmFkZChNSVNTSU5HX0VYUE9SVF9TSElNX1ZBUklBQkxFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoJ1N5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdzeXN0ZW0nOlxuICAgICAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoJ21vZHVsZScpLmFkZCgnZXhwb3J0cycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXMnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2pzJzpcbiAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKCdtb2R1bGUnKS5hZGQoJ3JlcXVpcmUnKS5hZGQoJ19fZmlsZW5hbWUnKS5hZGQoJ19fZGlybmFtZScpO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdXNlZE5hbWVzLmFkZCgnZXhwb3J0cycpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGVscGVyIG9mIEhFTFBFUl9OQU1FUykge1xuICAgICAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY29uZmxpY3RDaHVuayh0aGlzLm9yZGVyZWRNb2R1bGVzLCB0aGlzLmdldERlcGVuZGVuY2llc1RvQmVEZWNvbmZsaWN0ZWQoZm9ybWF0ICE9PSAnZXMnICYmIGZvcm1hdCAhPT0gJ3N5c3RlbScsIGZvcm1hdCA9PT0gJ2FtZCcgfHwgZm9ybWF0ID09PSAndW1kJyB8fCBmb3JtYXQgPT09ICdpaWZlJywgaW50ZXJvcCksIHRoaXMuaW1wb3J0cywgdXNlZE5hbWVzLCBmb3JtYXQsIGludGVyb3AsIHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMsIHRoaXMub3V0cHV0T3B0aW9ucy5leHRlcm5hbExpdmVCaW5kaW5ncywgdGhpcy5jaHVua0J5TW9kdWxlLCBzeW50aGV0aWNFeHBvcnRzLCB0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgdGhpcy5hY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcyk7XG4gICAgfVxuICAgIHNldFVwQ2h1bmtJbXBvcnRzQW5kRXhwb3J0c0Zvck1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlSW1wb3J0cyA9IG5ldyBTZXQobW9kdWxlLmltcG9ydHMpO1xuICAgICAgICAvLyB3aGVuIHdlIGFyZSBub3QgcHJlc2VydmluZyBtb2R1bGVzLCB3ZSBuZWVkIHRvIG1ha2UgYWxsIG5hbWVzcGFjZSB2YXJpYWJsZXMgYXZhaWxhYmxlIGZvclxuICAgICAgICAvLyByZW5kZXJpbmcgdGhlIG5hbWVzcGFjZSBvYmplY3RcbiAgICAgICAgaWYgKCF0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW1iZXJWYXJpYWJsZXMgPSBtb2R1bGUubmFtZXNwYWNlLmdldE1lbWJlclZhcmlhYmxlcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgT2JqZWN0LnZhbHVlcyhtZW1iZXJWYXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUltcG9ydHMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGUgb2YgbW9kdWxlSW1wb3J0cykge1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5nZXRPcmlnaW5hbFZhcmlhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5nZXRCYXNlVmFyaWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5jaHVua0J5TW9kdWxlLmdldCh2YXJpYWJsZS5tb2R1bGUpO1xuICAgICAgICAgICAgaWYgKGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzLmFkZCh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCEodmFyaWFibGUgaW5zdGFuY2VvZiBOYW1lc3BhY2VWYXJpYWJsZSAmJiB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5tb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuZXhwb3J0cy5hZGQodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ2lyY3VsYXJEZXBlbmRlbmN5SW1wb3J0KHZhcmlhYmxlLCBtb2R1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkgfHxcbiAgICAgICAgICAgIChtb2R1bGUuaW5mby5pc0VudHJ5ICYmIG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSAhPT0gZmFsc2UpIHx8XG4gICAgICAgICAgICBtb2R1bGUuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLnNvbWUoaW1wb3J0ZXIgPT4gdGhpcy5jaHVua0J5TW9kdWxlLmdldChpbXBvcnRlcikgIT09IHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlLCByZXNvbHV0aW9uIH0gb2YgbW9kdWxlLmR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlZCAmJlxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gaW5zdGFuY2VvZiBNb2R1bGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KHJlc29sdXRpb24pID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmhhcyhyZXNvbHV0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmFkZChyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENodW5rTmFtZUZyb21Nb2R1bGUobW9kdWxlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAoKF9kID0gKF9iID0gKF9hID0gbW9kdWxlLmNodW5rTmFtZXMuZmluZCgoeyBpc1VzZXJEZWZpbmVkIH0pID0+IGlzVXNlckRlZmluZWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gbW9kdWxlLmNodW5rTmFtZXNbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBnZXRBbGlhc05hbWUobW9kdWxlLmlkKSk7XG59XG5jb25zdCBRVUVSWV9IQVNIX1JFR0VYID0gL1s/I10vO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUFzc2V0RmlsZU5hbWUobmFtZSwgc291cmNlLCBvdXRwdXRPcHRpb25zLCBidW5kbGUpIHtcbiAgICBjb25zdCBlbWl0dGVkTmFtZSA9IG91dHB1dE9wdGlvbnMuc2FuaXRpemVGaWxlTmFtZShuYW1lIHx8ICdhc3NldCcpO1xuICAgIHJldHVybiBtYWtlVW5pcXVlKHJlbmRlck5hbWVQYXR0ZXJuKHR5cGVvZiBvdXRwdXRPcHRpb25zLmFzc2V0RmlsZU5hbWVzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3V0cHV0T3B0aW9ucy5hc3NldEZpbGVOYW1lcyh7IG5hbWUsIHNvdXJjZSwgdHlwZTogJ2Fzc2V0JyB9KVxuICAgICAgICA6IG91dHB1dE9wdGlvbnMuYXNzZXRGaWxlTmFtZXMsICdvdXRwdXQuYXNzZXRGaWxlTmFtZXMnLCB7XG4gICAgICAgIGV4dDogKCkgPT4gZXh0bmFtZShlbWl0dGVkTmFtZSkuc3Vic3RyaW5nKDEpLFxuICAgICAgICBleHRuYW1lOiAoKSA9PiBleHRuYW1lKGVtaXR0ZWROYW1lKSxcbiAgICAgICAgaGFzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVIYXNoKClcbiAgICAgICAgICAgICAgICAudXBkYXRlKGVtaXR0ZWROYW1lKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoJzonKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoc291cmNlKVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCA4KTtcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZTogKCkgPT4gZW1pdHRlZE5hbWUuc3Vic3RyaW5nKDAsIGVtaXR0ZWROYW1lLmxlbmd0aCAtIGV4dG5hbWUoZW1pdHRlZE5hbWUpLmxlbmd0aClcbiAgICB9KSwgYnVuZGxlKTtcbn1cbmZ1bmN0aW9uIHJlc2VydmVGaWxlTmFtZUluQnVuZGxlKGZpbGVOYW1lLCBidW5kbGUsIHdhcm4pIHtcbiAgICBpZiAoZmlsZU5hbWUgaW4gYnVuZGxlKSB7XG4gICAgICAgIHdhcm4oZXJyRmlsZU5hbWVDb25mbGljdChmaWxlTmFtZSkpO1xuICAgIH1cbiAgICBidW5kbGVbZmlsZU5hbWVdID0gRklMRV9QTEFDRUhPTERFUjtcbn1cbmNvbnN0IEZJTEVfUExBQ0VIT0xERVIgPSB7XG4gICAgdHlwZTogJ3BsYWNlaG9sZGVyJ1xufTtcbmZ1bmN0aW9uIGhhc1ZhbGlkVHlwZShlbWl0dGVkRmlsZSkge1xuICAgIHJldHVybiBCb29sZWFuKGVtaXR0ZWRGaWxlICYmXG4gICAgICAgIChlbWl0dGVkRmlsZS50eXBlID09PSAnYXNzZXQnIHx8XG4gICAgICAgICAgICBlbWl0dGVkRmlsZS50eXBlID09PSAnY2h1bmsnKSk7XG59XG5mdW5jdGlvbiBoYXNWYWxpZE5hbWUoZW1pdHRlZEZpbGUpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWROYW1lID0gZW1pdHRlZEZpbGUuZmlsZU5hbWUgfHwgZW1pdHRlZEZpbGUubmFtZTtcbiAgICByZXR1cm4gIXZhbGlkYXRlZE5hbWUgfHwgKHR5cGVvZiB2YWxpZGF0ZWROYW1lID09PSAnc3RyaW5nJyAmJiAhaXNQYXRoRnJhZ21lbnQodmFsaWRhdGVkTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRTb3VyY2Uoc291cmNlLCBlbWl0dGVkRmlsZSwgZmlsZVJlZmVyZW5jZUlkKSB7XG4gICAgaWYgKCEodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgY29uc3QgYXNzZXROYW1lID0gZW1pdHRlZEZpbGUuZmlsZU5hbWUgfHwgZW1pdHRlZEZpbGUubmFtZSB8fCBmaWxlUmVmZXJlbmNlSWQ7XG4gICAgICAgIHJldHVybiBlcnJvcihlcnJGYWlsZWRWYWxpZGF0aW9uKGBDb3VsZCBub3Qgc2V0IHNvdXJjZSBmb3IgJHt0eXBlb2YgYXNzZXROYW1lID09PSAnc3RyaW5nJyA/IGBhc3NldCBcIiR7YXNzZXROYW1lfVwiYCA6ICd1bm5hbWVkIGFzc2V0J30sIGFzc2V0IHNvdXJjZSBuZWVkcyB0byBiZSBhIHN0cmluZywgVWludDhBcnJheSBvciBCdWZmZXIuYCkpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gZ2V0QXNzZXRGaWxlTmFtZShmaWxlLCByZWZlcmVuY2VJZCkge1xuICAgIGlmICh0eXBlb2YgZmlsZS5maWxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckFzc2V0Tm90RmluYWxpc2VkRm9yRmlsZU5hbWUoZmlsZS5uYW1lIHx8IHJlZmVyZW5jZUlkKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlLmZpbGVOYW1lO1xufVxuZnVuY3Rpb24gZ2V0Q2h1bmtGaWxlTmFtZShmaWxlLCBmYWNhZGVDaHVua0J5TW9kdWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5maWxlTmFtZSB8fCAoZmlsZS5tb2R1bGUgJiYgKChfYSA9IGZhY2FkZUNodW5rQnlNb2R1bGUgPT09IG51bGwgfHwgZmFjYWRlQ2h1bmtCeU1vZHVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFjYWRlQ2h1bmtCeU1vZHVsZS5nZXQoZmlsZS5tb2R1bGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpKTtcbiAgICBpZiAoIWZpbGVOYW1lKVxuICAgICAgICByZXR1cm4gZXJyb3IoZXJyQ2h1bmtOb3RHZW5lcmF0ZWRGb3JGaWxlTmFtZShmaWxlLmZpbGVOYW1lIHx8IGZpbGUubmFtZSkpO1xuICAgIHJldHVybiBmaWxlTmFtZTtcbn1cbmNsYXNzIEZpbGVFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihncmFwaCwgb3B0aW9ucywgYmFzZUZpbGVFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5idW5kbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUgPSBudWxsO1xuICAgICAgICB0aGlzLm91dHB1dE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLmFzc2VydEFzc2V0c0ZpbmFsaXplZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlZmVyZW5jZUlkLCBlbWl0dGVkRmlsZV0gb2YgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1pdHRlZEZpbGUudHlwZSA9PT0gJ2Fzc2V0JyAmJiB0eXBlb2YgZW1pdHRlZEZpbGUuZmlsZU5hbWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJyTm9Bc3NldFNvdXJjZVNldChlbWl0dGVkRmlsZS5uYW1lIHx8IHJlZmVyZW5jZUlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdEZpbGUgPSAoZW1pdHRlZEZpbGUpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFzVmFsaWRUeXBlKGVtaXR0ZWRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJGYWlsZWRWYWxpZGF0aW9uKGBFbWl0dGVkIGZpbGVzIG11c3QgYmUgb2YgdHlwZSBcImFzc2V0XCIgb3IgXCJjaHVua1wiLCByZWNlaXZlZCBcIiR7ZW1pdHRlZEZpbGUgJiYgZW1pdHRlZEZpbGUudHlwZX1cIi5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1ZhbGlkTmFtZShlbWl0dGVkRmlsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJyRmFpbGVkVmFsaWRhdGlvbihgVGhlIFwiZmlsZU5hbWVcIiBvciBcIm5hbWVcIiBwcm9wZXJ0aWVzIG9mIGVtaXR0ZWQgZmlsZXMgbXVzdCBiZSBzdHJpbmdzIHRoYXQgYXJlIG5laXRoZXIgYWJzb2x1dGUgbm9yIHJlbGF0aXZlIHBhdGhzLCByZWNlaXZlZCBcIiR7ZW1pdHRlZEZpbGUuZmlsZU5hbWUgfHwgZW1pdHRlZEZpbGUubmFtZX1cIi5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdHRlZEZpbGUudHlwZSA9PT0gJ2NodW5rJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRDaHVuayhlbWl0dGVkRmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0QXNzZXQoZW1pdHRlZEZpbGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEZpbGVOYW1lID0gKGZpbGVSZWZlcmVuY2VJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdHRlZEZpbGUgPSB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5nZXQoZmlsZVJlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIGlmICghZW1pdHRlZEZpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckZpbGVSZWZlcmVuY2VJZE5vdEZvdW5kRm9yRmlsZW5hbWUoZmlsZVJlZmVyZW5jZUlkKSk7XG4gICAgICAgICAgICBpZiAoZW1pdHRlZEZpbGUudHlwZSA9PT0gJ2NodW5rJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaHVua0ZpbGVOYW1lKGVtaXR0ZWRGaWxlLCB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEFzc2V0RmlsZU5hbWUoZW1pdHRlZEZpbGUsIGZpbGVSZWZlcmVuY2VJZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0QXNzZXRTb3VyY2UgPSAocmVmZXJlbmNlSWQsIHJlcXVlc3RlZFNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29uc3VtZWRGaWxlID0gdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQuZ2V0KHJlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIGlmICghY29uc3VtZWRGaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJBc3NldFJlZmVyZW5jZUlkTm90Rm91bmRGb3JTZXRTb3VyY2UocmVmZXJlbmNlSWQpKTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lZEZpbGUudHlwZSAhPT0gJ2Fzc2V0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJGYWlsZWRWYWxpZGF0aW9uKGBBc3NldCBzb3VyY2VzIGNhbiBvbmx5IGJlIHNldCBmb3IgZW1pdHRlZCBhc3NldHMgYnV0IFwiJHtyZWZlcmVuY2VJZH1cIiBpcyBhbiBlbWl0dGVkIGNodW5rLmApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdW1lZEZpbGUuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJyQXNzZXRTb3VyY2VBbHJlYWR5U2V0KGNvbnN1bWVkRmlsZS5uYW1lIHx8IHJlZmVyZW5jZUlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBnZXRWYWxpZFNvdXJjZShyZXF1ZXN0ZWRTb3VyY2UsIGNvbnN1bWVkRmlsZSwgcmVmZXJlbmNlSWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUFzc2V0KGNvbnN1bWVkRmlsZSwgc291cmNlLCByZWZlcmVuY2VJZCwgdGhpcy5idW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3VtZWRGaWxlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRCdW5kbGUgPSAob3V0cHV0QnVuZGxlLCBvdXRwdXRPcHRpb25zLCBmYWNhZGVDaHVua0J5TW9kdWxlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dE9wdGlvbnMgPSBvdXRwdXRPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5idW5kbGUgPSBvdXRwdXRCdW5kbGU7XG4gICAgICAgICAgICB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUgPSBmYWNhZGVDaHVua0J5TW9kdWxlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbWl0dGVkRmlsZSBvZiB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVkRmlsZS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNlcnZlRmlsZU5hbWVJbkJ1bmRsZShlbWl0dGVkRmlsZS5maWxlTmFtZSwgdGhpcy5idW5kbGUsIHRoaXMub3B0aW9ucy5vbndhcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlZmVyZW5jZUlkLCBjb25zdW1lZEZpbGVdIG9mIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkRmlsZS50eXBlID09PSAnYXNzZXQnICYmIGNvbnN1bWVkRmlsZS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplQXNzZXQoY29uc3VtZWRGaWxlLCBjb25zdW1lZEZpbGUuc291cmNlLCByZWZlcmVuY2VJZCwgdGhpcy5idW5kbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQgPSBiYXNlRmlsZUVtaXR0ZXJcbiAgICAgICAgICAgID8gbmV3IE1hcChiYXNlRmlsZUVtaXR0ZXIuZmlsZXNCeVJlZmVyZW5jZUlkKVxuICAgICAgICAgICAgOiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzc2lnblJlZmVyZW5jZUlkKGZpbGUsIGlkQmFzZSkge1xuICAgICAgICBsZXQgcmVmZXJlbmNlSWQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkID0gY3JlYXRlSGFzaCgpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShyZWZlcmVuY2VJZCB8fCBpZEJhc2UpXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIDgpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5oYXMocmVmZXJlbmNlSWQpKTtcbiAgICAgICAgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQuc2V0KHJlZmVyZW5jZUlkLCBmaWxlKTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUlkO1xuICAgIH1cbiAgICBlbWl0QXNzZXQoZW1pdHRlZEFzc2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHR5cGVvZiBlbWl0dGVkQXNzZXQuc291cmNlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBnZXRWYWxpZFNvdXJjZShlbWl0dGVkQXNzZXQuc291cmNlLCBlbWl0dGVkQXNzZXQsIG51bGwpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY29uc3VtZWRBc3NldCA9IHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBlbWl0dGVkQXNzZXQuZmlsZU5hbWUsXG4gICAgICAgICAgICBuYW1lOiBlbWl0dGVkQXNzZXQubmFtZSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHR5cGU6ICdhc3NldCdcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSWQgPSB0aGlzLmFzc2lnblJlZmVyZW5jZUlkKGNvbnN1bWVkQXNzZXQsIGVtaXR0ZWRBc3NldC5maWxlTmFtZSB8fCBlbWl0dGVkQXNzZXQubmFtZSB8fCBlbWl0dGVkQXNzZXQudHlwZSk7XG4gICAgICAgIGlmICh0aGlzLmJ1bmRsZSkge1xuICAgICAgICAgICAgaWYgKGVtaXR0ZWRBc3NldC5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc2VydmVGaWxlTmFtZUluQnVuZGxlKGVtaXR0ZWRBc3NldC5maWxlTmFtZSwgdGhpcy5idW5kbGUsIHRoaXMub3B0aW9ucy5vbndhcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUFzc2V0KGNvbnN1bWVkQXNzZXQsIHNvdXJjZSwgcmVmZXJlbmNlSWQsIHRoaXMuYnVuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSWQ7XG4gICAgfVxuICAgIGVtaXRDaHVuayhlbWl0dGVkQ2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgucGhhc2UgPiBCdWlsZFBoYXNlLkxPQURfQU5EX1BBUlNFKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZFJvbGx1cFBoYXNlRm9yQ2h1bmtFbWlzc2lvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZWRDaHVuay5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJGYWlsZWRWYWxpZGF0aW9uKGBFbWl0dGVkIGNodW5rcyBuZWVkIHRvIGhhdmUgYSB2YWxpZCBzdHJpbmcgaWQsIHJlY2VpdmVkIFwiJHtlbWl0dGVkQ2h1bmsuaWR9XCJgKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uc3VtZWRDaHVuayA9IHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBlbWl0dGVkQ2h1bmsuZmlsZU5hbWUsXG4gICAgICAgICAgICBtb2R1bGU6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBlbWl0dGVkQ2h1bmsubmFtZSB8fCBlbWl0dGVkQ2h1bmsuaWQsXG4gICAgICAgICAgICB0eXBlOiAnY2h1bmsnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ3JhcGgubW9kdWxlTG9hZGVyXG4gICAgICAgICAgICAuZW1pdENodW5rKGVtaXR0ZWRDaHVuaylcbiAgICAgICAgICAgIC50aGVuKG1vZHVsZSA9PiAoY29uc3VtZWRDaHVuay5tb2R1bGUgPSBtb2R1bGUpKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEF2b2lkIHVuaGFuZGxlZCBQcm9taXNlIHJlamVjdGlvbiBhcyB0aGUgZXJyb3Igd2lsbCBiZSB0aHJvd24gbGF0ZXJcbiAgICAgICAgICAgIC8vIG9uY2UgbW9kdWxlIGxvYWRpbmcgaGFzIGZpbmlzaGVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NpZ25SZWZlcmVuY2VJZChjb25zdW1lZENodW5rLCBlbWl0dGVkQ2h1bmsuaWQpO1xuICAgIH1cbiAgICBmaW5hbGl6ZUFzc2V0KGNvbnN1bWVkRmlsZSwgc291cmNlLCByZWZlcmVuY2VJZCwgYnVuZGxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gY29uc3VtZWRGaWxlLmZpbGVOYW1lIHx8XG4gICAgICAgICAgICBmaW5kRXhpc3RpbmdBc3NldEZpbGVOYW1lV2l0aFNvdXJjZShidW5kbGUsIHNvdXJjZSkgfHxcbiAgICAgICAgICAgIGdlbmVyYXRlQXNzZXRGaWxlTmFtZShjb25zdW1lZEZpbGUubmFtZSwgc291cmNlLCB0aGlzLm91dHB1dE9wdGlvbnMsIGJ1bmRsZSk7XG4gICAgICAgIC8vIFdlIG11c3Qgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXNzZXRzIHRvIGF2b2lkIGludGVyYWN0aW9uIGJldHdlZW4gb3V0cHV0c1xuICAgICAgICBjb25zdCBhc3NldFdpdGhGaWxlTmFtZSA9IHsgLi4uY29uc3VtZWRGaWxlLCBmaWxlTmFtZSwgc291cmNlIH07XG4gICAgICAgIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLnNldChyZWZlcmVuY2VJZCwgYXNzZXRXaXRoRmlsZU5hbWUpO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGJ1bmRsZVtmaWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgICAgIGdldCBpc0Fzc2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbignQWNjZXNzaW5nIFwiaXNBc3NldFwiIG9uIGZpbGVzIGluIHRoZSBidW5kbGUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcInR5cGUgPT09IFxcJ2Fzc2V0XFwnXCIgaW5zdGVhZCcsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IGNvbnN1bWVkRmlsZS5uYW1lLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdHlwZTogJ2Fzc2V0J1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRFeGlzdGluZ0Fzc2V0RmlsZU5hbWVXaXRoU291cmNlKGJ1bmRsZSwgc291cmNlKSB7XG4gICAgZm9yIChjb25zdCBbZmlsZU5hbWUsIG91dHB1dEZpbGVdIG9mIE9iamVjdC5lbnRyaWVzKGJ1bmRsZSkpIHtcbiAgICAgICAgaWYgKG91dHB1dEZpbGUudHlwZSA9PT0gJ2Fzc2V0JyAmJiBhcmVTb3VyY2VzRXF1YWwoc291cmNlLCBvdXRwdXRGaWxlLnNvdXJjZSkpXG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXJlU291cmNlc0VxdWFsKHNvdXJjZUEsIHNvdXJjZUIpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VBID09PSBzb3VyY2VCO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZUIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCdlcXVhbHMnIGluIHNvdXJjZUEpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZUEuZXF1YWxzKHNvdXJjZUIpO1xuICAgIH1cbiAgICBpZiAoc291cmNlQS5sZW5ndGggIT09IHNvdXJjZUIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHNvdXJjZUEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChzb3VyY2VBW2luZGV4XSAhPT0gc291cmNlQltpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgY29uY2F0U2VwID0gKG91dCwgbmV4dCkgPT4gKG5leHQgPyBgJHtvdXR9XFxuJHtuZXh0fWAgOiBvdXQpO1xuY29uc3QgY29uY2F0RGJsU2VwID0gKG91dCwgbmV4dCkgPT4gKG5leHQgPyBgJHtvdXR9XFxuXFxuJHtuZXh0fWAgOiBvdXQpO1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWRkb25zKG9wdGlvbnMsIG91dHB1dFBsdWdpbkRyaXZlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBbYmFubmVyLCBmb290ZXIsIGludHJvLCBvdXRyb10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBvdXRwdXRQbHVnaW5Ecml2ZXIuaG9va1JlZHVjZVZhbHVlKCdiYW5uZXInLCBvcHRpb25zLmJhbm5lcigpLCBbXSwgY29uY2F0U2VwKSxcbiAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlci5ob29rUmVkdWNlVmFsdWUoJ2Zvb3RlcicsIG9wdGlvbnMuZm9vdGVyKCksIFtdLCBjb25jYXRTZXApLFxuICAgICAgICAgICAgb3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tSZWR1Y2VWYWx1ZSgnaW50cm8nLCBvcHRpb25zLmludHJvKCksIFtdLCBjb25jYXREYmxTZXApLFxuICAgICAgICAgICAgb3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tSZWR1Y2VWYWx1ZSgnb3V0cm8nLCBvcHRpb25zLm91dHJvKCksIFtdLCBjb25jYXREYmxTZXApXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaW50cm8pXG4gICAgICAgICAgICBpbnRybyArPSAnXFxuXFxuJztcbiAgICAgICAgaWYgKG91dHJvKVxuICAgICAgICAgICAgb3V0cm8gPSBgXFxuXFxuJHtvdXRyb31gO1xuICAgICAgICBpZiAoYmFubmVyLmxlbmd0aClcbiAgICAgICAgICAgIGJhbm5lciArPSAnXFxuJztcbiAgICAgICAgaWYgKGZvb3Rlci5sZW5ndGgpXG4gICAgICAgICAgICBmb290ZXIgPSAnXFxuJyArIGZvb3RlcjtcbiAgICAgICAgcmV0dXJuIHsgYmFubmVyLCBmb290ZXIsIGludHJvLCBvdXRybyB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAnQURET05fRVJST1InLFxuICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCByZXRyaWV2ZSAke2Vyci5ob29rfS4gQ2hlY2sgY29uZmlndXJhdGlvbiBvZiBwbHVnaW4gJHtlcnIucGx1Z2lufS5cblxcdEVycm9yIE1lc3NhZ2U6ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENodW5rQXNzaWdubWVudHMoZW50cnlNb2R1bGVzLCBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSkge1xuICAgIGNvbnN0IGNodW5rRGVmaW5pdGlvbnMgPSBbXTtcbiAgICBjb25zdCBtb2R1bGVzSW5NYW51YWxDaHVua3MgPSBuZXcgU2V0KG1hbnVhbENodW5rQWxpYXNCeUVudHJ5LmtleXMoKSk7XG4gICAgY29uc3QgbWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBbZW50cnksIGFsaWFzXSBvZiBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSkge1xuICAgICAgICBjb25zdCBjaHVua01vZHVsZXMgPSAobWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhc1thbGlhc10gPVxuICAgICAgICAgICAgbWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhc1thbGlhc10gfHwgW10pO1xuICAgICAgICBhZGRTdGF0aWNEZXBlbmRlbmNpZXNUb01hbnVhbENodW5rKGVudHJ5LCBjaHVua01vZHVsZXMsIG1vZHVsZXNJbk1hbnVhbENodW5rcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2FsaWFzLCBtb2R1bGVzXSBvZiBPYmplY3QuZW50cmllcyhtYW51YWxDaHVua01vZHVsZXNCeUFsaWFzKSkge1xuICAgICAgICBjaHVua0RlZmluaXRpb25zLnB1c2goeyBhbGlhcywgbW9kdWxlcyB9KTtcbiAgICB9XG4gICAgY29uc3QgYXNzaWduZWRFbnRyeVBvaW50c0J5TW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHsgZGVwZW5kZW50RW50cnlQb2ludHNCeU1vZHVsZSwgZHluYW1pY0VudHJ5TW9kdWxlcyB9ID0gYW5hbHl6ZU1vZHVsZUdyYXBoKGVudHJ5TW9kdWxlcyk7XG4gICAgY29uc3QgZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyeVBvaW50c0J5RHluYW1pY0VudHJ5ID0gZ2V0RHluYW1pY0RlcGVuZGVudEVudHJ5UG9pbnRzKGRlcGVuZGVudEVudHJ5UG9pbnRzQnlNb2R1bGUsIGR5bmFtaWNFbnRyeU1vZHVsZXMpO1xuICAgIGNvbnN0IHN0YXRpY0VudHJpZXMgPSBuZXcgU2V0KGVudHJ5TW9kdWxlcyk7XG4gICAgZnVuY3Rpb24gYXNzaWduRW50cnlUb1N0YXRpY0RlcGVuZGVuY2llcyhlbnRyeSwgZHluYW1pY0RlcGVuZGVudEVudHJ5UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXNUb0hhbmRsZSA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNUb0hhbmRsZSkge1xuICAgICAgICAgICAgY29uc3QgYXNzaWduZWRFbnRyeVBvaW50cyA9IGdldE9yQ3JlYXRlKGFzc2lnbmVkRW50cnlQb2ludHNCeU1vZHVsZSwgbW9kdWxlLCAoKSA9PiBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNEZXBlbmRlbnRFbnRyeVBvaW50cyAmJlxuICAgICAgICAgICAgICAgIGFyZUVudHJ5UG9pbnRzQ29udGFpbmVkT3JEeW5hbWljYWxseURlcGVuZGVudChkeW5hbWljRGVwZW5kZW50RW50cnlQb2ludHMsIGRlcGVuZGVudEVudHJ5UG9pbnRzQnlNb2R1bGUuZ2V0KG1vZHVsZSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25lZEVudHJ5UG9pbnRzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgbW9kdWxlLmdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlIHx8IG1vZHVsZXNJbk1hbnVhbENodW5rcy5oYXMoZGVwZW5kZW5jeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXNUb0hhbmRsZS5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUVudHJ5UG9pbnRzQ29udGFpbmVkT3JEeW5hbWljYWxseURlcGVuZGVudChlbnRyeVBvaW50cywgY29udGFpbmVkSW4pIHtcbiAgICAgICAgY29uc3QgZW50cmllc1RvQ2hlY2sgPSBuZXcgU2V0KGVudHJ5UG9pbnRzKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzVG9DaGVjaykge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZWRJbi5oYXMoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY0VudHJpZXMuaGFzKGVudHJ5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cnlQb2ludHMgPSBkeW5hbWljYWxseURlcGVuZGVudEVudHJ5UG9pbnRzQnlEeW5hbWljRW50cnkuZ2V0KGVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVudEVudHJ5IG9mIGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cnlQb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc1RvQ2hlY2suYWRkKGRlcGVuZGVudEVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlNb2R1bGVzKSB7XG4gICAgICAgIGlmICghbW9kdWxlc0luTWFudWFsQ2h1bmtzLmhhcyhlbnRyeSkpIHtcbiAgICAgICAgICAgIGFzc2lnbkVudHJ5VG9TdGF0aWNEZXBlbmRlbmNpZXMoZW50cnksIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZHluYW1pY0VudHJ5TW9kdWxlcykge1xuICAgICAgICBpZiAoIW1vZHVsZXNJbk1hbnVhbENodW5rcy5oYXMoZW50cnkpKSB7XG4gICAgICAgICAgICBhc3NpZ25FbnRyeVRvU3RhdGljRGVwZW5kZW5jaWVzKGVudHJ5LCBkeW5hbWljYWxseURlcGVuZGVudEVudHJ5UG9pbnRzQnlEeW5hbWljRW50cnkuZ2V0KGVudHJ5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2h1bmtEZWZpbml0aW9ucy5wdXNoKC4uLmNyZWF0ZUNodW5rcyhbLi4uZW50cnlNb2R1bGVzLCAuLi5keW5hbWljRW50cnlNb2R1bGVzXSwgYXNzaWduZWRFbnRyeVBvaW50c0J5TW9kdWxlKSk7XG4gICAgcmV0dXJuIGNodW5rRGVmaW5pdGlvbnM7XG59XG5mdW5jdGlvbiBhZGRTdGF0aWNEZXBlbmRlbmNpZXNUb01hbnVhbENodW5rKGVudHJ5LCBtYW51YWxDaHVua01vZHVsZXMsIG1vZHVsZXNJbk1hbnVhbENodW5rcykge1xuICAgIGNvbnN0IG1vZHVsZXNUb0hhbmRsZSA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc1RvSGFuZGxlKSB7XG4gICAgICAgIG1vZHVsZXNJbk1hbnVhbENodW5rcy5hZGQobW9kdWxlKTtcbiAgICAgICAgbWFudWFsQ2h1bmtNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSB8fCBtb2R1bGVzSW5NYW51YWxDaHVua3MuaGFzKGRlcGVuZGVuY3kpKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZXNUb0hhbmRsZS5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhbmFseXplTW9kdWxlR3JhcGgoZW50cnlNb2R1bGVzKSB7XG4gICAgY29uc3QgZHluYW1pY0VudHJ5TW9kdWxlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkZXBlbmRlbnRFbnRyeVBvaW50c0J5TW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVudHJpZXNUb0hhbmRsZSA9IG5ldyBTZXQoZW50cnlNb2R1bGVzKTtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRFbnRyeSBvZiBlbnRyaWVzVG9IYW5kbGUpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlc1RvSGFuZGxlID0gbmV3IFNldChbY3VycmVudEVudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNUb0hhbmRsZSkge1xuICAgICAgICAgICAgZ2V0T3JDcmVhdGUoZGVwZW5kZW50RW50cnlQb2ludHNCeU1vZHVsZSwgbW9kdWxlLCAoKSA9PiBuZXcgU2V0KCkpLmFkZChjdXJyZW50RW50cnkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlc1RvSGFuZGxlLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x1dGlvbiB9IG9mIG1vZHVsZS5keW5hbWljSW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHV0aW9uIGluc3RhbmNlb2YgTW9kdWxlICYmIHJlc29sdXRpb24uaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0VudHJ5TW9kdWxlcy5hZGQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNUb0hhbmRsZS5hZGQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0VudHJ5TW9kdWxlcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgZW50cmllc1RvSGFuZGxlLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZXBlbmRlbnRFbnRyeVBvaW50c0J5TW9kdWxlLCBkeW5hbWljRW50cnlNb2R1bGVzIH07XG59XG5mdW5jdGlvbiBnZXREeW5hbWljRGVwZW5kZW50RW50cnlQb2ludHMoZGVwZW5kZW50RW50cnlQb2ludHNCeU1vZHVsZSwgZHluYW1pY0VudHJ5TW9kdWxlcykge1xuICAgIGNvbnN0IGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cnlQb2ludHNCeUR5bmFtaWNFbnRyeSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGR5bmFtaWNFbnRyeSBvZiBkeW5hbWljRW50cnlNb2R1bGVzKSB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNEZXBlbmRlbnRFbnRyeVBvaW50cyA9IGdldE9yQ3JlYXRlKGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cnlQb2ludHNCeUR5bmFtaWNFbnRyeSwgZHluYW1pY0VudHJ5LCAoKSA9PiBuZXcgU2V0KCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGltcG9ydGVyIG9mIFtcbiAgICAgICAgICAgIC4uLmR5bmFtaWNFbnRyeS5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMsXG4gICAgICAgICAgICAuLi5keW5hbWljRW50cnkuaW1wbGljaXRseUxvYWRlZEFmdGVyXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnlQb2ludCBvZiBkZXBlbmRlbnRFbnRyeVBvaW50c0J5TW9kdWxlLmdldChpbXBvcnRlcikpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljRGVwZW5kZW50RW50cnlQb2ludHMuYWRkKGVudHJ5UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkeW5hbWljYWxseURlcGVuZGVudEVudHJ5UG9pbnRzQnlEeW5hbWljRW50cnk7XG59XG5mdW5jdGlvbiBjcmVhdGVDaHVua3MoYWxsRW50cnlQb2ludHMsIGFzc2lnbmVkRW50cnlQb2ludHNCeU1vZHVsZSkge1xuICAgIGNvbnN0IGNodW5rTW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBbbW9kdWxlLCBhc3NpZ25lZEVudHJ5UG9pbnRzXSBvZiBhc3NpZ25lZEVudHJ5UG9pbnRzQnlNb2R1bGUpIHtcbiAgICAgICAgbGV0IGNodW5rU2lnbmF0dXJlID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgYWxsRW50cnlQb2ludHMpIHtcbiAgICAgICAgICAgIGNodW5rU2lnbmF0dXJlICs9IGFzc2lnbmVkRW50cnlQb2ludHMuaGFzKGVudHJ5KSA/ICdYJyA6ICdfJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IGNodW5rTW9kdWxlc1tjaHVua1NpZ25hdHVyZV07XG4gICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgY2h1bmsucHVzaChtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2h1bmtNb2R1bGVzW2NodW5rU2lnbmF0dXJlXSA9IFttb2R1bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGNodW5rTW9kdWxlcykubWFwKG1vZHVsZXMgPT4gKHtcbiAgICAgICAgYWxpYXM6IG51bGwsXG4gICAgICAgIG1vZHVsZXNcbiAgICB9KSk7XG59XG5cbi8vIHBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9ub2RlLWNvbW1vbmRpclxuZnVuY3Rpb24gY29tbW9uZGlyKGZpbGVzKSB7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gZGlybmFtZShmaWxlc1swXSk7XG4gICAgY29uc3QgY29tbW9uU2VnbWVudHMgPSBmaWxlcy5zbGljZSgxKS5yZWR1Y2UoKGNvbW1vblNlZ21lbnRzLCBmaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGhTZWdlbWVudHMgPSBmaWxlLnNwbGl0KC9cXC8rfFxcXFwrLyk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBjb21tb25TZWdtZW50c1tpXSA9PT0gcGF0aFNlZ2VtZW50c1tpXSAmJlxuICAgICAgICAgICAgaSA8IE1hdGgubWluKGNvbW1vblNlZ21lbnRzLmxlbmd0aCwgcGF0aFNlZ2VtZW50cy5sZW5ndGgpOyBpKyspXG4gICAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBjb21tb25TZWdtZW50cy5zbGljZSgwLCBpKTtcbiAgICB9LCBmaWxlc1swXS5zcGxpdCgvXFwvK3xcXFxcKy8pKTtcbiAgICAvLyBXaW5kb3dzIGNvcnJlY3RseSBoYW5kbGVzIHBhdGhzIHdpdGggZm9yd2FyZC1zbGFzaGVzXG4gICAgcmV0dXJuIGNvbW1vblNlZ21lbnRzLmxlbmd0aCA+IDEgPyBjb21tb25TZWdtZW50cy5qb2luKCcvJykgOiAnLyc7XG59XG5cbmNvbnN0IGNvbXBhcmVFeGVjSW5kZXggPSAodW5pdEEsIHVuaXRCKSA9PiB1bml0QS5leGVjSW5kZXggPiB1bml0Qi5leGVjSW5kZXggPyAxIDogLTE7XG5mdW5jdGlvbiBzb3J0QnlFeGVjdXRpb25PcmRlcih1bml0cykge1xuICAgIHVuaXRzLnNvcnQoY29tcGFyZUV4ZWNJbmRleCk7XG59XG5mdW5jdGlvbiBhbmFseXNlTW9kdWxlRXhlY3V0aW9uKGVudHJ5TW9kdWxlcykge1xuICAgIGxldCBuZXh0RXhlY0luZGV4ID0gMDtcbiAgICBjb25zdCBjeWNsZVBhdGhzID0gW107XG4gICAgY29uc3QgYW5hbHlzZWRNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGR5bmFtaWNJbXBvcnRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb3JkZXJlZE1vZHVsZXMgPSBbXTtcbiAgICBjb25zdCBhbmFseXNlTW9kdWxlID0gKG1vZHVsZSkgPT4ge1xuICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgbW9kdWxlLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzLmhhcyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuYWx5c2VkTW9kdWxlcy5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlUGF0aHMucHVzaChnZXRDeWNsZVBhdGgoZGVwZW5kZW5jeSwgbW9kdWxlLCBwYXJlbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMuc2V0KGRlcGVuZGVuY3ksIG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgYW5hbHlzZU1vZHVsZShkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBtb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgbW9kdWxlLmR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdXRpb24gaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0ltcG9ydHMuYWRkKHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yZGVyZWRNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUuZXhlY0luZGV4ID0gbmV4dEV4ZWNJbmRleCsrO1xuICAgICAgICBhbmFseXNlZE1vZHVsZXMuYWRkKG1vZHVsZSk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGN1ckVudHJ5IG9mIGVudHJ5TW9kdWxlcykge1xuICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGN1ckVudHJ5KSkge1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VyRW50cnksIG51bGwpO1xuICAgICAgICAgICAgYW5hbHlzZU1vZHVsZShjdXJFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBjdXJFbnRyeSBvZiBkeW5hbWljSW1wb3J0cykge1xuICAgICAgICBpZiAoIXBhcmVudHMuaGFzKGN1ckVudHJ5KSkge1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VyRW50cnksIG51bGwpO1xuICAgICAgICAgICAgYW5hbHlzZU1vZHVsZShjdXJFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY3ljbGVQYXRocywgb3JkZXJlZE1vZHVsZXMgfTtcbn1cbmZ1bmN0aW9uIGdldEN5Y2xlUGF0aChtb2R1bGUsIHBhcmVudCwgcGFyZW50cykge1xuICAgIGNvbnN0IGN5Y2xlU3ltYm9sID0gU3ltYm9sKG1vZHVsZS5pZCk7XG4gICAgY29uc3QgcGF0aCA9IFtyZWxhdGl2ZUlkKG1vZHVsZS5pZCldO1xuICAgIGxldCBuZXh0TW9kdWxlID0gcGFyZW50O1xuICAgIG1vZHVsZS5jeWNsZXMuYWRkKGN5Y2xlU3ltYm9sKTtcbiAgICB3aGlsZSAobmV4dE1vZHVsZSAhPT0gbW9kdWxlKSB7XG4gICAgICAgIG5leHRNb2R1bGUuY3ljbGVzLmFkZChjeWNsZVN5bWJvbCk7XG4gICAgICAgIHBhdGgucHVzaChyZWxhdGl2ZUlkKG5leHRNb2R1bGUuaWQpKTtcbiAgICAgICAgbmV4dE1vZHVsZSA9IHBhcmVudHMuZ2V0KG5leHRNb2R1bGUpO1xuICAgIH1cbiAgICBwYXRoLnB1c2gocGF0aFswXSk7XG4gICAgcGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldEdlbmVyYXRlQ29kZVNuaXBwZXRzKHsgY29tcGFjdCwgZ2VuZXJhdGVkQ29kZTogeyBhcnJvd0Z1bmN0aW9ucywgY29uc3RCaW5kaW5ncywgb2JqZWN0U2hvcnRoYW5kLCByZXNlcnZlZE5hbWVzQXNQcm9wcyB9IH0pIHtcbiAgICBjb25zdCB7IF8sIG4sIHMgfSA9IGNvbXBhY3QgPyB7IF86ICcnLCBuOiAnJywgczogJycgfSA6IHsgXzogJyAnLCBuOiAnXFxuJywgczogJzsnIH07XG4gICAgY29uc3QgY25zdCA9IGNvbnN0QmluZGluZ3MgPyAnY29uc3QnIDogJ3Zhcic7XG4gICAgY29uc3QgZ2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvID0gKHBhcmFtcywgeyBpc0FzeW5jLCBuYW1lIH0pID0+IGAke2lzQXN5bmMgPyBgYXN5bmMgYCA6ICcnfWZ1bmN0aW9uJHtuYW1lID8gYCAke25hbWV9YCA6ICcnfSR7X30oJHtwYXJhbXMuam9pbihgLCR7X31gKX0pJHtffWA7XG4gICAgY29uc3QgZ2V0RnVuY3Rpb25JbnRybyA9IGFycm93RnVuY3Rpb25zXG4gICAgICAgID8gKHBhcmFtcywgeyBpc0FzeW5jLCBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpbmdsZVBhcmFtID0gcGFyYW1zLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGNvbnN0IGFzeW5jU3RyaW5nID0gaXNBc3luYyA/IGBhc3luYyR7c2luZ2xlUGFyYW0gPyAnICcgOiBffWAgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lID8gYCR7Y25zdH0gJHtuYW1lfSR7X309JHtffWAgOiAnJ30ke2FzeW5jU3RyaW5nfSR7c2luZ2xlUGFyYW0gPyBwYXJhbXNbMF0gOiBgKCR7cGFyYW1zLmpvaW4oYCwke199YCl9KWB9JHtffT0+JHtffWA7XG4gICAgICAgIH1cbiAgICAgICAgOiBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm87XG4gICAgY29uc3QgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24gPSAocGFyYW1zLCB7IGZ1bmN0aW9uUmV0dXJuLCBsaW5lQnJlYWtJbmRlbnQsIG5hbWUgfSkgPT4gW1xuICAgICAgICBgJHtnZXRGdW5jdGlvbkludHJvKHBhcmFtcywge1xuICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgIH0pfSR7YXJyb3dGdW5jdGlvbnNcbiAgICAgICAgICAgID8gbGluZUJyZWFrSW5kZW50XG4gICAgICAgICAgICAgICAgPyBgJHtufSR7bGluZUJyZWFrSW5kZW50LmJhc2V9JHtsaW5lQnJlYWtJbmRlbnQudH1gXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgOiBgeyR7bGluZUJyZWFrSW5kZW50ID8gYCR7bn0ke2xpbmVCcmVha0luZGVudC5iYXNlfSR7bGluZUJyZWFrSW5kZW50LnR9YCA6IF99JHtmdW5jdGlvblJldHVybiA/ICdyZXR1cm4gJyA6ICcnfWB9YCxcbiAgICAgICAgYXJyb3dGdW5jdGlvbnNcbiAgICAgICAgICAgID8gYCR7bmFtZSA/ICc7JyA6ICcnfSR7bGluZUJyZWFrSW5kZW50ID8gYCR7bn0ke2xpbmVCcmVha0luZGVudC5iYXNlfWAgOiAnJ31gXG4gICAgICAgICAgICA6IGAke3N9JHtsaW5lQnJlYWtJbmRlbnQgPyBgJHtufSR7bGluZUJyZWFrSW5kZW50LmJhc2V9YCA6IF99fWBcbiAgICBdO1xuICAgIGNvbnN0IGlzVmFsaWRQcm9wTmFtZSA9IHJlc2VydmVkTmFtZXNBc1Byb3BzXG4gICAgICAgID8gKG5hbWUpID0+IHZhbGlkUHJvcE5hbWUudGVzdChuYW1lKVxuICAgICAgICA6IChuYW1lKSA9PiAhUkVTRVJWRURfTkFNRVMkMS5oYXMobmFtZSkgJiYgdmFsaWRQcm9wTmFtZS50ZXN0KG5hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIF8sXG4gICAgICAgIGNuc3QsXG4gICAgICAgIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLFxuICAgICAgICBnZXREaXJlY3RSZXR1cm5JaWZlTGVmdDogKHBhcmFtcywgcmV0dXJuZWQsIHsgbmVlZHNBcnJvd1JldHVyblBhcmVucywgbmVlZHNXcmFwcGVkRnVuY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKHBhcmFtcywge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBgJHt3cmFwSWZOZWVkZWQoYCR7bGVmdH0ke3dyYXBJZk5lZWRlZChyZXR1cm5lZCwgYXJyb3dGdW5jdGlvbnMgJiYgbmVlZHNBcnJvd1JldHVyblBhcmVucyl9JHtyaWdodH1gLCBhcnJvd0Z1bmN0aW9ucyB8fCBuZWVkc1dyYXBwZWRGdW5jdGlvbil9KGA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEZ1bmN0aW9uSW50cm8sXG4gICAgICAgIGdldE5vbkFycm93RnVuY3Rpb25JbnRybyxcbiAgICAgICAgZ2V0T2JqZWN0KGZpZWxkcywgeyBsaW5lQnJlYWtJbmRlbnQgfSkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gbGluZUJyZWFrSW5kZW50ID8gYCR7bn0ke2xpbmVCcmVha0luZGVudC5iYXNlfSR7bGluZUJyZWFrSW5kZW50LnR9YCA6IF87XG4gICAgICAgICAgICByZXR1cm4gYHske2ZpZWxkc1xuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRzUXVvdGVzID0gIWlzVmFsaWRQcm9wTmFtZShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHZhbHVlICYmIG9iamVjdFNob3J0aGFuZCAmJiAhbmVlZHNRdW90ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBwcmVmaXggKyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtwcmVmaXh9JHtuZWVkc1F1b3RlcyA/IGAnJHtrZXl9J2AgOiBrZXl9OiR7X30ke3ZhbHVlfWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKGAsYCl9JHtmaWVsZHMubGVuZ3RoID09PSAwID8gJycgOiBsaW5lQnJlYWtJbmRlbnQgPyBgJHtufSR7bGluZUJyZWFrSW5kZW50LmJhc2V9YCA6IF99fWA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByb3BlcnR5QWNjZXNzOiAobmFtZSkgPT4gaXNWYWxpZFByb3BOYW1lKG5hbWUpID8gYC4ke25hbWV9YCA6IGBbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYCxcbiAgICAgICAgbixcbiAgICAgICAgc1xuICAgIH07XG59XG5jb25zdCB3cmFwSWZOZWVkZWQgPSAoY29kZSwgbmVlZHNQYXJlbnMpID0+IG5lZWRzUGFyZW5zID8gYCgke2NvZGV9KWAgOiBjb2RlO1xuY29uc3QgdmFsaWRQcm9wTmFtZSA9IC9eKD8hXFxkKVtcXHckXSskLztcblxuY2xhc3MgQnVuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMsIGlucHV0T3B0aW9ucywgcGx1Z2luRHJpdmVyLCBncmFwaCkge1xuICAgICAgICB0aGlzLm91dHB1dE9wdGlvbnMgPSBvdXRwdXRPcHRpb25zO1xuICAgICAgICB0aGlzLnVuc2V0T3B0aW9ucyA9IHVuc2V0T3B0aW9ucztcbiAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnM7XG4gICAgICAgIHRoaXMucGx1Z2luRHJpdmVyID0gcGx1Z2luRHJpdmVyO1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlKGlzV3JpdGUpIHtcbiAgICAgICAgdGltZVN0YXJ0KCdHRU5FUkFURScsIDEpO1xuICAgICAgICBjb25zdCBvdXRwdXRCdW5kbGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnBsdWdpbkRyaXZlci5zZXRPdXRwdXRCdW5kbGUob3V0cHV0QnVuZGxlLCB0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoJ3JlbmRlclN0YXJ0JywgW3RoaXMub3V0cHV0T3B0aW9ucywgdGhpcy5pbnB1dE9wdGlvbnNdKTtcbiAgICAgICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgY2h1bmtzJywgMik7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ2h1bmtzKCk7XG4gICAgICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZU9wdGlvbnNGb3JNdWx0aUNodW5rT3V0cHV0KHRoaXMub3V0cHV0T3B0aW9ucywgdGhpcy5pbnB1dE9wdGlvbnMub253YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0QmFzZSA9IGNvbW1vbmRpcihnZXRBYnNvbHV0ZUVudHJ5TW9kdWxlUGF0aHMoY2h1bmtzKSk7XG4gICAgICAgICAgICB0aW1lRW5kKCdnZW5lcmF0ZSBjaHVua3MnLCAyKTtcbiAgICAgICAgICAgIHRpbWVTdGFydCgncmVuZGVyIG1vZHVsZXMnLCAyKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFkZG9ucyBiZWZvcmUgcHJlcmVuZGVyIGJlY2F1c2UgYXQgdGhlIG1vbWVudCwgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbiBiZSBubyBhc3luYyBjb2RlIGJldHdlZW4gcHJlcmVuZGVyIGFuZCByZW5kZXIgZHVlIHRvIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBhZGRvbnMgPSBhd2FpdCBjcmVhdGVBZGRvbnModGhpcy5vdXRwdXRPcHRpb25zLCB0aGlzLnBsdWdpbkRyaXZlcik7XG4gICAgICAgICAgICBjb25zdCBzbmlwcGV0cyA9IGdldEdlbmVyYXRlQ29kZVNuaXBwZXRzKHRoaXMub3V0cHV0T3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnByZXJlbmRlckNodW5rcyhjaHVua3MsIGlucHV0QmFzZSwgc25pcHBldHMpO1xuICAgICAgICAgICAgdGltZUVuZCgncmVuZGVyIG1vZHVsZXMnLCAyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkRmluYWxpemVkQ2h1bmtzVG9CdW5kbGUoY2h1bmtzLCBpbnB1dEJhc2UsIGFkZG9ucywgb3V0cHV0QnVuZGxlLCBzbmlwcGV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdyZW5kZXJFcnJvcicsIFtlcnJdKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rU2VxKCdnZW5lcmF0ZUJ1bmRsZScsIFtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0T3B0aW9ucyxcbiAgICAgICAgICAgIG91dHB1dEJ1bmRsZSxcbiAgICAgICAgICAgIGlzV3JpdGVcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuZmluYWxpc2VBc3NldHMob3V0cHV0QnVuZGxlKTtcbiAgICAgICAgdGltZUVuZCgnR0VORVJBVEUnLCAxKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEJ1bmRsZTtcbiAgICB9XG4gICAgYXN5bmMgYWRkRmluYWxpemVkQ2h1bmtzVG9CdW5kbGUoY2h1bmtzLCBpbnB1dEJhc2UsIGFkZG9ucywgb3V0cHV0QnVuZGxlLCBzbmlwcGV0cykge1xuICAgICAgICB0aGlzLmFzc2lnbkNodW5rSWRzKGNodW5rcywgaW5wdXRCYXNlLCBhZGRvbnMsIG91dHB1dEJ1bmRsZSk7XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBvdXRwdXRCdW5kbGVbY2h1bmsuaWRdID0gY2h1bmsuZ2V0Q2h1bmtJbmZvV2l0aEZpbGVOYW1lcygpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNodW5rcy5tYXAoYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRDaHVuayA9IG91dHB1dEJ1bmRsZVtjaHVuay5pZF07XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dENodW5rLCBhd2FpdCBjaHVuay5yZW5kZXIodGhpcy5vdXRwdXRPcHRpb25zLCBhZGRvbnMsIG91dHB1dENodW5rLCBzbmlwcGV0cykpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZE1hbnVhbENodW5rcyhtYW51YWxDaHVua3MpIHtcbiAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNodW5rRW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKG1hbnVhbENodW5rcykubWFwKGFzeW5jIChbYWxpYXMsIGZpbGVzXSkgPT4gKHtcbiAgICAgICAgICAgIGFsaWFzLFxuICAgICAgICAgICAgZW50cmllczogYXdhaXQgdGhpcy5ncmFwaC5tb2R1bGVMb2FkZXIuYWRkQWRkaXRpb25hbE1vZHVsZXMoZmlsZXMpXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGZvciAoY29uc3QgeyBhbGlhcywgZW50cmllcyB9IG9mIGNodW5rRW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYWRkTW9kdWxlVG9NYW51YWxDaHVuayhhbGlhcywgZW50cnksIG1hbnVhbENodW5rQWxpYXNCeUVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFudWFsQ2h1bmtBbGlhc0J5RW50cnk7XG4gICAgfVxuICAgIGFzc2lnbkNodW5rSWRzKGNodW5rcywgaW5wdXRCYXNlLCBhZGRvbnMsIGJ1bmRsZSkge1xuICAgICAgICBjb25zdCBlbnRyeUNodW5rcyA9IFtdO1xuICAgICAgICBjb25zdCBvdGhlckNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgKGNodW5rLmZhY2FkZU1vZHVsZSAmJiBjaHVuay5mYWNhZGVNb2R1bGUuaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnRcbiAgICAgICAgICAgICAgICA/IGVudHJ5Q2h1bmtzXG4gICAgICAgICAgICAgICAgOiBvdGhlckNodW5rcykucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIGVudHJ5IGNodW5rIG5hbWVzIHRha2UgcHJlY2VkZW5jZSB3aXRoIHJlZ2FyZCB0byBkZWNvbmZsaWN0aW5nXG4gICAgICAgIGNvbnN0IGNodW5rc0Zvck5hbWluZyA9IGVudHJ5Q2h1bmtzLmNvbmNhdChvdGhlckNodW5rcyk7XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzRm9yTmFtaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRPcHRpb25zLmZpbGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5pZCA9IGJhc2VuYW1lKHRoaXMub3V0cHV0T3B0aW9ucy5maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5pZCA9IGNodW5rLmdlbmVyYXRlSWRQcmVzZXJ2ZU1vZHVsZXMoaW5wdXRCYXNlLCB0aGlzLm91dHB1dE9wdGlvbnMsIGJ1bmRsZSwgdGhpcy51bnNldE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuaWQgPSBjaHVuay5nZW5lcmF0ZUlkKGFkZG9ucywgdGhpcy5vdXRwdXRPcHRpb25zLCBidW5kbGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVuZGxlW2NodW5rLmlkXSA9IEZJTEVfUExBQ0VIT0xERVI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduTWFudWFsQ2h1bmtzKGdldE1hbnVhbENodW5rKSB7XG4gICAgICAgIGNvbnN0IG1hbnVhbENodW5rQWxpYXNlc1dpdGhFbnRyeSA9IFtdO1xuICAgICAgICBjb25zdCBtYW51YWxDaHVua3NBcGkgPSB7XG4gICAgICAgICAgICBnZXRNb2R1bGVJZHM6ICgpID0+IHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQua2V5cygpLFxuICAgICAgICAgICAgZ2V0TW9kdWxlSW5mbzogdGhpcy5ncmFwaC5nZXRNb2R1bGVJbmZvXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYW51YWxDaHVua0FsaWFzID0gZ2V0TWFudWFsQ2h1bmsobW9kdWxlLmlkLCBtYW51YWxDaHVua3NBcGkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFudWFsQ2h1bmtBbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFudWFsQ2h1bmtBbGlhc2VzV2l0aEVudHJ5LnB1c2goW21hbnVhbENodW5rQWxpYXMsIG1vZHVsZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYW51YWxDaHVua0FsaWFzZXNXaXRoRW50cnkuc29ydCgoW2FsaWFzQV0sIFthbGlhc0JdKSA9PiBhbGlhc0EgPiBhbGlhc0IgPyAxIDogYWxpYXNBIDwgYWxpYXNCID8gLTEgOiAwKTtcbiAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FsaWFzLCBtb2R1bGVdIG9mIG1hbnVhbENodW5rQWxpYXNlc1dpdGhFbnRyeSkge1xuICAgICAgICAgICAgYWRkTW9kdWxlVG9NYW51YWxDaHVuayhhbGlhcywgbW9kdWxlLCBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbnVhbENodW5rQWxpYXNCeUVudHJ5O1xuICAgIH1cbiAgICBmaW5hbGlzZUFzc2V0cyhvdXRwdXRCdW5kbGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIE9iamVjdC52YWx1ZXMob3V0cHV0QnVuZGxlKSkge1xuICAgICAgICAgICAgaWYgKCFmaWxlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oJ0EgcGx1Z2luIGlzIGRpcmVjdGx5IGFkZGluZyBwcm9wZXJ0aWVzIHRvIHRoZSBidW5kbGUgb2JqZWN0IGluIHRoZSBcImdlbmVyYXRlQnVuZGxlXCIgaG9vay4gVGhpcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgUm9sbHVwIHZlcnNpb24sIHBsZWFzZSB1c2UgXCJ0aGlzLmVtaXRGaWxlXCIgaW5zdGVhZC4nLCB0cnVlLCB0aGlzLmlucHV0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZmlsZS50eXBlID0gJ2Fzc2V0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dE9wdGlvbnMudmFsaWRhdGUgJiYgJ2NvZGUnIGluIGZpbGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmNvbnRleHRQYXJzZShmaWxlLmNvZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SGFzaEJhbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlY21hVmVyc2lvbjogJ2xhdGVzdCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMub253YXJuKGVyckNodW5rSW52YWxpZChmaWxlLCBlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbHVnaW5Ecml2ZXIuZmluYWxpc2VBc3NldHMoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDaHVua3MoKSB7XG4gICAgICAgIGNvbnN0IHsgbWFudWFsQ2h1bmtzIH0gPSB0aGlzLm91dHB1dE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1hbnVhbENodW5rQWxpYXNCeUVudHJ5ID0gdHlwZW9mIG1hbnVhbENodW5rcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5hZGRNYW51YWxDaHVua3MobWFudWFsQ2h1bmtzKVxuICAgICAgICAgICAgOiB0aGlzLmFzc2lnbk1hbnVhbENodW5rcyhtYW51YWxDaHVua3MpO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgY29uc3QgY2h1bmtCeU1vZHVsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCB7IGFsaWFzLCBtb2R1bGVzIH0gb2YgdGhpcy5vdXRwdXRPcHRpb25zLmlubGluZUR5bmFtaWNJbXBvcnRzXG4gICAgICAgICAgICA/IFt7IGFsaWFzOiBudWxsLCBtb2R1bGVzOiBnZXRJbmNsdWRlZE1vZHVsZXModGhpcy5ncmFwaC5tb2R1bGVzQnlJZCkgfV1cbiAgICAgICAgICAgIDogdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlc1xuICAgICAgICAgICAgICAgID8gZ2V0SW5jbHVkZWRNb2R1bGVzKHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQpLm1hcChtb2R1bGUgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgYWxpYXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXM6IFttb2R1bGVdXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgOiBnZXRDaHVua0Fzc2lnbm1lbnRzKHRoaXMuZ3JhcGguZW50cnlNb2R1bGVzLCBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSkpIHtcbiAgICAgICAgICAgIHNvcnRCeUV4ZWN1dGlvbk9yZGVyKG1vZHVsZXMpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQ2h1bmsobW9kdWxlcywgdGhpcy5pbnB1dE9wdGlvbnMsIHRoaXMub3V0cHV0T3B0aW9ucywgdGhpcy51bnNldE9wdGlvbnMsIHRoaXMucGx1Z2luRHJpdmVyLCB0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLCBjaHVua0J5TW9kdWxlLCB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUsIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLCBhbGlhcyk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtCeU1vZHVsZS5zZXQobW9kdWxlLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgIGNodW5rLmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWNhZGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBmYWNhZGVzLnB1c2goLi4uY2h1bmsuZ2VuZXJhdGVGYWNhZGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uY2h1bmtzLCAuLi5mYWNhZGVzXTtcbiAgICB9XG4gICAgcHJlcmVuZGVyQ2h1bmtzKGNodW5rcywgaW5wdXRCYXNlLCBzbmlwcGV0cykge1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgY2h1bmsuZ2VuZXJhdGVFeHBvcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgIGNodW5rLnByZVJlbmRlcih0aGlzLm91dHB1dE9wdGlvbnMsIGlucHV0QmFzZSwgc25pcHBldHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVFbnRyeU1vZHVsZVBhdGhzKGNodW5rcykge1xuICAgIGNvbnN0IGFic29sdXRlRW50cnlNb2R1bGVQYXRocyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnlNb2R1bGUgb2YgY2h1bmsuZW50cnlNb2R1bGVzKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZShlbnRyeU1vZHVsZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZUVudHJ5TW9kdWxlUGF0aHMucHVzaChlbnRyeU1vZHVsZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFic29sdXRlRW50cnlNb2R1bGVQYXRocztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc0Zvck11bHRpQ2h1bmtPdXRwdXQob3V0cHV0T3B0aW9ucywgb25XYXJuKSB7XG4gICAgaWYgKG91dHB1dE9wdGlvbnMuZm9ybWF0ID09PSAndW1kJyB8fCBvdXRwdXRPcHRpb25zLmZvcm1hdCA9PT0gJ2lpZmUnKVxuICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignb3V0cHV0LmZvcm1hdCcsICdvdXRwdXRmb3JtYXQnLCAnVU1EIGFuZCBJSUZFIG91dHB1dCBmb3JtYXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBjb2RlLXNwbGl0dGluZyBidWlsZHMnLCBvdXRwdXRPcHRpb25zLmZvcm1hdCkpO1xuICAgIGlmICh0eXBlb2Ygb3V0cHV0T3B0aW9ucy5maWxlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5maWxlJywgJ291dHB1dGRpcicsICd3aGVuIGJ1aWxkaW5nIG11bHRpcGxlIGNodW5rcywgdGhlIFwib3V0cHV0LmRpclwiIG9wdGlvbiBtdXN0IGJlIHVzZWQsIG5vdCBcIm91dHB1dC5maWxlXCIuIFRvIGlubGluZSBkeW5hbWljIGltcG9ydHMsIHNldCB0aGUgXCJpbmxpbmVEeW5hbWljSW1wb3J0c1wiIG9wdGlvbicpKTtcbiAgICBpZiAob3V0cHV0T3B0aW9ucy5zb3VyY2VtYXBGaWxlKVxuICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignb3V0cHV0LnNvdXJjZW1hcEZpbGUnLCAnb3V0cHV0c291cmNlbWFwZmlsZScsICdcIm91dHB1dC5zb3VyY2VtYXBGaWxlXCIgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNpbmdsZS1maWxlIGJ1aWxkcycpKTtcbiAgICBpZiAoIW91dHB1dE9wdGlvbnMuYW1kLmF1dG9JZCAmJiBvdXRwdXRPcHRpb25zLmFtZC5pZClcbiAgICAgICAgb25XYXJuKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5hbWQuaWQnLCAnb3V0cHV0YW1kJywgJ3RoaXMgb3B0aW9uIGlzIG9ubHkgcHJvcGVybHkgc3VwcG9ydGVkIGZvciBzaW5nbGUtZmlsZSBidWlsZHMuIFVzZSBcIm91dHB1dC5hbWQuYXV0b0lkXCIgYW5kIFwib3V0cHV0LmFtZC5iYXNlUGF0aFwiIGluc3RlYWQnKSk7XG59XG5mdW5jdGlvbiBnZXRJbmNsdWRlZE1vZHVsZXMobW9kdWxlc0J5SWQpIHtcbiAgICByZXR1cm4gWy4uLm1vZHVsZXNCeUlkLnZhbHVlcygpXS5maWx0ZXIoKG1vZHVsZSkgPT4gbW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlICYmXG4gICAgICAgIChtb2R1bGUuaXNJbmNsdWRlZCgpIHx8IG1vZHVsZS5pbmZvLmlzRW50cnkgfHwgbW9kdWxlLmluY2x1ZGVkRHluYW1pY0ltcG9ydGVycy5sZW5ndGggPiAwKSk7XG59XG5mdW5jdGlvbiBhZGRNb2R1bGVUb01hbnVhbENodW5rKGFsaWFzLCBtb2R1bGUsIG1hbnVhbENodW5rQWxpYXNCeUVudHJ5KSB7XG4gICAgY29uc3QgZXhpc3RpbmdBbGlhcyA9IG1hbnVhbENodW5rQWxpYXNCeUVudHJ5LmdldChtb2R1bGUpO1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdBbGlhcyA9PT0gJ3N0cmluZycgJiYgZXhpc3RpbmdBbGlhcyAhPT0gYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckNhbm5vdEFzc2lnbk1vZHVsZVRvQ2h1bmsobW9kdWxlLmlkLCBhbGlhcywgZXhpc3RpbmdBbGlhcykpO1xuICAgIH1cbiAgICBtYW51YWxDaHVua0FsaWFzQnlFbnRyeS5zZXQobW9kdWxlLCBhbGlhcyk7XG59XG5cbi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBcImVudW1cIixcbiAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbnZhciBrZXl3b3JkcyQxID0ge1xuICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgXCI1bW9kdWxlXCI6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG59O1xuXG52YXIga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9eaW4oc3RhbmNlb2YpPyQvO1xuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbi8vIEdlbmVyYXRlZCBieSBgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDg3MC1cXHUwODg3XFx1MDg4OS1cXHUwODhlXFx1MDhhMC1cXHUwOGM5XFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNWRcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNC1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MTFcXHUxNzFmLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRjXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmZcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYmZcXHU0ZTAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdjYVxcdWE3ZDBcXHVhN2QxXFx1YTdkM1xcdWE3ZDUtXFx1YTdkOVxcdWE3ZjItXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjlcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4OTgtXFx1MDg5ZlxcdTA4Y2EtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NS1cXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2NcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbnZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG5ub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG4vLyBUaGVzZSBhcmUgYSBydW4tbGVuZ3RoIGFuZCBvZmZzZXQgZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbi8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbi8vIG9mZnNldCBzdGFydHMgYXQgMHgxMDAwMCwgYW5kIGVhY2ggcGFpciBvZiBudW1iZXJzIHJlcHJlc2VudHMgYW5cbi8vIG9mZnNldCB0byB0aGUgbmV4dCByYW5nZSwgYW5kIHRoZW4gYSBzaXplIG9mIHRoZSByYW5nZS4gVGhleSB3ZXJlXG4vLyBnZW5lcmF0ZWQgYnkgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbnZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTMsMTAsMiwxNCwyLDYsMiwxLDIsMTAsMiwxNCwyLDYsMiwxLDY4LDMxMCwxMCwyMSwxMSw3LDI1LDUsMiw0MSwyLDgsNzAsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDM0OSw0MSw3LDEsNzksMjgsMTEsMCw5LDIxLDQzLDE3LDQ3LDIwLDI4LDIyLDEzLDUyLDU4LDEsMywwLDE0LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMywwLDksMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMiwzMSw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMzgsNiwxODYsNDMsMTE3LDYzLDMyLDcsMywwLDMsNywyLDEsMiwyMywxNiwwLDIsMCw5NSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDE5LDcyLDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMTkwLDAsODAsOTIxLDEwMywxMTAsMTgsMTk1LDI2MzcsOTYsMTYsMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDE4LDc4LDE4LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDc0LDYsMCw2NywxMiw2NSwxLDIsMCwyOSw2MTM1LDksMTIzNyw0Myw4LDg5MzYsMywyLDYsMiwxLDIsMjkwLDQ2LDIsMTgsMyw5LDM5NSwyMzA5LDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNywxODQ1LDMwLDQ4Miw0NCwxMSw2LDE3LDAsMzIyLDI5LDE5LDQzLDEyNjksNiwyLDMsMiwxLDIsMTQsMiwxOTYsNjAsNjcsOCwwLDEyMDUsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTksMzMsNDE1Miw4LDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MSwxNTA3LDQ5MzhdO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksMzcwLDEsMTU0LDEwLDUwLDMsMTIzLDIsNTQsMTQsMzIsMTAsMywxLDExLDMsNDYsMTAsOCwwLDQ2LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMywyLDExLDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksNzEsNSwyLDEsMywzLDIsMCwyLDEsMTMsOSwxMjAsNiwzLDYsNCwwLDI5LDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksODcsOSwzOSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsODIsMCwxMiwxLDE5NjI4LDEsNDcwNiw0NSwzLDIyLDU0Myw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjYyLDYsMTAsOSwzNTcsMCw2MiwxMywxNDk1LDYsMTEwLDYsNiw5LDQ3NTksOSw3ODc3MTksMjM5XTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBjb2RlIHN0YXJ0cyBhbiBpZGVudGlmaWVyLlxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcylcbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgaWYgKGNvZGUgPCA0OCkgeyByZXR1cm4gY29kZSA9PT0gMzYgfVxuICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA2NSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoY29kZSA8IDkxKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICBpZiAoY29kZSA8IDEyMykgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgeyByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKVxufVxuXG4vLyAjIyBUb2tlbiB0eXBlc1xuXG4vLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4vLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4vLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbi8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuLy9cbi8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4vLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4vLyBkaXJlY3RseSBzdGFydCBhbiBleHByZXNzaW9uIChsaWtlIGEgcXVvdGF0aW9uIG1hcmspIG9yIGNhblxuLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4vL1xuLy8gYGlzTG9vcGAgbWFya3MgYSBrZXl3b3JkIGFzIHN0YXJ0aW5nIGEgbG9vcCwgd2hpY2ggaXMgaW1wb3J0YW50XG4vLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxudmFyIFRva2VuVHlwZSA9IGZ1bmN0aW9uIFRva2VuVHlwZShsYWJlbCwgY29uZikge1xuICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG59XG52YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyA9IHt9O1xuXG4vLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG5mdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gIHJldHVybiBrZXl3b3Jkc1tuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbn1cblxudmFyIHR5cGVzJDEgPSB7XG4gIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICBwcml2YXRlSWQ6IG5ldyBUb2tlblR5cGUoXCJwcml2YXRlSWRcIiwgc3RhcnRzRXhwciksXG4gIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICBxdWVzdGlvbkRvdDogbmV3IFRva2VuVHlwZShcIj8uXCIpLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBjb2FsZXNjZTogYmlub3AoXCI/P1wiLCAxKSxcblxuICAvLyBLZXl3b3JkIHRva2VuIHR5cGVzLlxuICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICBfaWY6IGt3KFwiaWZcIiksXG4gIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgX3Zhcjoga3coXCJ2YXJcIiksXG4gIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxufTtcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbnZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCBjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5XG59XG5cbmZ1bmN0aW9uIG5leHRMaW5lQnJlYWsoY29kZSwgZnJvbSwgZW5kKSB7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBjb2RlLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIG5leHQgPSBjb2RlLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGlzTmV3TGluZShuZXh0KSlcbiAgICAgIHsgcmV0dXJuIGkgPCBlbmQgLSAxICYmIG5leHQgPT09IDEzICYmIGNvZGUuY2hhckNvZGVBdChpICsgMSkgPT09IDEwID8gaSArIDIgOiBpICsgMSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxudmFyIGhhc093biA9IE9iamVjdC5oYXNPd24gfHwgKGZ1bmN0aW9uIChvYmosIHByb3BOYW1lKSB7IHJldHVybiAoXG4gIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbik7IH0pO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChcbiAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbik7IH0pO1xuXG5mdW5jdGlvbiB3b3Jkc1JlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxufVxuXG52YXIgbG9uZVN1cnJvZ2F0ZSA9IC8oPzpbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvO1xuXG4vLyBUaGVzZSBhcmUgdXNlZCB3aGVuIGBvcHRpb25zLmxvY2F0aW9uc2AgaXMgb24sIGZvciB0aGVcbi8vIGBzdGFydExvY2AgYW5kIGBlbmRMb2NgIHByb3BlcnRpZXMuXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbDtcbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbn07XG5cbnZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbiAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxufTtcblxuLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuLy8gYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9mZiAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIGFuZCB5b3Vcbi8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4vLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4vLyBpbnRvLlxuXG5mdW5jdGlvbiBnZXRMaW5lSW5mbyhpbnB1dCwgb2Zmc2V0KSB7XG4gIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICB2YXIgbmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayhpbnB1dCwgY3VyLCBvZmZzZXQpO1xuICAgIGlmIChuZXh0QnJlYWsgPCAwKSB7IHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKSB9XG4gICAgKytsaW5lO1xuICAgIGN1ciA9IG5leHRCcmVhaztcbiAgfVxufVxuXG4vLyBBIHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIGdpdmVuIHRvIGNvbmZpZ3VyZSB0aGUgcGFyc2VyIHByb2Nlc3MuXG4vLyBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkIChvbmx5IGBlY21hVmVyc2lvbmAgaXMgcmVxdWlyZWQpOlxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgLy8gZWl0aGVyIDMsIDUsIDYgKG9yIDIwMTUpLCA3ICgyMDE2KSwgOCAoMjAxNyksIDkgKDIwMTgpLCAxMFxuICAvLyAoMjAxOSksIDExICgyMDIwKSwgMTIgKDIwMjEpLCAxMyAoMjAyMiksIG9yIGBcImxhdGVzdFwiYCAodGhlXG4gIC8vIGxhdGVzdCB2ZXJzaW9uIHRoZSBsaWJyYXJ5IHN1cHBvcnRzKS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnRcbiAgLy8gZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3JcbiAgLy8gbmV3IHN5bnRheCBmZWF0dXJlcy5cbiAgZWNtYVZlcnNpb246IG51bGwsXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tYSBhcyBhbiBvZmZzZXQsIGFuZCBpZiBgbG9jYXRpb25zYCBpc1xuICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAvLyBhcyBzZWNvbmQgYXJndW1lbnQuXG4gIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gIC8vIHRyYWlsaW5nIGNvbW1hcy5cbiAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAvLyBTZXQgYGFsbG93UmVzZXJ2ZWRgIHRvIGEgYm9vbGVhbiB2YWx1ZSB0byBleHBsaWNpdGx5IHR1cm4gdGhpcyBvblxuICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gIC8vIGVycm9yLlxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0sIGFuZCBhbiBpbXBvcnQubWV0YSBleHByZXNzaW9uXG4gIC8vIGluIGEgc2NyaXB0IGlzbid0IGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIC8vIEJ5IGRlZmF1bHQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlIG9ubHkgaWYgZWNtYVZlcnNpb24gPj0gMjAyMi5cbiAgLy8gV2hlbiBlbmFibGVkLCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSxcbiAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgc3VwZXIgaWRlbnRpZmllcnMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgaW4gbWV0aG9kcyBhbmQgZG8gbm90IHJhaXNlIGFuIGVycm9yIHdoZW4gdGhleSBhcHBlYXIgZWxzZXdoZXJlLlxuICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNrXHUyMDE0dGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja1x1MjAxNHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxufTtcblxuLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbnZhciB3YXJuZWRBYm91dEVjbWFWZXJzaW9uID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzT3duKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT09IFwibGF0ZXN0XCIpIHtcbiAgICBvcHRpb25zLmVjbWFWZXJzaW9uID0gMWU4O1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPT0gbnVsbCkge1xuICAgIGlmICghd2FybmVkQWJvdXRFY21hVmVyc2lvbiAmJiB0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgIHdhcm5lZEFib3V0RWNtYVZlcnNpb24gPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKFwiU2luY2UgQWNvcm4gOC4wLjAsIG9wdGlvbnMuZWNtYVZlcnNpb24gaXMgcmVxdWlyZWQuXFxuRGVmYXVsdGluZyB0byAyMDIwLCBidXQgdGhpcyB3aWxsIHN0b3Agd29ya2luZyBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy5lY21hVmVyc2lvbiA9IDExO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSkge1xuICAgIG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyOCxcbiAgICBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgPSAyNTYsXG4gICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0s7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG59XG5cbi8vIFVzZWQgaW4gY2hlY2tMVmFsKiBhbmQgZGVjbGFyZU5hbWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgYmluZGluZ1xudmFyXG4gICAgQklORF9OT05FID0gMCwgLy8gTm90IGEgYmluZGluZ1xuICAgIEJJTkRfVkFSID0gMSwgLy8gVmFyLXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICBCSU5EX0ZVTkNUSU9OID0gMywgLy8gRnVuY3Rpb24gZGVjbGFyYXRpb25cbiAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIC8vIFNpbXBsZSAoaWRlbnRpZmllciBwYXR0ZXJuKSBjYXRjaCBiaW5kaW5nXG4gICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3JkcyQxW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgIHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNSA/IDUgOiAzXTtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZCk7XG4gIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgdG9rZW4gc3RhdGVcblxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgdGhpcy5jdXJMaW5lID0gMTtcbiAgfVxuXG4gIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gIC8vIEl0cyB0eXBlXG4gIHRoaXMudHlwZSA9IHR5cGVzJDEuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcbiAgdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQgPSBmYWxzZTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG4gIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xuXG4gIC8vIFRoZSBzdGFjayBvZiBwcml2YXRlIG5hbWVzLlxuICAvLyBFYWNoIGVsZW1lbnQgaGFzIHR3byBwcm9wZXJ0aWVzOiAnZGVjbGFyZWQnIGFuZCAndXNlZCcuXG4gIC8vIFdoZW4gaXQgZXhpdGVkIGZyb20gdGhlIG91dGVybW9zdCBjbGFzcyBkZWZpbml0aW9uLCBhbGwgdXNlZCBwcml2YXRlIG5hbWVzIG11c3QgYmUgZGVjbGFyZWQuXG4gIHRoaXMucHJpdmF0ZU5hbWVTdGFjayA9IFtdO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNhbkF3YWl0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93TmV3RG90VGFyZ2V0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQ2xhc3NTdGF0aWNCbG9jazogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dFRva2VuKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCAmJiAhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jYW5Bd2FpdC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgfHwgc2NvcGUuZmxhZ3MgJiBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgeyByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9XG4gIH1cbiAgcmV0dXJuICh0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMykgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25cbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlZiA9IHRoaXMuY3VycmVudFRoaXNTY29wZSgpO1xuICAgIHZhciBmbGFncyA9IHJlZi5mbGFncztcbiAgICB2YXIgaW5DbGFzc0ZpZWxkSW5pdCA9IHJlZi5pbkNsYXNzRmllbGRJbml0O1xuICByZXR1cm4gKGZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB8fCBpbkNsYXNzRmllbGRJbml0IHx8IHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dOZXdEb3RUYXJnZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVmID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGZsYWdzID0gcmVmLmZsYWdzO1xuICAgIHZhciBpbkNsYXNzRmllbGRJbml0ID0gcmVmLmluQ2xhc3NGaWVsZEluaXQ7XG4gIHJldHVybiAoZmxhZ3MgJiAoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0spKSA+IDAgfHwgaW5DbGFzc0ZpZWxkSW5pdFxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluQ2xhc3NTdGF0aWNCbG9jay5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0NMQVNTX1NUQVRJQ19CTE9DSykgPiAwXG59O1xuXG5QYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgdmFyIGNscyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgcmV0dXJuIGNsc1xufTtcblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxufTtcblxuUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwYXJzZXIubmV4dFRva2VuKCk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbn07XG5cblBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbnZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ1xcXFxdKSo/KSd8XCIoKD86XFxcXC58W15cIlxcXFxdKSo/KVwiKS87XG5wcCQ5LnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIGZvciAoOzspIHtcbiAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgdmFyIHNwYWNlQWZ0ZXIgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpLCBlbmQgPSBzcGFjZUFmdGVyLmluZGV4ICsgc3BhY2VBZnRlclswXS5sZW5ndGg7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KGVuZCk7XG4gICAgICByZXR1cm4gbmV4dCA9PT0gXCI7XCIgfHwgbmV4dCA9PT0gXCJ9XCIgfHxcbiAgICAgICAgKGxpbmVCcmVhay50ZXN0KHNwYWNlQWZ0ZXJbMF0pICYmXG4gICAgICAgICAhKC9bKGAuWytcXC0vKiU8Pj0sP14mXS8udGVzdChuZXh0KSB8fCBuZXh0ID09PSBcIiFcIiAmJiB0aGlzLmlucHV0LmNoYXJBdChlbmQgKyAxKSA9PT0gXCI9XCIpKVxuICAgIH1cbiAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICB7IHN0YXJ0Kys7IH1cbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwJDkuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwJDkuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcCQ5LmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAkOS5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbChuYW1lKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxuLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxucHAkOS5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2VSIHx8XG4gICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxucHAkOS5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwJDkuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMkMS5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkOS5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwJDkudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxuZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgLTE7XG59XG5cbnBwJDkuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxufTtcblxucHAkOS5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxufTtcblxucHAkOS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG59O1xuXG5wcCQ5LmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcCQ4LnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5lb2YpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgfSB9XG4gIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG59O1xuXG52YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbnBwJDguaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgLy8gU3RhdGVtZW50KSBpcyBhbGxvd2VkIGhlcmUuIElmIGNvbnRleHQgaXMgbm90IGVtcHR5IHRoZW4gb25seSBhIFN0YXRlbWVudFxuICAvLyBpcyBhbGxvd2VkLiBIb3dldmVyLCBgbGV0IFtgIGlzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIGxvb2thaGVhZCBmb3JcbiAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICBpZiAobmV4dENoID09PSA5MSB8fCBuZXh0Q2ggPT09IDkyIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfSAvLyAnWycsICcvJywgYXN0cmFsXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgIGlmIChuZXh0Q2ggPT09IDkyIHx8IG5leHRDaCA+IDB4ZDdmZiAmJiBuZXh0Q2ggPCAweGRjMDApIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbi8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuLy8gLSAnYXN5bmMgLypcXG4qLyBmdW5jdGlvbicgaXMgaW52YWxpZC5cbnBwJDguaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIGFmdGVyO1xuICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8XG4gICAgICEoaXNJZGVudGlmaWVyQ2hhcihhZnRlciA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgOCkpIHx8IGFmdGVyID4gMHhkN2ZmICYmIGFmdGVyIDwgMHhkYzAwKSlcbn07XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbi8vXG4vLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2Vcbi8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbi8vIGRvZXMgbm90IGhlbHAuXG5cbnBwJDgucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgIHN0YXJ0dHlwZSA9IHR5cGVzJDEuX3ZhcjtcbiAgICBraW5kID0gXCJsZXRcIjtcbiAgfVxuXG4gIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAvLyBjb21wbGV4aXR5LlxuXG4gIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gIGNhc2UgdHlwZXMkMS5fYnJlYWs6IGNhc2UgdHlwZXMkMS5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgY2FzZSB0eXBlcyQxLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2Z1bmN0aW9uOlxuICAgIC8vIEZ1bmN0aW9uIGFzIHNvbGUgYm9keSBvZiBlaXRoZXIgYW4gaWYgc3RhdGVtZW50IG9yIGEgbGFiZWxlZCBzdGF0ZW1lbnRcbiAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgY2FzZSB0eXBlcyQxLl9jbGFzczpcbiAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgY2FzZSB0eXBlcyQxLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMkMS5fY29uc3Q6IGNhc2UgdHlwZXMkMS5fdmFyOlxuICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gIGNhc2UgdHlwZXMkMS5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcyQxLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICBjYXNlIHR5cGVzJDEuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzJDEuX2V4cG9ydDpcbiAgY2FzZSB0eXBlcyQxLl9pbXBvcnQ6XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMkMS5faW1wb3J0KSB7XG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDAgfHwgbmV4dENoID09PSA0NikgLy8gJygnIG9yICcuJ1xuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzJDEuX2ltcG9ydCA/IHRoaXMucGFyc2VJbXBvcnQobm9kZSkgOiB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIGV4cG9ydHMpXG5cbiAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgIC8vIHNpbXBseSBzdGFydCBwYXJzaW5nIGFuIGV4cHJlc3Npb24sIGFuZCBhZnRlcndhcmRzLCBpZiB0aGVcbiAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICBkZWZhdWx0OlxuICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KVxuICAgIH1cblxuICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcyQxLmNvbG9uKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICB9XG59O1xuXG5wcCQ4LnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQodHlwZXMkMS5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUubGFiZWwgPSBudWxsOyB9XG4gIGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIGVsc2Uge1xuICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gIC8vIGNvbnRpbnVlIHRvLlxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLl93aGlsZSk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgdGhpcy5lYXQodHlwZXMkMS5zZW1pKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDgucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmNhbkF3YWl0ICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgdGhpcy5lbnRlclNjb3BlKDApO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuTCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc2VtaSkge1xuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgfVxuICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgfVxuICB2YXIgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpLCBpc0Zvck9mID0gZmFsc2U7XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oYXdhaXRBdCA+IC0xID8gXCJhd2FpdFwiIDogdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IChpc0Zvck9mID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luKSB7XG4gICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgfVxuICAgIGlmIChzdGFydHNXaXRoTGV0ICYmIGlzRm9yT2YpIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAnbGV0Jy5cIik7IH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGluaXQpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgfVxuICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxufTtcblxucHAkOC5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbn07XG5cbnBwJDgucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzJDEuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgdmFyIGN1cjtcbiAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSOykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSQxID0gW107XG5cbnBwJDgucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NhdGNoKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkge1xuICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICB2YXIgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGNsYXVzZS5wYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlblIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgfVxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gIH1cbiAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcyQxLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxufTtcblxucHAkOC5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxufTtcblxucHAkOC5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDgucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgIHtcbiAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCQxID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICBsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgfSBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG59O1xuXG5wcCQ4LnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDgucGFyc2VCbG9jayA9IGZ1bmN0aW9uKGNyZWF0ZU5ld0xleGljYWxTY29wZSwgbm9kZSwgZXhpdFN0cmljdCkge1xuICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNlUikge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAoZXhpdFN0cmljdCkgeyB0aGlzLnN0cmljdCA9IGZhbHNlOyB9XG4gIHRoaXMubmV4dCgpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbi8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuLy8gZXhwcmVzc2lvbi5cblxucHAkOC5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgbm9kZS5pbml0ID0gaW5pdDtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMkMS5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwJDgucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luO1xuICB0aGlzLm5leHQoKTtcblxuICBpZiAoXG4gICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgIChcbiAgICAgICFpc0ZvckluIHx8XG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgIClcbiAgKSB7XG4gICAgdGhpcy5yYWlzZShcbiAgICAgIGluaXQuc3RhcnQsXG4gICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICk7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDgucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMkMS5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IGJyZWFrIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkOC5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICBkZWNsLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIHRoaXMuY2hlY2tMVmFsUGF0dGVybihkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbn07XG5cbnZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuLy8gUmVtb3ZlIGBhbGxvd0V4cHJlc3Npb25Cb2R5YCBmb3IgNy4wLjAsIGFzIGl0IGlzIG9ubHkgY2FsbGVkIHdpdGggZmFsc2VcbnBwJDgucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYywgZm9ySW5pdCkge1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdGFyICYmIChzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzJDEuc3Rhcik7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKG5vZGUuaWQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgIC8vIG1vZGUgZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNjb3BlIChzZWVcbiAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gIH1cblxuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgZmFsc2UsIGZvckluaXQpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5wcCQ4LnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMkMS5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG59O1xuXG4vLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkOC5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gZWNtYS0yNjIgMTQuNiBDbGFzcyBEZWZpbml0aW9uc1xuICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuXG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHZhciBwcml2YXRlTmFtZU1hcCA9IHRoaXMuZW50ZXJDbGFzc0JvZHkoKTtcbiAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ICYmIGVsZW1lbnQua2V5LnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIiAmJiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVsZW1lbnQua2V5LnN0YXJ0LCAoXCJJZGVudGlmaWVyICcjXCIgKyAoZWxlbWVudC5rZXkubmFtZSkgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHRoaXMuZXhpdENsYXNzQm9keSgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIga2V5TmFtZSA9IFwiXCI7XG4gIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICB2YXIga2luZCA9IFwibWV0aG9kXCI7XG4gIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJzdGF0aWNcIikpIHtcbiAgICAvLyBQYXJzZSBzdGF0aWMgaW5pdCBibG9ja1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMyAmJiB0aGlzLmVhdCh0eXBlcyQxLmJyYWNlTCkpIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKG5vZGUpO1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJzdGF0aWNcIjtcbiAgICB9XG4gIH1cbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgaWYgKCFrZXlOYW1lICYmIGVjbWFWZXJzaW9uID49IDggJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXN5bmNcIikpIHtcbiAgICBpZiAoKHRoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlOYW1lID0gXCJhc3luY1wiO1xuICAgIH1cbiAgfVxuICBpZiAoIWtleU5hbWUgJiYgKGVjbWFWZXJzaW9uID49IDkgfHwgIWlzQXN5bmMpICYmIHRoaXMuZWF0KHR5cGVzJDEuc3RhcikpIHtcbiAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gIH1cbiAgaWYgKCFrZXlOYW1lICYmICFpc0FzeW5jICYmICFpc0dlbmVyYXRvcikge1xuICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJnZXRcIikgfHwgdGhpcy5lYXRDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICBpZiAodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpKSB7XG4gICAgICAgIGtpbmQgPSBsYXN0VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlOYW1lID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGVsZW1lbnQgbmFtZVxuICBpZiAoa2V5TmFtZSkge1xuICAgIC8vICdhc3luYycsICdnZXQnLCAnc2V0Jywgb3IgJ3N0YXRpYycgd2VyZSBub3QgYSBrZXl3b3JkIGNvbnRleHR1YWxseS5cbiAgICAvLyBUaGUgbGFzdCB0b2tlbiBpcyBhbnkgb2YgdGhvc2UuIE1ha2UgaXQgdGhlIGVsZW1lbnQgbmFtZS5cbiAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbm9kZS5rZXkgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7XG4gICAgbm9kZS5rZXkubmFtZSA9IGtleU5hbWU7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUua2V5LCBcIklkZW50aWZpZXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzRWxlbWVudE5hbWUobm9kZSk7XG4gIH1cblxuICAvLyBQYXJzZSBlbGVtZW50IHZhbHVlXG4gIGlmIChlY21hVmVyc2lvbiA8IDEzIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwgfHwga2luZCAhPT0gXCJtZXRob2RcIiB8fCBpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7XG4gICAgdmFyIGlzQ29uc3RydWN0b3IgPSAhbm9kZS5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG5vZGUsIFwiY29uc3RydWN0b3JcIik7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gaXNDb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICAgIC8vIENvdWxkbid0IG1vdmUgdGhpcyBjaGVjayBpbnRvIHRoZSAncGFyc2VDbGFzc01ldGhvZCcgbWV0aG9kIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIGtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICBub2RlLmtpbmQgPSBpc0NvbnN0cnVjdG9yID8gXCJjb25zdHJ1Y3RvclwiIDoga2luZDtcbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlQ2xhc3NGaWVsZChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQ4LmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcyQxLm51bSB8fFxuICAgIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzJDEuYnJhY2tldEwgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZFxuICApXG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGFuIGVsZW1lbnQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBlbGVtZW50LmtleSA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGVsZW1lbnQpO1xuICB9XG59O1xuXG5wcCQ4LnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAvLyBDaGVjayBrZXkgYW5kIGZsYWdzXG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKG1ldGhvZCwgXCJwcm90b3R5cGVcIikpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cblxuICAvLyBQYXJzZSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG5cbiAgLy8gQ2hlY2sgdmFsdWVcbiAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIHZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgdmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh2YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIHZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxufTtcblxucHAkOC5wYXJzZUNsYXNzRmllbGQgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoY2hlY2tLZXlOYW1lKGZpZWxkLCBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgdGhpcy5yYWlzZShmaWVsZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiKTtcbiAgfSBlbHNlIGlmIChmaWVsZC5zdGF0aWMgJiYgY2hlY2tLZXlOYW1lKGZpZWxkLCBcInByb3RvdHlwZVwiKSkge1xuICAgIHRoaXMucmFpc2UoZmllbGQua2V5LnN0YXJ0LCBcIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhIHN0YXRpYyBmaWVsZCBuYW1lZCAncHJvdG90eXBlJ1wiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLmVxKSkge1xuICAgIC8vIFRvIHJhaXNlIFN5bnRheEVycm9yIGlmICdhcmd1bWVudHMnIGV4aXN0cyBpbiB0aGUgaW5pdGlhbGl6ZXIuXG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlKCk7XG4gICAgdmFyIGluQ2xhc3NGaWVsZEluaXQgPSBzY29wZS5pbkNsYXNzRmllbGRJbml0O1xuICAgIHNjb3BlLmluQ2xhc3NGaWVsZEluaXQgPSB0cnVlO1xuICAgIGZpZWxkLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgc2NvcGUuaW5DbGFzc0ZpZWxkSW5pdCA9IGluQ2xhc3NGaWVsZEluaXQ7XG4gIH0gZWxzZSB7XG4gICAgZmllbGQudmFsdWUgPSBudWxsO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWVsZCwgXCJQcm9wZXJ0eURlZmluaXRpb25cIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc1N0YXRpY0Jsb2NrID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmJvZHkgPSBbXTtcblxuICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gIHRoaXMubGFiZWxzID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9DTEFTU19TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VSKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RhdGljQmxvY2tcIilcbn07XG5cbnBwJDgucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5uYW1lKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgIHsgdGhpcy5jaGVja0xWYWxTaW1wbGUobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gIH1cbn07XG5cbnBwJDgucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcyQxLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhmYWxzZSkgOiBudWxsO1xufTtcblxucHAkOC5lbnRlckNsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbWVudCA9IHtkZWNsYXJlZDogT2JqZWN0LmNyZWF0ZShudWxsKSwgdXNlZDogW119O1xuICB0aGlzLnByaXZhdGVOYW1lU3RhY2sucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQuZGVjbGFyZWRcbn07XG5cbnBwJDguZXhpdENsYXNzQm9keSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVmID0gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpO1xuICB2YXIgZGVjbGFyZWQgPSByZWYuZGVjbGFyZWQ7XG4gIHZhciB1c2VkID0gcmVmLnVzZWQ7XG4gIHZhciBsZW4gPSB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoO1xuICB2YXIgcGFyZW50ID0gbGVuID09PSAwID8gbnVsbCA6IHRoaXMucHJpdmF0ZU5hbWVTdGFja1tsZW4gLSAxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1c2VkLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlkID0gdXNlZFtpXTtcbiAgICBpZiAoIWhhc093bihkZWNsYXJlZCwgaWQubmFtZSkpIHtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LnVzZWQucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoaWQuc3RhcnQsIChcIlByaXZhdGUgZmllbGQgJyNcIiArIChpZC5uYW1lKSArIFwiJyBtdXN0IGJlIGRlY2xhcmVkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc1ByaXZhdGVOYW1lQ29uZmxpY3RlZChwcml2YXRlTmFtZU1hcCwgZWxlbWVudCkge1xuICB2YXIgbmFtZSA9IGVsZW1lbnQua2V5Lm5hbWU7XG4gIHZhciBjdXJyID0gcHJpdmF0ZU5hbWVNYXBbbmFtZV07XG5cbiAgdmFyIG5leHQgPSBcInRydWVcIjtcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgKGVsZW1lbnQua2luZCA9PT0gXCJnZXRcIiB8fCBlbGVtZW50LmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgbmV4dCA9IChlbGVtZW50LnN0YXRpYyA/IFwic1wiIDogXCJpXCIpICsgZWxlbWVudC5raW5kO1xuICB9XG5cbiAgLy8gYGNsYXNzIHsgZ2V0ICNhKCl7fTsgc3RhdGljIHNldCAjYShfKXt9IH1gIGlzIGFsc28gY29uZmxpY3QuXG4gIGlmIChcbiAgICBjdXJyID09PSBcImlnZXRcIiAmJiBuZXh0ID09PSBcImlzZXRcIiB8fFxuICAgIGN1cnIgPT09IFwiaXNldFwiICYmIG5leHQgPT09IFwiaWdldFwiIHx8XG4gICAgY3VyciA9PT0gXCJzZ2V0XCIgJiYgbmV4dCA9PT0gXCJzc2V0XCIgfHxcbiAgICBjdXJyID09PSBcInNzZXRcIiAmJiBuZXh0ID09PSBcInNnZXRcIlxuICApIHtcbiAgICBwcml2YXRlTmFtZU1hcFtuYW1lXSA9IFwidHJ1ZVwiO1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFjdXJyKSB7XG4gICAgcHJpdmF0ZU5hbWVNYXBbbmFtZV0gPSBuZXh0O1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tLZXlOYW1lKG5vZGUsIG5hbWUpIHtcbiAgdmFyIGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZDtcbiAgdmFyIGtleSA9IG5vZGUua2V5O1xuICByZXR1cm4gIWNvbXB1dGVkICYmIChcbiAgICBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IG5hbWUgfHxcbiAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBuYW1lXG4gIClcbn1cblxuLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDgucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcyQxLnN0YXIpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICB2YXIgaXNBc3luYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcblxuICAgICAgICBpZiAoc3BlYy5sb2NhbC50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgIHRoaXMucmFpc2Uoc3BlYy5sb2NhbC5zdGFydCwgXCJBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGV4cG9ydGVkIGJpbmRpbmcgd2l0aG91dCBgZnJvbWAuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxufTtcblxucHAkOC5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgaWYgKGhhc093bihleHBvcnRzLCBuYW1lKSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xufTtcblxucHAkOC5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBwYXQubmFtZSwgcGF0LnN0YXJ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQcm9wZXJ0eVwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQubGVmdCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuZXhwcmVzc2lvbik7IH1cbn07XG5cbnBwJDguY2hlY2tWYXJpYWJsZUV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlY2xzKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gIH1cbn07XG5cbnBwJDguc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgdGhpcy5pc0xldCgpIHx8XG4gICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbnBwJDgucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMuY2hlY2tFeHBvcnQoXG4gICAgICBleHBvcnRzLFxuICAgICAgbm9kZS5leHBvcnRlZFtub2RlLmV4cG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gXCJuYW1lXCIgOiBcInZhbHVlXCJdLFxuICAgICAgbm9kZS5leHBvcnRlZC5zdGFydFxuICAgICk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkOC5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5JDE7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQ4LnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcyQxLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3Rhcikge1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcyQxLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMkMS5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbnBwJDgucGFyc2VNb2R1bGVFeHBvcnROYW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTMgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLnN0cmluZykge1xuICAgIHZhciBzdHJpbmdMaXRlcmFsID0gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk7XG4gICAgaWYgKGxvbmVTdXJyb2dhdGUudGVzdChzdHJpbmdMaXRlcmFsLnZhbHVlKSkge1xuICAgICAgdGhpcy5yYWlzZShzdHJpbmdMaXRlcmFsLnN0YXJ0LCBcIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbFxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkOC5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQ4LmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkNy50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQ2hhaW5FeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxucHAkNy50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgfVxuICByZXR1cm4gZXhwckxpc3Rcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkNy5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG59O1xuXG5wcCQ3LnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLm5hbWUpXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDcucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMkMS5icmFja2V0TDpcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgIGNhc2UgdHlwZXMkMS5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbn07XG5cbnBwJDcucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpOyB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDcucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICByZXR1cm4gcGFyYW1cbn07XG5cbi8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbnBwJDcucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcyQxLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyB0aHJlZSBmdW5jdGlvbnMgYWxsIHZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsdWUgXHUyMDE0XG4vLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYm91bmQsIG9yIGFzc2lnbmVkIHRvLiBJbiBvcmRlciB0byBkbyBzbywgdGhleSBwZXJmb3JtXG4vLyBhIHZhcmlldHkgb2YgY2hlY2tzOlxuLy9cbi8vIC0gQ2hlY2sgdGhhdCBub25lIG9mIHRoZSBib3VuZC9hc3NpZ25lZC10byBpZGVudGlmaWVycyBhcmUgcmVzZXJ2ZWQgd29yZHMuXG4vLyAtIFJlY29yZCBuYW1lIGRlY2xhcmF0aW9ucyBmb3IgYmluZGluZ3MgaW4gdGhlIGFwcHJvcHJpYXRlIHNjb3BlLlxuLy8gLSBDaGVjayBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMsIGlmIGNoZWNrQ2xhc2hlcyBpcyBzZXQuXG4vL1xuLy8gSWYgYSBjb21wbGV4IGJpbmRpbmcgcGF0dGVybiBpcyBlbmNvdW50ZXJlZCAoZS5nLiwgb2JqZWN0IGFuZCBhcnJheVxuLy8gZGVzdHJ1Y3R1cmluZyksIHRoZSBlbnRpcmUgcGF0dGVybiBpcyByZWN1cnNpdmVseSBjaGVja2VkLlxuLy9cbi8vIFRoZXJlIGFyZSB0aHJlZSB2ZXJzaW9ucyBvZiBjaGVja0xWYWwqKCkgYXBwcm9wcmlhdGUgZm9yIGRpZmZlcmVudFxuLy8gY2lyY3Vtc3RhbmNlczpcbi8vXG4vLyAtIGNoZWNrTFZhbFNpbXBsZSgpIHNoYWxsIGJlIHVzZWQgaWYgdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3Qgc3VwcG9ydHNcbi8vICAgbm90aGluZyBvdGhlciB0aGFuIGlkZW50aWZpZXJzIGFuZCBtZW1iZXIgZXhwcmVzc2lvbnMuIFBhcmVudGhlc2l6ZWRcbi8vICAgZXhwcmVzc2lvbnMgYXJlIGFsc28gY29ycmVjdGx5IGhhbmRsZWQuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvclxuLy8gICBjb25zdHJ1Y3RzIGZvciB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIEFzc2lnbm1lbnRUYXJnZXRUeXBlIG9mIFt0aGUgcHJvZHVjdGlvbl0gaXMgbm90XG4vLyAgID4gc2ltcGxlLlxuLy9cbi8vICAgSXQgaXMgYWxzbyBhcHByb3ByaWF0ZSBmb3IgY2hlY2tpbmcgaWYgYW4gaWRlbnRpZmllciBpcyB2YWxpZCBhbmQgbm90XG4vLyAgIGRlZmluZWQgZWxzZXdoZXJlLCBsaWtlIGltcG9ydCBkZWNsYXJhdGlvbnMgb3IgZnVuY3Rpb24vY2xhc3MgaWRlbnRpZmllcnMuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICBhICs9IFx1MjAyNjtcbi8vICAgICBpbXBvcnQgYSBmcm9tICdcdTIwMjYnO1xuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxQYXR0ZXJuKCkgc2hhbGwgYmUgdXNlZCBpZiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCBzdXBwb3J0c1xuLy8gICBhbnl0aGluZyBjaGVja0xWYWxTaW1wbGUoKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBvYmplY3QgYW5kIGFycmF5XG4vLyAgIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuIFRoaXMgaXMgZ2VuZXJhbGx5IGFwcHJvcHJpYXRlIGZvciBjb25zdHJ1Y3RzIGZvclxuLy8gICB3aGljaCB0aGUgc3BlYyBzYXlzXG4vL1xuLy8gICA+IEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIFt0aGUgcHJvZHVjdGlvbl0gaXMgbmVpdGhlciBhbiBPYmplY3RMaXRlcmFsIG5vclxuLy8gICA+IGFuIEFycmF5TGl0ZXJhbCBhbmQgQXNzaWdubWVudFRhcmdldFR5cGUgb2YgW3RoZSBwcm9kdWN0aW9uXSBpcyBub3Rcbi8vICAgPiBzaW1wbGUuXG4vL1xuLy8gICBFeGFtcGxlcyB3aGVyZSB0aGlzIGlzIHVzZWQgaW5jbHVkZTpcbi8vICAgICAoYSA9IFx1MjAyNik7XG4vLyAgICAgY29uc3QgYSA9IFx1MjAyNjtcbi8vICAgICB0cnkgeyBcdTIwMjYgfSBjYXRjaCAoYSkgeyBcdTIwMjYgfVxuLy8gICB3aGVyZSBhIGlzIHRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4vL1xuLy8gLSBjaGVja0xWYWxJbm5lclBhdHRlcm4oKSBzaGFsbCBiZSB1c2VkIGlmIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHN1cHBvcnRzXG4vLyAgIGFueXRoaW5nIGNoZWNrTFZhbFBhdHRlcm4oKSBzdXBwb3J0cywgYXMgd2VsbCBhcyBkZWZhdWx0IGFzc2lnbm1lbnRcbi8vICAgcGF0dGVybnMsIHJlc3QgZWxlbWVudHMsIGFuZCBvdGhlciBjb25zdHJ1Y3RzIHRoYXQgbWF5IGFwcGVhciB3aXRoaW4gYW5cbi8vICAgb2JqZWN0IG9yIGFycmF5IGRlc3RydWN0dXJpbmcgcGF0dGVybi5cbi8vXG4vLyAgIEFzIGEgc3BlY2lhbCBjYXNlLCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFsc28gdXNlIGNoZWNrTFZhbElubmVyUGF0dGVybigpLFxuLy8gICBhcyB0aGV5IGFsc28gc3VwcG9ydCBkZWZhdWx0cyBhbmQgcmVzdCBjb25zdHJ1Y3RzLlxuLy9cbi8vIFRoZXNlIGZ1bmN0aW9ucyBkZWxpYmVyYXRlbHkgc3VwcG9ydCBib3RoIGFzc2lnbm1lbnQgYW5kIGJpbmRpbmcgY29uc3RydWN0cyxcbi8vIGFzIHRoZSBsb2dpYyBmb3IgYm90aCBpcyBleGNlZWRpbmdseSBzaW1pbGFyLiBJZiB0aGUgbm9kZSBpcyB0aGUgdGFyZ2V0IG9mXG4vLyBhbiBhc3NpZ25tZW50LCB0aGVuIGJpbmRpbmdUeXBlIHNob3VsZCBiZSBzZXQgdG8gQklORF9OT05FLiBPdGhlcndpc2UsIGl0XG4vLyBzaG91bGQgYmUgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZSBCSU5EXyogY29uc3RhbnQsIGxpa2UgQklORF9WQVIgb3Jcbi8vIEJJTkRfTEVYSUNBTC5cbi8vXG4vLyBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYSBub24tQklORF9OT05FIGJpbmRpbmdUeXBlLCB0aGVuXG4vLyBhZGRpdGlvbmFsbHkgYSBjaGVja0NsYXNoZXMgb2JqZWN0IG1heSBiZSBzcGVjaWZpZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yXG4vLyBkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMuIGNoZWNrQ2xhc2hlcyBpcyBpZ25vcmVkIGlmIHRoZSBwcm92aWRlZCBjb25zdHJ1Y3Rcbi8vIGlzIGFuIGFzc2lnbm1lbnQgKGkuZS4sIGJpbmRpbmdUeXBlIGlzIEJJTkRfTk9ORSkuXG5cbnBwJDcuY2hlY2tMVmFsU2ltcGxlID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICB2YXIgaXNCaW5kID0gYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGlmIChpc0JpbmQpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXNPd24oY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gbGVmdC1oYW5kIHNpZGVcIik7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGlmIChpc0JpbmQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgaWYgKGlzQmluZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiKTsgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChpc0JpbmQgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG5wcCQ3LmNoZWNrTFZhbFBhdHRlcm4gPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5jaGVja0xWYWxTaW1wbGUoZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbn07XG5cbnBwJDcuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICB0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMuY2hlY2tMVmFsUGF0dGVybihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgfVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuXG52YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xufTtcblxudmFyIHR5cGVzID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ2LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMuYl9zdGF0XVxufTtcblxucHAkNi5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG5wcCQ2LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMuZl9zdGF0KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzJDEuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzJDEuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzLmJfc3RhdCB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMkMS5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ2LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDYudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzJDEuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBVc2VkIHRvIGhhbmRsZSBlZ2RlIGNhc2Ugd2hlbiB0b2tlbiBjb250ZXh0IGNvdWxkIG5vdCBiZSBpbmZlcnJlZCBjb3JyZWN0bHkgaW4gdG9rZW5pemUgcGhhc2VcbnBwJDYub3ZlcnJpZGVDb250ZXh0ID0gZnVuY3Rpb24odG9rZW5DdHgpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpICE9PSB0b2tlbkN0eCkge1xuICAgIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV0gPSB0b2tlbkN0eDtcbiAgfVxufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG50eXBlcyQxLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMkMS5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbn07XG5cbnR5cGVzJDEuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcy5iX3N0YXQgOiB0eXBlcy5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcyQxLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcyQxLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMkMS5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMucF9zdGF0IDogdHlwZXMucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcyQxLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMkMS5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzJDEuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMkMS5fZWxzZSAmJlxuICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMkMS5zZW1pICYmIHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5wX3N0YXQpICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcyQxLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcyQxLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcyQxLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLmJfc3RhdCkpXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLmZfc3RhdCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMkMS5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzJDEuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcyQxLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcy5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcy5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzJDEubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcyQxLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuXG52YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2ggXHUyMDE0XG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSBcdTIwMTQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQ1LmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgeyByZXR1cm4gfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgIHsgcmV0dXJuIH1cbiAgdmFyIGtleSA9IHByb3Aua2V5O1xuICB2YXIgbmFtZTtcbiAgc3dpdGNoIChrZXkudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOiBuYW1lID0ga2V5Lm5hbWU7IGJyZWFrXG4gIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgZGVmYXVsdDogcmV0dXJuXG4gIH1cbiAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApIHtcbiAgICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgaWYgKG90aGVyKSB7XG4gICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICB9XG4gICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgaW5pdDogZmFsc2UsXG4gICAgICBnZXQ6IGZhbHNlLFxuICAgICAgc2V0OiBmYWxzZVxuICAgIH07XG4gIH1cbiAgb3RoZXJba2luZF0gPSB0cnVlO1xufTtcblxuLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4vLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbi8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4vLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4vLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbi8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2Vcbi8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG5wcCQ1LnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGZvckluaXQsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQ1LnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkge1xuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoZm9ySW5pdCkgfVxuICAgIC8vIFRoZSB0b2tlbml6ZXIgd2lsbCBhc3N1bWUgYW4gZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGFmdGVyXG4gICAgLy8gYHlpZWxkYCwgYnV0IHRoaXMgaXNuJ3QgdGhhdCBraW5kIG9mIHlpZWxkXG4gICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICB9XG5cbiAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZSwgb2xkUGFyZW5Bc3NpZ24gPSAtMSwgb2xkVHJhaWxpbmdDb21tYSA9IC0xLCBvbGREb3VibGVQcm90byA9IC0xO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgIG9sZFRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWE7XG4gICAgb2xkRG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0O1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0ID0gZm9ySW5pdCA9PT0gXCJhd2FpdFwiO1xuICB9XG4gIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwoZm9ySW5pdCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVxKVxuICAgICAgeyBsZWZ0ID0gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gLTE7XG4gICAgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBsZWZ0LnN0YXJ0KVxuICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyB9IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5lcSlcbiAgICAgIHsgdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGxlZnQpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShsZWZ0KTsgfVxuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICBpZiAob2xkRG91YmxlUHJvdG8gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gb2xkRG91YmxlUHJvdG87IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICB9XG4gIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICByZXR1cm4gbGVmdFxufTtcblxuLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxucHAkNS5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbG9uKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmb3JJbml0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxucHAkNS5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihmb3JJbml0LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBmb3JJbml0KVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkNS5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KSB7XG4gIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICBpZiAocHJlYyAhPSBudWxsICYmICghZm9ySW5pdCB8fCB0aGlzLnR5cGUgIT09IHR5cGVzJDEuX2luKSkge1xuICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsQU5EO1xuICAgICAgdmFyIGNvYWxlc2NlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmNvYWxlc2NlO1xuICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgcHJlY2VkZW5jZSBvZiBgdHQuY29hbGVzY2VgIGFzIGVxdWFsIHRvIHRoZSByYW5nZSBvZiBsb2dpY2FsIGV4cHJlc3Npb25zLlxuICAgICAgICAvLyBJbiBvdGhlciB3b3JkcywgYG5vZGUucmlnaHRgIHNob3VsZG4ndCBjb250YWluIGxvZ2ljYWwgZXhwcmVzc2lvbnMgaW4gb3JkZXIgdG8gY2hlY2sgdGhlIG1peGVkIGVycm9yLlxuICAgICAgICBwcmVjID0gdHlwZXMkMS5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgfVxuICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIGZvckluaXQpO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwgfHwgY29hbGVzY2UpO1xuICAgICAgaWYgKChsb2dpY2FsICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2FsZXNjZSkgfHwgKGNvYWxlc2NlICYmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5sb2dpY2FsQU5EKSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiTG9naWNhbCBleHByZXNzaW9ucyBhbmQgY29hbGVzY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIG1peGVkLiBXcmFwIGVpdGhlciBieSBwYXJlbnRoZXNlc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBmb3JJbml0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVmdFxufTtcblxucHAkNS5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gIGlmIChyaWdodC50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIpIHsgdGhpcy5yYWlzZShyaWdodC5zdGFydCwgXCJQcml2YXRlIGlkZW50aWZpZXIgY2FuIG9ubHkgYmUgbGVmdCBzaWRlIG9mIGJpbmFyeSBleHByZXNzaW9uXCIpOyB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLm9wZXJhdG9yID0gb3A7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQ1LnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5LCBpbmNEZWMsIGZvckluaXQpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJiB0aGlzLmNhbkF3YWl0KSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdChmb3JJbml0KTtcbiAgICBzYXdVbmFyeSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcyQxLmluY0RlYztcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUsIHVwZGF0ZSwgZm9ySW5pdCk7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbFNpbXBsZShub2RlLmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5hcmd1bWVudCkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIlByaXZhdGUgZmllbGRzIGNhbiBub3QgYmUgZGVsZXRlZFwiKTsgfVxuICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wcml2YXRlSWQpIHtcbiAgICBpZiAoZm9ySW5pdCB8fCB0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgZXhwciA9IHRoaXMucGFyc2VQcml2YXRlSWRlbnQoKTtcbiAgICAvLyBvbmx5IGNvdWxkIGJlIHByaXZhdGUgZmllbGRzIGluICdpbicsIHN1Y2ggYXMgI3ggaW4gb2JqXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5faW4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZvckluaXQpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbFNpbXBsZShleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWluY0RlYyAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXJzdGFyKSkge1xuICAgIGlmIChzYXdVbmFyeSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSwgZmFsc2UsIGZvckluaXQpLCBcIioqXCIsIGZhbHNlKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0eS50eXBlID09PSBcIlByaXZhdGVJZGVudGlmaWVyXCIgfHxcbiAgICBub2RlLnR5cGUgPT09IFwiQ2hhaW5FeHByZXNzaW9uXCIgJiYgaXNQcml2YXRlRmllbGRBY2Nlc3Mobm9kZS5leHByZXNzaW9uKVxuICApXG59XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQ1LnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZm9ySW5pdCk7XG4gIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgZmFsc2UsIGZvckluaXQpO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSAtMTsgfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDUucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBmb3JJbml0KSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJlxuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICB2YXIgb3B0aW9uYWxDaGFpbmVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCk7XG5cbiAgICBpZiAoZWxlbWVudC5vcHRpb25hbCkgeyBvcHRpb25hbENoYWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGVsZW1lbnQgPT09IGJhc2UgfHwgZWxlbWVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdmFyIGNoYWluTm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgY2hhaW5Ob2RlLmV4cHJlc3Npb24gPSBlbGVtZW50O1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIGJhc2UgPSBlbGVtZW50O1xuICB9XG59O1xuXG5wcCQ1LnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCwgZm9ySW5pdCkge1xuICB2YXIgb3B0aW9uYWxTdXBwb3J0ZWQgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gIHZhciBvcHRpb25hbCA9IG9wdGlvbmFsU3VwcG9ydGVkICYmIHRoaXMuZWF0KHR5cGVzJDEucXVlc3Rpb25Eb3QpO1xuICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcyQxLmJyYWNrZXRMKTtcbiAgaWYgKGNvbXB1dGVkIHx8IChvcHRpb25hbCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5MICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5iYWNrUXVvdGUpIHx8IHRoaXMuZWF0KHR5cGVzJDEuZG90KSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFja2V0Uik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkICYmIGJhc2UudHlwZSAhPT0gXCJTdXBlclwiKSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVJZGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpO1xuICAgIH1cbiAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMkMS5wYXJlbkwpKSB7XG4gICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMkMS5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlLCBmb3JJbml0KVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICBpZiAob3B0aW9uYWxTdXBwb3J0ZWQpIHtcbiAgICAgIG5vZGUkMS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIH1cbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuYmFja1F1b3RlKSB7XG4gICAgaWYgKG9wdGlvbmFsIHx8IG9wdGlvbmFsQ2hhaW5lZCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRhZyBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbnNcIik7XG4gICAgfVxuICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gYmFzZVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24gXHUyMDE0IGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcCQ1LnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmb3JJbml0KSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzJDEuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciAoIEFyZ3VtZW50cyApXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMkMS5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcyQxLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMkMS5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMkMS5fZnVuY3Rpb24pKSB7XG4gICAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5mX2V4cHIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlLCBmb3JJbml0KVxuICAgIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UsIGZvckluaXQpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUgJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgKCF0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdCB8fCB0aGlzLnZhbHVlICE9PSBcIm9mXCIgfHwgdGhpcy5jb250YWluc0VzYykpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMkMS5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUsIGZvckluaXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMkMS5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMkMS5udW06IGNhc2UgdHlwZXMkMS5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcyQxLl9udWxsOiBjYXNlIHR5cGVzJDEuX3RydWU6IGNhc2UgdHlwZXMkMS5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMkMS5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93LCBmb3JJbml0KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzJDEuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcyQxLmJyYWNlTDpcbiAgICB0aGlzLm92ZXJyaWRlQ29udGV4dCh0eXBlcy5iX2V4cHIpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMkMS5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMkMS5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzJDEuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0eXBlcyQxLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzJDEuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkNS5wYXJzZUV4cHJJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIC8vIENvbnN1bWUgYGltcG9ydGAgYXMgYW4gaWRlbnRpZmllciBmb3IgYGltcG9ydC5tZXRhYC5cbiAgLy8gQmVjYXVzZSBgdGhpcy5wYXJzZUlkZW50KHRydWUpYCBkb2Vzbid0IGNoZWNrIGVzY2FwZSBzZXF1ZW5jZXMsIGl0IG5lZWRzIHRoZSBjaGVjayBvZiBgdGhpcy5jb250YWluc0VzY2AuXG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIGltcG9ydFwiKTsgfVxuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzJDEucGFyZW5MOlxuICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydChub2RlKVxuICBjYXNlIHR5cGVzJDEuZG90OlxuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbn07XG5cbnBwJDUucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTsgLy8gc2tpcCBgKGBcblxuICAvLyBQYXJzZSBub2RlLnNvdXJjZS5cbiAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcblxuICAvLyBWZXJpZnkgZW5kaW5nLlxuICBpZiAoIXRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgIHZhciBlcnJvclBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuY29tbWEpICYmIHRoaXMuZWF0KHR5cGVzJDEucGFyZW5SKSkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVycm9yUG9zLCBcIlRyYWlsaW5nIGNvbW1hIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoZXJyb3JQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQ1LnBhcnNlSW1wb3J0TWV0YSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7IC8vIHNraXAgYC5gXG5cbiAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcblxuICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcIm1ldGFcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIGltcG9ydCBpcyAnaW1wb3J0Lm1ldGEnXCIpOyB9XG4gIGlmIChjb250YWluc0VzYylcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIidpbXBvcnQubWV0YScgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlICE9PSBcIm1vZHVsZVwiICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiQ2Fubm90IHVzZSAnaW1wb3J0Lm1ldGEnIG91dHNpZGUgYSBtb2R1bGVcIik7IH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG59O1xuXG5wcCQ1LnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL18vZywgXCJcIik7IH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG59O1xuXG5wcCQ1LnBhcnNlUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzJDEucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxucHAkNS5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdywgZm9ySW5pdCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzJDEucGFyZW5SKSB7XG4gICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzLmV4cGVjdCh0eXBlcyQxLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMkMS5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmVsbGlwc2lzKSB7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5sYXN0VG9rRW5kLCBpbm5lckVuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLnBhcmVuUik7XG5cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcyQxLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCwgZm9ySW5pdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkNS5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDUucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QsIGZvckluaXQpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgZmFsc2UsIGZvckluaXQpXG59O1xuXG4vLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbi8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIFx1MjAxNCBhdCBsZWFzdCxcbi8vIG5vdCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHBhcmVudGhlc2VzLiBUaHVzLCBpdCB1c2VzIHRoZSBub0NhbGxzXG4vLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbi8vIGFyZ3VtZW50IGxpc3QuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcCQ1LnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMkMS5kb3QpKSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzICduZXcudGFyZ2V0J1wiKTsgfVxuICAgIGlmIChjb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgaWYgKCF0aGlzLmFsbG93TmV3RG90VGFyZ2V0KVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCInbmV3LnRhcmdldCcgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgYW5kIGNsYXNzIHN0YXRpYyBibG9ja1wiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGlzSW1wb3J0ID0gdGhpcy50eXBlID09PSB0eXBlcyQxLl9pbXBvcnQ7XG4gIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSwgZmFsc2UpO1xuICBpZiAoaXNJbXBvcnQgJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRFeHByZXNzaW9uXCIpIHtcbiAgICB0aGlzLnJhaXNlKHN0YXJ0UG9zLCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KClcIik7XG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcyQxLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkNS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSkge1xuICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICB9XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgIGNvb2tlZDogbnVsbFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDUucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcyQxLmRvbGxhckJyYWNlTCk7XG4gICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxufTtcblxucHAkNS5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICh0aGlzLnR5cGUgPT09IHR5cGVzJDEubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcyQxLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuc3RhcikpICYmXG4gICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbi8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxucHAkNS5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzJDEuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzJDEuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcyQxLmVsbGlwc2lzKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgfVxuICAgIC8vIFRvIGRpc2FsbG93IHBhcmVudGhlc2l6ZWQgaWRlbnRpZmllciB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGFyZ3VtZW50LlxuICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIC8vIEZpbmlzaFxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIH1cbiAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpOyB9XG4gIH1cbiAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgaXNBc3luYyA9IHRydWU7XG4gICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcyQxLnN0YXIpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5jb2xvbilcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzJDEuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMkMS5wYXJlbkwpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcyQxLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMkMS5icmFjZVIgJiYgdGhpcy50eXBlICE9PSB0eXBlcyQxLmVxKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCB0aGlzLmNvcHlOb2RlKHByb3Aua2V5KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgdGhpcy5jb3B5Tm9kZShwcm9wLmtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5jb3B5Tm9kZShwcm9wLmtleSk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDUucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcyQxLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMkMS5icmFja2V0Uik7XG4gICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzJDEubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMkMS5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQ1LmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5pZCA9IG51bGw7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gZmFsc2U7IH1cbn07XG5cbi8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbnBwJDUucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dEaXJlY3RTdXBlcikge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgdGhpcy5leHBlY3QodHlwZXMkMS5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcyQxLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxucHAkNS5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgZm9ySW5pdCkge1xuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSwgZm9ySW5pdCk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkNS5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QsIGZvckluaXQpIHtcbiAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzJDEuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZm9ySW5pdCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgIC8vIEVuc3VyZSB0aGUgZnVuY3Rpb24gbmFtZSBpc24ndCBhIGZvcmJpZGRlbiBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLCBlLmcuICdldmFsJ1xuICAgIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsU2ltcGxlKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5leGl0U2NvcGUoKTtcbn07XG5cbnBwJDUuaXNTaW1wbGVQYXJhbUxpc3QgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICB9IH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4vLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxucHAkNS5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICB2YXIgbmFtZUhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbi8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4vLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4vLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbi8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbnBwJDUucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzJDEuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzJDEuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQ1LmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gIGlmICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0ICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXJndW1lbnRzJyBpbiBjbGFzcyBmaWVsZCBpbml0aWFsaXplclwiKTsgfVxuICBpZiAodGhpcy5pbkNsYXNzU3RhdGljQmxvY2sgJiYgKG5hbWUgPT09IFwiYXJndW1lbnRzXCIgfHwgbmFtZSA9PT0gXCJhd2FpdFwiKSlcbiAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIkNhbm5vdCB1c2UgXCIgKyBuYW1lICsgXCIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrXCIpKTsgfVxuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQ1LnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoISFsaWJlcmFsKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxucHAkNS5wYXJzZVByaXZhdGVJZGVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzJDEucHJpdmF0ZUlkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZUlkZW50aWZpZXJcIik7XG5cbiAgLy8gRm9yIHZhbGlkYXRpbmcgZXhpc3RlbmNlXG4gIGlmICh0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCAoXCJQcml2YXRlIGZpZWxkICcjXCIgKyAobm9kZS5uYW1lKSArIFwiJyBtdXN0IGJlIGRlY2xhcmVkIGluIGFuIGVuY2xvc2luZyBjbGFzc1wiKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcml2YXRlTmFtZVN0YWNrW3RoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGggLSAxXS51c2VkLnB1c2gobm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAkNS5wYXJzZVlpZWxkID0gZnVuY3Rpb24oZm9ySW5pdCkge1xuICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcyQxLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcyQxLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMkMS5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZvckluaXQpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDUucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKGZvckluaXQpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUsIGZhbHNlLCBmb3JJbml0KTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxufTtcblxudmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmFpc2UgZXhjZXB0aW9ucyBvbiBwYXJzZSBlcnJvcnMuIEl0XG4vLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbi8vIG9mIHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgdGhlbiByYWlzZXMgYSBgU3ludGF4RXJyb3JgIHdpdGggdGhhdFxuLy8gbWVzc2FnZS5cblxucHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgdGhyb3cgZXJyXG59O1xuXG5wcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG5wcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gIH1cbn07XG5cbnZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxudmFyIFNjb3BlID0gZnVuY3Rpb24gU2NvcGUoZmxhZ3MpIHtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAvLyBBIGxpc3Qgb2YgdmFyLWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy52YXIgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMubGV4aWNhbCA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIEZ1bmN0aW9uRGVjbGFyYXRpb24gbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAvLyBBIHN3aXRjaCB0byBkaXNhbGxvdyB0aGUgaWRlbnRpZmllciByZWZlcmVuY2UgJ2FyZ3VtZW50cydcbiAgdGhpcy5pbkNsYXNzRmllbGRJbml0ID0gZmFsc2U7XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDMuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xufTtcblxucHAkMy5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxuLy8gVGhlIHNwZWMgc2F5czpcbi8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbi8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbnBwJDMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbn07XG5cbnBwJDMuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbn07XG5cbnBwJDMuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICB9XG59O1xuXG5wcCQzLmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxufTtcblxucHAkMy5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG4vLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbnBwJDMuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgfVxufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDIuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkMi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkMi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQyLmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbnBwJDIuY29weU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcywgbm9kZS5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gIGZvciAodmFyIHByb3AgaW4gbm9kZSkgeyBuZXdOb2RlW3Byb3BdID0gbm9kZVtwcm9wXTsgfVxuICByZXR1cm4gbmV3Tm9kZVxufTtcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdFxuLy8gc3BlY2lmaWNhdGlvbi4gVGhlIGxpc3RzIGFyZSBleHRyYWN0ZWQgbGlrZSBzbzpcbi8vICQkKCcjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllcyA+IGZpZ3VyZSA+IHRhYmxlID4gdGJvZHkgPiB0ciA+IHRkOm50aC1jaGlsZCgxKSBjb2RlJykubWFwKGVsID0+IGVsLmlubmVyVGV4dClcblxuLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbnZhciBlY21hOUJpbmFyeVByb3BlcnRpZXMgPSBcIkFTQ0lJIEFTQ0lJX0hleF9EaWdpdCBBSGV4IEFscGhhYmV0aWMgQWxwaGEgQW55IEFzc2lnbmVkIEJpZGlfQ29udHJvbCBCaWRpX0MgQmlkaV9NaXJyb3JlZCBCaWRpX00gQ2FzZV9JZ25vcmFibGUgQ0kgQ2FzZWQgQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQgQ1dDRiBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNIENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkIENXTCBDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkIENXS0NGIENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVCBDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCBDV1UgRGFzaCBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJIERlcHJlY2F0ZWQgRGVwIERpYWNyaXRpYyBEaWEgRW1vamkgRW1vamlfQ29tcG9uZW50IEVtb2ppX01vZGlmaWVyIEVtb2ppX01vZGlmaWVyX0Jhc2UgRW1vamlfUHJlc2VudGF0aW9uIEV4dGVuZGVyIEV4dCBHcmFwaGVtZV9CYXNlIEdyX0Jhc2UgR3JhcGhlbWVfRXh0ZW5kIEdyX0V4dCBIZXhfRGlnaXQgSGV4IElEU19CaW5hcnlfT3BlcmF0b3IgSURTQiBJRFNfVHJpbmFyeV9PcGVyYXRvciBJRFNUIElEX0NvbnRpbnVlIElEQyBJRF9TdGFydCBJRFMgSWRlb2dyYXBoaWMgSWRlbyBKb2luX0NvbnRyb2wgSm9pbl9DIExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRSBMb3dlcmNhc2UgTG93ZXIgTWF0aCBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhciBQYXR0ZXJuX1N5bnRheCBQYXRfU3luIFBhdHRlcm5fV2hpdGVfU3BhY2UgUGF0X1dTIFF1b3RhdGlvbl9NYXJrIFFNYXJrIFJhZGljYWwgUmVnaW9uYWxfSW5kaWNhdG9yIFJJIFNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtIFNvZnRfRG90dGVkIFNEIFRlcm1pbmFsX1B1bmN0dWF0aW9uIFRlcm0gVW5pZmllZF9JZGVvZ3JhcGggVUlkZW8gVXBwZXJjYXNlIFVwcGVyIFZhcmlhdGlvbl9TZWxlY3RvciBWUyBXaGl0ZV9TcGFjZSBzcGFjZSBYSURfQ29udGludWUgWElEQyBYSURfU3RhcnQgWElEU1wiO1xudmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbnZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbnZhciBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTExQmluYXJ5UHJvcGVydGllcyArIFwiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdFwiO1xudmFyIGVjbWExM0JpbmFyeVByb3BlcnRpZXMgPSBlY21hMTJCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllcyxcbiAgMTI6IGVjbWExMkJpbmFyeVByb3BlcnRpZXMsXG4gIDEzOiBlY21hMTNCaW5hcnlQcm9wZXJ0aWVzXG59O1xuXG4vLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xudmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xudmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG52YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xudmFyIGVjbWExMVNjcmlwdFZhbHVlcyA9IGVjbWExMFNjcmlwdFZhbHVlcyArIFwiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2Nob1wiO1xudmFyIGVjbWExMlNjcmlwdFZhbHVlcyA9IGVjbWExMVNjcmlwdFZhbHVlcyArIFwiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaVwiO1xudmFyIGVjbWExM1NjcmlwdFZhbHVlcyA9IGVjbWExMlNjcmlwdFZhbHVlcyArIFwiIEN5cHJvX01pbm9hbiBDcG1uIE9sZF9VeWdodXIgT3VnciBUYW5nc2EgVG5zYSBUb3RvIFZpdGhrdXFpIFZpdGhcIjtcbnZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgMTE6IGVjbWExMVNjcmlwdFZhbHVlcyxcbiAgMTI6IGVjbWExMlNjcmlwdFZhbHVlcyxcbiAgMTM6IGVjbWExM1NjcmlwdFZhbHVlc1xufTtcblxudmFyIGRhdGEgPSB7fTtcbmZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgbm9uQmluYXJ5OiB7XG4gICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgfVxuICB9O1xuICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbn1cblxuZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBbOSwgMTAsIDExLCAxMiwgMTNdOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICB2YXIgZWNtYVZlcnNpb24gPSBsaXN0W2ldO1xuXG4gIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pO1xufVxuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMyA/IFwiZFwiIDogXCJcIik7XG4gIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEzID8gMTMgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gIHRoaXMuc291cmNlID0gXCJcIjtcbiAgdGhpcy5mbGFncyA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG59O1xuXG4vLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGksIGZvcmNlVSkge1xuICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICByZXR1cm4gY1xuICB9XG4gIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSksIG5leHQ7XG4gIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgIHJldHVybiBpICsgMVxuICB9XG4gIHJldHVybiBpICsgMlxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLmF0KHRoaXMucG9zLCBmb3JjZVUpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpLCBmb3JjZVUpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlIChmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcywgZm9yY2VVKTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCwgZm9yY2VVKSB7XG4gICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmN1cnJlbnQoZm9yY2VVKSA9PT0gY2gpIHtcbiAgICB0aGlzLmFkdmFuY2UoZm9yY2VVKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjaCkge1xuICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gIGNoIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDEudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkMS52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbnBwJDEucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5wb3MgPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkMS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgfVxuXG4gIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbnBwJDEucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgeyB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxucHAkMS5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxucHAkMS5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAvLyBeLCAkXG4gIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBcXGIgXFxCXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxucHAkMS5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG5wcCQxLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICApXG59O1xucHAkMS5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG5wcCQxLnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICApXG59O1xucHAkMS5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQxLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQxLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDEucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDEucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkMS5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVxucHAkMS5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWUgYD5gXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDEucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyTmFtZSA6OlxuLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRcbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWUgUmVnRXhwSWRlbnRpZmllclBhcnRcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJTdGFydCA6OlxuLy8gICBVbmljb2RlSURTdGFydFxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWytVXVxucHAkMS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgZm9yY2VVID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gUmVnRXhwSWRlbnRpZmllclBhcnQgOjpcbi8vICAgVW5pY29kZUlEQ29udGludWVcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVsrVV1cbi8vICAgPFpXTko+XG4vLyAgIDxaV0o+XG5wcCQxLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGZvcmNlVSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICBzdGF0ZS5hZHZhbmNlKGZvcmNlVSk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZm9yY2VVKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbnBwJDEucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoXG4gICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg2QiAvKiBrICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DaGFyYWN0ZXJFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZmFsc2UpIHx8XG4gICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICApXG59O1xucHAkMS5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkMS5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgLyogMCAqLyAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA9PT0gMHg3NCAvKiB0ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDZFIC8qIG4gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyAvKiBcXG4gKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IC8qIFxcdiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2NiAvKiBmICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDcyIC8qIHIgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyAvKiBcXHIgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xMZXR0ZXJcbnBwJDEucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg1QSAvKiBaICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxucHAkMS5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUsIGZvcmNlVSkge1xuICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgc3dpdGNoVSA9IGZvcmNlVSB8fCBzdGF0ZS5zd2l0Y2hVO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHN3aXRjaFUgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSAmJlxuICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSWRlbnRpdHlFc2NhcGVcbnBwJDEucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDJGIC8qIC8gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbnBwJDEucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA+PSAweDMxIC8qIDEgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgZG8ge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKFxuICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgIChjaCA9PT0gMHg1MCAvKiBQICovIHx8IGNoID09PSAweDcwIC8qIHAgKi8pXG4gICkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgY2ggPT09IDB4NzMgLyogcyAqLyB8fFxuICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgY2ggPT09IDB4NTcgLyogVyAqL1xuICApXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbnBwJDEucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgLyogPSAqLykpIHtcbiAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSwgbmFtZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZVwiKTsgfVxufTtcbnBwJDEucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdChuYW1lT3JWYWx1ZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxufTtcblxuLy8gVW5pY29kZVByb3BlcnR5TmFtZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xucHAkMS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQxLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG59XG5cbi8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDEucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG5wcCQxLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgIHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogXSAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFVucmVhY2hhYmxlIHNpbmNlIGl0IHRocmV3IFwidW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiIGVycm9yIGJlZm9yZS5cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxucHAkMS5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbnBwJDEucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NUQgLyogXSAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbnBwJDEucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQxLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkMS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDEucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkMS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQxLnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQxLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwLm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHRoaXMudHlwZS5rZXl3b3JkKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwLmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG59O1xuXG4vLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gIHsgcHBbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzJDEuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxufTtcblxucHAuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGRjMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gbmV4dCA8PSAweGRiZmYgfHwgbmV4dCA+PSAweGUwMDAgPyBjb2RlIDogKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgZm9yICh2YXIgbmV4dEJyZWFrID0gKHZvaWQgMCksIHBvcyA9IHN0YXJ0OyAobmV4dEJyZWFrID0gbmV4dExpbmVCcmVhayh0aGlzLmlucHV0LCBwb3MsIHRoaXMucG9zKSkgPiAtMTspIHtcbiAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgcG9zID0gdGhpcy5saW5lU3RhcnQgPSBuZXh0QnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwLnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICBjYXNlIDQyOiAvLyAnKidcbiAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbi8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbi8vIHRoZSB0b2tlbiwgc28gdGhhdCB0aGUgbmV4dCBvbmUncyBgc3RhcnRgIHdpbGwgcG9pbnQgYXQgdGhlXG4vLyByaWdodCBwb3NpdGlvbi5cblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwLnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5kb3QpXG4gIH1cbn07XG5cbnBwLnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuc2xhc2gsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnJSonXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgdmFyIHRva2VudHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMkMS5zdGFyIDogdHlwZXMkMS5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMkMS5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcyQxLmxvZ2ljYWxPUiA6IHR5cGVzJDEubG9naWNhbEFORCwgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMkMS5iaXR3aXNlT1IgOiB0eXBlcyQxLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5pbmNEZWMsIDIpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzJDEucGx1c01pbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5iaXRTaGlmdCwgc2l6ZSlcbiAgfVxuICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcyQxLmVxIDogdHlwZXMkMS5wcmVmaXgsIDEpXG59O1xuXG5wcC5yZWFkVG9rZW5fcXVlc3Rpb24gPSBmdW5jdGlvbigpIHsgLy8gJz8nXG4gIHZhciBlY21hVmVyc2lvbiA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtcbiAgaWYgKGVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNDYpIHtcbiAgICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgICAgaWYgKG5leHQyIDwgNDggfHwgbmV4dDIgPiA1NykgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnF1ZXN0aW9uRG90LCAyKSB9XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKGVjbWFWZXJzaW9uID49IDEyKSB7XG4gICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgIGlmIChuZXh0MiQxID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLmFzc2lnbiwgMykgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5jb2FsZXNjZSwgMilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMkMS5xdWVzdGlvbiwgMSlcbn07XG5cbnBwLnJlYWRUb2tlbl9udW1iZXJTaWduID0gZnVuY3Rpb24oKSB7IC8vICcjJ1xuICB2YXIgZWNtYVZlcnNpb24gPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247XG4gIHZhciBjb2RlID0gMzU7IC8vICcjJ1xuICBpZiAoZWNtYVZlcnNpb24gPj0gMTMpIHtcbiAgICArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRydWUpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucHJpdmF0ZUlkLCB0aGlzLnJlYWRXb3JkMSgpKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcC5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmNvbG9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDYzOiAvLyAnPydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcyQxLnByZWZpeCwgMSlcblxuICBjYXNlIDM1OiAvLyAnIydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbnVtYmVyU2lnbigpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICB0aGlzLnBvcyArPSBzaXplO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG59O1xuXG5wcC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICB0cnkge1xuICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAvLyBgbGVuYCBpcyB1c2VkIGZvciBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcy4gSW4gdGhhdCBjYXNlLCBkaXNhbGxvdyBzZXBhcmF0b3JzLlxuICB2YXIgYWxsb3dTZXBhcmF0b3JzID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEyICYmIGxlbiA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIGBtYXliZUxlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWxgIGlzIHRydWUgaWYgaXQgZG9lc24ndCBoYXZlIHByZWZpeCAoMHgsMG8sMGIpXG4gIC8vIGFuZCBpc24ndCBmcmFjdGlvbiBwYXJ0IG5vciBleHBvbmVudCBwYXJ0LiBJbiB0aGF0IGNhc2UsIGlmIHRoZSBmaXJzdCBkaWdpdFxuICAvLyBpcyB6ZXJvIHRoZW4gZGlzYWxsb3cgc2VwYXJhdG9ycy5cbiAgdmFyIGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCA9IG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSA0ODtcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwLCBsYXN0Q29kZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSwgKyt0aGlzLnBvcykge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGNvZGUgPT09IDk1KSB7XG4gICAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBpbiBsZWdhY3kgb2N0YWwgbnVtZXJpYyBsaXRlcmFsc1wiKTsgfVxuICAgICAgaWYgKGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlXCIpOyB9XG4gICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIFwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICBsYXN0Q29kZSA9IGNvZGU7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG5cbiAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBsYXN0Q29kZSA9PT0gOTUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zIC0gMSwgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBhdCB0aGUgbGFzdCBvZiBkaWdpdHNcIik7IH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxuZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXIoc3RyLCBpc0xlZ2FjeU9jdGFsTnVtZXJpY0xpdGVyYWwpIHtcbiAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIHJldHVybiBwYXJzZUludChzdHIsIDgpXG4gIH1cblxuICAvLyBgcGFyc2VGbG9hdCh2YWx1ZSlgIHN0b3BzIHBhcnNpbmcgYXQgdGhlIGZpcnN0IG51bWVyaWMgc2VwYXJhdG9yIHRoZW4gcmV0dXJucyBhIHdyb25nIHZhbHVlLlxuICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CaWdJbnQoc3RyKSB7XG4gIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gYEJpZ0ludCh2YWx1ZSlgIHRocm93cyBzeW50YXggZXJyb3IgaWYgdGhlIHN0cmluZyBjb250YWlucyBudW1lcmljIHNlcGFyYXRvcnMuXG4gIHJldHVybiBCaWdJbnQoc3RyLnJlcGxhY2UoL18vZywgXCJcIikpXG59XG5cbnBwLnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICArK3RoaXMucG9zO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwLnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgIHZhciB2YWwkMSA9IHN0cmluZ1RvQmlnSW50KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5udW0sIHZhbCQxKVxuICB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgdmFsID0gc3RyaW5nVG9OdW1iZXIodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCBvY3RhbCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnBwLnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lKys7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcysrKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMkMS5zdHJpbmcsIG91dClcbn07XG5cbi8vIFJlYWRzIHRlbXBsYXRlIHN0cmluZyB0b2tlbnMuXG5cbnZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG5wcC50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbn07XG5cbnBwLmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgfVxufTtcblxucHAucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMkMS50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzJDEuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmRvbGxhckJyYWNlTClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzJDEuYmFja1F1b3RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLnRlbXBsYXRlLCBvdXQpXG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xucHAucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCIkXCI6XG4gICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgIGNhc2UgXCJgXCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcyQxLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9XG4gIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbnBwLnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICBzd2l0Y2ggKGNoKSB7XG4gIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIiAvLyAnbicgLT4gJ1xcbidcbiAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgLy8gJ3gnXG4gIGNhc2UgMTE3OiByZXR1cm4gY29kZVBvaW50VG9TdHJpbmcodGhpcy5yZWFkQ29kZVBvaW50KCkpIC8vICd1J1xuICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIC8vICdiJyAtPiAnXFxiJ1xuICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIC8vICd2JyAtPiAnXFx1MDAwYidcbiAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSAvLyAnXFxyXFxuJ1xuICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgIHJldHVybiBcIlwiXG4gIGNhc2UgNTY6XG4gIGNhc2UgNTc6XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgdGhpcy5wb3MgLSAxLFxuICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zIC0gMTtcblxuICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgIGNvZGVQb3MsXG4gICAgICAgIFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICBkZWZhdWx0OlxuICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICB9XG4gICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgIC8vIFVuaWNvZGUgbmV3IGxpbmUgY2hhcmFjdGVycyBhZnRlciBcXCBnZXQgcmVtb3ZlZCBmcm9tIG91dHB1dCBpbiBib3RoXG4gICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbnBwLnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gIHJldHVybiBuXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4vLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbi8vXG4vLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4vLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxucHAucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nKGVzYyk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4vLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxucHAucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICB2YXIgdHlwZSA9IHR5cGVzJDEubmFtZTtcbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgIHR5cGUgPSBrZXl3b3Jkc1t3b3JkXTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxufTtcblxuLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cblxudmFyIHZlcnNpb24gPSBcIjguNy4wXCI7XG5cblBhcnNlci5hY29ybiA9IHtcbiAgUGFyc2VyOiBQYXJzZXIsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgUG9zaXRpb246IFBvc2l0aW9uLFxuICBTb3VyY2VMb2NhdGlvbjogU291cmNlTG9jYXRpb24sXG4gIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgTm9kZTogTm9kZSxcbiAgVG9rZW5UeXBlOiBUb2tlblR5cGUsXG4gIHRva1R5cGVzOiB0eXBlcyQxLFxuICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzLFxuICBUb2tDb250ZXh0OiBUb2tDb250ZXh0LFxuICB0b2tDb250ZXh0czogdHlwZXMsXG4gIGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG4gIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgVG9rZW46IFRva2VuLFxuICBpc05ld0xpbmU6IGlzTmV3TGluZSxcbiAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gIG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG59O1xuXG5jbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IobWF4UGFyYWxsZWwpIHtcbiAgICAgICAgdGhpcy5tYXhQYXJhbGxlbCA9IG1heFBhcmFsbGVsO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMud29ya2VyQ291bnQgPSAwO1xuICAgIH1cbiAgICBydW4odGFzaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgcmVqZWN0LCByZXNvbHZlLCB0YXNrIH0pO1xuICAgICAgICAgICAgdGhpcy53b3JrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3b3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJDb3VudCA+PSB0aGlzLm1heFBhcmFsbGVsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLndvcmtlckNvdW50Kys7XG4gICAgICAgIGxldCBlbnRyeTtcbiAgICAgICAgd2hpbGUgKChlbnRyeSA9IHRoaXMucXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0LCByZXNvbHZlLCB0YXNrIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGFzaygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmtlckNvdW50LS07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSWRWaWFQbHVnaW5zKHNvdXJjZSwgaW1wb3J0ZXIsIHBsdWdpbkRyaXZlciwgbW9kdWxlTG9hZGVyUmVzb2x2ZUlkLCBza2lwLCBjdXN0b21PcHRpb25zLCBpc0VudHJ5KSB7XG4gICAgbGV0IHNraXBwZWQgPSBudWxsO1xuICAgIGxldCByZXBsYWNlQ29udGV4dCA9IG51bGw7XG4gICAgaWYgKHNraXApIHtcbiAgICAgICAgc2tpcHBlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBza2lwcGVkQ2FsbCBvZiBza2lwKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBza2lwcGVkQ2FsbC5zb3VyY2UgJiYgaW1wb3J0ZXIgPT09IHNraXBwZWRDYWxsLmltcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZC5hZGQoc2tpcHBlZENhbGwucGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlQ29udGV4dCA9IChwbHVnaW5Db250ZXh0LCBwbHVnaW4pID0+ICh7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0LFxuICAgICAgICAgICAgcmVzb2x2ZTogKHNvdXJjZSwgaW1wb3J0ZXIsIHsgY3VzdG9tLCBpc0VudHJ5LCBza2lwU2VsZiB9ID0gQkxBTkspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlTG9hZGVyUmVzb2x2ZUlkKHNvdXJjZSwgaW1wb3J0ZXIsIGN1c3RvbSwgaXNFbnRyeSwgc2tpcFNlbGYgPyBbLi4uc2tpcCwgeyBpbXBvcnRlciwgcGx1Z2luLCBzb3VyY2UgfV0gOiBza2lwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5Ecml2ZXIuaG9va0ZpcnN0KCdyZXNvbHZlSWQnLCBbc291cmNlLCBpbXBvcnRlciwgeyBjdXN0b206IGN1c3RvbU9wdGlvbnMsIGlzRW50cnkgfV0sIHJlcGxhY2VDb250ZXh0LCBza2lwcGVkKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUlkKHNvdXJjZSwgaW1wb3J0ZXIsIHByZXNlcnZlU3ltbGlua3MsIHBsdWdpbkRyaXZlciwgbW9kdWxlTG9hZGVyUmVzb2x2ZUlkLCBza2lwLCBjdXN0b21PcHRpb25zLCBpc0VudHJ5KSB7XG4gICAgY29uc3QgcGx1Z2luUmVzdWx0ID0gYXdhaXQgcmVzb2x2ZUlkVmlhUGx1Z2lucyhzb3VyY2UsIGltcG9ydGVyLCBwbHVnaW5Ecml2ZXIsIG1vZHVsZUxvYWRlclJlc29sdmVJZCwgc2tpcCwgY3VzdG9tT3B0aW9ucywgaXNFbnRyeSk7XG4gICAgaWYgKHBsdWdpblJlc3VsdCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcGx1Z2luUmVzdWx0O1xuICAgIC8vIGV4dGVybmFsIG1vZHVsZXMgKG5vbi1lbnRyeSBtb2R1bGVzIHRoYXQgc3RhcnQgd2l0aCBuZWl0aGVyICcuJyBvciAnLycpXG4gICAgLy8gYXJlIHNraXBwZWQgYXQgdGhpcyBzdGFnZS5cbiAgICBpZiAoaW1wb3J0ZXIgIT09IHVuZGVmaW5lZCAmJiAhaXNBYnNvbHV0ZShzb3VyY2UpICYmIHNvdXJjZVswXSAhPT0gJy4nKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBgcmVzb2x2ZWAgcHJvY2Vzc2VzIHBhdGhzIGZyb20gcmlnaHQgdG8gbGVmdCwgcHJlcGVuZGluZyB0aGVtIHVudGlsIGFuXG4gICAgLy8gYWJzb2x1dGUgcGF0aCBpcyBjcmVhdGVkLiBBYnNvbHV0ZSBpbXBvcnRlZXMgdGhlcmVmb3JlIHNob3J0Y2lyY3VpdCB0aGVcbiAgICAvLyByZXNvbHZlIGNhbGwgYW5kIHJlcXVpcmUgbm8gc3BlY2lhbCBoYW5kaW5nIG9uIG91ciBwYXJ0LlxuICAgIC8vIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhdGguaHRtbCNwYXRoX3BhdGhfcmVzb2x2ZV9wYXRoc1xuICAgIHJldHVybiBhZGRKc0V4dGVuc2lvbklmTmVjZXNzYXJ5KGltcG9ydGVyID8gcmVzb2x2ZShkaXJuYW1lKGltcG9ydGVyKSwgc291cmNlKSA6IHJlc29sdmUoc291cmNlKSwgcHJlc2VydmVTeW1saW5rcyk7XG59XG5hc3luYyBmdW5jdGlvbiBhZGRKc0V4dGVuc2lvbklmTmVjZXNzYXJ5KGZpbGUsIHByZXNlcnZlU3ltbGlua3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoKF9iID0gKF9hID0gKGF3YWl0IGZpbmRGaWxlKGZpbGUsIHByZXNlcnZlU3ltbGlua3MpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGF3YWl0IGZpbmRGaWxlKGZpbGUgKyAnLm1qcycsIHByZXNlcnZlU3ltbGlua3MpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKGF3YWl0IGZpbmRGaWxlKGZpbGUgKyAnLmpzJywgcHJlc2VydmVTeW1saW5rcykpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmRGaWxlKGZpbGUsIHByZXNlcnZlU3ltbGlua3MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHByb21pc2VzLmxzdGF0KGZpbGUpO1xuICAgICAgICBpZiAoIXByZXNlcnZlU3ltbGlua3MgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSlcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmaW5kRmlsZShhd2FpdCBwcm9taXNlcy5yZWFscGF0aChmaWxlKSwgcHJlc2VydmVTeW1saW5rcyk7XG4gICAgICAgIGlmICgocHJlc2VydmVTeW1saW5rcyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB8fCBzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgY2FzZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGJhc2VuYW1lKGZpbGUpO1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBwcm9taXNlcy5yZWFkZGlyKGRpcm5hbWUoZmlsZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGVzLmluY2x1ZGVzKG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBzdXBwcmVzc1xuICAgIH1cbn1cblxuY29uc3QgQU5PTllNT1VTX1BMVUdJTl9QUkVGSVggPSAnYXQgcG9zaXRpb24gJztcbmNvbnN0IEFOT05ZTU9VU19PVVRQVVRfUExVR0lOX1BSRUZJWCA9ICdhdCBvdXRwdXQgcG9zaXRpb24gJztcbmZ1bmN0aW9uIHRocm93UGx1Z2luRXJyb3IoZXJyLCBwbHVnaW4sIHsgaG9vaywgaWQgfSA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKVxuICAgICAgICBlcnIgPSB7IG1lc3NhZ2U6IGVyciB9O1xuICAgIGlmIChlcnIuY29kZSAmJiBlcnIuY29kZSAhPT0gRXJyb3JzLlBMVUdJTl9FUlJPUikge1xuICAgICAgICBlcnIucGx1Z2luQ29kZSA9IGVyci5jb2RlO1xuICAgIH1cbiAgICBlcnIuY29kZSA9IEVycm9ycy5QTFVHSU5fRVJST1I7XG4gICAgZXJyLnBsdWdpbiA9IHBsdWdpbjtcbiAgICBpZiAoaG9vaykge1xuICAgICAgICBlcnIuaG9vayA9IGhvb2s7XG4gICAgfVxuICAgIGlmIChpZCkge1xuICAgICAgICBlcnIuaWQgPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yKGVycik7XG59XG5jb25zdCBkZXByZWNhdGVkSG9va3MgPSBbXG4gICAgeyBhY3RpdmU6IHRydWUsIGRlcHJlY2F0ZWQ6ICdyZXNvbHZlQXNzZXRVcmwnLCByZXBsYWNlbWVudDogJ3Jlc29sdmVGaWxlVXJsJyB9XG5dO1xuZnVuY3Rpb24gd2FybkRlcHJlY2F0ZWRIb29rcyhwbHVnaW5zLCBvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCB7IGFjdGl2ZSwgZGVwcmVjYXRlZCwgcmVwbGFjZW1lbnQgfSBvZiBkZXByZWNhdGVkSG9va3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKGRlcHJlY2F0ZWQgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBcIiR7ZGVwcmVjYXRlZH1cIiBob29rIHVzZWQgYnkgcGx1Z2luICR7cGx1Z2luLm5hbWV9IGlzIGRlcHJlY2F0ZWQuIFRoZSBcIiR7cmVwbGFjZW1lbnR9XCIgaG9vayBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLmAsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLm5hbWVcbiAgICAgICAgICAgICAgICB9LCBhY3RpdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW5DYWNoZShjYWNoZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGV0ZShpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgICAgIH0sXG4gICAgICAgIGdldChpZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGNhY2hlW2lkXTtcbiAgICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbVswXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVsxXTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gY2FjaGVbaWRdO1xuICAgICAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGl0ZW1bMF0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChpZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhY2hlW2lkXSA9IFswLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tlZFBsdWdpbkNhY2hlKHBsdWdpbkNhY2hlLCBvblVzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGV0ZShpZCkge1xuICAgICAgICAgICAgb25Vc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5DYWNoZS5kZWxldGUoaWQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQoaWQpIHtcbiAgICAgICAgICAgIG9uVXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luQ2FjaGUuZ2V0KGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGlkKSB7XG4gICAgICAgICAgICBvblVzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkNhY2hlLmhhcyhpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChpZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9uVXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luQ2FjaGUuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgTk9fQ0FDSEUgPSB7XG4gICAgZGVsZXRlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBoYXMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHNldCgpIHsgfVxufTtcbmZ1bmN0aW9uIHVuY2FjaGVhYmxlUGx1Z2luRXJyb3IocGx1Z2luTmFtZSkge1xuICAgIGlmIChwbHVnaW5OYW1lLnN0YXJ0c1dpdGgoQU5PTllNT1VTX1BMVUdJTl9QUkVGSVgpIHx8XG4gICAgICAgIHBsdWdpbk5hbWUuc3RhcnRzV2l0aChBTk9OWU1PVVNfT1VUUFVUX1BMVUdJTl9QUkVGSVgpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAnQU5PTllNT1VTX1BMVUdJTl9DQUNIRScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQSBwbHVnaW4gaXMgdHJ5aW5nIHRvIHVzZSB0aGUgUm9sbHVwIGNhY2hlIGJ1dCBpcyBub3QgZGVjbGFyaW5nIGEgcGx1Z2luIG5hbWUgb3IgY2FjaGVLZXkuJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yKHtcbiAgICAgICAgY29kZTogJ0RVUExJQ0FURV9QTFVHSU5fTkFNRScsXG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgcGx1Z2luIG5hbWUgJHtwbHVnaW5OYW1lfSBpcyBiZWluZyB1c2VkIHR3aWNlIGluIHRoZSBzYW1lIGJ1aWxkLiBQbHVnaW4gbmFtZXMgbXVzdCBiZSBkaXN0aW5jdCBvciBwcm92aWRlIGEgY2FjaGVLZXkgKHBsZWFzZSBwb3N0IGFuIGlzc3VlIHRvIHRoZSBwbHVnaW4gaWYgeW91IGFyZSBhIHBsdWdpbiB1c2VyKS5gXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDYWNoZUZvclVuY2FjaGVhYmxlUGx1Z2luKHBsdWdpbk5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxldGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5jYWNoZWFibGVQbHVnaW5FcnJvcihwbHVnaW5OYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuY2FjaGVhYmxlUGx1Z2luRXJyb3IocGx1Z2luTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmNhY2hlYWJsZVBsdWdpbkVycm9yKHBsdWdpbk5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5jYWNoZWFibGVQbHVnaW5FcnJvcihwbHVnaW5OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybShzb3VyY2UsIG1vZHVsZSwgcGx1Z2luRHJpdmVyLCB3YXJuKSB7XG4gICAgY29uc3QgaWQgPSBtb2R1bGUuaWQ7XG4gICAgY29uc3Qgc291cmNlbWFwQ2hhaW4gPSBbXTtcbiAgICBsZXQgb3JpZ2luYWxTb3VyY2VtYXAgPSBzb3VyY2UubWFwID09PSBudWxsID8gbnVsbCA6IGRlY29kZWRTb3VyY2VtYXAoc291cmNlLm1hcCk7XG4gICAgY29uc3Qgb3JpZ2luYWxDb2RlID0gc291cmNlLmNvZGU7XG4gICAgbGV0IGFzdCA9IHNvdXJjZS5hc3Q7XG4gICAgY29uc3QgdHJhbnNmb3JtRGVwZW5kZW5jaWVzID0gW107XG4gICAgY29uc3QgZW1pdHRlZEZpbGVzID0gW107XG4gICAgbGV0IGN1c3RvbVRyYW5zZm9ybUNhY2hlID0gZmFsc2U7XG4gICAgY29uc3QgdXNlQ3VzdG9tVHJhbnNmb3JtQ2FjaGUgPSAoKSA9PiAoY3VzdG9tVHJhbnNmb3JtQ2FjaGUgPSB0cnVlKTtcbiAgICBsZXQgcGx1Z2luTmFtZSA9ICcnO1xuICAgIGNvbnN0IGN1clNvdXJjZSA9IHNvdXJjZS5jb2RlO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlZHVjZXIocHJldmlvdXNDb2RlLCByZXN1bHQsIHBsdWdpbikge1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgbGV0IG1hcDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb2RlID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbW9kdWxlLnVwZGF0ZU9wdGlvbnMocmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY29kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXAgfHwgcmVzdWx0LmFzdCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGVyck5vVHJhbnNmb3JtTWFwT3JBc3RXaXRob3V0Q29kZShwbHVnaW4ubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHsgY29kZSwgbWFwLCBhc3QgfSA9IHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNDb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmljdCBudWxsIGNoZWNrIGFsbG93cyAnbnVsbCcgbWFwcyB0byBub3QgYmUgcHVzaGVkIHRvIHRoZSBjaGFpbixcbiAgICAgICAgLy8gd2hpbGUgJ3VuZGVmaW5lZCcgZ2V0cyB0aGUgbWlzc2luZyBtYXAgd2FybmluZ1xuICAgICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VtYXBDaGFpbi5wdXNoKGRlY29kZWRTb3VyY2VtYXAodHlwZW9mIG1hcCA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXApIHx8IHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBsZXQgY29kZTtcbiAgICB0cnkge1xuICAgICAgICBjb2RlID0gYXdhaXQgcGx1Z2luRHJpdmVyLmhvb2tSZWR1Y2VBcmcwKCd0cmFuc2Zvcm0nLCBbY3VyU291cmNlLCBpZF0sIHRyYW5zZm9ybVJlZHVjZXIsIChwbHVnaW5Db250ZXh0LCBwbHVnaW4pID0+IHtcbiAgICAgICAgICAgIHBsdWdpbk5hbWUgPSBwbHVnaW4ubmFtZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCxcbiAgICAgICAgICAgICAgICBhZGRXYXRjaEZpbGUoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRGVwZW5kZW5jaWVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5Db250ZXh0LmFkZFdhdGNoRmlsZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWNoZTogY3VzdG9tVHJhbnNmb3JtQ2FjaGVcbiAgICAgICAgICAgICAgICAgICAgPyBwbHVnaW5Db250ZXh0LmNhY2hlXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0VHJhY2tlZFBsdWdpbkNhY2hlKHBsdWdpbkNvbnRleHQuY2FjaGUsIHVzZUN1c3RvbVRyYW5zZm9ybUNhY2hlKSxcbiAgICAgICAgICAgICAgICBlbWl0QXNzZXQobmFtZSwgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRGaWxlcy5wdXNoKHsgbmFtZSwgc291cmNlLCB0eXBlOiAnYXNzZXQnIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luQ29udGV4dC5lbWl0QXNzZXQobmFtZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtaXRDaHVuayhpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVkRmlsZXMucHVzaCh7IGlkLCBuYW1lOiBvcHRpb25zICYmIG9wdGlvbnMubmFtZSwgdHlwZTogJ2NodW5rJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkNvbnRleHQuZW1pdENodW5rKGlkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtaXRGaWxlKGVtaXR0ZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRGaWxlcy5wdXNoKGVtaXR0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkRyaXZlci5lbWl0RmlsZShlbWl0dGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcihlcnIsIHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSB7IG1lc3NhZ2U6IGVyciB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudENvZGVMb2NhdGlvbihlcnIsIHBvcywgY3VyU291cmNlLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGVyci5pZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICBlcnIuaG9vayA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luQ29udGV4dC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0Q29tYmluZWRTb3VyY2VtYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkTWFwID0gY29sbGFwc2VTb3VyY2VtYXAoaWQsIG9yaWdpbmFsQ29kZSwgb3JpZ2luYWxTb3VyY2VtYXAsIHNvdXJjZW1hcENoYWluLCB3YXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21iaW5lZE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFnaWNTdHJpbmcgPSBuZXcgTWFnaWNTdHJpbmckMShvcmlnaW5hbENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hZ2ljU3RyaW5nLmdlbmVyYXRlTWFwKHsgaGlyZXM6IHRydWUsIGluY2x1ZGVDb250ZW50OiB0cnVlLCBzb3VyY2U6IGlkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFNvdXJjZW1hcCAhPT0gY29tYmluZWRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU291cmNlbWFwID0gY29tYmluZWRNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VtYXBDaGFpbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbWJpbmVkTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNDb250ZW50OiBjb21iaW5lZE1hcC5zb3VyY2VzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldEFzc2V0U291cmNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnSU5WQUxJRF9TRVRBU1NFVFNPVVJDRScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgc2V0QXNzZXRTb3VyY2UgY2Fubm90IGJlIGNhbGxlZCBpbiB0cmFuc2Zvcm0gZm9yIGNhY2hpbmcgcmVhc29ucy4gVXNlIGVtaXRGaWxlIHdpdGggYSBzb3VyY2UsIG9yIGNhbGwgc2V0QXNzZXRTb3VyY2UgaW4gYW5vdGhlciBob29rLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3YXJuKHdhcm5pbmcsIHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhcm5pbmcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZyA9IHsgbWVzc2FnZTogd2FybmluZyB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudENvZGVMb2NhdGlvbih3YXJuaW5nLCBwb3MsIGN1clNvdXJjZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcuaG9vayA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5Db250ZXh0Lndhcm4od2FybmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3dQbHVnaW5FcnJvcihlcnIsIHBsdWdpbk5hbWUsIHsgaG9vazogJ3RyYW5zZm9ybScsIGlkIH0pO1xuICAgIH1cbiAgICBpZiAoIWN1c3RvbVRyYW5zZm9ybUNhY2hlKSB7XG4gICAgICAgIC8vIGZpbGVzIGVtaXR0ZWQgYnkgYSB0cmFuc2Zvcm0gaG9vayBuZWVkIHRvIGJlIGVtaXR0ZWQgYWdhaW4gaWYgdGhlIGhvb2sgaXMgc2tpcHBlZFxuICAgICAgICBpZiAoZW1pdHRlZEZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgIG1vZHVsZS50cmFuc2Zvcm1GaWxlcyA9IGVtaXR0ZWRGaWxlcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN0LFxuICAgICAgICBjb2RlLFxuICAgICAgICBjdXN0b21UcmFuc2Zvcm1DYWNoZSxcbiAgICAgICAgb3JpZ2luYWxDb2RlLFxuICAgICAgICBvcmlnaW5hbFNvdXJjZW1hcCxcbiAgICAgICAgc291cmNlbWFwQ2hhaW4sXG4gICAgICAgIHRyYW5zZm9ybURlcGVuZGVuY2llc1xuICAgIH07XG59XG5cbmNvbnN0IFJFU09MVkVfREVQRU5ERU5DSUVTID0gJ3Jlc29sdmVEZXBlbmRlbmNpZXMnO1xuY2xhc3MgTW9kdWxlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihncmFwaCwgbW9kdWxlc0J5SWQsIG9wdGlvbnMsIHBsdWdpbkRyaXZlcikge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWQgPSBtb2R1bGVzQnlJZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wbHVnaW5Ecml2ZXIgPSBwbHVnaW5Ecml2ZXI7XG4gICAgICAgIHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLm1vZHVsZUxvYWRQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tb2R1bGVzV2l0aExvYWRlZERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5uZXh0Q2h1bmtOYW1lUHJpb3JpdHkgPSAwO1xuICAgICAgICB0aGlzLm5leHRFbnRyeU1vZHVsZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yZXNvbHZlSWQgPSBhc3luYyAoc291cmNlLCBpbXBvcnRlciwgY3VzdG9tT3B0aW9ucywgaXNFbnRyeSwgc2tpcCA9IG51bGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHModGhpcy5nZXROb3JtYWxpemVkUmVzb2x2ZWRJZFdpdGhvdXREZWZhdWx0cyh0aGlzLm9wdGlvbnMuZXh0ZXJuYWwoc291cmNlLCBpbXBvcnRlciwgZmFsc2UpXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogYXdhaXQgcmVzb2x2ZUlkKHNvdXJjZSwgaW1wb3J0ZXIsIHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVN5bWxpbmtzLCB0aGlzLnBsdWdpbkRyaXZlciwgdGhpcy5yZXNvbHZlSWQsIHNraXAsIGN1c3RvbU9wdGlvbnMsIHR5cGVvZiBpc0VudHJ5ID09PSAnYm9vbGVhbicgPyBpc0VudHJ5IDogIWltcG9ydGVyKSwgaW1wb3J0ZXIsIHNvdXJjZSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc01vZHVsZVNpZGVFZmZlY3RzID0gb3B0aW9ucy50cmVlc2hha2VcbiAgICAgICAgICAgID8gb3B0aW9ucy50cmVlc2hha2UubW9kdWxlU2lkZUVmZmVjdHNcbiAgICAgICAgICAgIDogKCkgPT4gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkUXVldWUgPSBuZXcgUXVldWUob3B0aW9ucy5tYXhQYXJhbGxlbEZpbGVSZWFkcyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEFkZGl0aW9uYWxNb2R1bGVzKHVucmVzb2x2ZWRNb2R1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXh0ZW5kTG9hZE1vZHVsZXNQcm9taXNlKFByb21pc2UuYWxsKHVucmVzb2x2ZWRNb2R1bGVzLm1hcChpZCA9PiB0aGlzLmxvYWRFbnRyeU1vZHVsZShpZCwgZmFsc2UsIHVuZGVmaW5lZCwgbnVsbCkpKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgYWRkRW50cnlNb2R1bGVzKHVucmVzb2x2ZWRFbnRyeU1vZHVsZXMsIGlzVXNlckRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZmlyc3RFbnRyeU1vZHVsZUluZGV4ID0gdGhpcy5uZXh0RW50cnlNb2R1bGVJbmRleDtcbiAgICAgICAgdGhpcy5uZXh0RW50cnlNb2R1bGVJbmRleCArPSB1bnJlc29sdmVkRW50cnlNb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZmlyc3RDaHVua05hbWVQcmlvcml0eSA9IHRoaXMubmV4dENodW5rTmFtZVByaW9yaXR5O1xuICAgICAgICB0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eSArPSB1bnJlc29sdmVkRW50cnlNb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3RW50cnlNb2R1bGVzID0gYXdhaXQgdGhpcy5leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UoUHJvbWlzZS5hbGwodW5yZXNvbHZlZEVudHJ5TW9kdWxlcy5tYXAoKHsgaWQsIGltcG9ydGVyIH0pID0+IHRoaXMubG9hZEVudHJ5TW9kdWxlKGlkLCB0cnVlLCBpbXBvcnRlciwgbnVsbCkpKS50aGVuKGVudHJ5TW9kdWxlcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZW50cnlNb2R1bGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5TW9kdWxlID0gZW50cnlNb2R1bGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBlbnRyeU1vZHVsZS5pc1VzZXJEZWZpbmVkRW50cnlQb2ludCA9XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5TW9kdWxlLmlzVXNlckRlZmluZWRFbnRyeVBvaW50IHx8IGlzVXNlckRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWRkQ2h1bmtOYW1lc1RvTW9kdWxlKGVudHJ5TW9kdWxlLCB1bnJlc29sdmVkRW50cnlNb2R1bGVzW2luZGV4XSwgaXNVc2VyRGVmaW5lZCwgZmlyc3RDaHVua05hbWVQcmlvcml0eSArIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ZWRNb2R1bGUgPSB0aGlzLmluZGV4ZWRFbnRyeU1vZHVsZXMuZmluZChpbmRleGVkTW9kdWxlID0+IGluZGV4ZWRNb2R1bGUubW9kdWxlID09PSBlbnRyeU1vZHVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0luZGV4ZWRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleGVkRW50cnlNb2R1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGZpcnN0RW50cnlNb2R1bGVJbmRleCArIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBlbnRyeU1vZHVsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5kZXhlZE1vZHVsZS5pbmRleCA9IE1hdGgubWluKGV4aXN0aW5nSW5kZXhlZE1vZHVsZS5pbmRleCwgZmlyc3RFbnRyeU1vZHVsZUluZGV4ICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcy5zb3J0KCh7IGluZGV4OiBpbmRleEEgfSwgeyBpbmRleDogaW5kZXhCIH0pID0+IGluZGV4QSA+IGluZGV4QiA/IDEgOiAtMSk7XG4gICAgICAgICAgICByZXR1cm4gZW50cnlNb2R1bGVzO1xuICAgICAgICB9KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudHJ5TW9kdWxlczogdGhpcy5pbmRleGVkRW50cnlNb2R1bGVzLm1hcCgoeyBtb2R1bGUgfSkgPT4gbW9kdWxlKSxcbiAgICAgICAgICAgIGltcGxpY2l0RW50cnlNb2R1bGVzOiBbLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc10sXG4gICAgICAgICAgICBuZXdFbnRyeU1vZHVsZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZW1pdENodW5rKHsgZmlsZU5hbWUsIGlkLCBpbXBvcnRlciwgbmFtZSwgaW1wbGljaXRseUxvYWRlZEFmdGVyT25lT2YsIHByZXNlcnZlU2lnbmF0dXJlIH0pIHtcbiAgICAgICAgY29uc3QgdW5yZXNvbHZlZE1vZHVsZSA9IHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpbXBvcnRlcixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJPbmVPZlxuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLmFkZEVudHJ5V2l0aEltcGxpY2l0RGVwZW5kYW50cyh1bnJlc29sdmVkTW9kdWxlLCBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJPbmVPZilcbiAgICAgICAgICAgIDogKGF3YWl0IHRoaXMuYWRkRW50cnlNb2R1bGVzKFt1bnJlc29sdmVkTW9kdWxlXSwgZmFsc2UpKS5uZXdFbnRyeU1vZHVsZXNbMF07XG4gICAgICAgIGlmIChwcmVzZXJ2ZVNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtb2R1bGUucHJlc2VydmVTaWduYXR1cmUgPSBwcmVzZXJ2ZVNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBhc3luYyBwcmVsb2FkTW9kdWxlKHJlc29sdmVkSWQpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgdGhpcy5mZXRjaE1vZHVsZSh0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHMocmVzb2x2ZWRJZCksIHVuZGVmaW5lZCwgZmFsc2UsIHJlc29sdmVkSWQucmVzb2x2ZURlcGVuZGVuY2llcyA/IFJFU09MVkVfREVQRU5ERU5DSUVTIDogdHJ1ZSk7XG4gICAgICAgIHJldHVybiBtb2R1bGUuaW5mbztcbiAgICB9XG4gICAgYWRkRW50cnlXaXRoSW1wbGljaXREZXBlbmRhbnRzKHVucmVzb2x2ZWRNb2R1bGUsIGltcGxpY2l0bHlMb2FkZWRBZnRlcikge1xuICAgICAgICBjb25zdCBjaHVua05hbWVQcmlvcml0eSA9IHRoaXMubmV4dENodW5rTmFtZVByaW9yaXR5Kys7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZExvYWRNb2R1bGVzUHJvbWlzZSh0aGlzLmxvYWRFbnRyeU1vZHVsZSh1bnJlc29sdmVkTW9kdWxlLmlkLCBmYWxzZSwgdW5yZXNvbHZlZE1vZHVsZS5pbXBvcnRlciwgbnVsbCkudGhlbihhc3luYyAoZW50cnlNb2R1bGUpID0+IHtcbiAgICAgICAgICAgIGFkZENodW5rTmFtZXNUb01vZHVsZShlbnRyeU1vZHVsZSwgdW5yZXNvbHZlZE1vZHVsZSwgZmFsc2UsIGNodW5rTmFtZVByaW9yaXR5KTtcbiAgICAgICAgICAgIGlmICghZW50cnlNb2R1bGUuaW5mby5pc0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcy5hZGQoZW50cnlNb2R1bGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0bHlMb2FkZWRBZnRlck1vZHVsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbXBsaWNpdGx5TG9hZGVkQWZ0ZXIubWFwKGlkID0+IHRoaXMubG9hZEVudHJ5TW9kdWxlKGlkLCBmYWxzZSwgdW5yZXNvbHZlZE1vZHVsZS5pbXBvcnRlciwgZW50cnlNb2R1bGUuaWQpKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgaW1wbGljaXRseUxvYWRlZEFmdGVyTW9kdWxlcykge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeU1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kYW50IG9mIGVudHJ5TW9kdWxlLmltcGxpY2l0bHlMb2FkZWRBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRhbnQuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5hZGQoZW50cnlNb2R1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnRyeU1vZHVsZTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBhZGRNb2R1bGVTb3VyY2UoaWQsIGltcG9ydGVyLCBtb2R1bGUpIHtcbiAgICAgICAgdGltZVN0YXJ0KCdsb2FkIG1vZHVsZXMnLCAzKTtcbiAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZSA9IGF3YWl0IHRoaXMucmVhZFF1ZXVlLnJ1bihhc3luYyAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IChhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rRmlyc3QoJ2xvYWQnLCBbaWRdKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChhd2FpdCBwcm9taXNlcy5yZWFkRmlsZShpZCwgJ3V0ZjgnKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRpbWVFbmQoJ2xvYWQgbW9kdWxlcycsIDMpO1xuICAgICAgICAgICAgbGV0IG1zZyA9IGBDb3VsZCBub3QgbG9hZCAke2lkfWA7XG4gICAgICAgICAgICBpZiAoaW1wb3J0ZXIpXG4gICAgICAgICAgICAgICAgbXNnICs9IGAgKGltcG9ydGVkIGJ5ICR7cmVsYXRpdmVJZChpbXBvcnRlcil9KWA7XG4gICAgICAgICAgICBtc2cgKz0gYDogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGltZUVuZCgnbG9hZCBtb2R1bGVzJywgMyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZURlc2NyaXB0aW9uID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8geyBjb2RlOiBzb3VyY2UgfVxuICAgICAgICAgICAgOiBzb3VyY2UgIT0gbnVsbCAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc291cmNlLmNvZGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgICAgICAgICA6IGVycm9yKGVyckJhZExvYWRlcihpZCkpO1xuICAgICAgICBjb25zdCBjYWNoZWRNb2R1bGUgPSB0aGlzLmdyYXBoLmNhY2hlZE1vZHVsZXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGNhY2hlZE1vZHVsZSAmJlxuICAgICAgICAgICAgIWNhY2hlZE1vZHVsZS5jdXN0b21UcmFuc2Zvcm1DYWNoZSAmJlxuICAgICAgICAgICAgY2FjaGVkTW9kdWxlLm9yaWdpbmFsQ29kZSA9PT0gc291cmNlRGVzY3JpcHRpb24uY29kZSAmJlxuICAgICAgICAgICAgIShhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rRmlyc3QoJ3Nob3VsZFRyYW5zZm9ybUNhY2hlZE1vZHVsZScsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFzdDogY2FjaGVkTW9kdWxlLmFzdCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY2FjaGVkTW9kdWxlLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjYWNoZWRNb2R1bGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IGNhY2hlZE1vZHVsZS5tZXRhLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogY2FjaGVkTW9kdWxlLm1vZHVsZVNpZGVFZmZlY3RzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFNvdXJjZXM6IGNhY2hlZE1vZHVsZS5yZXNvbHZlZElkcyxcbiAgICAgICAgICAgICAgICAgICAgc3ludGhldGljTmFtZWRFeHBvcnRzOiBjYWNoZWRNb2R1bGUuc3ludGhldGljTmFtZWRFeHBvcnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSkpKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVkTW9kdWxlLnRyYW5zZm9ybUZpbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbWl0dGVkRmlsZSBvZiBjYWNoZWRNb2R1bGUudHJhbnNmb3JtRmlsZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luRHJpdmVyLmVtaXRGaWxlKGVtaXR0ZWRGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZS5zZXRTb3VyY2UoY2FjaGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS51cGRhdGVPcHRpb25zKHNvdXJjZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIG1vZHVsZS5zZXRTb3VyY2UoYXdhaXQgdHJhbnNmb3JtKHNvdXJjZURlc2NyaXB0aW9uLCBtb2R1bGUsIHRoaXMucGx1Z2luRHJpdmVyLCB0aGlzLm9wdGlvbnMub253YXJuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKSB7XG4gICAgICAgIGxldCBzdGFydGluZ1Byb21pc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nUHJvbWlzZSA9IHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgc3RhcnRpbmdQcm9taXNlO1xuICAgICAgICB9IHdoaWxlIChzdGFydGluZ1Byb21pc2UgIT09IHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlKTtcbiAgICB9XG4gICAgZXh0ZW5kTG9hZE1vZHVsZXNQcm9taXNlKGxvYWROZXdNb2R1bGVzUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGxvYWROZXdNb2R1bGVzUHJvbWlzZSxcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvKiBBdm9pZCB1bmhhbmRsZWQgUHJvbWlzZSByZWplY3Rpb25zICovXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbG9hZE5ld01vZHVsZXNQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaER5bmFtaWNEZXBlbmRlbmNpZXMobW9kdWxlLCByZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2VzKSB7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc29sdmVEeW5hbWljSW1wb3J0UHJvbWlzZXMubWFwKHJlc29sdmVEeW5hbWljSW1wb3J0UHJvbWlzZSA9PiByZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2UudGhlbihhc3luYyAoW2R5bmFtaWNJbXBvcnQsIHJlc29sdmVkSWRdKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRJZCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWRJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljSW1wb3J0LnJlc29sdXRpb24gPSByZXNvbHZlZElkO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChkeW5hbWljSW1wb3J0LnJlc29sdXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUmVzb2x2ZWREZXBlbmRlbmN5KHJlbGF0aXZlSWQocmVzb2x2ZWRJZC5pZCksIG1vZHVsZS5pZCwgcmVzb2x2ZWRJZCkpO1xuICAgICAgICB9KSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5keW5hbWljRGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5LmR5bmFtaWNJbXBvcnRlcnMucHVzaChtb2R1bGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYSBwcmVsb2FkLCB0aGVuIHRoaXMgbWV0aG9kIGFsd2F5cyB3YWl0cyBmb3IgdGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgbW9kdWxlIHRvIGJlIHJlc29sdmVkLlxuICAgIC8vIE90aGVyd2lzZSBpZiB0aGUgbW9kdWxlIGRvZXMgbm90IGV4aXN0LCBpdCB3YWl0cyBmb3IgdGhlIG1vZHVsZSBhbmQgYWxsIGl0cyBkZXBlbmRlbmNpZXMgdG8gYmUgbG9hZGVkLlxuICAgIC8vIE90aGVyd2lzZSBpdCByZXR1cm5zIGltbWVkaWF0ZWx5LlxuICAgIGFzeW5jIGZldGNoTW9kdWxlKHsgaWQsIG1ldGEsIG1vZHVsZVNpZGVFZmZlY3RzLCBzeW50aGV0aWNOYW1lZEV4cG9ydHMgfSwgaW1wb3J0ZXIsIGlzRW50cnksIGlzUHJlbG9hZCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ01vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUV4aXN0aW5nTW9kdWxlKGV4aXN0aW5nTW9kdWxlLCBpc0VudHJ5LCBpc1ByZWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTW9kdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBNb2R1bGUodGhpcy5ncmFwaCwgaWQsIHRoaXMub3B0aW9ucywgaXNFbnRyeSwgbW9kdWxlU2lkZUVmZmVjdHMsIHN5bnRoZXRpY05hbWVkRXhwb3J0cywgbWV0YSk7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWQuc2V0KGlkLCBtb2R1bGUpO1xuICAgICAgICB0aGlzLmdyYXBoLndhdGNoRmlsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLmFkZE1vZHVsZVNvdXJjZShpZCwgaW1wb3J0ZXIsIG1vZHVsZSkudGhlbigoKSA9PiBbXG4gICAgICAgICAgICB0aGlzLmdldFJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMobW9kdWxlKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlcyhtb2R1bGUpLFxuICAgICAgICAgICAgbG9hZEFuZFJlc29sdmVEZXBlbmRlbmNpZXNQcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBsb2FkQW5kUmVzb2x2ZURlcGVuZGVuY2llc1Byb21pc2UgPSB3YWl0Rm9yRGVwZW5kZW5jeVJlc29sdXRpb24obG9hZFByb21pc2UpLnRoZW4oKCkgPT4gdGhpcy5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdtb2R1bGVQYXJzZWQnLCBbbW9kdWxlLmluZm9dKSk7XG4gICAgICAgIGxvYWRBbmRSZXNvbHZlRGVwZW5kZW5jaWVzUHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvKiBhdm9pZCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZHVsZUxvYWRQcm9taXNlcy5zZXQobW9kdWxlLCBsb2FkUHJvbWlzZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVEZXBlbmRlbmN5UHJvbWlzZXMgPSBhd2FpdCBsb2FkUHJvbWlzZTtcbiAgICAgICAgaWYgKCFpc1ByZWxvYWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hNb2R1bGVEZXBlbmRlbmNpZXMobW9kdWxlLCAuLi5yZXNvbHZlRGVwZW5kZW5jeVByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByZWxvYWQgPT09IFJFU09MVkVfREVQRU5ERU5DSUVTKSB7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQW5kUmVzb2x2ZURlcGVuZGVuY2llc1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hNb2R1bGVEZXBlbmRlbmNpZXMobW9kdWxlLCByZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2VzLCByZXNvbHZlRHluYW1pY0RlcGVuZGVuY3lQcm9taXNlcywgbG9hZEFuZFJlc29sdmVEZXBlbmRlbmNpZXNQcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZXNXaXRoTG9hZGVkRGVwZW5kZW5jaWVzLmhhcyhtb2R1bGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGVzV2l0aExvYWRlZERlcGVuZGVuY2llcy5hZGQobW9kdWxlKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5mZXRjaFN0YXRpY0RlcGVuZGVuY2llcyhtb2R1bGUsIHJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMpLFxuICAgICAgICAgICAgdGhpcy5mZXRjaER5bmFtaWNEZXBlbmRlbmNpZXMobW9kdWxlLCByZXNvbHZlRHluYW1pY0RlcGVuZGVuY3lQcm9taXNlcylcbiAgICAgICAgXSk7XG4gICAgICAgIG1vZHVsZS5saW5rSW1wb3J0cygpO1xuICAgICAgICAvLyBUbyBoYW5kbGUgZXJyb3JzIHdoZW4gcmVzb2x2aW5nIGRlcGVuZGVuY2llcyBvciBpbiBtb2R1bGVQYXJzZWRcbiAgICAgICAgYXdhaXQgbG9hZEFuZFJlc29sdmVEZXBlbmRlbmNpZXNQcm9taXNlO1xuICAgIH1cbiAgICBmZXRjaFJlc29sdmVkRGVwZW5kZW5jeShzb3VyY2UsIGltcG9ydGVyLCByZXNvbHZlZElkKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZElkLmV4dGVybmFsKSB7XG4gICAgICAgICAgICBjb25zdCB7IGV4dGVybmFsLCBpZCwgbW9kdWxlU2lkZUVmZmVjdHMsIG1ldGEgfSA9IHJlc29sdmVkSWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9kdWxlc0J5SWQuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlc0J5SWQuc2V0KGlkLCBuZXcgRXh0ZXJuYWxNb2R1bGUodGhpcy5vcHRpb25zLCBpZCwgbW9kdWxlU2lkZUVmZmVjdHMsIG1ldGEsIGV4dGVybmFsICE9PSAnYWJzb2x1dGUnICYmIGlzQWJzb2x1dGUoaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRlcm5hbE1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICghKGV4dGVybmFsTW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckludGVybmFsSWRDYW5ub3RCZUV4dGVybmFsKHNvdXJjZSwgaW1wb3J0ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZXh0ZXJuYWxNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoTW9kdWxlKHJlc29sdmVkSWQsIGltcG9ydGVyLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFN0YXRpY0RlcGVuZGVuY2llcyhtb2R1bGUsIHJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGF3YWl0IFByb21pc2UuYWxsKHJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMubWFwKHJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZSA9PiByZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2UudGhlbigoW3NvdXJjZSwgcmVzb2x2ZWRJZF0pID0+IHRoaXMuZmV0Y2hSZXNvbHZlZERlcGVuZGVuY3koc291cmNlLCBtb2R1bGUuaWQsIHJlc29sdmVkSWQpKSkpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIGRlcGVuZGVuY3kuaW1wb3J0ZXJzLnB1c2gobW9kdWxlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50cmVlc2hha2UgfHwgbW9kdWxlLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMgPT09ICduby10cmVlc2hha2UnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgbW9kdWxlLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kuaW1wb3J0ZWRGcm9tTm90VHJlZXNoYWtlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5vcm1hbGl6ZWRSZXNvbHZlZElkV2l0aG91dERlZmF1bHRzKHJlc29sdmVJZFJlc3VsdCwgaW1wb3J0ZXIsIHNvdXJjZSkge1xuICAgICAgICBjb25zdCB7IG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChyZXNvbHZlSWRSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZUlkUmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsID0gcmVzb2x2ZUlkUmVzdWx0LmV4dGVybmFsIHx8IHRoaXMub3B0aW9ucy5leHRlcm5hbChyZXNvbHZlSWRSZXN1bHQuaWQsIGltcG9ydGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXNvbHZlSWRSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBleHRlcm5hbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGV4dGVybmFsID09PSAncmVsYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzQWJzb2x1dGUocmVzb2x2ZUlkUmVzdWx0LmlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleHRlcm5hbCA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05vdEFic29sdXRlRXh0ZXJuYWwocmVzb2x2ZUlkUmVzdWx0LmlkLCBzb3VyY2UsIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWJzb2x1dGUnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRlcm5hbCA9IHRoaXMub3B0aW9ucy5leHRlcm5hbChyZXNvbHZlSWRSZXN1bHQsIGltcG9ydGVyLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IGV4dGVybmFsICYmXG4gICAgICAgICAgICAgICAgICAgIChpc05vdEFic29sdXRlRXh0ZXJuYWwocmVzb2x2ZUlkUmVzdWx0LCBzb3VyY2UsIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fic29sdXRlJyksXG4gICAgICAgICAgICAgICAgaWQ6IGV4dGVybmFsICYmIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlXG4gICAgICAgICAgICAgICAgICAgID8gbm9ybWFsaXplUmVsYXRpdmVFeHRlcm5hbElkKHJlc29sdmVJZFJlc3VsdCwgaW1wb3J0ZXIpXG4gICAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZUlkUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gbWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmVcbiAgICAgICAgICAgID8gbm9ybWFsaXplUmVsYXRpdmVFeHRlcm5hbElkKHNvdXJjZSwgaW1wb3J0ZXIpXG4gICAgICAgICAgICA6IHNvdXJjZTtcbiAgICAgICAgaWYgKHJlc29sdmVJZFJlc3VsdCAhPT0gZmFsc2UgJiYgIXRoaXMub3B0aW9ucy5leHRlcm5hbChpZCwgaW1wb3J0ZXIsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXh0ZXJuYWw6IGlzTm90QWJzb2x1dGVFeHRlcm5hbChpZCwgc291cmNlLCBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZSkgfHwgJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJlc29sdmVEeW5hbWljSW1wb3J0UHJvbWlzZXMobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZHluYW1pY0ltcG9ydHMubWFwKGFzeW5jIChkeW5hbWljSW1wb3J0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZElkID0gYXdhaXQgdGhpcy5yZXNvbHZlRHluYW1pY0ltcG9ydChtb2R1bGUsIHR5cGVvZiBkeW5hbWljSW1wb3J0LmFyZ3VtZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZHluYW1pY0ltcG9ydC5hcmd1bWVudFxuICAgICAgICAgICAgICAgIDogZHluYW1pY0ltcG9ydC5hcmd1bWVudC5lc1RyZWVOb2RlLCBtb2R1bGUuaWQpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkSWQgJiYgdHlwZW9mIHJlc29sdmVkSWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0ltcG9ydC5pZCA9IHJlc29sdmVkSWQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2R5bmFtaWNJbXBvcnQsIHJlc29sdmVkSWRdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcyhtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obW9kdWxlLnNvdXJjZXMsIGFzeW5jIChzb3VyY2UpID0+IFtcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIChtb2R1bGUucmVzb2x2ZWRJZHNbc291cmNlXSA9XG4gICAgICAgICAgICAgICAgbW9kdWxlLnJlc29sdmVkSWRzW3NvdXJjZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHZlSWQoYXdhaXQgdGhpcy5yZXNvbHZlSWQoc291cmNlLCBtb2R1bGUuaWQsIEVNUFRZX09CSkVDVCwgZmFsc2UpLCBzb3VyY2UsIG1vZHVsZS5pZCkpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlZElkV2l0aERlZmF1bHRzKHJlc29sdmVkSWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZXNvbHZlZElkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlcm5hbCA9IHJlc29sdmVkSWQuZXh0ZXJuYWwgfHwgZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHRlcm5hbCxcbiAgICAgICAgICAgIGlkOiByZXNvbHZlZElkLmlkLFxuICAgICAgICAgICAgbWV0YTogcmVzb2x2ZWRJZC5tZXRhIHx8IHt9LFxuICAgICAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6IChfYSA9IHJlc29sdmVkSWQubW9kdWxlU2lkZUVmZmVjdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuaGFzTW9kdWxlU2lkZUVmZmVjdHMocmVzb2x2ZWRJZC5pZCwgISFleHRlcm5hbCksXG4gICAgICAgICAgICBzeW50aGV0aWNOYW1lZEV4cG9ydHM6IChfYiA9IHJlc29sdmVkSWQuc3ludGhldGljTmFtZWRFeHBvcnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVFeGlzdGluZ01vZHVsZShtb2R1bGUsIGlzRW50cnksIGlzUHJlbG9hZCkge1xuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IHRoaXMubW9kdWxlTG9hZFByb21pc2VzLmdldChtb2R1bGUpO1xuICAgICAgICBpZiAoaXNQcmVsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVsb2FkID09PSBSRVNPTFZFX0RFUEVOREVOQ0lFU1xuICAgICAgICAgICAgICAgID8gd2FpdEZvckRlcGVuZGVuY3lSZXNvbHV0aW9uKGxvYWRQcm9taXNlKVxuICAgICAgICAgICAgICAgIDogbG9hZFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRW50cnkpIHtcbiAgICAgICAgICAgIG1vZHVsZS5pbmZvLmlzRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcy5kZWxldGUobW9kdWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kYW50IG9mIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRhbnQuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5kZWxldGUobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE1vZHVsZURlcGVuZGVuY2llcyhtb2R1bGUsIC4uLihhd2FpdCBsb2FkUHJvbWlzZSkpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHZlSWQocmVzb2x2ZWRJZCwgc291cmNlLCBpbXBvcnRlcikge1xuICAgICAgICBpZiAocmVzb2x2ZWRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzUmVsYXRpdmUoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJVbnJlc29sdmVkSW1wb3J0KHNvdXJjZSwgaW1wb3J0ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbndhcm4oZXJyVW5yZXNvbHZlZEltcG9ydFRyZWF0ZWRBc0V4dGVybmFsKHNvdXJjZSwgaW1wb3J0ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgaWQ6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogdGhpcy5oYXNNb2R1bGVTaWRlRWZmZWN0cyhzb3VyY2UsIHRydWUpLFxuICAgICAgICAgICAgICAgIHN5bnRoZXRpY05hbWVkRXhwb3J0czogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb2x2ZWRJZC5leHRlcm5hbCAmJiByZXNvbHZlZElkLnN5bnRoZXRpY05hbWVkRXhwb3J0cykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9ud2FybihlcnJFeHRlcm5hbFN5bnRoZXRpY0V4cG9ydHMoc291cmNlLCBpbXBvcnRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZElkO1xuICAgIH1cbiAgICBhc3luYyBsb2FkRW50cnlNb2R1bGUodW5yZXNvbHZlZElkLCBpc0VudHJ5LCBpbXBvcnRlciwgaW1wbGljaXRseUxvYWRlZEJlZm9yZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlSWRSZXN1bHQgPSBhd2FpdCByZXNvbHZlSWQodW5yZXNvbHZlZElkLCBpbXBvcnRlciwgdGhpcy5vcHRpb25zLnByZXNlcnZlU3ltbGlua3MsIHRoaXMucGx1Z2luRHJpdmVyLCB0aGlzLnJlc29sdmVJZCwgbnVsbCwgRU1QVFlfT0JKRUNULCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc29sdmVJZFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoaW1wbGljaXRseUxvYWRlZEJlZm9yZSA9PT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXJyVW5yZXNvbHZlZEVudHJ5KHVucmVzb2x2ZWRJZClcbiAgICAgICAgICAgICAgICA6IGVyclVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGFudCh1bnJlc29sdmVkSWQsIGltcGxpY2l0bHlMb2FkZWRCZWZvcmUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZUlkUmVzdWx0ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiByZXNvbHZlSWRSZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc29sdmVJZFJlc3VsdC5leHRlcm5hbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihpbXBsaWNpdGx5TG9hZGVkQmVmb3JlID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyBlcnJFbnRyeUNhbm5vdEJlRXh0ZXJuYWwodW5yZXNvbHZlZElkKVxuICAgICAgICAgICAgICAgIDogZXJySW1wbGljaXREZXBlbmRhbnRDYW5ub3RCZUV4dGVybmFsKHVucmVzb2x2ZWRJZCwgaW1wbGljaXRseUxvYWRlZEJlZm9yZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoTW9kdWxlKHRoaXMuZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyh0eXBlb2YgcmVzb2x2ZUlkUmVzdWx0ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyByZXNvbHZlSWRSZXN1bHRcbiAgICAgICAgICAgIDogeyBpZDogcmVzb2x2ZUlkUmVzdWx0IH0pLCB1bmRlZmluZWQsIGlzRW50cnksIGZhbHNlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZUR5bmFtaWNJbXBvcnQobW9kdWxlLCBzcGVjaWZpZXIsIGltcG9ydGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gYXdhaXQgdGhpcy5wbHVnaW5Ecml2ZXIuaG9va0ZpcnN0KCdyZXNvbHZlRHluYW1pY0ltcG9ydCcsIFtcbiAgICAgICAgICAgIHNwZWNpZmllcixcbiAgICAgICAgICAgIGltcG9ydGVyXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzb2x1dGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ucmVzb2x1dGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IChfYiA9IG1vZHVsZS5yZXNvbHZlZElkcylbc3BlY2lmaWVyXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iW3NwZWNpZmllcl0gPSB0aGlzLmhhbmRsZVJlc29sdmVJZChhd2FpdCB0aGlzLnJlc29sdmVJZChzcGVjaWZpZXIsIG1vZHVsZS5pZCwgRU1QVFlfT0JKRUNULCBmYWxzZSksIHNwZWNpZmllciwgbW9kdWxlLmlkKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc29sdmVJZCh0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHModGhpcy5nZXROb3JtYWxpemVkUmVzb2x2ZWRJZFdpdGhvdXREZWZhdWx0cyhyZXNvbHV0aW9uLCBpbXBvcnRlciwgc3BlY2lmaWVyKSksIHNwZWNpZmllciwgaW1wb3J0ZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlRXh0ZXJuYWxJZChzb3VyY2UsIGltcG9ydGVyKSB7XG4gICAgcmV0dXJuIGlzUmVsYXRpdmUoc291cmNlKVxuICAgICAgICA/IGltcG9ydGVyXG4gICAgICAgICAgICA/IHJlc29sdmUoaW1wb3J0ZXIsICcuLicsIHNvdXJjZSlcbiAgICAgICAgICAgIDogcmVzb2x2ZShzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmtOYW1lc1RvTW9kdWxlKG1vZHVsZSwgeyBmaWxlTmFtZSwgbmFtZSB9LCBpc1VzZXJEZWZpbmVkLCBwcmlvcml0eSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZmlsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgbW9kdWxlLmNodW5rRmlsZU5hbWVzLmFkZChmaWxlTmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQWx3YXlzIGtlZXAgY2h1bmtOYW1lcyBzb3J0ZWQgYnkgcHJpb3JpdHlcbiAgICAgICAgbGV0IG5hbWVQb3NpdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICgoKF9hID0gbW9kdWxlLmNodW5rTmFtZXNbbmFtZVBvc2l0aW9uXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByaW9yaXR5KSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgbmFtZVBvc2l0aW9uKys7XG4gICAgICAgIG1vZHVsZS5jaHVua05hbWVzLnNwbGljZShuYW1lUG9zaXRpb24sIDAsIHsgaXNVc2VyRGVmaW5lZCwgbmFtZSwgcHJpb3JpdHkgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOb3RBYnNvbHV0ZUV4dGVybmFsKGlkLCBzb3VyY2UsIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlKSB7XG4gICAgcmV0dXJuIChtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZSA9PT0gdHJ1ZSB8fFxuICAgICAgICAobWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmUgPT09ICdpZlJlbGF0aXZlU291cmNlJyAmJiBpc1JlbGF0aXZlKHNvdXJjZSkpIHx8XG4gICAgICAgICFpc0Fic29sdXRlKGlkKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRGVwZW5kZW5jeVJlc29sdXRpb24obG9hZFByb21pc2UpIHtcbiAgICBjb25zdCBbcmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcywgcmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlc10gPSBhd2FpdCBsb2FkUHJvbWlzZTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLnJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMsIC4uLnJlc29sdmVEeW5hbWljSW1wb3J0UHJvbWlzZXNdKTtcbn1cblxuY2xhc3MgR2xvYmFsU2NvcGUgZXh0ZW5kcyBTY29wZSQxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQoJ3VuZGVmaW5lZCcsIG5ldyBVbmRlZmluZWRWYXJpYWJsZSgpKTtcbiAgICB9XG4gICAgZmluZFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhcmlhYmxlID0gdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IG5ldyBHbG9iYWxWYXJpYWJsZShuYW1lKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVwcmVjYXRlZENvbnRleHRIYW5kbGVyKGhhbmRsZXIsIGhhbmRsZXJOYW1lLCBuZXdIYW5kbGVyTmFtZSwgcGx1Z2luTmFtZSwgYWN0aXZlRGVwcmVjYXRpb24sIG9wdGlvbnMpIHtcbiAgICBsZXQgZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSBmYWxzZTtcbiAgICByZXR1cm4gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25XYXJuaW5nU2hvd24pIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBcInRoaXMuJHtoYW5kbGVyTmFtZX1cIiBwbHVnaW4gY29udGV4dCBmdW5jdGlvbiB1c2VkIGJ5IHBsdWdpbiAke3BsdWdpbk5hbWV9IGlzIGRlcHJlY2F0ZWQuIFRoZSBcInRoaXMuJHtuZXdIYW5kbGVyTmFtZX1cIiBwbHVnaW4gY29udGV4dCBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLmAsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW5OYW1lXG4gICAgICAgICAgICB9LCBhY3RpdmVEZXByZWNhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoLi4uYXJncyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5Db250ZXh0KHBsdWdpbiwgcGx1Z2luQ2FjaGUsIGdyYXBoLCBvcHRpb25zLCBmaWxlRW1pdHRlciwgZXhpc3RpbmdQbHVnaW5OYW1lcykge1xuICAgIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmNhY2hlS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocGx1Z2luLm5hbWUuc3RhcnRzV2l0aChBTk9OWU1PVVNfUExVR0lOX1BSRUZJWCkgfHxcbiAgICAgICAgICAgIHBsdWdpbi5uYW1lLnN0YXJ0c1dpdGgoQU5PTllNT1VTX09VVFBVVF9QTFVHSU5fUFJFRklYKSB8fFxuICAgICAgICAgICAgZXhpc3RpbmdQbHVnaW5OYW1lcy5oYXMocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nUGx1Z2luTmFtZXMuYWRkKHBsdWdpbi5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2FjaGVJbnN0YW5jZTtcbiAgICBpZiAoIXBsdWdpbkNhY2hlKSB7XG4gICAgICAgIGNhY2hlSW5zdGFuY2UgPSBOT19DQUNIRTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FjaGVhYmxlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGx1Z2luLmNhY2hlS2V5IHx8IHBsdWdpbi5uYW1lO1xuICAgICAgICBjYWNoZUluc3RhbmNlID0gY3JlYXRlUGx1Z2luQ2FjaGUocGx1Z2luQ2FjaGVbY2FjaGVLZXldIHx8IChwbHVnaW5DYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWNoZUluc3RhbmNlID0gZ2V0Q2FjaGVGb3JVbmNhY2hlYWJsZVBsdWdpbihwbHVnaW4ubmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIGFkZFdhdGNoRmlsZShpZCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoLnBoYXNlID49IEJ1aWxkUGhhc2UuR0VORVJBVEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJJbnZhbGlkUm9sbHVwUGhhc2VGb3JBZGRXYXRjaEZpbGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaC53YXRjaEZpbGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlOiBjYWNoZUluc3RhbmNlLFxuICAgICAgICBlbWl0QXNzZXQ6IGdldERlcHJlY2F0ZWRDb250ZXh0SGFuZGxlcigobmFtZSwgc291cmNlKSA9PiBmaWxlRW1pdHRlci5lbWl0RmlsZSh7IG5hbWUsIHNvdXJjZSwgdHlwZTogJ2Fzc2V0JyB9KSwgJ2VtaXRBc3NldCcsICdlbWl0RmlsZScsIHBsdWdpbi5uYW1lLCB0cnVlLCBvcHRpb25zKSxcbiAgICAgICAgZW1pdENodW5rOiBnZXREZXByZWNhdGVkQ29udGV4dEhhbmRsZXIoKGlkLCBvcHRpb25zKSA9PiBmaWxlRW1pdHRlci5lbWl0RmlsZSh7IGlkLCBuYW1lOiBvcHRpb25zICYmIG9wdGlvbnMubmFtZSwgdHlwZTogJ2NodW5rJyB9KSwgJ2VtaXRDaHVuaycsICdlbWl0RmlsZScsIHBsdWdpbi5uYW1lLCB0cnVlLCBvcHRpb25zKSxcbiAgICAgICAgZW1pdEZpbGU6IGZpbGVFbWl0dGVyLmVtaXRGaWxlLmJpbmQoZmlsZUVtaXR0ZXIpLFxuICAgICAgICBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd1BsdWdpbkVycm9yKGVyciwgcGx1Z2luLm5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRBc3NldEZpbGVOYW1lOiBnZXREZXByZWNhdGVkQ29udGV4dEhhbmRsZXIoZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUsICdnZXRBc3NldEZpbGVOYW1lJywgJ2dldEZpbGVOYW1lJywgcGx1Z2luLm5hbWUsIHRydWUsIG9wdGlvbnMpLFxuICAgICAgICBnZXRDaHVua0ZpbGVOYW1lOiBnZXREZXByZWNhdGVkQ29udGV4dEhhbmRsZXIoZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUsICdnZXRDaHVua0ZpbGVOYW1lJywgJ2dldEZpbGVOYW1lJywgcGx1Z2luLm5hbWUsIHRydWUsIG9wdGlvbnMpLFxuICAgICAgICBnZXRGaWxlTmFtZTogZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUsXG4gICAgICAgIGdldE1vZHVsZUlkczogKCkgPT4gZ3JhcGgubW9kdWxlc0J5SWQua2V5cygpLFxuICAgICAgICBnZXRNb2R1bGVJbmZvOiBncmFwaC5nZXRNb2R1bGVJbmZvLFxuICAgICAgICBnZXRXYXRjaEZpbGVzOiAoKSA9PiBPYmplY3Qua2V5cyhncmFwaC53YXRjaEZpbGVzKSxcbiAgICAgICAgaXNFeHRlcm5hbDogZ2V0RGVwcmVjYXRlZENvbnRleHRIYW5kbGVyKChpZCwgcGFyZW50SWQsIGlzUmVzb2x2ZWQgPSBmYWxzZSkgPT4gb3B0aW9ucy5leHRlcm5hbChpZCwgcGFyZW50SWQsIGlzUmVzb2x2ZWQpLCAnaXNFeHRlcm5hbCcsICdyZXNvbHZlJywgcGx1Z2luLm5hbWUsIHRydWUsIG9wdGlvbnMpLFxuICAgICAgICBsb2FkKHJlc29sdmVkSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5tb2R1bGVMb2FkZXIucHJlbG9hZE1vZHVsZShyZXNvbHZlZElkKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgcm9sbHVwVmVyc2lvbjogdmVyc2lvbiQxLFxuICAgICAgICAgICAgd2F0Y2hNb2RlOiBncmFwaC53YXRjaE1vZGVcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IG1vZHVsZUlkcygpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uKiB3cmFwcGVkTW9kdWxlSWRzKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSB3cmFwcGluZyB0aGlzIGluIGEgZ2VuZXJhdG9yIHRvIG9ubHkgc2hvdyB0aGUgbWVzc2FnZSBvbmNlIHdlIGFyZSBhY3R1YWxseSBpdGVyYXRpbmdcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQWNjZXNzaW5nIFwidGhpcy5tb2R1bGVJZHNcIiBvbiB0aGUgcGx1Z2luIGNvbnRleHQgYnkgcGx1Z2luICR7cGx1Z2luLm5hbWV9IGlzIGRlcHJlY2F0ZWQuIFRoZSBcInRoaXMuZ2V0TW9kdWxlSWRzXCIgcGx1Z2luIGNvbnRleHQgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5gLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW46IHBsdWdpbi5uYW1lXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBtb2R1bGVJZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVJZHMgPSBncmFwaC5tb2R1bGVzQnlJZC5rZXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZE1vZHVsZUlkcygpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZ3JhcGguY29udGV4dFBhcnNlLmJpbmQoZ3JhcGgpLFxuICAgICAgICByZXNvbHZlKHNvdXJjZSwgaW1wb3J0ZXIsIHsgY3VzdG9tLCBpc0VudHJ5LCBza2lwU2VsZiB9ID0gQkxBTkspIHtcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5tb2R1bGVMb2FkZXIucmVzb2x2ZUlkKHNvdXJjZSwgaW1wb3J0ZXIsIGN1c3RvbSwgaXNFbnRyeSwgc2tpcFNlbGYgPyBbeyBpbXBvcnRlciwgcGx1Z2luLCBzb3VyY2UgfV0gOiBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZUlkOiBnZXREZXByZWNhdGVkQ29udGV4dEhhbmRsZXIoKHNvdXJjZSwgaW1wb3J0ZXIpID0+IGdyYXBoLm1vZHVsZUxvYWRlclxuICAgICAgICAgICAgLnJlc29sdmVJZChzb3VyY2UsIGltcG9ydGVyLCBCTEFOSywgdW5kZWZpbmVkKVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZUlkID0+IHJlc29sdmVJZCAmJiByZXNvbHZlSWQuaWQpLCAncmVzb2x2ZUlkJywgJ3Jlc29sdmUnLCBwbHVnaW4ubmFtZSwgdHJ1ZSwgb3B0aW9ucyksXG4gICAgICAgIHNldEFzc2V0U291cmNlOiBmaWxlRW1pdHRlci5zZXRBc3NldFNvdXJjZSxcbiAgICAgICAgd2Fybih3YXJuaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhcm5pbmcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHdhcm5pbmcgPSB7IG1lc3NhZ2U6IHdhcm5pbmcgfTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nLmNvZGUpXG4gICAgICAgICAgICAgICAgd2FybmluZy5wbHVnaW5Db2RlID0gd2FybmluZy5jb2RlO1xuICAgICAgICAgICAgd2FybmluZy5jb2RlID0gJ1BMVUdJTl9XQVJOSU5HJztcbiAgICAgICAgICAgIHdhcm5pbmcucGx1Z2luID0gcGx1Z2luLm5hbWU7XG4gICAgICAgICAgICBvcHRpb25zLm9ud2Fybih3YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmNvbnN0IGlucHV0SG9va05hbWVzID0ge1xuICAgIGJ1aWxkRW5kOiAxLFxuICAgIGJ1aWxkU3RhcnQ6IDEsXG4gICAgY2xvc2VCdW5kbGU6IDEsXG4gICAgY2xvc2VXYXRjaGVyOiAxLFxuICAgIGxvYWQ6IDEsXG4gICAgbW9kdWxlUGFyc2VkOiAxLFxuICAgIG9wdGlvbnM6IDEsXG4gICAgcmVzb2x2ZUR5bmFtaWNJbXBvcnQ6IDEsXG4gICAgcmVzb2x2ZUlkOiAxLFxuICAgIHNob3VsZFRyYW5zZm9ybUNhY2hlZE1vZHVsZTogMSxcbiAgICB0cmFuc2Zvcm06IDEsXG4gICAgd2F0Y2hDaGFuZ2U6IDFcbn07XG5jb25zdCBpbnB1dEhvb2tzID0gT2JqZWN0LmtleXMoaW5wdXRIb29rTmFtZXMpO1xuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKGhvb2tOYW1lLCBwbHVnaW5OYW1lKSB7XG4gICAgcmV0dXJuIGVycm9yKHtcbiAgICAgICAgY29kZTogJ0lOVkFMSURfUExVR0lOX0hPT0snLFxuICAgICAgICBtZXNzYWdlOiBgRXJyb3IgcnVubmluZyBwbHVnaW4gaG9vayAke2hvb2tOYW1lfSBmb3IgJHtwbHVnaW5OYW1lfSwgZXhwZWN0ZWQgYSBmdW5jdGlvbiBob29rLmBcbiAgICB9KTtcbn1cbmNsYXNzIFBsdWdpbkRyaXZlciB7XG4gICAgY29uc3RydWN0b3IoZ3JhcGgsIG9wdGlvbnMsIHVzZXJQbHVnaW5zLCBwbHVnaW5DYWNoZSwgYmFzZVBsdWdpbkRyaXZlcikge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB3YXJuRGVwcmVjYXRlZEhvb2tzKHVzZXJQbHVnaW5zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wbHVnaW5DYWNoZSA9IHBsdWdpbkNhY2hlO1xuICAgICAgICB0aGlzLmZpbGVFbWl0dGVyID0gbmV3IEZpbGVFbWl0dGVyKGdyYXBoLCBvcHRpb25zLCBiYXNlUGx1Z2luRHJpdmVyICYmIGJhc2VQbHVnaW5Ecml2ZXIuZmlsZUVtaXR0ZXIpO1xuICAgICAgICB0aGlzLmVtaXRGaWxlID0gdGhpcy5maWxlRW1pdHRlci5lbWl0RmlsZS5iaW5kKHRoaXMuZmlsZUVtaXR0ZXIpO1xuICAgICAgICB0aGlzLmdldEZpbGVOYW1lID0gdGhpcy5maWxlRW1pdHRlci5nZXRGaWxlTmFtZS5iaW5kKHRoaXMuZmlsZUVtaXR0ZXIpO1xuICAgICAgICB0aGlzLmZpbmFsaXNlQXNzZXRzID0gdGhpcy5maWxlRW1pdHRlci5hc3NlcnRBc3NldHNGaW5hbGl6ZWQuYmluZCh0aGlzLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRCdW5kbGUgPSB0aGlzLmZpbGVFbWl0dGVyLnNldE91dHB1dEJ1bmRsZS5iaW5kKHRoaXMuZmlsZUVtaXR0ZXIpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB1c2VyUGx1Z2lucy5jb25jYXQoYmFzZVBsdWdpbkRyaXZlciA/IGJhc2VQbHVnaW5Ecml2ZXIucGx1Z2lucyA6IFtdKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQbHVnaW5OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5wbHVnaW5Db250ZXh0cyA9IG5ldyBNYXAodGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gW1xuICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgZ2V0UGx1Z2luQ29udGV4dChwbHVnaW4sIHBsdWdpbkNhY2hlLCBncmFwaCwgb3B0aW9ucywgdGhpcy5maWxlRW1pdHRlciwgZXhpc3RpbmdQbHVnaW5OYW1lcylcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAoYmFzZVBsdWdpbkRyaXZlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdXNlclBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgaW5wdXRIb29rcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9vayBpbiBwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub253YXJuKGVycklucHV0SG9va0luT3V0cHV0UGx1Z2luKHBsdWdpbi5uYW1lLCBob29rKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlT3V0cHV0UGx1Z2luRHJpdmVyKHBsdWdpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW5Ecml2ZXIodGhpcy5ncmFwaCwgdGhpcy5vcHRpb25zLCBwbHVnaW5zLCB0aGlzLnBsdWdpbkNhY2hlLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0VW5mdWxmaWxsZWRIb29rQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zO1xuICAgIH1cbiAgICAvLyBjaGFpbnMsIGZpcnN0IG5vbi1udWxsIHJlc3VsdCBzdG9wcyBhbmQgcmV0dXJuc1xuICAgIGhvb2tGaXJzdChob29rTmFtZSwgYXJncywgcmVwbGFjZUNvbnRleHQsIHNraXBwZWQpIHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZCAmJiBza2lwcGVkLmhhcyhwbHVnaW4pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5Ib29rKGhvb2tOYW1lLCBhcmdzLCBwbHVnaW4sIGZhbHNlLCByZXBsYWNlQ29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLy8gY2hhaW5zIHN5bmNocm9ub3VzbHksIGZpcnN0IG5vbi1udWxsIHJlc3VsdCBzdG9wcyBhbmQgcmV0dXJuc1xuICAgIGhvb2tGaXJzdFN5bmMoaG9va05hbWUsIGFyZ3MsIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ydW5Ib29rU3luYyhob29rTmFtZSwgYXJncywgcGx1Z2luLCByZXBsYWNlQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gcGFyYWxsZWwsIGlnbm9yZXMgcmV0dXJuc1xuICAgIGhvb2tQYXJhbGxlbChob29rTmFtZSwgYXJncywgcmVwbGFjZUNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBob29rUHJvbWlzZSA9IHRoaXMucnVuSG9vayhob29rTmFtZSwgYXJncywgcGx1Z2luLCBmYWxzZSwgcmVwbGFjZUNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFob29rUHJvbWlzZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goaG9va1Byb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7IH0pO1xuICAgIH1cbiAgICAvLyBjaGFpbnMsIHJlZHVjZXMgcmV0dXJuZWQgdmFsdWUsIGhhbmRsaW5nIHRoZSByZWR1Y2VkIHZhbHVlIGFzIHRoZSBmaXJzdCBob29rIGFyZ3VtZW50XG4gICAgaG9va1JlZHVjZUFyZzAoaG9va05hbWUsIFthcmcwLCAuLi5yZXN0XSwgcmVkdWNlLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhcmcwKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGFyZzAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbYXJnMCwgLi4ucmVzdF07XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va1Byb21pc2UgPSB0aGlzLnJ1bkhvb2soaG9va05hbWUsIGFyZ3MsIHBsdWdpbiwgZmFsc2UsIHJlcGxhY2VDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tQcm9taXNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9va1Byb21pc2UudGhlbihyZXN1bHQgPT4gcmVkdWNlLmNhbGwodGhpcy5wbHVnaW5Db250ZXh0cy5nZXQocGx1Z2luKSwgYXJnMCwgcmVzdWx0LCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBjaGFpbnMgc3luY2hyb25vdXNseSwgcmVkdWNlcyByZXR1cm5lZCB2YWx1ZSwgaGFuZGxpbmcgdGhlIHJlZHVjZWQgdmFsdWUgYXMgdGhlIGZpcnN0IGhvb2sgYXJndW1lbnRcbiAgICBob29rUmVkdWNlQXJnMFN5bmMoaG9va05hbWUsIFthcmcwLCAuLi5yZXN0XSwgcmVkdWNlLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbYXJnMCwgLi4ucmVzdF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJ1bkhvb2tTeW5jKGhvb2tOYW1lLCBhcmdzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KTtcbiAgICAgICAgICAgIGFyZzAgPSByZWR1Y2UuY2FsbCh0aGlzLnBsdWdpbkNvbnRleHRzLmdldChwbHVnaW4pLCBhcmcwLCByZXN1bHQsIHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZzA7XG4gICAgfVxuICAgIC8vIGNoYWlucywgcmVkdWNlcyByZXR1cm5lZCB2YWx1ZSB0byB0eXBlIFQsIGhhbmRsaW5nIHRoZSByZWR1Y2VkIHZhbHVlIHNlcGFyYXRlbHkuIHBlcm1pdHMgaG9va3MgYXMgdmFsdWVzLlxuICAgIGhvb2tSZWR1Y2VWYWx1ZShob29rTmFtZSwgaW5pdGlhbFZhbHVlLCBhcmdzLCByZWR1Y2UsIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va1Byb21pc2UgPSB0aGlzLnJ1bkhvb2soaG9va05hbWUsIGFyZ3MsIHBsdWdpbiwgdHJ1ZSwgcmVwbGFjZUNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghaG9va1Byb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9va1Byb21pc2UudGhlbihyZXN1bHQgPT4gcmVkdWNlLmNhbGwodGhpcy5wbHVnaW5Db250ZXh0cy5nZXQocGx1Z2luKSwgdmFsdWUsIHJlc3VsdCwgcGx1Z2luKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLy8gY2hhaW5zIHN5bmNocm9ub3VzbHksIHJlZHVjZXMgcmV0dXJuZWQgdmFsdWUgdG8gdHlwZSBULCBoYW5kbGluZyB0aGUgcmVkdWNlZCB2YWx1ZSBzZXBhcmF0ZWx5LiBwZXJtaXRzIGhvb2tzIGFzIHZhbHVlcy5cbiAgICBob29rUmVkdWNlVmFsdWVTeW5jKGhvb2tOYW1lLCBpbml0aWFsVmFsdWUsIGFyZ3MsIHJlZHVjZSwgcmVwbGFjZUNvbnRleHQpIHtcbiAgICAgICAgbGV0IGFjYyA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJ1bkhvb2tTeW5jKGhvb2tOYW1lLCBhcmdzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KTtcbiAgICAgICAgICAgIGFjYyA9IHJlZHVjZS5jYWxsKHRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KHBsdWdpbiksIGFjYywgcmVzdWx0LCBwbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIC8vIGNoYWlucywgaWdub3JlcyByZXR1cm5zXG4gICAgaG9va1NlcShob29rTmFtZSwgYXJncywgcmVwbGFjZUNvbnRleHQpIHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKCgpID0+IHRoaXMucnVuSG9vayhob29rTmFtZSwgYXJncywgcGx1Z2luLCBmYWxzZSwgcmVwbGFjZUNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcnVuSG9vayhob29rTmFtZSwgYXJncywgcGx1Z2luLCBwZXJtaXRWYWx1ZXMsIGhvb2tDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBwbHVnaW5baG9va05hbWVdO1xuICAgICAgICBpZiAoIWhvb2spXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChob29rQ29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IGhvb2tDb250ZXh0KGNvbnRleHQsIHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gcGVybWl0IHZhbHVlcyBhbGxvd3MgdmFsdWVzIHRvIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYSBmdW5jdGlvbmFsIGhvb2tcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChwZXJtaXRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBob29rO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0ludmFsaWRIb29rRXJyb3IoaG9va05hbWUsIHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgICAgICAgICBjb25zdCBob29rUmVzdWx0ID0gaG9vay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghaG9va1Jlc3VsdCB8fCAhaG9va1Jlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnQgY2lyY3VpdCBmb3Igbm9uLXRoZW5hYmxlcyBhbmQgbm9uLVByb21pc2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvb2tSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFjayBwZW5kaW5nIGhvb2sgYWN0aW9ucyB0byBwcm9wZXJseSBlcnJvciBvdXQgd2hlblxuICAgICAgICAgICAgLy8gdW5mdWxmaWxsZWQgcHJvbWlzZXMgY2F1c2Ugcm9sbHVwIHRvIGFicnVwdGx5IGFuZCBjb25mdXNpbmdseVxuICAgICAgICAgICAgLy8gZXhpdCB3aXRoIGEgc3VjY2Vzc2Z1bCAwIHJldHVybiBjb2RlIGJ1dCB3aXRob3V0IHByb2R1Y2luZyBhbnlcbiAgICAgICAgICAgIC8vIG91dHB1dCwgZXJyb3JzIG9yIHdhcm5pbmdzLlxuICAgICAgICAgICAgYWN0aW9uID0gW3BsdWdpbi5uYW1lLCBob29rTmFtZSwgYXJnc107XG4gICAgICAgICAgICB0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucy5hZGQoYWN0aW9uKTtcbiAgICAgICAgICAgIC8vIEFsdGhvdWdoIGl0IHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB0byBqdXN0IHJldHVybiBob29rUmVzdWx0IGhlcmVcbiAgICAgICAgICAgIC8vIGFuZCBwdXQgdGhlIC50aGVuKCkgaGFuZGxlciBqdXN0IGFib3ZlIHRoZSAuY2F0Y2goKSBoYW5kbGVyIGJlbG93LFxuICAgICAgICAgICAgLy8gZG9pbmcgc28gd291bGQgc3VidGx5IGNoYW5nZSB0aGUgZGVmYWN0byBhc3luYyBldmVudCBkaXNwYXRjaCBvcmRlclxuICAgICAgICAgICAgLy8gd2hpY2ggYXQgbGVhc3Qgb25lIHRlc3QgYW5kIHNvbWUgcGx1Z2lucyBpbiB0aGUgd2lsZCBtYXkgZGVwZW5kIG9uLlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rUmVzdWx0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYWN0aW9uIHdhcyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgICB0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb24gY29uc2lkZXJlZCB0byBiZSBmdWxmaWxsZWQgc2luY2UgZXJyb3IgYmVpbmcgaGFuZGxlZFxuICAgICAgICAgICAgICAgIHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRocm93UGx1Z2luRXJyb3IoZXJyLCBwbHVnaW4ubmFtZSwgeyBob29rOiBob29rTmFtZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBhIHN5bmMgcGx1Z2luIGhvb2sgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBob29rTmFtZSBOYW1lIG9mIHRoZSBwbHVnaW4gaG9vay4gTXVzdCBiZSBpbiBgUGx1Z2luSG9va3NgLlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBsdWdpbiBob29rLlxuICAgICAqIEBwYXJhbSBwbHVnaW4gVGhlIGFjdXRhbCBwbHVnaW5cbiAgICAgKiBAcGFyYW0gaG9va0NvbnRleHQgV2hlbiBwYXNzZWQsIHRoZSBwbHVnaW4gY29udGV4dCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBydW5Ib29rU3luYyhob29rTmFtZSwgYXJncywgcGx1Z2luLCBob29rQ29udGV4dCkge1xuICAgICAgICBjb25zdCBob29rID0gcGx1Z2luW2hvb2tOYW1lXTtcbiAgICAgICAgaWYgKCFob29rKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLnBsdWdpbkNvbnRleHRzLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoaG9va0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBob29rQ29udGV4dChjb250ZXh0LCBwbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBwZXJtaXQgdmFsdWVzIGFsbG93cyB2YWx1ZXMgdG8gYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uYWwgaG9va1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93SW52YWxpZEhvb2tFcnJvcihob29rTmFtZSwgcGx1Z2luLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBob29rLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd1BsdWdpbkVycm9yKGVyciwgcGx1Z2luLm5hbWUsIHsgaG9vazogaG9va05hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVudHJ5TW9kdWxlcyhlbnRyeU1vZHVsZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeU1vZHVsZXMpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeU1vZHVsZXMubWFwKGlkID0+ICh7XG4gICAgICAgICAgICBmaWxlTmFtZTogbnVsbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaW1wbGljaXRseUxvYWRlZEFmdGVyOiBbXSxcbiAgICAgICAgICAgIGltcG9ydGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGVudHJ5TW9kdWxlcykubWFwKChbbmFtZSwgaWRdKSA9PiAoe1xuICAgICAgICBmaWxlTmFtZTogbnVsbCxcbiAgICAgICAgaWQsXG4gICAgICAgIGltcGxpY2l0bHlMb2FkZWRBZnRlcjogW10sXG4gICAgICAgIGltcG9ydGVyOiB1bmRlZmluZWQsXG4gICAgICAgIG5hbWVcbiAgICB9KSk7XG59XG5jbGFzcyBHcmFwaCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgd2F0Y2hlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNhY2hlZE1vZHVsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6YXRpb25UcmFja2VyID0gbmV3IFBhdGhUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuZW50cnlNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waGFzZSA9IEJ1aWxkUGhhc2UuTE9BRF9BTkRfUEFSU0U7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgR2xvYmFsU2NvcGUoKTtcbiAgICAgICAgdGhpcy53YXRjaEZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy53YXRjaE1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlcm5hbE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRNb2R1bGVJbmZvID0gKG1vZHVsZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZE1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWQuZ2V0KG1vZHVsZUlkKTtcbiAgICAgICAgICAgIGlmICghZm91bmRNb2R1bGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRNb2R1bGUuaW5mbztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gb3B0aW9ucy5jYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBvcHRpb25zLmNhY2hlLm1vZHVsZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkTW9kdWxlcy5zZXQobW9kdWxlLmlkLCBtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5DYWNoZSA9ICgoX2IgPSBvcHRpb25zLmNhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGx1Z2lucykgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBhY2Nlc3MgY291bnRlclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMucGx1Z2luQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luQ2FjaGVbbmFtZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2F0Y2hlcikge1xuICAgICAgICAgICAgdGhpcy53YXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKC4uLmFyZ3MpID0+IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnd2F0Y2hDaGFuZ2UnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gKCkgPT4gdGhpcy5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdjbG9zZVdhdGNoZXInLCBbXSk7XG4gICAgICAgICAgICB3YXRjaGVyLm9uQ3VycmVudEF3YWl0ZWQoJ2NoYW5nZScsIGhhbmRsZUNoYW5nZSk7XG4gICAgICAgICAgICB3YXRjaGVyLm9uQ3VycmVudEF3YWl0ZWQoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGx1Z2luRHJpdmVyID0gbmV3IFBsdWdpbkRyaXZlcih0aGlzLCBvcHRpb25zLCBvcHRpb25zLnBsdWdpbnMsIHRoaXMucGx1Z2luQ2FjaGUpO1xuICAgICAgICB0aGlzLmFjb3JuUGFyc2VyID0gUGFyc2VyLmV4dGVuZCguLi5vcHRpb25zLmFjb3JuSW5qZWN0UGx1Z2lucyk7XG4gICAgICAgIHRoaXMubW9kdWxlTG9hZGVyID0gbmV3IE1vZHVsZUxvYWRlcih0aGlzLCB0aGlzLm1vZHVsZXNCeUlkLCB0aGlzLm9wdGlvbnMsIHRoaXMucGx1Z2luRHJpdmVyKTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGQoKSB7XG4gICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgbW9kdWxlIGdyYXBoJywgMik7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVNb2R1bGVHcmFwaCgpO1xuICAgICAgICB0aW1lRW5kKCdnZW5lcmF0ZSBtb2R1bGUgZ3JhcGgnLCAyKTtcbiAgICAgICAgdGltZVN0YXJ0KCdzb3J0IG1vZHVsZXMnLCAyKTtcbiAgICAgICAgdGhpcy5waGFzZSA9IEJ1aWxkUGhhc2UuQU5BTFlTRTtcbiAgICAgICAgdGhpcy5zb3J0TW9kdWxlcygpO1xuICAgICAgICB0aW1lRW5kKCdzb3J0IG1vZHVsZXMnLCAyKTtcbiAgICAgICAgdGltZVN0YXJ0KCdtYXJrIGluY2x1ZGVkIHN0YXRlbWVudHMnLCAyKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlU3RhdGVtZW50cygpO1xuICAgICAgICB0aW1lRW5kKCdtYXJrIGluY2x1ZGVkIHN0YXRlbWVudHMnLCAyKTtcbiAgICAgICAgdGhpcy5waGFzZSA9IEJ1aWxkUGhhc2UuR0VORVJBVEU7XG4gICAgfVxuICAgIGNvbnRleHRQYXJzZShjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgb25Db21tZW50T3JpZyA9IG9wdGlvbnMub25Db21tZW50O1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xuICAgICAgICBpZiAob25Db21tZW50T3JpZyAmJiB0eXBlb2Ygb25Db21tZW50T3JpZyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uQ29tbWVudCA9IChibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goeyBlbmQsIHN0YXJ0LCB0eXBlOiBibG9jayA/ICdCbG9jaycgOiAnTGluZScsIHZhbHVlOiB0ZXh0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkNvbW1lbnRPcmlnLmNhbGwob3B0aW9ucywgYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25Db21tZW50ID0gY29tbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5hY29yblBhcnNlci5wYXJzZShjb2RlLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuYWNvcm4sXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWVudE9yaWcgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9uQ29tbWVudE9yaWcucHVzaCguLi5jb21tZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vbkNvbW1lbnQgPSBvbkNvbW1lbnRPcmlnO1xuICAgICAgICBhZGRBbm5vdGF0aW9ucyhjb21tZW50cywgYXN0LCBjb2RlKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgZ2V0Q2FjaGUoKSB7XG4gICAgICAgIC8vIGhhbmRsZSBwbHVnaW4gY2FjaGUgZXZpY3Rpb25cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMucGx1Z2luQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wbHVnaW5DYWNoZVtuYW1lXTtcbiAgICAgICAgICAgIGxldCBhbGxEZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNhY2hlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA+PSB0aGlzLm9wdGlvbnMuZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnkpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYWxsRGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbERlbGV0ZWQpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luQ2FjaGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZHVsZXM6IHRoaXMubW9kdWxlcy5tYXAobW9kdWxlID0+IG1vZHVsZS50b0pTT04oKSksXG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLnBsdWdpbkNhY2hlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTW9kdWxlR3JhcGgoKSB7XG4gICAgICAgICh7IGVudHJ5TW9kdWxlczogdGhpcy5lbnRyeU1vZHVsZXMsIGltcGxpY2l0RW50cnlNb2R1bGVzOiB0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzIH0gPVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5tb2R1bGVMb2FkZXIuYWRkRW50cnlNb2R1bGVzKG5vcm1hbGl6ZUVudHJ5TW9kdWxlcyh0aGlzLm9wdGlvbnMuaW5wdXQpLCB0cnVlKSk7XG4gICAgICAgIGlmICh0aGlzLmVudHJ5TW9kdWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IG9wdGlvbnMuaW5wdXQgdG8gcm9sbHVwJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5tb2R1bGVzQnlJZC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVybmFsTW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZVN0YXRlbWVudHMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIFsuLi50aGlzLmVudHJ5TW9kdWxlcywgLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc10pIHtcbiAgICAgICAgICAgIG1hcmtNb2R1bGVBbmRJbXB1cmVEZXBlbmRlbmNpZXNBc0V4ZWN1dGVkKG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmVlc2hha2UpIHtcbiAgICAgICAgICAgIGxldCB0cmVlc2hha2luZ1Bhc3MgPSAxO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRpbWVTdGFydChgdHJlZXNoYWtpbmcgcGFzcyAke3RyZWVzaGFraW5nUGFzc31gLCAzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzVHJlZXNoYWtpbmdQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5tb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaXNFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzID09PSAnbm8tdHJlZXNoYWtlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5pbmNsdWRlQWxsSW5CdW5kbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5pbmNsdWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVzaGFraW5nUGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGluY2x1ZGUgZXhwb3J0cyBhZnRlciB0aGUgZmlyc3QgcGFzcyB0byBhdm9pZCBpc3N1ZXMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgVERaIGRldGVjdGlvbiBsb2dpY1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBbLi4udGhpcy5lbnRyeU1vZHVsZXMsIC4uLnRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLnByZXNlcnZlU2lnbmF0dXJlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5pbmNsdWRlQWxsRXhwb3J0cyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc1RyZWVzaGFraW5nUGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZUVuZChgdHJlZXNoYWtpbmcgcGFzcyAke3RyZWVzaGFraW5nUGFzcysrfWAsIDMpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5uZWVkc1RyZWVzaGFraW5nUGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXMpXG4gICAgICAgICAgICAgICAgbW9kdWxlLmluY2x1ZGVBbGxJbkJ1bmRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXh0ZXJuYWxNb2R1bGUgb2YgdGhpcy5leHRlcm5hbE1vZHVsZXMpXG4gICAgICAgICAgICBleHRlcm5hbE1vZHVsZS53YXJuVW51c2VkSW1wb3J0cygpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGFudCBvZiBtb2R1bGUuaW1wbGljaXRseUxvYWRlZEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGVwZW5kYW50LmluZm8uaXNFbnRyeSB8fCBkZXBlbmRhbnQuaXNJbmNsdWRlZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihlcnJJbXBsaWNpdERlcGVuZGFudElzTm90SW5jbHVkZWQoZGVwZW5kYW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNvcnRNb2R1bGVzKCkge1xuICAgICAgICBjb25zdCB7IG9yZGVyZWRNb2R1bGVzLCBjeWNsZVBhdGhzIH0gPSBhbmFseXNlTW9kdWxlRXhlY3V0aW9uKHRoaXMuZW50cnlNb2R1bGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBjeWNsZVBhdGggb2YgY3ljbGVQYXRocykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9ud2Fybih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0NJUkNVTEFSX0RFUEVOREVOQ1knLFxuICAgICAgICAgICAgICAgIGN5Y2xlOiBjeWNsZVBhdGgsXG4gICAgICAgICAgICAgICAgaW1wb3J0ZXI6IGN5Y2xlUGF0aFswXSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ2lyY3VsYXIgZGVwZW5kZW5jeTogJHtjeWNsZVBhdGguam9pbignIC0+ICcpfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IG9yZGVyZWRNb2R1bGVzO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5iaW5kUmVmZXJlbmNlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybkZvck1pc3NpbmdFeHBvcnRzKCk7XG4gICAgfVxuICAgIHdhcm5Gb3JNaXNzaW5nRXhwb3J0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5tb2R1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGltcG9ydERlc2NyaXB0aW9uIG9mIG1vZHVsZS5pbXBvcnREZXNjcmlwdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0RGVzY3JpcHRpb24ubmFtZSAhPT0gJyonICYmXG4gICAgICAgICAgICAgICAgICAgICFpbXBvcnREZXNjcmlwdGlvbi5tb2R1bGUuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKGltcG9ydERlc2NyaXB0aW9uLm5hbWUpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS53YXJuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICdOT05fRVhJU1RFTlRfRVhQT1JUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tZXhpc3RlbnQgZXhwb3J0ICcke2ltcG9ydERlc2NyaXB0aW9uLm5hbWV9JyBpcyBpbXBvcnRlZCBmcm9tICR7cmVsYXRpdmVJZChpbXBvcnREZXNjcmlwdGlvbi5tb2R1bGUuaWQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpbXBvcnREZXNjcmlwdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBpbXBvcnREZXNjcmlwdGlvbi5tb2R1bGUuaWRcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wb3J0RGVzY3JpcHRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlQXJyYXkoaXRlbXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBbaXRlbXNdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFjdGlvbihbcGx1Z2luTmFtZSwgaG9va05hbWUsIGFyZ3NdKSB7XG4gICAgY29uc3QgYWN0aW9uID0gYCgke3BsdWdpbk5hbWV9KSAke2hvb2tOYW1lfWA7XG4gICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5O1xuICAgIHN3aXRjaCAoaG9va05hbWUpIHtcbiAgICAgICAgY2FzZSAncmVzb2x2ZUlkJzpcbiAgICAgICAgICAgIHJldHVybiBgJHthY3Rpb259ICR7cyhhcmdzWzBdKX0gJHtzKGFyZ3NbMV0pfWA7XG4gICAgICAgIGNhc2UgJ2xvYWQnOlxuICAgICAgICAgICAgcmV0dXJuIGAke2FjdGlvbn0gJHtzKGFyZ3NbMF0pfWA7XG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MoYXJnc1sxXSl9YDtcbiAgICAgICAgY2FzZSAnc2hvdWxkVHJhbnNmb3JtQ2FjaGVkTW9kdWxlJzpcbiAgICAgICAgICAgIHJldHVybiBgJHthY3Rpb259ICR7cyhhcmdzWzBdLmlkKX1gO1xuICAgICAgICBjYXNlICdtb2R1bGVQYXJzZWQnOlxuICAgICAgICAgICAgcmV0dXJuIGAke2FjdGlvbn0gJHtzKGFyZ3NbMF0uaWQpfWA7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb247XG59XG5hc3luYyBmdW5jdGlvbiBjYXRjaFVuZmluaXNoZWRIb29rQWN0aW9ucyhwbHVnaW5Ecml2ZXIsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGhhbmRsZUVtcHR5RXZlbnRMb29wO1xuICAgIGNvbnN0IGVtcHR5RXZlbnRMb29wUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgaGFuZGxlRW1wdHlFdmVudExvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmZ1bGZpbGxlZEFjdGlvbnMgPSBwbHVnaW5Ecml2ZXIuZ2V0VW5mdWxmaWxsZWRIb29rQWN0aW9ucygpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5leHBlY3RlZCBlYXJseSBleGl0LiBUaGlzIGhhcHBlbnMgd2hlbiBQcm9taXNlcyByZXR1cm5lZCBieSBwbHVnaW5zIGNhbm5vdCByZXNvbHZlLiBVbmZpbmlzaGVkIGhvb2sgYWN0aW9uKHMpIG9uIGV4aXQ6XFxuYCArXG4gICAgICAgICAgICAgICAgWy4uLnVuZnVsZmlsbGVkQWN0aW9uc10ubWFwKGZvcm1hdEFjdGlvbikuam9pbignXFxuJykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2VzcyQxLm9uY2UoJ2JlZm9yZUV4aXQnLCBoYW5kbGVFbXB0eUV2ZW50TG9vcCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYWxsYmFjaygpLCBlbXB0eUV2ZW50TG9vcFByb21pc2VdKTtcbiAgICBwcm9jZXNzJDEub2ZmKCdiZWZvcmVFeGl0JywgaGFuZGxlRW1wdHlFdmVudExvb3ApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IGRlZmF1bHRPbldhcm4gPSB3YXJuaW5nID0+IGNvbnNvbGUud2Fybih3YXJuaW5nLm1lc3NhZ2UgfHwgd2FybmluZyk7XG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMocGFzc2VkT3B0aW9ucywgdmFsaWRPcHRpb25zLCBvcHRpb25UeXBlLCB3YXJuLCBpZ25vcmVkS2V5cyA9IC8kLi8pIHtcbiAgICBjb25zdCB2YWxpZE9wdGlvblNldCA9IG5ldyBTZXQodmFsaWRPcHRpb25zKTtcbiAgICBjb25zdCB1bmtub3duT3B0aW9ucyA9IE9iamVjdC5rZXlzKHBhc3NlZE9wdGlvbnMpLmZpbHRlcihrZXkgPT4gISh2YWxpZE9wdGlvblNldC5oYXMoa2V5KSB8fCBpZ25vcmVkS2V5cy50ZXN0KGtleSkpKTtcbiAgICBpZiAodW5rbm93bk9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB3YXJuKHtcbiAgICAgICAgICAgIGNvZGU6ICdVTktOT1dOX09QVElPTicsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5rbm93biAke29wdGlvblR5cGV9OiAke3Vua25vd25PcHRpb25zLmpvaW4oJywgJyl9LiBBbGxvd2VkIG9wdGlvbnM6ICR7W1xuICAgICAgICAgICAgICAgIC4uLnZhbGlkT3B0aW9uU2V0XG4gICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgdHJlZXNoYWtlUHJlc2V0cyA9IHtcbiAgICByZWNvbW1lbmRlZDoge1xuICAgICAgICBhbm5vdGF0aW9uczogdHJ1ZSxcbiAgICAgICAgY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb246IGZhbHNlLFxuICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogKCkgPT4gdHJ1ZSxcbiAgICAgICAgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6IHRydWUsXG4gICAgICAgIHRyeUNhdGNoRGVvcHRpbWl6YXRpb246IHRydWUsXG4gICAgICAgIHVua25vd25HbG9iYWxTaWRlRWZmZWN0czogZmFsc2VcbiAgICB9LFxuICAgIHNhZmVzdDoge1xuICAgICAgICBhbm5vdGF0aW9uczogdHJ1ZSxcbiAgICAgICAgY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb246IHRydWUsXG4gICAgICAgIG1vZHVsZVNpZGVFZmZlY3RzOiAoKSA9PiB0cnVlLFxuICAgICAgICBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0czogdHJ1ZSxcbiAgICAgICAgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgdW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzOiB0cnVlXG4gICAgfSxcbiAgICBzbWFsbGVzdDoge1xuICAgICAgICBhbm5vdGF0aW9uczogdHJ1ZSxcbiAgICAgICAgY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb246IGZhbHNlLFxuICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogKCkgPT4gZmFsc2UsXG4gICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzOiBmYWxzZSxcbiAgICAgICAgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvbjogZmFsc2UsXG4gICAgICAgIHVua25vd25HbG9iYWxTaWRlRWZmZWN0czogZmFsc2VcbiAgICB9XG59O1xuY29uc3QgZ2VuZXJhdGVkQ29kZVByZXNldHMgPSB7XG4gICAgZXMyMDE1OiB7XG4gICAgICAgIGFycm93RnVuY3Rpb25zOiB0cnVlLFxuICAgICAgICBjb25zdEJpbmRpbmdzOiB0cnVlLFxuICAgICAgICBvYmplY3RTaG9ydGhhbmQ6IHRydWUsXG4gICAgICAgIHJlc2VydmVkTmFtZXNBc1Byb3BzOiB0cnVlLFxuICAgICAgICBzeW1ib2xzOiB0cnVlXG4gICAgfSxcbiAgICBlczU6IHtcbiAgICAgICAgYXJyb3dGdW5jdGlvbnM6IGZhbHNlLFxuICAgICAgICBjb25zdEJpbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgb2JqZWN0U2hvcnRoYW5kOiBmYWxzZSxcbiAgICAgICAgcmVzZXJ2ZWROYW1lc0FzUHJvcHM6IHRydWUsXG4gICAgICAgIHN5bWJvbHM6IGZhbHNlXG4gICAgfVxufTtcbmNvbnN0IG9iamVjdGlmeU9wdGlvbiA9ICh2YWx1ZSkgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDoge307XG5jb25zdCBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyA9IChwcmVzZXRzLCBvcHRpb25OYW1lLCBhZGRpdGlvbmFsVmFsdWVzKSA9PiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBwcmVzZXQgPSBwcmVzZXRzW3ZhbHVlXTtcbiAgICAgICAgaWYgKHByZXNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXNldDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihlcnJJbnZhbGlkT3B0aW9uKG9wdGlvbk5hbWUsIGdldEhhc2hGcm9tT2JqZWN0T3B0aW9uKG9wdGlvbk5hbWUpLCBgdmFsaWQgdmFsdWVzIGFyZSAke2FkZGl0aW9uYWxWYWx1ZXN9JHtwcmludFF1b3RlZFN0cmluZ0xpc3QoT2JqZWN0LmtleXMocHJlc2V0cykpfS4gWW91IGNhbiBhbHNvIHN1cHBseSBhbiBvYmplY3QgZm9yIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2xgLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0aWZ5T3B0aW9uKHZhbHVlKTtcbn07XG5jb25zdCBnZXRPcHRpb25XaXRoUHJlc2V0ID0gKHZhbHVlLCBwcmVzZXRzLCBvcHRpb25OYW1lLCBhZGRpdGlvbmFsVmFsdWVzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXNldE5hbWUgPSAoX2EgPSB2YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXNldDtcbiAgICBpZiAocHJlc2V0TmFtZSkge1xuICAgICAgICBjb25zdCBwcmVzZXQgPSBwcmVzZXRzW3ByZXNldE5hbWVdO1xuICAgICAgICBpZiAocHJlc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5wcmVzZXQsIC4uLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcihlcnJJbnZhbGlkT3B0aW9uKGAke29wdGlvbk5hbWV9LnByZXNldGAsIGdldEhhc2hGcm9tT2JqZWN0T3B0aW9uKG9wdGlvbk5hbWUpLCBgdmFsaWQgdmFsdWVzIGFyZSAke3ByaW50UXVvdGVkU3RyaW5nTGlzdChPYmplY3Qua2V5cyhwcmVzZXRzKSl9YCwgcHJlc2V0TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyhwcmVzZXRzLCBvcHRpb25OYW1lLCBhZGRpdGlvbmFsVmFsdWVzKSh2YWx1ZSk7XG59O1xuY29uc3QgZ2V0SGFzaEZyb21PYmplY3RPcHRpb24gPSAob3B0aW9uTmFtZSkgPT4gb3B0aW9uTmFtZS5zcGxpdCgnLicpLmpvaW4oJycpLnRvTG93ZXJDYXNlKCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlucHV0T3B0aW9ucyhjb25maWcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBUaGVzZSBhcmUgb3B0aW9ucyB0aGF0IG1heSB0cmlnZ2VyIHNwZWNpYWwgd2FybmluZ3Mgb3IgYmVoYXZpb3VyIGxhdGVyXG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkIG5vdCBzZWxlY3QgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBjb25zdCB1bnNldE9wdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgY29udGV4dCA9IChfYSA9IGNvbmZpZy5jb250ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5kZWZpbmVkJztcbiAgICBjb25zdCBvbndhcm4gPSBnZXRPbndhcm4oY29uZmlnKTtcbiAgICBjb25zdCBzdHJpY3REZXByZWNhdGlvbnMgPSBjb25maWcuc3RyaWN0RGVwcmVjYXRpb25zIHx8IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGFjb3JuOiBnZXRBY29ybihjb25maWcpLFxuICAgICAgICBhY29ybkluamVjdFBsdWdpbnM6IGdldEFjb3JuSW5qZWN0UGx1Z2lucyhjb25maWcpLFxuICAgICAgICBjYWNoZTogZ2V0Q2FjaGUoY29uZmlnKSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnk6IChfYiA9IGNvbmZpZy5leHBlcmltZW50YWxDYWNoZUV4cGlyeSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTAsXG4gICAgICAgIGV4dGVybmFsOiBnZXRJZE1hdGNoZXIoY29uZmlnLmV4dGVybmFsKSxcbiAgICAgICAgaW5saW5lRHluYW1pY0ltcG9ydHM6IGdldElubGluZUR5bmFtaWNJbXBvcnRzJDEoY29uZmlnLCBvbndhcm4sIHN0cmljdERlcHJlY2F0aW9ucyksXG4gICAgICAgIGlucHV0OiBnZXRJbnB1dChjb25maWcpLFxuICAgICAgICBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZTogKF9jID0gY29uZmlnLm1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlLFxuICAgICAgICBtYW51YWxDaHVua3M6IGdldE1hbnVhbENodW5rcyQxKGNvbmZpZywgb253YXJuLCBzdHJpY3REZXByZWNhdGlvbnMpLFxuICAgICAgICBtYXhQYXJhbGxlbEZpbGVSZWFkczogZ2V0TWF4UGFyYWxsZWxGaWxlUmVhZHMoY29uZmlnKSxcbiAgICAgICAgbW9kdWxlQ29udGV4dDogZ2V0TW9kdWxlQ29udGV4dChjb25maWcsIGNvbnRleHQpLFxuICAgICAgICBvbndhcm4sXG4gICAgICAgIHBlcmY6IGNvbmZpZy5wZXJmIHx8IGZhbHNlLFxuICAgICAgICBwbHVnaW5zOiBlbnN1cmVBcnJheShjb25maWcucGx1Z2lucyksXG4gICAgICAgIHByZXNlcnZlRW50cnlTaWduYXR1cmVzOiBnZXRQcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyhjb25maWcsIHVuc2V0T3B0aW9ucyksXG4gICAgICAgIHByZXNlcnZlTW9kdWxlczogZ2V0UHJlc2VydmVNb2R1bGVzJDEoY29uZmlnLCBvbndhcm4sIHN0cmljdERlcHJlY2F0aW9ucyksXG4gICAgICAgIHByZXNlcnZlU3ltbGlua3M6IGNvbmZpZy5wcmVzZXJ2ZVN5bWxpbmtzIHx8IGZhbHNlLFxuICAgICAgICBzaGltTWlzc2luZ0V4cG9ydHM6IGNvbmZpZy5zaGltTWlzc2luZ0V4cG9ydHMgfHwgZmFsc2UsXG4gICAgICAgIHN0cmljdERlcHJlY2F0aW9ucyxcbiAgICAgICAgdHJlZXNoYWtlOiBnZXRUcmVlc2hha2UoY29uZmlnLCBvbndhcm4sIHN0cmljdERlcHJlY2F0aW9ucylcbiAgICB9O1xuICAgIHdhcm5Vbmtub3duT3B0aW9ucyhjb25maWcsIFsuLi5PYmplY3Qua2V5cyhvcHRpb25zKSwgJ3dhdGNoJ10sICdpbnB1dCBvcHRpb25zJywgb3B0aW9ucy5vbndhcm4sIC9eKG91dHB1dCkkLyk7XG4gICAgcmV0dXJuIHsgb3B0aW9ucywgdW5zZXRPcHRpb25zIH07XG59XG5jb25zdCBnZXRPbndhcm4gPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgeyBvbndhcm4gfSA9IGNvbmZpZztcbiAgICByZXR1cm4gb253YXJuXG4gICAgICAgID8gd2FybmluZyA9PiB7XG4gICAgICAgICAgICB3YXJuaW5nLnRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAod2FybmluZy5wbHVnaW4pXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBgKCR7d2FybmluZy5wbHVnaW59IHBsdWdpbikgYDtcbiAgICAgICAgICAgICAgICBpZiAod2FybmluZy5sb2MpXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBgJHtyZWxhdGl2ZUlkKHdhcm5pbmcubG9jLmZpbGUpfSAoJHt3YXJuaW5nLmxvYy5saW5lfToke3dhcm5pbmcubG9jLmNvbHVtbn0pIGA7XG4gICAgICAgICAgICAgICAgc3RyICs9IHdhcm5pbmcubWVzc2FnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9ud2Fybih3YXJuaW5nLCBkZWZhdWx0T25XYXJuKTtcbiAgICAgICAgfVxuICAgICAgICA6IGRlZmF1bHRPbldhcm47XG59O1xuY29uc3QgZ2V0QWNvcm4gPSAoY29uZmlnKSA9PiAoe1xuICAgIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IHRydWUsXG4gICAgZWNtYVZlcnNpb246ICdsYXRlc3QnLFxuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZSxcbiAgICBzb3VyY2VUeXBlOiAnbW9kdWxlJyxcbiAgICAuLi5jb25maWcuYWNvcm5cbn0pO1xuY29uc3QgZ2V0QWNvcm5JbmplY3RQbHVnaW5zID0gKGNvbmZpZykgPT4gZW5zdXJlQXJyYXkoY29uZmlnLmFjb3JuSW5qZWN0UGx1Z2lucyk7XG5jb25zdCBnZXRDYWNoZSA9IChjb25maWcpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGNvbmZpZy5jYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhY2hlKSB8fCBjb25maWcuY2FjaGU7IH07XG5jb25zdCBnZXRJZE1hdGNoZXIgPSAob3B0aW9uKSA9PiB7XG4gICAgaWYgKG9wdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChpZCwgLi4uYXJncykgPT4gKCFpZC5zdGFydHNXaXRoKCdcXDAnKSAmJiBvcHRpb24oaWQsIC4uLmFyZ3MpKSB8fCBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbikge1xuICAgICAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW5zdXJlQXJyYXkob3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZHMuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlkLCAuLi5fYXJncykgPT4gaWRzLmhhcyhpZCkgfHwgbWF0Y2hlcnMuc29tZShtYXRjaGVyID0+IG1hdGNoZXIudGVzdChpZCkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gZmFsc2U7XG59O1xuY29uc3QgZ2V0SW5saW5lRHluYW1pY0ltcG9ydHMkMSA9IChjb25maWcsIHdhcm4sIHN0cmljdERlcHJlY2F0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ0lubGluZUR5bmFtaWNJbXBvcnRzID0gY29uZmlnLmlubGluZUR5bmFtaWNJbXBvcnRzO1xuICAgIGlmIChjb25maWdJbmxpbmVEeW5hbWljSW1wb3J0cykge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb25XaXRoT3B0aW9ucygnVGhlIFwiaW5saW5lRHluYW1pY0ltcG9ydHNcIiBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBcIm91dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0c1wiIG9wdGlvbiBpbnN0ZWFkLicsIGZhbHNlLCB3YXJuLCBzdHJpY3REZXByZWNhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnSW5saW5lRHluYW1pY0ltcG9ydHM7XG59O1xuY29uc3QgZ2V0SW5wdXQgPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY29uZmlnSW5wdXQgPSBjb25maWcuaW5wdXQ7XG4gICAgcmV0dXJuIGNvbmZpZ0lucHV0ID09IG51bGwgPyBbXSA6IHR5cGVvZiBjb25maWdJbnB1dCA9PT0gJ3N0cmluZycgPyBbY29uZmlnSW5wdXRdIDogY29uZmlnSW5wdXQ7XG59O1xuY29uc3QgZ2V0TWFudWFsQ2h1bmtzJDEgPSAoY29uZmlnLCB3YXJuLCBzdHJpY3REZXByZWNhdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb25maWdNYW51YWxDaHVua3MgPSBjb25maWcubWFudWFsQ2h1bmtzO1xuICAgIGlmIChjb25maWdNYW51YWxDaHVua3MpIHtcbiAgICAgICAgd2FybkRlcHJlY2F0aW9uV2l0aE9wdGlvbnMoJ1RoZSBcIm1hbnVhbENodW5rc1wiIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIFwib3V0cHV0Lm1hbnVhbENodW5rc1wiIG9wdGlvbiBpbnN0ZWFkLicsIGZhbHNlLCB3YXJuLCBzdHJpY3REZXByZWNhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnTWFudWFsQ2h1bmtzO1xufTtcbmNvbnN0IGdldE1heFBhcmFsbGVsRmlsZVJlYWRzID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IG1heFBhcmFsbGVsRmlsZVJlYWRzID0gY29uZmlnLm1heFBhcmFsbGVsRmlsZVJlYWRzO1xuICAgIGlmICh0eXBlb2YgbWF4UGFyYWxsZWxGaWxlUmVhZHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChtYXhQYXJhbGxlbEZpbGVSZWFkcyA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICByZXR1cm4gbWF4UGFyYWxsZWxGaWxlUmVhZHM7XG4gICAgfVxuICAgIHJldHVybiAyMDtcbn07XG5jb25zdCBnZXRNb2R1bGVDb250ZXh0ID0gKGNvbmZpZywgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ01vZHVsZUNvbnRleHQgPSBjb25maWcubW9kdWxlQ29udGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ01vZHVsZUNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gY29uZmlnTW9kdWxlQ29udGV4dChpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHQ7IH07XG4gICAgfVxuICAgIGlmIChjb25maWdNb2R1bGVDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHRCeU1vZHVsZUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBtb2R1bGVDb250ZXh0XSBvZiBPYmplY3QuZW50cmllcyhjb25maWdNb2R1bGVDb250ZXh0KSkge1xuICAgICAgICAgICAgY29udGV4dEJ5TW9kdWxlSWRbcmVzb2x2ZShrZXkpXSA9IG1vZHVsZUNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkID0+IGNvbnRleHRCeU1vZHVsZUlkW2lkXSB8fCBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gY29udGV4dDtcbn07XG5jb25zdCBnZXRQcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyA9IChjb25maWcsIHVuc2V0T3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ1ByZXNlcnZlRW50cnlTaWduYXR1cmVzID0gY29uZmlnLnByZXNlcnZlRW50cnlTaWduYXR1cmVzO1xuICAgIGlmIChjb25maWdQcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyA9PSBudWxsKSB7XG4gICAgICAgIHVuc2V0T3B0aW9ucy5hZGQoJ3ByZXNlcnZlRW50cnlTaWduYXR1cmVzJyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdQcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyAhPT0gbnVsbCAmJiBjb25maWdQcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyAhPT0gdm9pZCAwID8gY29uZmlnUHJlc2VydmVFbnRyeVNpZ25hdHVyZXMgOiAnc3RyaWN0Jztcbn07XG5jb25zdCBnZXRQcmVzZXJ2ZU1vZHVsZXMkMSA9IChjb25maWcsIHdhcm4sIHN0cmljdERlcHJlY2F0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ1ByZXNlcnZlTW9kdWxlcyA9IGNvbmZpZy5wcmVzZXJ2ZU1vZHVsZXM7XG4gICAgaWYgKGNvbmZpZ1ByZXNlcnZlTW9kdWxlcykge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb25XaXRoT3B0aW9ucygnVGhlIFwicHJlc2VydmVNb2R1bGVzXCIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgXCJvdXRwdXQucHJlc2VydmVNb2R1bGVzXCIgb3B0aW9uIGluc3RlYWQuJywgZmFsc2UsIHdhcm4sIHN0cmljdERlcHJlY2F0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdQcmVzZXJ2ZU1vZHVsZXM7XG59O1xuY29uc3QgZ2V0VHJlZXNoYWtlID0gKGNvbmZpZywgd2Fybiwgc3RyaWN0RGVwcmVjYXRpb25zKSA9PiB7XG4gICAgY29uc3QgY29uZmlnVHJlZXNoYWtlID0gY29uZmlnLnRyZWVzaGFrZTtcbiAgICBpZiAoY29uZmlnVHJlZXNoYWtlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZ1dpdGhQcmVzZXQgPSBnZXRPcHRpb25XaXRoUHJlc2V0KGNvbmZpZy50cmVlc2hha2UsIHRyZWVzaGFrZVByZXNldHMsICd0cmVlc2hha2UnLCAnZmFsc2UsIHRydWUsICcpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnV2l0aFByZXNldC5wdXJlRXh0ZXJuYWxNb2R1bGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb25XaXRoT3B0aW9ucyhgVGhlIFwidHJlZXNoYWtlLnB1cmVFeHRlcm5hbE1vZHVsZXNcIiBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVGhlIFwidHJlZXNoYWtlLm1vZHVsZVNpZGVFZmZlY3RzXCIgb3B0aW9uIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuIFwidHJlZXNoYWtlLnB1cmVFeHRlcm5hbE1vZHVsZXM6IHRydWVcIiBpcyBlcXVpdmFsZW50IHRvIFwidHJlZXNoYWtlLm1vZHVsZVNpZGVFZmZlY3RzOiAnbm8tZXh0ZXJuYWwnXCJgLCB0cnVlLCB3YXJuLCBzdHJpY3REZXByZWNhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbm5vdGF0aW9uczogY29uZmlnV2l0aFByZXNldC5hbm5vdGF0aW9ucyAhPT0gZmFsc2UsXG4gICAgICAgIGNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uOiBjb25maWdXaXRoUHJlc2V0LmNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uID09PSB0cnVlLFxuICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogdHlwZW9mIGNvbmZpZ1RyZWVzaGFrZSA9PT0gJ29iamVjdCcgJiYgY29uZmlnVHJlZXNoYWtlLnB1cmVFeHRlcm5hbE1vZHVsZXNcbiAgICAgICAgICAgID8gZ2V0SGFzTW9kdWxlU2lkZUVmZmVjdHMoY29uZmlnVHJlZXNoYWtlLm1vZHVsZVNpZGVFZmZlY3RzLCBjb25maWdUcmVlc2hha2UucHVyZUV4dGVybmFsTW9kdWxlcylcbiAgICAgICAgICAgIDogZ2V0SGFzTW9kdWxlU2lkZUVmZmVjdHMoY29uZmlnV2l0aFByZXNldC5tb2R1bGVTaWRlRWZmZWN0cywgdW5kZWZpbmVkKSxcbiAgICAgICAgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6IGNvbmZpZ1dpdGhQcmVzZXQucHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgPT09ICdhbHdheXMnXG4gICAgICAgICAgICA/ICdhbHdheXMnXG4gICAgICAgICAgICA6IGNvbmZpZ1dpdGhQcmVzZXQucHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgIT09IGZhbHNlLFxuICAgICAgICB0cnlDYXRjaERlb3B0aW1pemF0aW9uOiBjb25maWdXaXRoUHJlc2V0LnRyeUNhdGNoRGVvcHRpbWl6YXRpb24gIT09IGZhbHNlLFxuICAgICAgICB1bmtub3duR2xvYmFsU2lkZUVmZmVjdHM6IGNvbmZpZ1dpdGhQcmVzZXQudW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzICE9PSBmYWxzZVxuICAgIH07XG59O1xuY29uc3QgZ2V0SGFzTW9kdWxlU2lkZUVmZmVjdHMgPSAobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24sIHB1cmVFeHRlcm5hbE1vZHVsZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uO1xuICAgIH1cbiAgICBpZiAobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24gPT09ICduby1leHRlcm5hbCcpIHtcbiAgICAgICAgcmV0dXJuIChfaWQsIGV4dGVybmFsKSA9PiAhZXh0ZXJuYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbW9kdWxlU2lkZUVmZmVjdHNPcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChpZCwgZXh0ZXJuYWwpID0+ICFpZC5zdGFydHNXaXRoKCdcXDAnKSA/IG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uKGlkLCBleHRlcm5hbCkgIT09IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24pKSB7XG4gICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24pO1xuICAgICAgICByZXR1cm4gaWQgPT4gaWRzLmhhcyhpZCk7XG4gICAgfVxuICAgIGlmIChtb2R1bGVTaWRlRWZmZWN0c09wdGlvbikge1xuICAgICAgICBlcnJvcihlcnJJbnZhbGlkT3B0aW9uKCd0cmVlc2hha2UubW9kdWxlU2lkZUVmZmVjdHMnLCAndHJlZXNoYWtlJywgJ3BsZWFzZSB1c2Ugb25lIG9mIGZhbHNlLCBcIm5vLWV4dGVybmFsXCIsIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXknKSk7XG4gICAgfVxuICAgIGNvbnN0IGlzUHVyZUV4dGVybmFsTW9kdWxlID0gZ2V0SWRNYXRjaGVyKHB1cmVFeHRlcm5hbE1vZHVsZXMpO1xuICAgIHJldHVybiAoaWQsIGV4dGVybmFsKSA9PiAhKGV4dGVybmFsICYmIGlzUHVyZUV4dGVybmFsTW9kdWxlKGlkKSk7XG59O1xuXG4vLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzIzOTZcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBJTlZBTElEX0NIQVJfUkVHRVggPSAvW1xceDAwLVxceDFGXFx4N0Y8PiojXCJ7fXxeW1xcXWA7PzomPSskLF0vZztcbmNvbnN0IERSSVZFX0xFVFRFUl9SRUdFWCA9IC9eW2Etel06L2k7XG5mdW5jdGlvbiBzYW5pdGl6ZUZpbGVOYW1lKG5hbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IERSSVZFX0xFVFRFUl9SRUdFWC5leGVjKG5hbWUpO1xuICAgIGNvbnN0IGRyaXZlTGV0dGVyID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIC8vIEEgYDpgIGlzIG9ubHkgYWxsb3dlZCBhcyBwYXJ0IG9mIGEgd2luZG93cyBkcml2ZSBsZXR0ZXIgKGV4OiBDOlxcZm9vKVxuICAgIC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlbSBiZWNhdXNlIHRoZXkgY2FuIHJlZmVyIHRvIE5URlMgYWx0ZXJuYXRlIGRhdGEgc3RyZWFtcy5cbiAgICByZXR1cm4gZHJpdmVMZXR0ZXIgKyBuYW1lLnN1YnN0cihkcml2ZUxldHRlci5sZW5ndGgpLnJlcGxhY2UoSU5WQUxJRF9DSEFSX1JFR0VYLCAnXycpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPdXRwdXRPcHRpb25zKGNvbmZpZywgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAvLyBUaGVzZSBhcmUgb3B0aW9ucyB0aGF0IG1heSB0cmlnZ2VyIHNwZWNpYWwgd2FybmluZ3Mgb3IgYmVoYXZpb3VyIGxhdGVyXG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkIG5vdCBzZWxlY3QgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBjb25zdCB1bnNldE9wdGlvbnMgPSBuZXcgU2V0KHVuc2V0SW5wdXRPcHRpb25zKTtcbiAgICBjb25zdCBjb21wYWN0ID0gY29uZmlnLmNvbXBhY3QgfHwgZmFsc2U7XG4gICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KGNvbmZpZyk7XG4gICAgY29uc3QgaW5saW5lRHluYW1pY0ltcG9ydHMgPSBnZXRJbmxpbmVEeW5hbWljSW1wb3J0cyhjb25maWcsIGlucHV0T3B0aW9ucyk7XG4gICAgY29uc3QgcHJlc2VydmVNb2R1bGVzID0gZ2V0UHJlc2VydmVNb2R1bGVzKGNvbmZpZywgaW5saW5lRHluYW1pY0ltcG9ydHMsIGlucHV0T3B0aW9ucyk7XG4gICAgY29uc3QgZmlsZSA9IGdldEZpbGUoY29uZmlnLCBwcmVzZXJ2ZU1vZHVsZXMsIGlucHV0T3B0aW9ucyk7XG4gICAgY29uc3QgcHJlZmVyQ29uc3QgPSBnZXRQcmVmZXJDb25zdChjb25maWcsIGlucHV0T3B0aW9ucyk7XG4gICAgY29uc3QgZ2VuZXJhdGVkQ29kZSA9IGdldEdlbmVyYXRlZENvZGUoY29uZmlnLCBwcmVmZXJDb25zdCk7XG4gICAgY29uc3Qgb3V0cHV0T3B0aW9ucyA9IHtcbiAgICAgICAgYW1kOiBnZXRBbWQoY29uZmlnKSxcbiAgICAgICAgYXNzZXRGaWxlTmFtZXM6IChfYSA9IGNvbmZpZy5hc3NldEZpbGVOYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2Fzc2V0cy9bbmFtZV0tW2hhc2hdW2V4dG5hbWVdJyxcbiAgICAgICAgYmFubmVyOiBnZXRBZGRvbihjb25maWcsICdiYW5uZXInKSxcbiAgICAgICAgY2h1bmtGaWxlTmFtZXM6IChfYiA9IGNvbmZpZy5jaHVua0ZpbGVOYW1lcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ1tuYW1lXS1baGFzaF0uanMnLFxuICAgICAgICBjb21wYWN0LFxuICAgICAgICBkaXI6IGdldERpcihjb25maWcsIGZpbGUpLFxuICAgICAgICBkeW5hbWljSW1wb3J0RnVuY3Rpb246IGdldER5bmFtaWNJbXBvcnRGdW5jdGlvbihjb25maWcsIGlucHV0T3B0aW9ucyksXG4gICAgICAgIGVudHJ5RmlsZU5hbWVzOiBnZXRFbnRyeUZpbGVOYW1lcyhjb25maWcsIHVuc2V0T3B0aW9ucyksXG4gICAgICAgIGVzTW9kdWxlOiAoX2MgPSBjb25maWcuZXNNb2R1bGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRydWUsXG4gICAgICAgIGV4cG9ydHM6IGdldEV4cG9ydHMoY29uZmlnLCB1bnNldE9wdGlvbnMpLFxuICAgICAgICBleHRlbmQ6IGNvbmZpZy5leHRlbmQgfHwgZmFsc2UsXG4gICAgICAgIGV4dGVybmFsTGl2ZUJpbmRpbmdzOiAoX2QgPSBjb25maWcuZXh0ZXJuYWxMaXZlQmluZGluZ3MpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgIGZpbGUsXG4gICAgICAgIGZvb3RlcjogZ2V0QWRkb24oY29uZmlnLCAnZm9vdGVyJyksXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgZnJlZXplOiAoX2UgPSBjb25maWcuZnJlZXplKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgICAgICBnZW5lcmF0ZWRDb2RlLFxuICAgICAgICBnbG9iYWxzOiBjb25maWcuZ2xvYmFscyB8fCB7fSxcbiAgICAgICAgaG9pc3RUcmFuc2l0aXZlSW1wb3J0czogKF9mID0gY29uZmlnLmhvaXN0VHJhbnNpdGl2ZUltcG9ydHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUsXG4gICAgICAgIGluZGVudDogZ2V0SW5kZW50KGNvbmZpZywgY29tcGFjdCksXG4gICAgICAgIGlubGluZUR5bmFtaWNJbXBvcnRzLFxuICAgICAgICBpbnRlcm9wOiBnZXRJbnRlcm9wKGNvbmZpZywgaW5wdXRPcHRpb25zKSxcbiAgICAgICAgaW50cm86IGdldEFkZG9uKGNvbmZpZywgJ2ludHJvJyksXG4gICAgICAgIG1hbnVhbENodW5rczogZ2V0TWFudWFsQ2h1bmtzKGNvbmZpZywgaW5saW5lRHluYW1pY0ltcG9ydHMsIHByZXNlcnZlTW9kdWxlcywgaW5wdXRPcHRpb25zKSxcbiAgICAgICAgbWluaWZ5SW50ZXJuYWxFeHBvcnRzOiBnZXRNaW5pZnlJbnRlcm5hbEV4cG9ydHMoY29uZmlnLCBmb3JtYXQsIGNvbXBhY3QpLFxuICAgICAgICBuYW1lOiBjb25maWcubmFtZSxcbiAgICAgICAgbmFtZXNwYWNlVG9TdHJpbmdUYWc6IGdldE5hbWVzcGFjZVRvU3RyaW5nVGFnKGNvbmZpZywgZ2VuZXJhdGVkQ29kZSwgaW5wdXRPcHRpb25zKSxcbiAgICAgICAgbm9Db25mbGljdDogY29uZmlnLm5vQ29uZmxpY3QgfHwgZmFsc2UsXG4gICAgICAgIG91dHJvOiBnZXRBZGRvbihjb25maWcsICdvdXRybycpLFxuICAgICAgICBwYXRoczogY29uZmlnLnBhdGhzIHx8IHt9LFxuICAgICAgICBwbHVnaW5zOiBlbnN1cmVBcnJheShjb25maWcucGx1Z2lucyksXG4gICAgICAgIHByZWZlckNvbnN0LFxuICAgICAgICBwcmVzZXJ2ZU1vZHVsZXMsXG4gICAgICAgIHByZXNlcnZlTW9kdWxlc1Jvb3Q6IGdldFByZXNlcnZlTW9kdWxlc1Jvb3QoY29uZmlnKSxcbiAgICAgICAgc2FuaXRpemVGaWxlTmFtZTogdHlwZW9mIGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lXG4gICAgICAgICAgICA6IGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lID09PSBmYWxzZVxuICAgICAgICAgICAgICAgID8gaWQgPT4gaWRcbiAgICAgICAgICAgICAgICA6IHNhbml0aXplRmlsZU5hbWUsXG4gICAgICAgIHNvdXJjZW1hcDogY29uZmlnLnNvdXJjZW1hcCB8fCBmYWxzZSxcbiAgICAgICAgc291cmNlbWFwRXhjbHVkZVNvdXJjZXM6IGNvbmZpZy5zb3VyY2VtYXBFeGNsdWRlU291cmNlcyB8fCBmYWxzZSxcbiAgICAgICAgc291cmNlbWFwRmlsZTogY29uZmlnLnNvdXJjZW1hcEZpbGUsXG4gICAgICAgIHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm06IGNvbmZpZy5zb3VyY2VtYXBQYXRoVHJhbnNmb3JtLFxuICAgICAgICBzdHJpY3Q6IChfZyA9IGNvbmZpZy5zdHJpY3QpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHRydWUsXG4gICAgICAgIHN5c3RlbU51bGxTZXR0ZXJzOiBjb25maWcuc3lzdGVtTnVsbFNldHRlcnMgfHwgZmFsc2UsXG4gICAgICAgIHZhbGlkYXRlOiBjb25maWcudmFsaWRhdGUgfHwgZmFsc2VcbiAgICB9O1xuICAgIHdhcm5Vbmtub3duT3B0aW9ucyhjb25maWcsIE9iamVjdC5rZXlzKG91dHB1dE9wdGlvbnMpLCAnb3V0cHV0IG9wdGlvbnMnLCBpbnB1dE9wdGlvbnMub253YXJuKTtcbiAgICByZXR1cm4geyBvcHRpb25zOiBvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMgfTtcbn1cbmNvbnN0IGdldEZpbGUgPSAoY29uZmlnLCBwcmVzZXJ2ZU1vZHVsZXMsIGlucHV0T3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgZmlsZSB9ID0gY29uZmlnO1xuICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlTW9kdWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5maWxlJywgJ291dHB1dGRpcicsICd5b3UgbXVzdCBzZXQgXCJvdXRwdXQuZGlyXCIgaW5zdGVhZCBvZiBcIm91dHB1dC5maWxlXCIgd2hlbiB1c2luZyB0aGUgXCJvdXRwdXQucHJlc2VydmVNb2R1bGVzXCIgb3B0aW9uJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dE9wdGlvbnMuaW5wdXQpKVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5maWxlJywgJ291dHB1dGRpcicsICd5b3UgbXVzdCBzZXQgXCJvdXRwdXQuZGlyXCIgaW5zdGVhZCBvZiBcIm91dHB1dC5maWxlXCIgd2hlbiBwcm92aWRpbmcgbmFtZWQgaW5wdXRzJykpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbn07XG5jb25zdCBnZXRGb3JtYXQgPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY29uZmlnRm9ybWF0ID0gY29uZmlnLmZvcm1hdDtcbiAgICBzd2l0Y2ggKGNvbmZpZ0Zvcm1hdCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnZXMnOlxuICAgICAgICBjYXNlICdlc20nOlxuICAgICAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgICAgICAgcmV0dXJuICdlcyc7XG4gICAgICAgIGNhc2UgJ2Nqcyc6XG4gICAgICAgIGNhc2UgJ2NvbW1vbmpzJzpcbiAgICAgICAgICAgIHJldHVybiAnY2pzJztcbiAgICAgICAgY2FzZSAnc3lzdGVtJzpcbiAgICAgICAgY2FzZSAnc3lzdGVtanMnOlxuICAgICAgICAgICAgcmV0dXJuICdzeXN0ZW0nO1xuICAgICAgICBjYXNlICdhbWQnOlxuICAgICAgICBjYXNlICdpaWZlJzpcbiAgICAgICAgY2FzZSAndW1kJzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWdGb3JtYXQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBZb3UgbXVzdCBzcGVjaWZ5IFwib3V0cHV0LmZvcm1hdFwiLCB3aGljaCBjYW4gYmUgb25lIG9mIFwiYW1kXCIsIFwiY2pzXCIsIFwic3lzdGVtXCIsIFwiZXNcIiwgXCJpaWZlXCIgb3IgXCJ1bWRcIi5gLFxuICAgICAgICAgICAgICAgIHVybDogYGh0dHBzOi8vcm9sbHVwanMub3JnL2d1aWRlL2VuLyNvdXRwdXRmb3JtYXRgXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgZ2V0SW5saW5lRHluYW1pY0ltcG9ydHMgPSAoY29uZmlnLCBpbnB1dE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaW5saW5lRHluYW1pY0ltcG9ydHMgPSAoKF9hID0gY29uZmlnLmlubGluZUR5bmFtaWNJbXBvcnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbnB1dE9wdGlvbnMuaW5saW5lRHluYW1pY0ltcG9ydHMpIHx8IGZhbHNlO1xuICAgIGNvbnN0IHsgaW5wdXQgfSA9IGlucHV0T3B0aW9ucztcbiAgICBpZiAoaW5saW5lRHluYW1pY0ltcG9ydHMgJiYgKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBPYmplY3Qua2V5cyhpbnB1dCkpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0cycsICdvdXRwdXRpbmxpbmVkeW5hbWljaW1wb3J0cycsICdtdWx0aXBsZSBpbnB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2hlbiBcIm91dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0c1wiIGlzIHRydWUnKSk7XG4gICAgfVxuICAgIHJldHVybiBpbmxpbmVEeW5hbWljSW1wb3J0cztcbn07XG5jb25zdCBnZXRQcmVzZXJ2ZU1vZHVsZXMgPSAoY29uZmlnLCBpbmxpbmVEeW5hbWljSW1wb3J0cywgaW5wdXRPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXNlcnZlTW9kdWxlcyA9ICgoX2EgPSBjb25maWcucHJlc2VydmVNb2R1bGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbnB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSB8fCBmYWxzZTtcbiAgICBpZiAocHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgIGlmIChpbmxpbmVEeW5hbWljSW1wb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0cycsICdvdXRwdXRpbmxpbmVkeW5hbWljaW1wb3J0cycsIGB0aGlzIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBcIm91dHB1dC5wcmVzZXJ2ZU1vZHVsZXNcImApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRPcHRpb25zLnByZXNlcnZlRW50cnlTaWduYXR1cmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ3ByZXNlcnZlRW50cnlTaWduYXR1cmVzJywgJ3ByZXNlcnZlZW50cnlzaWduYXR1cmVzJywgJ3NldHRpbmcgdGhpcyBvcHRpb24gdG8gZmFsc2UgaXMgbm90IHN1cHBvcnRlZCBmb3IgXCJvdXRwdXQucHJlc2VydmVNb2R1bGVzXCInKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZXNlcnZlTW9kdWxlcztcbn07XG5jb25zdCBnZXRQcmVmZXJDb25zdCA9IChjb25maWcsIGlucHV0T3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ1ByZWZlckNvbnN0ID0gY29uZmlnLnByZWZlckNvbnN0O1xuICAgIGlmIChjb25maWdQcmVmZXJDb25zdCAhPSBudWxsKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihgVGhlIFwib3V0cHV0LnByZWZlckNvbnN0XCIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgXCJvdXRwdXQuZ2VuZXJhdGVkQ29kZS5jb25zdEJpbmRpbmdzXCIgb3B0aW9uIGluc3RlYWQuYCwgZmFsc2UsIGlucHV0T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiAhIWNvbmZpZ1ByZWZlckNvbnN0O1xufTtcbmNvbnN0IGdldFByZXNlcnZlTW9kdWxlc1Jvb3QgPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgeyBwcmVzZXJ2ZU1vZHVsZXNSb290IH0gPSBjb25maWc7XG4gICAgaWYgKHByZXNlcnZlTW9kdWxlc1Jvb3QgPT09IG51bGwgfHwgcHJlc2VydmVNb2R1bGVzUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlKHByZXNlcnZlTW9kdWxlc1Jvb3QpO1xufTtcbmNvbnN0IGdldEFtZCA9IChjb25maWcpID0+IHtcbiAgICBjb25zdCBtZXJnZWRPcHRpb24gPSB7XG4gICAgICAgIGF1dG9JZDogZmFsc2UsXG4gICAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICAgICAgZGVmaW5lOiAnZGVmaW5lJyxcbiAgICAgICAgLi4uY29uZmlnLmFtZFxuICAgIH07XG4gICAgaWYgKChtZXJnZWRPcHRpb24uYXV0b0lkIHx8IG1lcmdlZE9wdGlvbi5iYXNlUGF0aCkgJiYgbWVyZ2VkT3B0aW9uLmlkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihlcnJJbnZhbGlkT3B0aW9uKCdvdXRwdXQuYW1kLmlkJywgJ291dHB1dGFtZCcsICd0aGlzIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIFwib3V0cHV0LmFtZC5hdXRvSWRcIi9cIm91dHB1dC5hbWQuYmFzZVBhdGhcIicpKTtcbiAgICB9XG4gICAgaWYgKG1lcmdlZE9wdGlvbi5iYXNlUGF0aCAmJiAhbWVyZ2VkT3B0aW9uLmF1dG9JZCkge1xuICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignb3V0cHV0LmFtZC5iYXNlUGF0aCcsICdvdXRwdXRhbWQnLCAndGhpcyBvcHRpb24gb25seSB3b3JrcyB3aXRoIFwib3V0cHV0LmFtZC5hdXRvSWRcIicpKTtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWQ7XG4gICAgaWYgKG1lcmdlZE9wdGlvbi5hdXRvSWQpIHtcbiAgICAgICAgbm9ybWFsaXplZCA9IHtcbiAgICAgICAgICAgIGF1dG9JZDogdHJ1ZSxcbiAgICAgICAgICAgIGJhc2VQYXRoOiBtZXJnZWRPcHRpb24uYmFzZVBhdGgsXG4gICAgICAgICAgICBkZWZpbmU6IG1lcmdlZE9wdGlvbi5kZWZpbmVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSB7XG4gICAgICAgICAgICBhdXRvSWQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVmaW5lOiBtZXJnZWRPcHRpb24uZGVmaW5lLFxuICAgICAgICAgICAgaWQ6IG1lcmdlZE9wdGlvbi5pZFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBnZXRBZGRvbiA9IChjb25maWcsIG5hbWUpID0+IHtcbiAgICBjb25zdCBjb25maWdBZGRvbiA9IGNvbmZpZ1tuYW1lXTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ0FkZG9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjb25maWdBZGRvbjtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IGNvbmZpZ0FkZG9uIHx8ICcnO1xufTtcbmNvbnN0IGdldERpciA9IChjb25maWcsIGZpbGUpID0+IHtcbiAgICBjb25zdCB7IGRpciB9ID0gY29uZmlnO1xuICAgIGlmICh0eXBlb2YgZGlyID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGVyckludmFsaWRPcHRpb24oJ291dHB1dC5kaXInLCAnb3V0cHV0ZGlyJywgJ3lvdSBtdXN0IHNldCBlaXRoZXIgXCJvdXRwdXQuZmlsZVwiIGZvciBhIHNpbmdsZS1maWxlIGJ1aWxkIG9yIFwib3V0cHV0LmRpclwiIHdoZW4gZ2VuZXJhdGluZyBtdWx0aXBsZSBjaHVua3MnKSk7XG4gICAgfVxuICAgIHJldHVybiBkaXI7XG59O1xuY29uc3QgZ2V0RHluYW1pY0ltcG9ydEZ1bmN0aW9uID0gKGNvbmZpZywgaW5wdXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29uZmlnRHluYW1pY0ltcG9ydEZ1bmN0aW9uID0gY29uZmlnLmR5bmFtaWNJbXBvcnRGdW5jdGlvbjtcbiAgICBpZiAoY29uZmlnRHluYW1pY0ltcG9ydEZ1bmN0aW9uKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihgVGhlIFwib3V0cHV0LmR5bmFtaWNJbXBvcnRGdW5jdGlvblwiIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIFwicmVuZGVyRHluYW1pY0ltcG9ydFwiIHBsdWdpbiBob29rIGluc3RlYWQuYCwgZmFsc2UsIGlucHV0T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdEeW5hbWljSW1wb3J0RnVuY3Rpb247XG59O1xuY29uc3QgZ2V0RW50cnlGaWxlTmFtZXMgPSAoY29uZmlnLCB1bnNldE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb25maWdFbnRyeUZpbGVOYW1lcyA9IGNvbmZpZy5lbnRyeUZpbGVOYW1lcztcbiAgICBpZiAoY29uZmlnRW50cnlGaWxlTmFtZXMgPT0gbnVsbCkge1xuICAgICAgICB1bnNldE9wdGlvbnMuYWRkKCdlbnRyeUZpbGVOYW1lcycpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnRW50cnlGaWxlTmFtZXMgIT09IG51bGwgJiYgY29uZmlnRW50cnlGaWxlTmFtZXMgIT09IHZvaWQgMCA/IGNvbmZpZ0VudHJ5RmlsZU5hbWVzIDogJ1tuYW1lXS5qcyc7XG59O1xuZnVuY3Rpb24gZ2V0RXhwb3J0cyhjb25maWcsIHVuc2V0T3B0aW9ucykge1xuICAgIGNvbnN0IGNvbmZpZ0V4cG9ydHMgPSBjb25maWcuZXhwb3J0cztcbiAgICBpZiAoY29uZmlnRXhwb3J0cyA9PSBudWxsKSB7XG4gICAgICAgIHVuc2V0T3B0aW9ucy5hZGQoJ2V4cG9ydHMnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIVsnZGVmYXVsdCcsICduYW1lZCcsICdub25lJywgJ2F1dG8nXS5pbmNsdWRlcyhjb25maWdFeHBvcnRzKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZEV4cG9ydE9wdGlvblZhbHVlKGNvbmZpZ0V4cG9ydHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ0V4cG9ydHMgfHwgJ2F1dG8nO1xufVxuY29uc3QgZ2V0R2VuZXJhdGVkQ29kZSA9IChjb25maWcsIHByZWZlckNvbnN0KSA9PiB7XG4gICAgY29uc3QgY29uZmlnV2l0aFByZXNldCA9IGdldE9wdGlvbldpdGhQcmVzZXQoY29uZmlnLmdlbmVyYXRlZENvZGUsIGdlbmVyYXRlZENvZGVQcmVzZXRzLCAnb3V0cHV0LmdlbmVyYXRlZENvZGUnLCAnJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJyb3dGdW5jdGlvbnM6IGNvbmZpZ1dpdGhQcmVzZXQuYXJyb3dGdW5jdGlvbnMgPT09IHRydWUsXG4gICAgICAgIGNvbnN0QmluZGluZ3M6IGNvbmZpZ1dpdGhQcmVzZXQuY29uc3RCaW5kaW5ncyA9PT0gdHJ1ZSB8fCBwcmVmZXJDb25zdCxcbiAgICAgICAgb2JqZWN0U2hvcnRoYW5kOiBjb25maWdXaXRoUHJlc2V0Lm9iamVjdFNob3J0aGFuZCA9PT0gdHJ1ZSxcbiAgICAgICAgcmVzZXJ2ZWROYW1lc0FzUHJvcHM6IGNvbmZpZ1dpdGhQcmVzZXQucmVzZXJ2ZWROYW1lc0FzUHJvcHMgPT09IHRydWUsXG4gICAgICAgIHN5bWJvbHM6IGNvbmZpZ1dpdGhQcmVzZXQuc3ltYm9scyA9PT0gdHJ1ZVxuICAgIH07XG59O1xuY29uc3QgZ2V0SW5kZW50ID0gKGNvbmZpZywgY29tcGFjdCkgPT4ge1xuICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgY29uZmlnSW5kZW50ID0gY29uZmlnLmluZGVudDtcbiAgICByZXR1cm4gY29uZmlnSW5kZW50ID09PSBmYWxzZSA/ICcnIDogY29uZmlnSW5kZW50ICE9PSBudWxsICYmIGNvbmZpZ0luZGVudCAhPT0gdm9pZCAwID8gY29uZmlnSW5kZW50IDogdHJ1ZTtcbn07XG5jb25zdCBBTExPV0VEX0lOVEVST1BfVFlQRVMgPSBuZXcgU2V0KFtcbiAgICAnYXV0bycsXG4gICAgJ2VzTW9kdWxlJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmF1bHRPbmx5JyxcbiAgICB0cnVlLFxuICAgIGZhbHNlXG5dKTtcbmNvbnN0IGdldEludGVyb3AgPSAoY29uZmlnLCBpbnB1dE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb25maWdJbnRlcm9wID0gY29uZmlnLmludGVyb3A7XG4gICAgY29uc3QgdmFsaWRhdGVkSW50ZXJvcFR5cGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHZhbGlkYXRlSW50ZXJvcCA9IChpbnRlcm9wKSA9PiB7XG4gICAgICAgIGlmICghdmFsaWRhdGVkSW50ZXJvcFR5cGVzLmhhcyhpbnRlcm9wKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVkSW50ZXJvcFR5cGVzLmFkZChpbnRlcm9wKTtcbiAgICAgICAgICAgIGlmICghQUxMT1dFRF9JTlRFUk9QX1RZUEVTLmhhcyhpbnRlcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnJJbnZhbGlkT3B0aW9uKCdvdXRwdXQuaW50ZXJvcCcsICdvdXRwdXRpbnRlcm9wJywgYHVzZSBvbmUgb2YgJHtBcnJheS5mcm9tKEFMTE9XRURfSU5URVJPUF9UWVBFUywgdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKS5qb2luKCcsICcpfWAsIGludGVyb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW50ZXJvcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBib29sZWFuIHZhbHVlIFwiJHtpbnRlcm9wfVwiIGZvciB0aGUgXCJvdXRwdXQuaW50ZXJvcFwiIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgJHtpbnRlcm9wID8gJ1wiYXV0b1wiJyA6ICdcImVzTW9kdWxlXCIsIFwiZGVmYXVsdFwiIG9yIFwiZGVmYXVsdE9ubHlcIid9IGluc3RlYWQuYCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI291dHB1dGludGVyb3AnXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UsIGlucHV0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyb3A7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ0ludGVyb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgaW50ZXJvcFBlcklkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGRlZmF1bHRJbnRlcm9wID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGlkID0+IGlkID09PSBudWxsXG4gICAgICAgICAgICA/IGRlZmF1bHRJbnRlcm9wIHx8IHZhbGlkYXRlSW50ZXJvcCgoZGVmYXVsdEludGVyb3AgPSBjb25maWdJbnRlcm9wKGlkKSkpXG4gICAgICAgICAgICA6IGlkIGluIGludGVyb3BQZXJJZFxuICAgICAgICAgICAgICAgID8gaW50ZXJvcFBlcklkW2lkXVxuICAgICAgICAgICAgICAgIDogdmFsaWRhdGVJbnRlcm9wKChpbnRlcm9wUGVySWRbaWRdID0gY29uZmlnSW50ZXJvcChpZCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ0ludGVyb3AgPT09IHVuZGVmaW5lZCA/ICgpID0+IHRydWUgOiAoKSA9PiB2YWxpZGF0ZUludGVyb3AoY29uZmlnSW50ZXJvcCk7XG59O1xuY29uc3QgZ2V0TWFudWFsQ2h1bmtzID0gKGNvbmZpZywgaW5saW5lRHluYW1pY0ltcG9ydHMsIHByZXNlcnZlTW9kdWxlcywgaW5wdXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29uZmlnTWFudWFsQ2h1bmtzID0gY29uZmlnLm1hbnVhbENodW5rcyB8fCBpbnB1dE9wdGlvbnMubWFudWFsQ2h1bmtzO1xuICAgIGlmIChjb25maWdNYW51YWxDaHVua3MpIHtcbiAgICAgICAgaWYgKGlubGluZUR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignb3V0cHV0Lm1hbnVhbENodW5rcycsICdvdXRwdXRtYW51YWxjaHVua3MnLCAndGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgXCJvdXRwdXQuaW5saW5lRHluYW1pY0ltcG9ydHNcIicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignb3V0cHV0Lm1hbnVhbENodW5rcycsICdvdXRwdXRtYW51YWxjaHVua3MnLCAndGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgXCJvdXRwdXQucHJlc2VydmVNb2R1bGVzXCInKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ01hbnVhbENodW5rcyB8fCB7fTtcbn07XG5jb25zdCBnZXRNaW5pZnlJbnRlcm5hbEV4cG9ydHMgPSAoY29uZmlnLCBmb3JtYXQsIGNvbXBhY3QpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gY29uZmlnLm1pbmlmeUludGVybmFsRXhwb3J0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNvbXBhY3QgfHwgZm9ybWF0ID09PSAnZXMnIHx8IGZvcm1hdCA9PT0gJ3N5c3RlbScpOyB9O1xuY29uc3QgZ2V0TmFtZXNwYWNlVG9TdHJpbmdUYWcgPSAoY29uZmlnLCBnZW5lcmF0ZWRDb2RlLCBpbnB1dE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBjb25maWdOYW1lc3BhY2VUb1N0cmluZ1RhZyA9IGNvbmZpZy5uYW1lc3BhY2VUb1N0cmluZ1RhZztcbiAgICBpZiAoY29uZmlnTmFtZXNwYWNlVG9TdHJpbmdUYWcgIT0gbnVsbCkge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb24oYFRoZSBcIm91dHB1dC5uYW1lc3BhY2VUb1N0cmluZ1RhZ1wiIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIFwib3V0cHV0LmdlbmVyYXRlZENvZGUuc3ltYm9sc1wiIG9wdGlvbiBpbnN0ZWFkLmAsIGZhbHNlLCBpbnB1dE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY29uZmlnTmFtZXNwYWNlVG9TdHJpbmdUYWc7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZWRDb2RlLnN5bWJvbHMgfHwgZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByb2xsdXAocmF3SW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvbGx1cEludGVybmFsKHJhd0lucHV0T3B0aW9ucywgbnVsbCk7XG59XG5hc3luYyBmdW5jdGlvbiByb2xsdXBJbnRlcm5hbChyYXdJbnB1dE9wdGlvbnMsIHdhdGNoZXIpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IGlucHV0T3B0aW9ucywgdW5zZXRPcHRpb25zOiB1bnNldElucHV0T3B0aW9ucyB9ID0gYXdhaXQgZ2V0SW5wdXRPcHRpb25zKHJhd0lucHV0T3B0aW9ucywgd2F0Y2hlciAhPT0gbnVsbCk7XG4gICAgaW5pdGlhbGlzZVRpbWVycyhpbnB1dE9wdGlvbnMpO1xuICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKGlucHV0T3B0aW9ucywgd2F0Y2hlcik7XG4gICAgLy8gcmVtb3ZlIHRoZSBjYWNoZSBvcHRpb24gZnJvbSB0aGUgbWVtb3J5IGFmdGVyIGdyYXBoIGNyZWF0aW9uIChjYWNoZSBpcyBub3QgdXNlZCBhbnltb3JlKVxuICAgIGNvbnN0IHVzZUNhY2hlID0gcmF3SW5wdXRPcHRpb25zLmNhY2hlICE9PSBmYWxzZTtcbiAgICBkZWxldGUgaW5wdXRPcHRpb25zLmNhY2hlO1xuICAgIGRlbGV0ZSByYXdJbnB1dE9wdGlvbnMuY2FjaGU7XG4gICAgdGltZVN0YXJ0KCdCVUlMRCcsIDEpO1xuICAgIGF3YWl0IGNhdGNoVW5maW5pc2hlZEhvb2tBY3Rpb25zKGdyYXBoLnBsdWdpbkRyaXZlciwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnYnVpbGRTdGFydCcsIFtpbnB1dE9wdGlvbnNdKTtcbiAgICAgICAgICAgIGF3YWl0IGdyYXBoLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3Qgd2F0Y2hGaWxlcyA9IE9iamVjdC5rZXlzKGdyYXBoLndhdGNoRmlsZXMpO1xuICAgICAgICAgICAgaWYgKHdhdGNoRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVyci53YXRjaEZpbGVzID0gd2F0Y2hGaWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGdyYXBoLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoJ2J1aWxkRW5kJywgW2Vycl0pO1xuICAgICAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnY2xvc2VCdW5kbGUnLCBbXSk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnYnVpbGRFbmQnLCBbXSk7XG4gICAgfSk7XG4gICAgdGltZUVuZCgnQlVJTEQnLCAxKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGNhY2hlOiB1c2VDYWNoZSA/IGdyYXBoLmdldENhY2hlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdWx0LmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBncmFwaC5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdjbG9zZUJ1bmRsZScsIFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgICAgYXN5bmMgZ2VuZXJhdGUocmF3T3V0cHV0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckFscmVhZHlDbG9zZWQoKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlR2VuZXJhdGVXcml0ZShmYWxzZSwgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucywgcmF3T3V0cHV0T3B0aW9ucywgZ3JhcGgpO1xuICAgICAgICB9LFxuICAgICAgICB3YXRjaEZpbGVzOiBPYmplY3Qua2V5cyhncmFwaC53YXRjaEZpbGVzKSxcbiAgICAgICAgYXN5bmMgd3JpdGUocmF3T3V0cHV0T3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVyckFscmVhZHlDbG9zZWQoKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlR2VuZXJhdGVXcml0ZSh0cnVlLCBpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zLCByYXdPdXRwdXRPcHRpb25zLCBncmFwaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnB1dE9wdGlvbnMucGVyZilcbiAgICAgICAgcmVzdWx0LmdldFRpbWluZ3MgPSBnZXRUaW1pbmdzO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJbnB1dE9wdGlvbnMocmF3SW5wdXRPcHRpb25zLCB3YXRjaE1vZGUpIHtcbiAgICBpZiAoIXJhd0lucHV0T3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byByb2xsdXAnKTtcbiAgICB9XG4gICAgY29uc3QgcmF3UGx1Z2lucyA9IGVuc3VyZUFycmF5KHJhd0lucHV0T3B0aW9ucy5wbHVnaW5zKTtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHVuc2V0T3B0aW9ucyB9ID0gbm9ybWFsaXplSW5wdXRPcHRpb25zKGF3YWl0IHJhd1BsdWdpbnMucmVkdWNlKGFwcGx5T3B0aW9uSG9vayh3YXRjaE1vZGUpLCBQcm9taXNlLnJlc29sdmUocmF3SW5wdXRPcHRpb25zKSkpO1xuICAgIG5vcm1hbGl6ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zLCBBTk9OWU1PVVNfUExVR0lOX1BSRUZJWCk7XG4gICAgcmV0dXJuIHsgb3B0aW9ucywgdW5zZXRPcHRpb25zIH07XG59XG5mdW5jdGlvbiBhcHBseU9wdGlvbkhvb2sod2F0Y2hNb2RlKSB7XG4gICAgcmV0dXJuIGFzeW5jIChpbnB1dE9wdGlvbnMsIHBsdWdpbikgPT4ge1xuICAgICAgICBpZiAocGx1Z2luLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGF3YWl0IHBsdWdpbi5vcHRpb25zLmNhbGwoeyBtZXRhOiB7IHJvbGx1cFZlcnNpb246IHZlcnNpb24kMSwgd2F0Y2hNb2RlIH0gfSwgYXdhaXQgaW5wdXRPcHRpb25zKSkgfHwgaW5wdXRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRPcHRpb25zO1xuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQbHVnaW5zKHBsdWdpbnMsIGFub255bW91c1ByZWZpeCkge1xuICAgIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoIXBsdWdpbi5uYW1lKSB7XG4gICAgICAgICAgICBwbHVnaW4ubmFtZSA9IGAke2Fub255bW91c1ByZWZpeH0ke2luZGV4ICsgMX1gO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVHZW5lcmF0ZVdyaXRlKGlzV3JpdGUsIGlucHV0T3B0aW9ucywgdW5zZXRJbnB1dE9wdGlvbnMsIHJhd091dHB1dE9wdGlvbnMsIGdyYXBoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zOiBvdXRwdXRPcHRpb25zLCBvdXRwdXRQbHVnaW5Ecml2ZXIsIHVuc2V0T3B0aW9ucyB9ID0gZ2V0T3V0cHV0T3B0aW9uc0FuZFBsdWdpbkRyaXZlcihyYXdPdXRwdXRPcHRpb25zLCBncmFwaC5wbHVnaW5Ecml2ZXIsIGlucHV0T3B0aW9ucywgdW5zZXRJbnB1dE9wdGlvbnMpO1xuICAgIHJldHVybiBjYXRjaFVuZmluaXNoZWRIb29rQWN0aW9ucyhvdXRwdXRQbHVnaW5Ecml2ZXIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3IEJ1bmRsZShvdXRwdXRPcHRpb25zLCB1bnNldE9wdGlvbnMsIGlucHV0T3B0aW9ucywgb3V0cHV0UGx1Z2luRHJpdmVyLCBncmFwaCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGF3YWl0IGJ1bmRsZS5nZW5lcmF0ZShpc1dyaXRlKTtcbiAgICAgICAgaWYgKGlzV3JpdGUpIHtcbiAgICAgICAgICAgIGlmICghb3V0cHV0T3B0aW9ucy5kaXIgJiYgIW91dHB1dE9wdGlvbnMuZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdNSVNTSU5HX09QVElPTicsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBzcGVjaWZ5IFwib3V0cHV0LmZpbGVcIiBvciBcIm91dHB1dC5kaXJcIiBmb3IgdGhlIGJ1aWxkLidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoZ2VuZXJhdGVkKS5tYXAoY2h1bmsgPT4gd3JpdGVPdXRwdXRGaWxlKGNodW5rLCBvdXRwdXRPcHRpb25zKSkpO1xuICAgICAgICAgICAgYXdhaXQgb3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnd3JpdGVCdW5kbGUnLCBbb3V0cHV0T3B0aW9ucywgZ2VuZXJhdGVkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU91dHB1dChnZW5lcmF0ZWQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0T3B0aW9uc0FuZFBsdWdpbkRyaXZlcihyYXdPdXRwdXRPcHRpb25zLCBpbnB1dFBsdWdpbkRyaXZlciwgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucykge1xuICAgIGlmICghcmF3T3V0cHV0T3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCByYXdQbHVnaW5zID0gZW5zdXJlQXJyYXkocmF3T3V0cHV0T3B0aW9ucy5wbHVnaW5zKTtcbiAgICBub3JtYWxpemVQbHVnaW5zKHJhd1BsdWdpbnMsIEFOT05ZTU9VU19PVVRQVVRfUExVR0lOX1BSRUZJWCk7XG4gICAgY29uc3Qgb3V0cHV0UGx1Z2luRHJpdmVyID0gaW5wdXRQbHVnaW5Ecml2ZXIuY3JlYXRlT3V0cHV0UGx1Z2luRHJpdmVyKHJhd1BsdWdpbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldE91dHB1dE9wdGlvbnMoaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucywgcmF3T3V0cHV0T3B0aW9ucywgb3V0cHV0UGx1Z2luRHJpdmVyKSxcbiAgICAgICAgb3V0cHV0UGx1Z2luRHJpdmVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dE9wdGlvbnMoaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucywgcmF3T3V0cHV0T3B0aW9ucywgb3V0cHV0UGx1Z2luRHJpdmVyKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU91dHB1dE9wdGlvbnMob3V0cHV0UGx1Z2luRHJpdmVyLmhvb2tSZWR1Y2VBcmcwU3luYygnb3V0cHV0T3B0aW9ucycsIFtyYXdPdXRwdXRPcHRpb25zLm91dHB1dCB8fCByYXdPdXRwdXRPcHRpb25zXSwgKG91dHB1dE9wdGlvbnMsIHJlc3VsdCkgPT4gcmVzdWx0IHx8IG91dHB1dE9wdGlvbnMsIHBsdWdpbkNvbnRleHQgPT4ge1xuICAgICAgICBjb25zdCBlbWl0RXJyb3IgPSAoKSA9PiBwbHVnaW5Db250ZXh0LmVycm9yKGVyckNhbm5vdEVtaXRGcm9tT3B0aW9uc0hvb2soKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0LFxuICAgICAgICAgICAgZW1pdEZpbGU6IGVtaXRFcnJvcixcbiAgICAgICAgICAgIHNldEFzc2V0U291cmNlOiBlbWl0RXJyb3JcbiAgICAgICAgfTtcbiAgICB9KSwgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVPdXRwdXQob3V0cHV0QnVuZGxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0OiBPYmplY3QudmFsdWVzKG91dHB1dEJ1bmRsZSkuZmlsdGVyKG91dHB1dEZpbGUgPT4gT2JqZWN0LmtleXMob3V0cHV0RmlsZSkubGVuZ3RoID4gMCkuc29ydCgob3V0cHV0RmlsZUEsIG91dHB1dEZpbGVCKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlVHlwZUEgPSBnZXRTb3J0aW5nRmlsZVR5cGUob3V0cHV0RmlsZUEpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVR5cGVCID0gZ2V0U29ydGluZ0ZpbGVUeXBlKG91dHB1dEZpbGVCKTtcbiAgICAgICAgICAgIGlmIChmaWxlVHlwZUEgPT09IGZpbGVUeXBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiBmaWxlVHlwZUEgPCBmaWxlVHlwZUIgPyAtMSA6IDE7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbnZhciBTb3J0aW5nRmlsZVR5cGU7XG4oZnVuY3Rpb24gKFNvcnRpbmdGaWxlVHlwZSkge1xuICAgIFNvcnRpbmdGaWxlVHlwZVtTb3J0aW5nRmlsZVR5cGVbXCJFTlRSWV9DSFVOS1wiXSA9IDBdID0gXCJFTlRSWV9DSFVOS1wiO1xuICAgIFNvcnRpbmdGaWxlVHlwZVtTb3J0aW5nRmlsZVR5cGVbXCJTRUNPTkRBUllfQ0hVTktcIl0gPSAxXSA9IFwiU0VDT05EQVJZX0NIVU5LXCI7XG4gICAgU29ydGluZ0ZpbGVUeXBlW1NvcnRpbmdGaWxlVHlwZVtcIkFTU0VUXCJdID0gMl0gPSBcIkFTU0VUXCI7XG59KShTb3J0aW5nRmlsZVR5cGUgfHwgKFNvcnRpbmdGaWxlVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTb3J0aW5nRmlsZVR5cGUoZmlsZSkge1xuICAgIGlmIChmaWxlLnR5cGUgPT09ICdhc3NldCcpIHtcbiAgICAgICAgcmV0dXJuIFNvcnRpbmdGaWxlVHlwZS5BU1NFVDtcbiAgICB9XG4gICAgaWYgKGZpbGUuaXNFbnRyeSkge1xuICAgICAgICByZXR1cm4gU29ydGluZ0ZpbGVUeXBlLkVOVFJZX0NIVU5LO1xuICAgIH1cbiAgICByZXR1cm4gU29ydGluZ0ZpbGVUeXBlLlNFQ09OREFSWV9DSFVOSztcbn1cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlT3V0cHV0RmlsZShvdXRwdXRGaWxlLCBvdXRwdXRPcHRpb25zKSB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSByZXNvbHZlKG91dHB1dE9wdGlvbnMuZGlyIHx8IGRpcm5hbWUob3V0cHV0T3B0aW9ucy5maWxlKSwgb3V0cHV0RmlsZS5maWxlTmFtZSk7XG4gICAgLy8gJ3JlY3Vyc2l2ZTogdHJ1ZScgZG9lcyBub3QgdGhyb3cgaWYgdGhlIGZvbGRlciBzdHJ1Y3R1cmUsIG9yIHBhcnRzIG9mIGl0LCBhbHJlYWR5IGV4aXN0XG4gICAgYXdhaXQgcHJvbWlzZXMubWtkaXIoZGlybmFtZShmaWxlTmFtZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGxldCB3cml0ZVNvdXJjZU1hcFByb21pc2U7XG4gICAgbGV0IHNvdXJjZTtcbiAgICBpZiAob3V0cHV0RmlsZS50eXBlID09PSAnYXNzZXQnKSB7XG4gICAgICAgIHNvdXJjZSA9IG91dHB1dEZpbGUuc291cmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc291cmNlID0gb3V0cHV0RmlsZS5jb2RlO1xuICAgICAgICBpZiAob3V0cHV0T3B0aW9ucy5zb3VyY2VtYXAgJiYgb3V0cHV0RmlsZS5tYXApIHtcbiAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICBpZiAob3V0cHV0T3B0aW9ucy5zb3VyY2VtYXAgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gb3V0cHV0RmlsZS5tYXAudG9VcmwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IGAke2Jhc2VuYW1lKG91dHB1dEZpbGUuZmlsZU5hbWUpfS5tYXBgO1xuICAgICAgICAgICAgICAgIHdyaXRlU291cmNlTWFwUHJvbWlzZSA9IHByb21pc2VzLndyaXRlRmlsZShgJHtmaWxlTmFtZX0ubWFwYCwgb3V0cHV0RmlsZS5tYXAudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0T3B0aW9ucy5zb3VyY2VtYXAgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc291cmNlICs9IGAvLyMgJHtTT1VSQ0VNQVBQSU5HX1VSTH09JHt1cmx9XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3Byb21pc2VzLndyaXRlRmlsZShmaWxlTmFtZSwgc291cmNlKSwgd3JpdGVTb3VyY2VNYXBQcm9taXNlXSk7XG59XG4vKipcbiAqIEF1eGlsaWFyeSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgcm9sbHVwIGNvbmZpZ3VyYXRpb25cbiAqIE1haW5seSB0byBmYWNpbGl0YXRlIElERSBjb2RlIHByb21wdHMsIGFmdGVyIGFsbCwgZXhwb3J0IGRlZmF1bHQgZG9lcyBub3QgcHJvbXB0LCBldmVuIGlmIHlvdSBhZGQgQHR5cGUgYW5ub3RhdGlvbnMsIGl0IGlzIG5vdCBhY2N1cmF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ29uZmlnKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuY2xhc3MgV2F0Y2hFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hd2FpdGVkSGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBBbGxvd3MgbW9yZSB0aGFuIDEwIGJ1bmRsZXMgdG8gYmUgd2F0Y2hlZCB3aXRob3V0XG4gICAgICAgIC8vIHNob3dpbmcgdGhlIGBNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmdgIHRvIHRoZSB1c2VyLlxuICAgICAgICB0aGlzLnNldE1heExpc3RlbmVycyhJbmZpbml0eSk7XG4gICAgfVxuICAgIC8vIFdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgUm9sbHVwXG4gICAgYXN5bmMgY2xvc2UoKSB7IH1cbiAgICBlbWl0QW5kQXdhaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuZ2V0SGFuZGxlcnMoZXZlbnQpLm1hcChoYW5kbGVyID0+IGhhbmRsZXIoLi4uYXJncykpKTtcbiAgICB9XG4gICAgb25DdXJyZW50QXdhaXRlZChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5nZXRIYW5kbGVycyhldmVudCkucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVBd2FpdGVkKCkge1xuICAgICAgICB0aGlzLmF3YWl0ZWRIYW5kbGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0SGFuZGxlcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXdhaXRlZEhhbmRsZXJzW2V2ZW50XSB8fCAodGhpcy5hd2FpdGVkSGFuZGxlcnNbZXZlbnRdID0gW10pO1xuICAgIH1cbn1cblxubGV0IGZzRXZlbnRzO1xubGV0IGZzRXZlbnRzSW1wb3J0RXJyb3I7XG5hc3luYyBmdW5jdGlvbiBsb2FkRnNFdmVudHMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgZGVmYXVsdDogZnNFdmVudHMgfSA9IGF3YWl0IGltcG9ydCgnZnNldmVudHMnKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZnNFdmVudHNJbXBvcnRFcnJvciA9IGVycjtcbiAgICB9XG59XG4vLyBBIGNhbGwgdG8gdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGluamVjdGVkIGludG8gdGhlIGNob2tpZGFyIGNvZGVcbmZ1bmN0aW9uIGdldEZzRXZlbnRzKCkge1xuICAgIGlmIChmc0V2ZW50c0ltcG9ydEVycm9yKVxuICAgICAgICB0aHJvdyBmc0V2ZW50c0ltcG9ydEVycm9yO1xuICAgIHJldHVybiBmc0V2ZW50cztcbn1cblxuY29uc3QgZnNldmVudHNJbXBvcnRlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGxvYWRGc0V2ZW50cyxcbiAgZ2V0RnNFdmVudHNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cbmZ1bmN0aW9uIHdhdGNoKGNvbmZpZ3MpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IFdhdGNoRW1pdHRlcigpO1xuICAgIGNvbnN0IGNvbmZpZ0FycmF5ID0gZW5zdXJlQXJyYXkoY29uZmlncyk7XG4gICAgY29uc3Qgd2F0Y2hDb25maWdzID0gY29uZmlnQXJyYXkuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcud2F0Y2ggIT09IGZhbHNlKTtcbiAgICBpZiAod2F0Y2hDb25maWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZXJyb3IoZXJySW52YWxpZE9wdGlvbignd2F0Y2gnLCAnd2F0Y2gnLCAndGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgY29uZmlnIHdoZXJlIFwid2F0Y2hcIiBpcyBub3Qgc2V0IHRvIFwiZmFsc2VcIicpKTtcbiAgICB9XG4gICAgbG9hZEZzRXZlbnRzKClcbiAgICAgICAgLnRoZW4oKCkgPT4gaW1wb3J0KCcuL3dhdGNoLmpzJykpXG4gICAgICAgIC50aGVuKCh7IFdhdGNoZXIgfSkgPT4gbmV3IFdhdGNoZXIod2F0Y2hDb25maWdzLCBlbWl0dGVyKSk7XG4gICAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUZpbHRlciwgZGVmYXVsdE9uV2FybiwgZGVmaW5lQ29uZmlnLCBlbnN1cmVBcnJheSwgZnNldmVudHNJbXBvcnRlciwgZ2VuZXJhdGVkQ29kZVByZXNldHMsIGdldEF1Z21lbnRlZE5hbWVzcGFjZSwgb2JqZWN0aWZ5T3B0aW9uLCBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cywgcGljb21hdGNoLCByb2xsdXAsIHJvbGx1cEludGVybmFsLCB0cmVlc2hha2VQcmVzZXRzLCB2ZXJzaW9uJDEgYXMgdmVyc2lvbiwgd2FyblVua25vd25PcHRpb25zLCB3YXRjaCB9O1xuIiwgIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtidWlsdGluTW9kdWxlc30gPSByZXF1aXJlKCdtb2R1bGUnKTtcblxuY29uc3QgaWdub3JlTGlzdCA9IFtcblx0J3N5cydcbl07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpXG5tb2R1bGUuZXhwb3J0cyA9IChidWlsdGluTW9kdWxlcyB8fCBPYmplY3Qua2V5cyhwcm9jZXNzLmJpbmRpbmcoJ25hdGl2ZXMnKSkpXG5cdC5maWx0ZXIoeCA9PiAhL15ffF4oaW50ZXJuYWx8djh8bm9kZS1pbnNwZWN0KVxcL3xcXC8vLnRlc3QoeCkgJiYgIWlnbm9yZUxpc3QuaW5jbHVkZXMoeCkpXG5cdC5zb3J0KCk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIiwgIlxuLy8gbm8gaWRlYSB3aGF0IHRoZXNlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZG8sXG4vLyBidXQgaSBleHRyYWN0ZWQgaXQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20veWFob28vanMtbW9kdWxlLWZvcm1hdHMvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDE4XG52YXIgRVM2SW1wb3J0RXhwb3J0UmVnRXhwID0gLyg/Ol5cXHMqfFt9e1xcKFxcKTssXFxuXVxccyopKGltcG9ydFxccytbJ1wiXXwoaW1wb3J0fG1vZHVsZSlcXHMrW15cIidcXChcXClcXG47XStcXHMrZnJvbVxccytbJ1wiXXxleHBvcnRcXHMrKFxcKnxcXHt8ZGVmYXVsdHxmdW5jdGlvbnx2YXJ8Y29uc3R8bGV0fFtfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qKSkvO1xuXG52YXIgRVM2QWxpYXNSZWdFeHAgPSAvKD86Xlxccyp8W317XFwoXFwpOyxcXG5dXFxzKikoZXhwb3J0XFxzKlxcKlxccypmcm9tXFxzKig/OicoW14nXSspJ3xcIihbXlwiXSspXCIpKS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNhdWNlKSB7XG4gIHJldHVybiBFUzZJbXBvcnRFeHBvcnRSZWdFeHAudGVzdChzYXVjZSlcbiAgICB8fCBFUzZBbGlhc1JlZ0V4cC50ZXN0KHNhdWNlKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9vcy1ob21lZGlyL2Jsb2IvMTFlMDg5ZjQ3NTRkYjM4YmI1MzVlNWE4NDE2MzIwYzQ0NDZlOGNmZC9pbmRleC5qc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9zLmhvbWVkaXIgfHwgZnVuY3Rpb24gaG9tZWRpcigpIHtcbiAgICB2YXIgaG9tZSA9IHByb2Nlc3MuZW52LkhPTUU7XG4gICAgdmFyIHVzZXIgPSBwcm9jZXNzLmVudi5MT0dOQU1FIHx8IHByb2Nlc3MuZW52LlVTRVIgfHwgcHJvY2Vzcy5lbnYuTE5BTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUk5BTUU7XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVVNFUlBST0ZJTEUgfHwgcHJvY2Vzcy5lbnYuSE9NRURSSVZFICsgcHJvY2Vzcy5lbnYuSE9NRVBBVEggfHwgaG9tZSB8fCBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICByZXR1cm4gaG9tZSB8fCAodXNlciA/ICcvVXNlcnMvJyArIHVzZXIgOiBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgICAgICByZXR1cm4gaG9tZSB8fCAocHJvY2Vzcy5nZXR1aWQoKSA9PT0gMCA/ICcvcm9vdCcgOiAodXNlciA/ICcvaG9tZS8nICsgdXNlciA6IG51bGwpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICB9XG5cbiAgICByZXR1cm4gaG9tZSB8fCBudWxsO1xufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpXG4gICAgdmFyIG9yaWdQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7IHJldHVybiBzdGFjazsgfTtcbiAgICB2YXIgc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZ1ByZXBhcmVTdGFja1RyYWNlO1xuICAgIHJldHVybiBzdGFja1syXS5nZXRGaWxlTmFtZSgpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuXG4vLyBSZWdleCB0byBzcGxpdCBhIHdpbmRvd3MgcGF0aCBpbnRvIGludG8gW2Rpciwgcm9vdCwgYmFzZW5hbWUsIG5hbWUsIGV4dF1cbnZhciBzcGxpdFdpbmRvd3NSZSA9XG4gICAgL14oKCg/OlthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXStbXlxcXFxcXC9dKyk/W1xcXFxcXC9dPykoPzpbXlxcXFxcXC9dKltcXFxcXFwvXSkqKSgoXFwuezEsMn18W15cXFxcXFwvXSs/fCkoXFwuW14uXFwvXFxcXF0qfCkpW1xcXFxcXC9dKiQvO1xuXG52YXIgd2luMzIgPSB7fTtcblxuZnVuY3Rpb24gd2luMzJTcGxpdFBhdGgoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0V2luZG93c1JlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufVxuXG53aW4zMi5wYXJzZSA9IGZ1bmN0aW9uKHBhdGhTdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiUGFyYW1ldGVyICdwYXRoU3RyaW5nJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgcGF0aFN0cmluZ1xuICAgICk7XG4gIH1cbiAgdmFyIGFsbFBhcnRzID0gd2luMzJTcGxpdFBhdGgocGF0aFN0cmluZyk7XG4gIGlmICghYWxsUGFydHMgfHwgYWxsUGFydHMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGF0aCAnXCIgKyBwYXRoU3RyaW5nICsgXCInXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcm9vdDogYWxsUGFydHNbMV0sXG4gICAgZGlyOiBhbGxQYXJ0c1swXSA9PT0gYWxsUGFydHNbMV0gPyBhbGxQYXJ0c1swXSA6IGFsbFBhcnRzWzBdLnNsaWNlKDAsIC0xKSxcbiAgICBiYXNlOiBhbGxQYXJ0c1syXSxcbiAgICBleHQ6IGFsbFBhcnRzWzRdLFxuICAgIG5hbWU6IGFsbFBhcnRzWzNdXG4gIH07XG59O1xuXG5cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtkaXIsIHJvb3QsIGJhc2VuYW1lLCBuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKChcXC8/KSg/OlteXFwvXSpcXC8pKikoKFxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSlbXFwvXSokLztcbnZhciBwb3NpeCA9IHt9O1xuXG5cbmZ1bmN0aW9uIHBvc2l4U3BsaXRQYXRoKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn1cblxuXG5wb3NpeC5wYXJzZSA9IGZ1bmN0aW9uKHBhdGhTdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiUGFyYW1ldGVyICdwYXRoU3RyaW5nJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgcGF0aFN0cmluZ1xuICAgICk7XG4gIH1cbiAgdmFyIGFsbFBhcnRzID0gcG9zaXhTcGxpdFBhdGgocGF0aFN0cmluZyk7XG4gIGlmICghYWxsUGFydHMgfHwgYWxsUGFydHMubGVuZ3RoICE9PSA1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGF0aCAnXCIgKyBwYXRoU3RyaW5nICsgXCInXCIpO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHJvb3Q6IGFsbFBhcnRzWzFdLFxuICAgIGRpcjogYWxsUGFydHNbMF0uc2xpY2UoMCwgLTEpLFxuICAgIGJhc2U6IGFsbFBhcnRzWzJdLFxuICAgIGV4dDogYWxsUGFydHNbNF0sXG4gICAgbmFtZTogYWxsUGFydHNbM10sXG4gIH07XG59O1xuXG5cbmlmIChpc1dpbmRvd3MpXG4gIG1vZHVsZS5leHBvcnRzID0gd2luMzIucGFyc2U7XG5lbHNlIC8qIHBvc2l4ICovXG4gIG1vZHVsZS5leHBvcnRzID0gcG9zaXgucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzLnBvc2l4ID0gcG9zaXgucGFyc2U7XG5tb2R1bGUuZXhwb3J0cy53aW4zMiA9IHdpbjMyLnBhcnNlO1xuIiwgInZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHBhcnNlID0gcGF0aC5wYXJzZSB8fCByZXF1aXJlKCdwYXRoLXBhcnNlJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblxudmFyIGdldE5vZGVNb2R1bGVzRGlycyA9IGZ1bmN0aW9uIGdldE5vZGVNb2R1bGVzRGlycyhhYnNvbHV0ZVN0YXJ0LCBtb2R1bGVzKSB7XG4gICAgdmFyIHByZWZpeCA9ICcvJztcbiAgICBpZiAoKC9eKFtBLVphLXpdOikvKS50ZXN0KGFic29sdXRlU3RhcnQpKSB7XG4gICAgICAgIHByZWZpeCA9ICcnO1xuICAgIH0gZWxzZSBpZiAoKC9eXFxcXFxcXFwvKS50ZXN0KGFic29sdXRlU3RhcnQpKSB7XG4gICAgICAgIHByZWZpeCA9ICdcXFxcXFxcXCc7XG4gICAgfVxuXG4gICAgdmFyIHBhdGhzID0gW2Fic29sdXRlU3RhcnRdO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZShhYnNvbHV0ZVN0YXJ0KTtcbiAgICB3aGlsZSAocGFyc2VkLmRpciAhPT0gcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXJzZWQuZGlyKTtcbiAgICAgICAgcGFyc2VkID0gcGFyc2UocGFyc2VkLmRpcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzLnJlZHVjZShmdW5jdGlvbiAoZGlycywgYVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGRpcnMuY29uY2F0KG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGVEaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnJlc29sdmUocHJlZml4LCBhUGF0aCwgbW9kdWxlRGlyKTtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9kZU1vZHVsZXNQYXRocyhzdGFydCwgb3B0cywgcmVxdWVzdCkge1xuICAgIHZhciBtb2R1bGVzID0gb3B0cyAmJiBvcHRzLm1vZHVsZURpcmVjdG9yeVxuICAgICAgICA/IFtdLmNvbmNhdChvcHRzLm1vZHVsZURpcmVjdG9yeSlcbiAgICAgICAgOiBbJ25vZGVfbW9kdWxlcyddO1xuXG4gICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMucGF0aHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMucGF0aHMoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXROb2RlTW9kdWxlc0RpcnMoc3RhcnQsIG1vZHVsZXMpOyB9LFxuICAgICAgICAgICAgb3B0c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBkaXJzID0gZ2V0Tm9kZU1vZHVsZXNEaXJzKHN0YXJ0LCBtb2R1bGVzKTtcbiAgICByZXR1cm4gb3B0cyAmJiBvcHRzLnBhdGhzID8gZGlycy5jb25jYXQob3B0cy5wYXRocykgOiBkaXJzO1xufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4LCBvcHRzKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBmaWxlIGlzIHB1cnBvc2VmdWxseSBhIHBhc3N0aHJvdWdoLiBJdCdzIGV4cGVjdGVkIHRoYXQgdGhpcmQtcGFydHlcbiAgICAgKiBlbnZpcm9ubWVudHMgd2lsbCBvdmVycmlkZSBpdCBhdCBydW50aW1lIGluIG9yZGVyIHRvIGluamVjdCBzcGVjaWFsIGxvZ2ljXG4gICAgICogaW50byBgcmVzb2x2ZWAgKGJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucykuIE9uZSBzdWNoIGV4YW1wbGUgaXMgdGhlIFBuUFxuICAgICAqIGNvZGUgcGF0aCBpbiBZYXJuLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIG9wdHMgfHwge307XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSByZXF1aXJlKCdoYXMnKTtcblxuZnVuY3Rpb24gc3BlY2lmaWVySW5jbHVkZWQoY3VycmVudCwgc3BlY2lmaWVyKSB7XG5cdHZhciBub2RlUGFydHMgPSBjdXJyZW50LnNwbGl0KCcuJyk7XG5cdHZhciBwYXJ0cyA9IHNwZWNpZmllci5zcGxpdCgnICcpO1xuXHR2YXIgb3AgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMF0gOiAnPSc7XG5cdHZhciB2ZXJzaW9uUGFydHMgPSAocGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdIDogcGFydHNbMF0pLnNwbGl0KCcuJyk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcblx0XHR2YXIgY3VyID0gcGFyc2VJbnQobm9kZVBhcnRzW2ldIHx8IDAsIDEwKTtcblx0XHR2YXIgdmVyID0gcGFyc2VJbnQodmVyc2lvblBhcnRzW2ldIHx8IDAsIDEwKTtcblx0XHRpZiAoY3VyID09PSB2ZXIpIHtcblx0XHRcdGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuXHRcdH1cblx0XHRpZiAob3AgPT09ICc8Jykge1xuXHRcdFx0cmV0dXJuIGN1ciA8IHZlcjtcblx0XHR9XG5cdFx0aWYgKG9wID09PSAnPj0nKSB7XG5cdFx0XHRyZXR1cm4gY3VyID49IHZlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiBvcCA9PT0gJz49Jztcbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1JhbmdlKGN1cnJlbnQsIHJhbmdlKSB7XG5cdHZhciBzcGVjaWZpZXJzID0gcmFuZ2Uuc3BsaXQoLyA/JiYgPy8pO1xuXHRpZiAoc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpZXJzLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKCFzcGVjaWZpZXJJbmNsdWRlZChjdXJyZW50LCBzcGVjaWZpZXJzW2ldKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmVyc2lvbkluY2x1ZGVkKG5vZGVWZXJzaW9uLCBzcGVjaWZpZXJWYWx1ZSkge1xuXHRpZiAodHlwZW9mIHNwZWNpZmllclZhbHVlID09PSAnYm9vbGVhbicpIHtcblx0XHRyZXR1cm4gc3BlY2lmaWVyVmFsdWU7XG5cdH1cblxuXHR2YXIgY3VycmVudCA9IHR5cGVvZiBub2RlVmVyc2lvbiA9PT0gJ3VuZGVmaW5lZCdcblx0XHQ/IHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlXG5cdFx0OiBub2RlVmVyc2lvbjtcblxuXHRpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcih0eXBlb2Ygbm9kZVZlcnNpb24gPT09ICd1bmRlZmluZWQnID8gJ1VuYWJsZSB0byBkZXRlcm1pbmUgY3VycmVudCBub2RlIHZlcnNpb24nIDogJ0lmIHByb3ZpZGVkLCBhIHZhbGlkIG5vZGUgdmVyc2lvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cblx0aWYgKHNwZWNpZmllclZhbHVlICYmIHR5cGVvZiBzcGVjaWZpZXJWYWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmllclZhbHVlLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRpZiAobWF0Y2hlc1JhbmdlKGN1cnJlbnQsIHNwZWNpZmllclZhbHVlW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiBtYXRjaGVzUmFuZ2UoY3VycmVudCwgc3BlY2lmaWVyVmFsdWUpO1xufVxuXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vY29yZS5qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDb3JlKHgsIG5vZGVWZXJzaW9uKSB7XG5cdHJldHVybiBoYXMoZGF0YSwgeCkgJiYgdmVyc2lvbkluY2x1ZGVkKG5vZGVWZXJzaW9uLCBkYXRhW3hdKTtcbn07XG4iLCAidmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBnZXRIb21lZGlyID0gcmVxdWlyZSgnLi9ob21lZGlyJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBjYWxsZXIgPSByZXF1aXJlKCcuL2NhbGxlcicpO1xudmFyIG5vZGVNb2R1bGVzUGF0aHMgPSByZXF1aXJlKCcuL25vZGUtbW9kdWxlcy1wYXRocycpO1xudmFyIG5vcm1hbGl6ZU9wdGlvbnMgPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1vcHRpb25zJyk7XG52YXIgaXNDb3JlID0gcmVxdWlyZSgnaXMtY29yZS1tb2R1bGUnKTtcblxudmFyIHJlYWxwYXRoRlMgPSBmcy5yZWFscGF0aCAmJiB0eXBlb2YgZnMucmVhbHBhdGgubmF0aXZlID09PSAnZnVuY3Rpb24nID8gZnMucmVhbHBhdGgubmF0aXZlIDogZnMucmVhbHBhdGg7XG5cbnZhciBob21lZGlyID0gZ2V0SG9tZWRpcigpO1xudmFyIGRlZmF1bHRQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBwYXRoLmpvaW4oaG9tZWRpciwgJy5ub2RlX21vZHVsZXMnKSxcbiAgICAgICAgcGF0aC5qb2luKGhvbWVkaXIsICcubm9kZV9saWJyYXJpZXMnKVxuICAgIF07XG59O1xuXG52YXIgZGVmYXVsdElzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZShmaWxlLCBjYikge1xuICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHN0YXQuaXNGaWxlKCkgfHwgc3RhdC5pc0ZJRk8oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJyB8fCBlcnIuY29kZSA9PT0gJ0VOT1RESVInKSByZXR1cm4gY2IobnVsbCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9KTtcbn07XG5cbnZhciBkZWZhdWx0SXNEaXIgPSBmdW5jdGlvbiBpc0RpcmVjdG9yeShkaXIsIGNiKSB7XG4gICAgZnMuc3RhdChkaXIsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBzdGF0LmlzRGlyZWN0b3J5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZXJyLmNvZGUgPT09ICdFTk9URElSJykgcmV0dXJuIGNiKG51bGwsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfSk7XG59O1xuXG52YXIgZGVmYXVsdFJlYWxwYXRoID0gZnVuY3Rpb24gcmVhbHBhdGgoeCwgY2IpIHtcbiAgICByZWFscGF0aEZTKHgsIGZ1bmN0aW9uIChyZWFscGF0aEVyciwgcmVhbFBhdGgpIHtcbiAgICAgICAgaWYgKHJlYWxwYXRoRXJyICYmIHJlYWxwYXRoRXJyLmNvZGUgIT09ICdFTk9FTlQnKSBjYihyZWFscGF0aEVycik7XG4gICAgICAgIGVsc2UgY2IobnVsbCwgcmVhbHBhdGhFcnIgPyB4IDogcmVhbFBhdGgpO1xuICAgIH0pO1xufTtcblxudmFyIG1heWJlUmVhbHBhdGggPSBmdW5jdGlvbiBtYXliZVJlYWxwYXRoKHJlYWxwYXRoLCB4LCBvcHRzLCBjYikge1xuICAgIGlmIChvcHRzICYmIG9wdHMucHJlc2VydmVTeW1saW5rcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVhbHBhdGgoeCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIHgpO1xuICAgIH1cbn07XG5cbnZhciBkZWZhdWx0UmVhZFBhY2thZ2UgPSBmdW5jdGlvbiBkZWZhdWx0UmVhZFBhY2thZ2UocmVhZEZpbGUsIHBrZ2ZpbGUsIGNiKSB7XG4gICAgcmVhZEZpbGUocGtnZmlsZSwgZnVuY3Rpb24gKHJlYWRGaWxlRXJyLCBib2R5KSB7XG4gICAgICAgIGlmIChyZWFkRmlsZUVycikgY2IocmVhZEZpbGVFcnIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHBrZyA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgcGtnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGpzb25FcnIpIHtcbiAgICAgICAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxudmFyIGdldFBhY2thZ2VDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0UGFja2FnZUNhbmRpZGF0ZXMoeCwgc3RhcnQsIG9wdHMpIHtcbiAgICB2YXIgZGlycyA9IG5vZGVNb2R1bGVzUGF0aHMoc3RhcnQsIG9wdHMsIHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaXJzW2ldID0gcGF0aC5qb2luKGRpcnNbaV0sIHgpO1xuICAgIH1cbiAgICByZXR1cm4gZGlycztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZSh4LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgIHZhciBvcHRzID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMoeCwgb3B0cyk7XG5cbiAgICB2YXIgaXNGaWxlID0gb3B0cy5pc0ZpbGUgfHwgZGVmYXVsdElzRmlsZTtcbiAgICB2YXIgaXNEaXJlY3RvcnkgPSBvcHRzLmlzRGlyZWN0b3J5IHx8IGRlZmF1bHRJc0RpcjtcbiAgICB2YXIgcmVhZEZpbGUgPSBvcHRzLnJlYWRGaWxlIHx8IGZzLnJlYWRGaWxlO1xuICAgIHZhciByZWFscGF0aCA9IG9wdHMucmVhbHBhdGggfHwgZGVmYXVsdFJlYWxwYXRoO1xuICAgIHZhciByZWFkUGFja2FnZSA9IG9wdHMucmVhZFBhY2thZ2UgfHwgZGVmYXVsdFJlYWRQYWNrYWdlO1xuICAgIGlmIChvcHRzLnJlYWRGaWxlICYmIG9wdHMucmVhZFBhY2thZ2UpIHtcbiAgICAgICAgdmFyIGNvbmZsaWN0RXJyID0gbmV3IFR5cGVFcnJvcignYHJlYWRGaWxlYCBhbmQgYHJlYWRQYWNrYWdlYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYihjb25mbGljdEVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcGFja2FnZUl0ZXJhdG9yID0gb3B0cy5wYWNrYWdlSXRlcmF0b3I7XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyB8fCBbJy5qcyddO1xuICAgIHZhciBpbmNsdWRlQ29yZU1vZHVsZXMgPSBvcHRzLmluY2x1ZGVDb3JlTW9kdWxlcyAhPT0gZmFsc2U7XG4gICAgdmFyIGJhc2VkaXIgPSBvcHRzLmJhc2VkaXIgfHwgcGF0aC5kaXJuYW1lKGNhbGxlcigpKTtcbiAgICB2YXIgcGFyZW50ID0gb3B0cy5maWxlbmFtZSB8fCBiYXNlZGlyO1xuXG4gICAgb3B0cy5wYXRocyA9IG9wdHMucGF0aHMgfHwgZGVmYXVsdFBhdGhzKCk7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCBgYmFzZWRpcmAgaXMgYW4gYWJzb2x1dGUgcGF0aCBhdCB0aGlzIHBvaW50LCByZXNvbHZpbmcgYWdhaW5zdCB0aGUgcHJvY2VzcycgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgIHZhciBhYnNvbHV0ZVN0YXJ0ID0gcGF0aC5yZXNvbHZlKGJhc2VkaXIpO1xuXG4gICAgbWF5YmVSZWFscGF0aChcbiAgICAgICAgcmVhbHBhdGgsXG4gICAgICAgIGFic29sdXRlU3RhcnQsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlYWxTdGFydCkge1xuICAgICAgICAgICAgaWYgKGVycikgY2IoZXJyKTtcbiAgICAgICAgICAgIGVsc2UgaW5pdChyZWFsU3RhcnQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciByZXM7XG4gICAgZnVuY3Rpb24gaW5pdChiYXNlZGlyKSB7XG4gICAgICAgIGlmICgoL14oPzpcXC5cXC4/KD86XFwvfCQpfFxcL3woW0EtWmEtel06KT9bL1xcXFxdKS8pLnRlc3QoeCkpIHtcbiAgICAgICAgICAgIHJlcyA9IHBhdGgucmVzb2x2ZShiYXNlZGlyLCB4KTtcbiAgICAgICAgICAgIGlmICh4ID09PSAnLicgfHwgeCA9PT0gJy4uJyB8fCB4LnNsaWNlKC0xKSA9PT0gJy8nKSByZXMgKz0gJy8nO1xuICAgICAgICAgICAgaWYgKCgvXFwvJC8pLnRlc3QoeCkgJiYgcmVzID09PSBiYXNlZGlyKSB7XG4gICAgICAgICAgICAgICAgbG9hZEFzRGlyZWN0b3J5KHJlcywgb3B0cy5wYWNrYWdlLCBvbmZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGxvYWRBc0ZpbGUocmVzLCBvcHRzLnBhY2thZ2UsIG9uZmlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZUNvcmVNb2R1bGVzICYmIGlzQ29yZSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHgpO1xuICAgICAgICB9IGVsc2UgbG9hZE5vZGVNb2R1bGVzKHgsIGJhc2VkaXIsIGZ1bmN0aW9uIChlcnIsIG4sIHBrZykge1xuICAgICAgICAgICAgaWYgKGVycikgY2IoZXJyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVSZWFscGF0aChyZWFscGF0aCwgbiwgb3B0cywgZnVuY3Rpb24gKGVyciwgcmVhbE4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlYWxOLCBwa2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGVFcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyB4ICsgXCInIGZyb20gJ1wiICsgcGFyZW50ICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIG1vZHVsZUVycm9yLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG4gICAgICAgICAgICAgICAgY2IobW9kdWxlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmZpbGUoZXJyLCBtLCBwa2cpIHtcbiAgICAgICAgaWYgKGVycikgY2IoZXJyKTtcbiAgICAgICAgZWxzZSBpZiAobSkgY2IobnVsbCwgbSwgcGtnKTtcbiAgICAgICAgZWxzZSBsb2FkQXNEaXJlY3RvcnkocmVzLCBmdW5jdGlvbiAoZXJyLCBkLCBwa2cpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGNiKGVycik7XG4gICAgICAgICAgICBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVSZWFscGF0aChyZWFscGF0aCwgZCwgb3B0cywgZnVuY3Rpb24gKGVyciwgcmVhbEQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlYWxELCBwa2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGVFcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyB4ICsgXCInIGZyb20gJ1wiICsgcGFyZW50ICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIG1vZHVsZUVycm9yLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG4gICAgICAgICAgICAgICAgY2IobW9kdWxlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQXNGaWxlKHgsIHRoZVBhY2thZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBsb2FkQXNGaWxlUGFja2FnZSA9IHRoZVBhY2thZ2U7XG4gICAgICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGxvYWRBc0ZpbGVQYWNrYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGxvYWRBc0ZpbGVQYWNrYWdlO1xuICAgICAgICAgICAgbG9hZEFzRmlsZVBhY2thZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXh0cyA9IFsnJ10uY29uY2F0KGV4dGVuc2lvbnMpO1xuICAgICAgICBsb2FkKGV4dHMsIHgsIGxvYWRBc0ZpbGVQYWNrYWdlKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkKGV4dHMsIHgsIGxvYWRQYWNrYWdlKSB7XG4gICAgICAgICAgICBpZiAoZXh0cy5sZW5ndGggPT09IDApIHJldHVybiBjYihudWxsLCB1bmRlZmluZWQsIGxvYWRQYWNrYWdlKTtcbiAgICAgICAgICAgIHZhciBmaWxlID0geCArIGV4dHNbMF07XG5cbiAgICAgICAgICAgIHZhciBwa2cgPSBsb2FkUGFja2FnZTtcbiAgICAgICAgICAgIGlmIChwa2cpIG9ucGtnKG51bGwsIHBrZyk7XG4gICAgICAgICAgICBlbHNlIGxvYWRwa2cocGF0aC5kaXJuYW1lKGZpbGUpLCBvbnBrZyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9ucGtnKGVyciwgcGtnXywgZGlyKSB7XG4gICAgICAgICAgICAgICAgcGtnID0gcGtnXztcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyICYmIHBrZyAmJiBvcHRzLnBhdGhGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJmaWxlID0gcGF0aC5yZWxhdGl2ZShkaXIsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsID0gcmZpbGUuc2xpY2UoMCwgcmZpbGUubGVuZ3RoIC0gZXh0c1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG9wdHMucGF0aEZpbHRlcihwa2csIHgsIHJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyKSByZXR1cm4gbG9hZChcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnJ10uY29uY2F0KGV4dGVuc2lvbnMuc2xpY2UoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnJlc29sdmUoZGlyLCByKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc0ZpbGUoZmlsZSwgb25leCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbmV4KGVyciwgZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoZXgpIHJldHVybiBjYihudWxsLCBmaWxlLCBwa2cpO1xuICAgICAgICAgICAgICAgIGxvYWQoZXh0cy5zbGljZSgxKSwgeCwgcGtnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRwa2coZGlyLCBjYikge1xuICAgICAgICBpZiAoZGlyID09PSAnJyB8fCBkaXIgPT09ICcvJykgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAoL15cXHc6Wy9cXFxcXSokLykudGVzdChkaXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0qJC8pLnRlc3QoZGlyKSkgcmV0dXJuIGNiKG51bGwpO1xuXG4gICAgICAgIG1heWJlUmVhbHBhdGgocmVhbHBhdGgsIGRpciwgb3B0cywgZnVuY3Rpb24gKHVud3JhcEVyciwgcGtnZGlyKSB7XG4gICAgICAgICAgICBpZiAodW53cmFwRXJyKSByZXR1cm4gbG9hZHBrZyhwYXRoLmRpcm5hbWUoZGlyKSwgY2IpO1xuICAgICAgICAgICAgdmFyIHBrZ2ZpbGUgPSBwYXRoLmpvaW4ocGtnZGlyLCAncGFja2FnZS5qc29uJyk7XG4gICAgICAgICAgICBpc0ZpbGUocGtnZmlsZSwgZnVuY3Rpb24gKGVyciwgZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBvbiBlcnIsIGV4IGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKCFleCkgcmV0dXJuIGxvYWRwa2cocGF0aC5kaXJuYW1lKGRpciksIGNiKTtcblxuICAgICAgICAgICAgICAgIHJlYWRQYWNrYWdlKHJlYWRGaWxlLCBwa2dmaWxlLCBmdW5jdGlvbiAoZXJyLCBwa2dQYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBjYihlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwa2cgPSBwa2dQYXJhbTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGtnICYmIG9wdHMucGFja2FnZUZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnID0gb3B0cy5wYWNrYWdlRmlsdGVyKHBrZywgcGtnZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcGtnLCBkaXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBc0RpcmVjdG9yeSh4LCBsb2FkQXNEaXJlY3RvcnlQYWNrYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgdmFyIGZwa2cgPSBsb2FkQXNEaXJlY3RvcnlQYWNrYWdlO1xuICAgICAgICBpZiAodHlwZW9mIGZwa2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZnBrZztcbiAgICAgICAgICAgIGZwa2cgPSBvcHRzLnBhY2thZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBtYXliZVJlYWxwYXRoKHJlYWxwYXRoLCB4LCBvcHRzLCBmdW5jdGlvbiAodW53cmFwRXJyLCBwa2dkaXIpIHtcbiAgICAgICAgICAgIGlmICh1bndyYXBFcnIpIHJldHVybiBjYih1bndyYXBFcnIpO1xuICAgICAgICAgICAgdmFyIHBrZ2ZpbGUgPSBwYXRoLmpvaW4ocGtnZGlyLCAncGFja2FnZS5qc29uJyk7XG4gICAgICAgICAgICBpc0ZpbGUocGtnZmlsZSwgZnVuY3Rpb24gKGVyciwgZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4KSByZXR1cm4gbG9hZEFzRmlsZShwYXRoLmpvaW4oeCwgJ2luZGV4JyksIGZwa2csIGNiKTtcblxuICAgICAgICAgICAgICAgIHJlYWRQYWNrYWdlKHJlYWRGaWxlLCBwa2dmaWxlLCBmdW5jdGlvbiAoZXJyLCBwa2dQYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGtnID0gcGtnUGFyYW07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBrZyAmJiBvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBrZyA9IG9wdHMucGFja2FnZUZpbHRlcihwa2csIHBrZ2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBrZyAmJiBwa2cubWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwa2cubWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFpbkVycm9yID0gbmV3IFR5cGVFcnJvcigncGFja2FnZSBcdTIwMUMnICsgcGtnLm5hbWUgKyAnXHUyMDFEIGBtYWluYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkVycm9yLmNvZGUgPSAnSU5WQUxJRF9QQUNLQUdFX01BSU4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihtYWluRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBrZy5tYWluID09PSAnLicgfHwgcGtnLm1haW4gPT09ICcuLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa2cubWFpbiA9ICdpbmRleCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkQXNGaWxlKHBhdGgucmVzb2x2ZSh4LCBwa2cubWFpbiksIHBrZywgZnVuY3Rpb24gKGVyciwgbSwgcGtnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHJldHVybiBjYihudWxsLCBtLCBwa2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGtnKSByZXR1cm4gbG9hZEFzRmlsZShwYXRoLmpvaW4oeCwgJ2luZGV4JyksIHBrZywgY2IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IHBhdGgucmVzb2x2ZSh4LCBwa2cubWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEFzRGlyZWN0b3J5KGRpciwgcGtnLCBmdW5jdGlvbiAoZXJyLCBuLCBwa2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuKSByZXR1cm4gY2IobnVsbCwgbiwgcGtnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEFzRmlsZShwYXRoLmpvaW4oeCwgJ2luZGV4JyksIHBrZywgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsb2FkQXNGaWxlKHBhdGguam9pbih4LCAnL2luZGV4JyksIHBrZywgY2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NEaXJzKGNiLCBkaXJzKSB7XG4gICAgICAgIGlmIChkaXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNiKG51bGwsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBkaXIgPSBkaXJzWzBdO1xuXG4gICAgICAgIGlzRGlyZWN0b3J5KHBhdGguZGlybmFtZShkaXIpLCBpc2Rpcik7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNkaXIoZXJyLCBpc2Rpcikge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICBpZiAoIWlzZGlyKSByZXR1cm4gcHJvY2Vzc0RpcnMoY2IsIGRpcnMuc2xpY2UoMSkpO1xuICAgICAgICAgICAgbG9hZEFzRmlsZShkaXIsIG9wdHMucGFja2FnZSwgb25maWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uZmlsZShlcnIsIG0sIHBrZykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICBpZiAobSkgcmV0dXJuIGNiKG51bGwsIG0sIHBrZyk7XG4gICAgICAgICAgICBsb2FkQXNEaXJlY3RvcnkoZGlyLCBvcHRzLnBhY2thZ2UsIG9uZGlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uZGlyKGVyciwgbiwgcGtnKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgIGlmIChuKSByZXR1cm4gY2IobnVsbCwgbiwgcGtnKTtcbiAgICAgICAgICAgIHByb2Nlc3NEaXJzKGNiLCBkaXJzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkTm9kZU1vZHVsZXMoeCwgc3RhcnQsIGNiKSB7XG4gICAgICAgIHZhciB0aHVuayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldFBhY2thZ2VDYW5kaWRhdGVzKHgsIHN0YXJ0LCBvcHRzKTsgfTtcbiAgICAgICAgcHJvY2Vzc0RpcnMoXG4gICAgICAgICAgICBjYixcbiAgICAgICAgICAgIHBhY2thZ2VJdGVyYXRvciA/IHBhY2thZ2VJdGVyYXRvcih4LCBzdGFydCwgdGh1bmssIG9wdHMpIDogdGh1bmsoKVxuICAgICAgICApO1xuICAgIH1cbn07XG4iLCAidmFyIGN1cnJlbnQgPSAocHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJykpIHx8IFtdO1xuXG5mdW5jdGlvbiBzcGVjaWZpZXJJbmNsdWRlZChzcGVjaWZpZXIpIHtcbiAgICB2YXIgcGFydHMgPSBzcGVjaWZpZXIuc3BsaXQoJyAnKTtcbiAgICB2YXIgb3AgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMF0gOiAnPSc7XG4gICAgdmFyIHZlcnNpb25QYXJ0cyA9IChwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0gOiBwYXJ0c1swXSkuc3BsaXQoJy4nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgIHZhciBjdXIgPSBwYXJzZUludChjdXJyZW50W2ldIHx8IDAsIDEwKTtcbiAgICAgICAgdmFyIHZlciA9IHBhcnNlSW50KHZlcnNpb25QYXJ0c1tpXSB8fCAwLCAxMCk7XG4gICAgICAgIGlmIChjdXIgPT09IHZlcikge1xuICAgICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wID09PSAnPCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXIgPCB2ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT09ICc+PScpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXIgPj0gdmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9wID09PSAnPj0nO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgc3BlY2lmaWVycyA9IHJhbmdlLnNwbGl0KC8gPyYmID8vKTtcbiAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghc3BlY2lmaWVySW5jbHVkZWQoc3BlY2lmaWVyc1tpXSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2ZXJzaW9uSW5jbHVkZWQoc3BlY2lmaWVyVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllclZhbHVlID09PSAnYm9vbGVhbicpIHsgcmV0dXJuIHNwZWNpZmllclZhbHVlOyB9XG4gICAgaWYgKHNwZWNpZmllclZhbHVlICYmIHR5cGVvZiBzcGVjaWZpZXJWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjaWZpZXJWYWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNSYW5nZShzcGVjaWZpZXJWYWx1ZVtpXSkpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzUmFuZ2Uoc3BlY2lmaWVyVmFsdWUpO1xufVxuXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vY29yZS5qc29uJyk7XG5cbnZhciBjb3JlID0ge307XG5mb3IgKHZhciBtb2QgaW4gZGF0YSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBtb2QpKSB7XG4gICAgICAgIGNvcmVbbW9kXSA9IHZlcnNpb25JbmNsdWRlZChkYXRhW21vZF0pO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY29yZTtcbiIsICJ2YXIgaXNDb3JlTW9kdWxlID0gcmVxdWlyZSgnaXMtY29yZS1tb2R1bGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NvcmUoeCkge1xuICAgIHJldHVybiBpc0NvcmVNb2R1bGUoeCk7XG59O1xuIiwgInZhciBpc0NvcmUgPSByZXF1aXJlKCdpcy1jb3JlLW1vZHVsZScpO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGdldEhvbWVkaXIgPSByZXF1aXJlKCcuL2hvbWVkaXInKTtcbnZhciBjYWxsZXIgPSByZXF1aXJlKCcuL2NhbGxlcicpO1xudmFyIG5vZGVNb2R1bGVzUGF0aHMgPSByZXF1aXJlKCcuL25vZGUtbW9kdWxlcy1wYXRocycpO1xudmFyIG5vcm1hbGl6ZU9wdGlvbnMgPSByZXF1aXJlKCcuL25vcm1hbGl6ZS1vcHRpb25zJyk7XG5cbnZhciByZWFscGF0aEZTID0gZnMucmVhbHBhdGhTeW5jICYmIHR5cGVvZiBmcy5yZWFscGF0aFN5bmMubmF0aXZlID09PSAnZnVuY3Rpb24nID8gZnMucmVhbHBhdGhTeW5jLm5hdGl2ZSA6IGZzLnJlYWxwYXRoU3luYztcblxudmFyIGhvbWVkaXIgPSBnZXRIb21lZGlyKCk7XG52YXIgZGVmYXVsdFBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhdGguam9pbihob21lZGlyLCAnLm5vZGVfbW9kdWxlcycpLFxuICAgICAgICBwYXRoLmpvaW4oaG9tZWRpciwgJy5ub2RlX2xpYnJhcmllcycpXG4gICAgXTtcbn07XG5cbnZhciBkZWZhdWx0SXNGaWxlID0gZnVuY3Rpb24gaXNGaWxlKGZpbGUpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUsIHsgdGhyb3dJZk5vRW50cnk6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgKGUuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZS5jb2RlID09PSAnRU5PVERJUicpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiAhIXN0YXQgJiYgKHN0YXQuaXNGaWxlKCkgfHwgc3RhdC5pc0ZJRk8oKSk7XG59O1xuXG52YXIgZGVmYXVsdElzRGlyID0gZnVuY3Rpb24gaXNEaXJlY3RvcnkoZGlyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHN0YXQgPSBmcy5zdGF0U3luYyhkaXIsIHsgdGhyb3dJZk5vRW50cnk6IGZhbHNlIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgKGUuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZS5jb2RlID09PSAnRU5PVERJUicpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiAhIXN0YXQgJiYgc3RhdC5pc0RpcmVjdG9yeSgpO1xufTtcblxudmFyIGRlZmF1bHRSZWFscGF0aFN5bmMgPSBmdW5jdGlvbiByZWFscGF0aFN5bmMoeCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWFscGF0aEZTKHgpO1xuICAgIH0gY2F0Y2ggKHJlYWxwYXRoRXJyKSB7XG4gICAgICAgIGlmIChyZWFscGF0aEVyci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgdGhyb3cgcmVhbHBhdGhFcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG52YXIgbWF5YmVSZWFscGF0aFN5bmMgPSBmdW5jdGlvbiBtYXliZVJlYWxwYXRoU3luYyhyZWFscGF0aFN5bmMsIHgsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAmJiBvcHRzLnByZXNlcnZlU3ltbGlua3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZWFscGF0aFN5bmMoeCk7XG4gICAgfVxuICAgIHJldHVybiB4O1xufTtcblxudmFyIGRlZmF1bHRSZWFkUGFja2FnZVN5bmMgPSBmdW5jdGlvbiBkZWZhdWx0UmVhZFBhY2thZ2VTeW5jKHJlYWRGaWxlU3luYywgcGtnZmlsZSkge1xuICAgIHZhciBib2R5ID0gcmVhZEZpbGVTeW5jKHBrZ2ZpbGUpO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBwa2cgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gcGtnO1xuICAgIH0gY2F0Y2ggKGpzb25FcnIpIHt9XG59O1xuXG52YXIgZ2V0UGFja2FnZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRQYWNrYWdlQ2FuZGlkYXRlcyh4LCBzdGFydCwgb3B0cykge1xuICAgIHZhciBkaXJzID0gbm9kZU1vZHVsZXNQYXRocyhzdGFydCwgb3B0cywgeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpcnNbaV0gPSBwYXRoLmpvaW4oZGlyc1tpXSwgeCk7XG4gICAgfVxuICAgIHJldHVybiBkaXJzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXNvbHZlU3luYyh4LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyh4LCBvcHRpb25zKTtcblxuICAgIHZhciBpc0ZpbGUgPSBvcHRzLmlzRmlsZSB8fCBkZWZhdWx0SXNGaWxlO1xuICAgIHZhciByZWFkRmlsZVN5bmMgPSBvcHRzLnJlYWRGaWxlU3luYyB8fCBmcy5yZWFkRmlsZVN5bmM7XG4gICAgdmFyIGlzRGlyZWN0b3J5ID0gb3B0cy5pc0RpcmVjdG9yeSB8fCBkZWZhdWx0SXNEaXI7XG4gICAgdmFyIHJlYWxwYXRoU3luYyA9IG9wdHMucmVhbHBhdGhTeW5jIHx8IGRlZmF1bHRSZWFscGF0aFN5bmM7XG4gICAgdmFyIHJlYWRQYWNrYWdlU3luYyA9IG9wdHMucmVhZFBhY2thZ2VTeW5jIHx8IGRlZmF1bHRSZWFkUGFja2FnZVN5bmM7XG4gICAgaWYgKG9wdHMucmVhZEZpbGVTeW5jICYmIG9wdHMucmVhZFBhY2thZ2VTeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ByZWFkRmlsZVN5bmNgIGFuZCBgcmVhZFBhY2thZ2VTeW5jYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgIH1cbiAgICB2YXIgcGFja2FnZUl0ZXJhdG9yID0gb3B0cy5wYWNrYWdlSXRlcmF0b3I7XG5cbiAgICB2YXIgZXh0ZW5zaW9ucyA9IG9wdHMuZXh0ZW5zaW9ucyB8fCBbJy5qcyddO1xuICAgIHZhciBpbmNsdWRlQ29yZU1vZHVsZXMgPSBvcHRzLmluY2x1ZGVDb3JlTW9kdWxlcyAhPT0gZmFsc2U7XG4gICAgdmFyIGJhc2VkaXIgPSBvcHRzLmJhc2VkaXIgfHwgcGF0aC5kaXJuYW1lKGNhbGxlcigpKTtcbiAgICB2YXIgcGFyZW50ID0gb3B0cy5maWxlbmFtZSB8fCBiYXNlZGlyO1xuXG4gICAgb3B0cy5wYXRocyA9IG9wdHMucGF0aHMgfHwgZGVmYXVsdFBhdGhzKCk7XG5cbiAgICAvLyBlbnN1cmUgdGhhdCBgYmFzZWRpcmAgaXMgYW4gYWJzb2x1dGUgcGF0aCBhdCB0aGlzIHBvaW50LCByZXNvbHZpbmcgYWdhaW5zdCB0aGUgcHJvY2VzcycgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgIHZhciBhYnNvbHV0ZVN0YXJ0ID0gbWF5YmVSZWFscGF0aFN5bmMocmVhbHBhdGhTeW5jLCBwYXRoLnJlc29sdmUoYmFzZWRpciksIG9wdHMpO1xuXG4gICAgaWYgKCgvXig/OlxcLlxcLj8oPzpcXC98JCl8XFwvfChbQS1aYS16XTopP1svXFxcXF0pLykudGVzdCh4KSkge1xuICAgICAgICB2YXIgcmVzID0gcGF0aC5yZXNvbHZlKGFic29sdXRlU3RhcnQsIHgpO1xuICAgICAgICBpZiAoeCA9PT0gJy4nIHx8IHggPT09ICcuLicgfHwgeC5zbGljZSgtMSkgPT09ICcvJykgcmVzICs9ICcvJztcbiAgICAgICAgdmFyIG0gPSBsb2FkQXNGaWxlU3luYyhyZXMpIHx8IGxvYWRBc0RpcmVjdG9yeVN5bmMocmVzKTtcbiAgICAgICAgaWYgKG0pIHJldHVybiBtYXliZVJlYWxwYXRoU3luYyhyZWFscGF0aFN5bmMsIG0sIG9wdHMpO1xuICAgIH0gZWxzZSBpZiAoaW5jbHVkZUNvcmVNb2R1bGVzICYmIGlzQ29yZSh4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbiA9IGxvYWROb2RlTW9kdWxlc1N5bmMoeCwgYWJzb2x1dGVTdGFydCk7XG4gICAgICAgIGlmIChuKSByZXR1cm4gbWF5YmVSZWFscGF0aFN5bmMocmVhbHBhdGhTeW5jLCBuLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHggKyBcIicgZnJvbSAnXCIgKyBwYXJlbnQgKyBcIidcIik7XG4gICAgZXJyLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG4gICAgdGhyb3cgZXJyO1xuXG4gICAgZnVuY3Rpb24gbG9hZEFzRmlsZVN5bmMoeCkge1xuICAgICAgICB2YXIgcGtnID0gbG9hZHBrZyhwYXRoLmRpcm5hbWUoeCkpO1xuXG4gICAgICAgIGlmIChwa2cgJiYgcGtnLmRpciAmJiBwa2cucGtnICYmIG9wdHMucGF0aEZpbHRlcikge1xuICAgICAgICAgICAgdmFyIHJmaWxlID0gcGF0aC5yZWxhdGl2ZShwa2cuZGlyLCB4KTtcbiAgICAgICAgICAgIHZhciByID0gb3B0cy5wYXRoRmlsdGVyKHBrZy5wa2csIHgsIHJmaWxlKTtcbiAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBhdGgucmVzb2x2ZShwa2cuZGlyLCByKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmlsZSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0geCArIGV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgICBpZiAoaXNGaWxlKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkcGtnKGRpcikge1xuICAgICAgICBpZiAoZGlyID09PSAnJyB8fCBkaXIgPT09ICcvJykgcmV0dXJuO1xuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAoL15cXHc6Wy9cXFxcXSokLykudGVzdChkaXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0qJC8pLnRlc3QoZGlyKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwa2dmaWxlID0gcGF0aC5qb2luKG1heWJlUmVhbHBhdGhTeW5jKHJlYWxwYXRoU3luYywgZGlyLCBvcHRzKSwgJ3BhY2thZ2UuanNvbicpO1xuXG4gICAgICAgIGlmICghaXNGaWxlKHBrZ2ZpbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZHBrZyhwYXRoLmRpcm5hbWUoZGlyKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGtnID0gcmVhZFBhY2thZ2VTeW5jKHJlYWRGaWxlU3luYywgcGtnZmlsZSk7XG5cbiAgICAgICAgaWYgKHBrZyAmJiBvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIC8vIHYyIHdpbGwgcGFzcyBwa2dmaWxlXG4gICAgICAgICAgICBwa2cgPSBvcHRzLnBhY2thZ2VGaWx0ZXIocGtnLCAvKnBrZ2ZpbGUsKi8gZGlyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzcGFjZWQtY29tbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGtnOiBwa2csIGRpcjogZGlyIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFzRGlyZWN0b3J5U3luYyh4KSB7XG4gICAgICAgIHZhciBwa2dmaWxlID0gcGF0aC5qb2luKG1heWJlUmVhbHBhdGhTeW5jKHJlYWxwYXRoU3luYywgeCwgb3B0cyksICcvcGFja2FnZS5qc29uJyk7XG4gICAgICAgIGlmIChpc0ZpbGUocGtnZmlsZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHBrZyA9IHJlYWRQYWNrYWdlU3luYyhyZWFkRmlsZVN5bmMsIHBrZ2ZpbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgICAgICAgaWYgKHBrZyAmJiBvcHRzLnBhY2thZ2VGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB2MiB3aWxsIHBhc3MgcGtnZmlsZVxuICAgICAgICAgICAgICAgIHBrZyA9IG9wdHMucGFja2FnZUZpbHRlcihwa2csIC8qcGtnZmlsZSwqLyB4KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzcGFjZWQtY29tbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGtnICYmIHBrZy5tYWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwa2cubWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1haW5FcnJvciA9IG5ldyBUeXBlRXJyb3IoJ3BhY2thZ2UgXHUyMDFDJyArIHBrZy5uYW1lICsgJ1x1MjAxRCBgbWFpbmAgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICBtYWluRXJyb3IuY29kZSA9ICdJTlZBTElEX1BBQ0tBR0VfTUFJTic7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1haW5FcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBrZy5tYWluID09PSAnLicgfHwgcGtnLm1haW4gPT09ICcuLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnLm1haW4gPSAnaW5kZXgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGxvYWRBc0ZpbGVTeW5jKHBhdGgucmVzb2x2ZSh4LCBwa2cubWFpbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkgcmV0dXJuIG07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbG9hZEFzRGlyZWN0b3J5U3luYyhwYXRoLnJlc29sdmUoeCwgcGtnLm1haW4pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9hZEFzRmlsZVN5bmMocGF0aC5qb2luKHgsICcvaW5kZXgnKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZE5vZGVNb2R1bGVzU3luYyh4LCBzdGFydCkge1xuICAgICAgICB2YXIgdGh1bmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRQYWNrYWdlQ2FuZGlkYXRlcyh4LCBzdGFydCwgb3B0cyk7IH07XG4gICAgICAgIHZhciBkaXJzID0gcGFja2FnZUl0ZXJhdG9yID8gcGFja2FnZUl0ZXJhdG9yKHgsIHN0YXJ0LCB0aHVuaywgb3B0cykgOiB0aHVuaygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpciA9IGRpcnNbaV07XG4gICAgICAgICAgICBpZiAoaXNEaXJlY3RvcnkocGF0aC5kaXJuYW1lKGRpcikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBsb2FkQXNGaWxlU3luYyhkaXIpO1xuICAgICAgICAgICAgICAgIGlmIChtKSByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGxvYWRBc0RpcmVjdG9yeVN5bmMoZGlyKTtcbiAgICAgICAgICAgICAgICBpZiAobikgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwgInZhciBhc3luYyA9IHJlcXVpcmUoJy4vbGliL2FzeW5jJyk7XG5hc3luYy5jb3JlID0gcmVxdWlyZSgnLi9saWIvY29yZScpO1xuYXN5bmMuaXNDb3JlID0gcmVxdWlyZSgnLi9saWIvaXMtY29yZScpO1xuYXN5bmMuc3luYyA9IHJlcXVpcmUoJy4vbGliL3N5bmMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBXSU5fU0xBU0ggPSAnXFxcXFxcXFwvJztcbmNvbnN0IFdJTl9OT19TTEFTSCA9IGBbXiR7V0lOX1NMQVNIfV1gO1xuXG4vKipcbiAqIFBvc2l4IGdsb2IgcmVnZXhcbiAqL1xuXG5jb25zdCBET1RfTElURVJBTCA9ICdcXFxcLic7XG5jb25zdCBQTFVTX0xJVEVSQUwgPSAnXFxcXCsnO1xuY29uc3QgUU1BUktfTElURVJBTCA9ICdcXFxcPyc7XG5jb25zdCBTTEFTSF9MSVRFUkFMID0gJ1xcXFwvJztcbmNvbnN0IE9ORV9DSEFSID0gJyg/PS4pJztcbmNvbnN0IFFNQVJLID0gJ1teL10nO1xuY29uc3QgRU5EX0FOQ0hPUiA9IGAoPzoke1NMQVNIX0xJVEVSQUx9fCQpYDtcbmNvbnN0IFNUQVJUX0FOQ0hPUiA9IGAoPzpefCR7U0xBU0hfTElURVJBTH0pYDtcbmNvbnN0IERPVFNfU0xBU0ggPSBgJHtET1RfTElURVJBTH17MSwyfSR7RU5EX0FOQ0hPUn1gO1xuY29uc3QgTk9fRE9UID0gYCg/ISR7RE9UX0xJVEVSQUx9KWA7XG5jb25zdCBOT19ET1RTID0gYCg/ISR7U1RBUlRfQU5DSE9SfSR7RE9UU19TTEFTSH0pYDtcbmNvbnN0IE5PX0RPVF9TTEFTSCA9IGAoPyEke0RPVF9MSVRFUkFMfXswLDF9JHtFTkRfQU5DSE9SfSlgO1xuY29uc3QgTk9fRE9UU19TTEFTSCA9IGAoPyEke0RPVFNfU0xBU0h9KWA7XG5jb25zdCBRTUFSS19OT19ET1QgPSBgW14uJHtTTEFTSF9MSVRFUkFMfV1gO1xuY29uc3QgU1RBUiA9IGAke1FNQVJLfSo/YDtcblxuY29uc3QgUE9TSVhfQ0hBUlMgPSB7XG4gIERPVF9MSVRFUkFMLFxuICBQTFVTX0xJVEVSQUwsXG4gIFFNQVJLX0xJVEVSQUwsXG4gIFNMQVNIX0xJVEVSQUwsXG4gIE9ORV9DSEFSLFxuICBRTUFSSyxcbiAgRU5EX0FOQ0hPUixcbiAgRE9UU19TTEFTSCxcbiAgTk9fRE9ULFxuICBOT19ET1RTLFxuICBOT19ET1RfU0xBU0gsXG4gIE5PX0RPVFNfU0xBU0gsXG4gIFFNQVJLX05PX0RPVCxcbiAgU1RBUixcbiAgU1RBUlRfQU5DSE9SXG59O1xuXG4vKipcbiAqIFdpbmRvd3MgZ2xvYiByZWdleFxuICovXG5cbmNvbnN0IFdJTkRPV1NfQ0hBUlMgPSB7XG4gIC4uLlBPU0lYX0NIQVJTLFxuXG4gIFNMQVNIX0xJVEVSQUw6IGBbJHtXSU5fU0xBU0h9XWAsXG4gIFFNQVJLOiBXSU5fTk9fU0xBU0gsXG4gIFNUQVI6IGAke1dJTl9OT19TTEFTSH0qP2AsXG4gIERPVFNfU0xBU0g6IGAke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JClgLFxuICBOT19ET1Q6IGAoPyEke0RPVF9MSVRFUkFMfSlgLFxuICBOT19ET1RTOiBgKD8hKD86XnxbJHtXSU5fU0xBU0h9XSkke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgTk9fRE9UX1NMQVNIOiBgKD8hJHtET1RfTElURVJBTH17MCwxfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG4gIE5PX0RPVFNfU0xBU0g6IGAoPyEke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgUU1BUktfTk9fRE9UOiBgW14uJHtXSU5fU0xBU0h9XWAsXG4gIFNUQVJUX0FOQ0hPUjogYCg/Ol58WyR7V0lOX1NMQVNIfV0pYCxcbiAgRU5EX0FOQ0hPUjogYCg/Olske1dJTl9TTEFTSH1dfCQpYFxufTtcblxuLyoqXG4gKiBQT1NJWCBCcmFja2V0IFJlZ2V4XG4gKi9cblxuY29uc3QgUE9TSVhfUkVHRVhfU09VUkNFID0ge1xuICBhbG51bTogJ2EtekEtWjAtOScsXG4gIGFscGhhOiAnYS16QS1aJyxcbiAgYXNjaWk6ICdcXFxceDAwLVxcXFx4N0YnLFxuICBibGFuazogJyBcXFxcdCcsXG4gIGNudHJsOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3RicsXG4gIGRpZ2l0OiAnMC05JyxcbiAgZ3JhcGg6ICdcXFxceDIxLVxcXFx4N0UnLFxuICBsb3dlcjogJ2EteicsXG4gIHByaW50OiAnXFxcXHgyMC1cXFxceDdFICcsXG4gIHB1bmN0OiAnXFxcXC0hXCIjJCUmXFwnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9ficsXG4gIHNwYWNlOiAnIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLFxuICB1cHBlcjogJ0EtWicsXG4gIHdvcmQ6ICdBLVphLXowLTlfJyxcbiAgeGRpZ2l0OiAnQS1GYS1mMC05J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEg6IDEwMjQgKiA2NCxcbiAgUE9TSVhfUkVHRVhfU09VUkNFLFxuXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgUkVHRVhfQkFDS1NMQVNIOiAvXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOiAvXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlM6IC9bLSorPy5eJHt9KHwpW1xcXV0vLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6IC8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDogLyhbLSorPy5eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6IC8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxcblxuICAvLyBSZXBsYWNlIGdsb2JzIHdpdGggZXF1aXZhbGVudCBwYXR0ZXJucyB0byByZWR1Y2UgcGFyc2luZyB0aW1lLlxuICBSRVBMQUNFTUVOVFM6IHtcbiAgICAnKioqJzogJyonLFxuICAgICcqKi8qKic6ICcqKicsXG4gICAgJyoqLyoqLyoqJzogJyoqJ1xuICB9LFxuXG4gIC8vIERpZ2l0c1xuICBDSEFSXzA6IDQ4LCAvKiAwICovXG4gIENIQVJfOTogNTcsIC8qIDkgKi9cblxuICAvLyBBbHBoYWJldCBjaGFycy5cbiAgQ0hBUl9VUFBFUkNBU0VfQTogNjUsIC8qIEEgKi9cbiAgQ0hBUl9MT1dFUkNBU0VfQTogOTcsIC8qIGEgKi9cbiAgQ0hBUl9VUFBFUkNBU0VfWjogOTAsIC8qIFogKi9cbiAgQ0hBUl9MT1dFUkNBU0VfWjogMTIyLCAvKiB6ICovXG5cbiAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiA0MCwgLyogKCAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOiA0MSwgLyogKSAqL1xuXG4gIENIQVJfQVNURVJJU0s6IDQyLCAvKiAqICovXG5cbiAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG4gIENIQVJfQU1QRVJTQU5EOiAzOCwgLyogJiAqL1xuICBDSEFSX0FUOiA2NCwgLyogQCAqL1xuICBDSEFSX0JBQ0tXQVJEX1NMQVNIOiA5MiwgLyogXFwgKi9cbiAgQ0hBUl9DQVJSSUFHRV9SRVRVUk46IDEzLCAvKiBcXHIgKi9cbiAgQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDogOTQsIC8qIF4gKi9cbiAgQ0hBUl9DT0xPTjogNTgsIC8qIDogKi9cbiAgQ0hBUl9DT01NQTogNDQsIC8qICwgKi9cbiAgQ0hBUl9ET1Q6IDQ2LCAvKiAuICovXG4gIENIQVJfRE9VQkxFX1FVT1RFOiAzNCwgLyogXCIgKi9cbiAgQ0hBUl9FUVVBTDogNjEsIC8qID0gKi9cbiAgQ0hBUl9FWENMQU1BVElPTl9NQVJLOiAzMywgLyogISAqL1xuICBDSEFSX0ZPUk1fRkVFRDogMTIsIC8qIFxcZiAqL1xuICBDSEFSX0ZPUldBUkRfU0xBU0g6IDQ3LCAvKiAvICovXG4gIENIQVJfR1JBVkVfQUNDRU5UOiA5NiwgLyogYCAqL1xuICBDSEFSX0hBU0g6IDM1LCAvKiAjICovXG4gIENIQVJfSFlQSEVOX01JTlVTOiA0NSwgLyogLSAqL1xuICBDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDogNjAsIC8qIDwgKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAxMjMsIC8qIHsgKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiA5MSwgLyogWyAqL1xuICBDSEFSX0xJTkVfRkVFRDogMTAsIC8qIFxcbiAqL1xuICBDSEFSX05PX0JSRUFLX1NQQUNFOiAxNjAsIC8qIFxcdTAwQTAgKi9cbiAgQ0hBUl9QRVJDRU5UOiAzNywgLyogJSAqL1xuICBDSEFSX1BMVVM6IDQzLCAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSzogNjMsIC8qID8gKi9cbiAgQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOiA2MiwgLyogPiAqL1xuICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOiAxMjUsIC8qIH0gKi9cbiAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDogOTMsIC8qIF0gKi9cbiAgQ0hBUl9TRU1JQ09MT046IDU5LCAvKiA7ICovXG4gIENIQVJfU0lOR0xFX1FVT1RFOiAzOSwgLyogJyAqL1xuICBDSEFSX1NQQUNFOiAzMiwgLyogICAqL1xuICBDSEFSX1RBQjogOSwgLyogXFx0ICovXG4gIENIQVJfVU5ERVJTQ09SRTogOTUsIC8qIF8gKi9cbiAgQ0hBUl9WRVJUSUNBTF9MSU5FOiAxMjQsIC8qIHwgKi9cbiAgQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6IDY1Mjc5LCAvKiBcXHVGRUZGICovXG5cbiAgU0VQOiBwYXRoLnNlcCxcblxuICAvKipcbiAgICogQ3JlYXRlIEVYVEdMT0JfQ0hBUlNcbiAgICovXG5cbiAgZXh0Z2xvYkNoYXJzKGNoYXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICchJzogeyB0eXBlOiAnbmVnYXRlJywgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiBgKSkke2NoYXJzLlNUQVJ9KWAgfSxcbiAgICAgICc/JzogeyB0eXBlOiAncW1hcmsnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgICAgICcrJzogeyB0eXBlOiAncGx1cycsIG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAgICAgJyonOiB7IHR5cGU6ICdzdGFyJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICAgICAnQCc6IHsgdHlwZTogJ2F0Jywgb3BlbjogJyg/OicsIGNsb3NlOiAnKScgfVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBHTE9CX0NIQVJTXG4gICAqL1xuXG4gIGdsb2JDaGFycyh3aW4zMikge1xuICAgIHJldHVybiB3aW4zMiA9PT0gdHJ1ZSA/IFdJTkRPV1NfQ0hBUlMgOiBQT1NJWF9DSEFSUztcbiAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB3aW4zMiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5jb25zdCB7XG4gIFJFR0VYX0JBQ0tTTEFTSCxcbiAgUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSUyxcbiAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gdmFsID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuZXhwb3J0cy5oYXNSZWdleENoYXJzID0gc3RyID0+IFJFR0VYX1NQRUNJQUxfQ0hBUlMudGVzdChzdHIpO1xuZXhwb3J0cy5pc1JlZ2V4Q2hhciA9IHN0ciA9PiBzdHIubGVuZ3RoID09PSAxICYmIGV4cG9ydHMuaGFzUmVnZXhDaGFycyhzdHIpO1xuZXhwb3J0cy5lc2NhcGVSZWdleCA9IHN0ciA9PiBzdHIucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTCwgJ1xcXFwkMScpO1xuZXhwb3J0cy50b1Bvc2l4U2xhc2hlcyA9IHN0ciA9PiBzdHIucmVwbGFjZShSRUdFWF9CQUNLU0xBU0gsICcvJyk7XG5cbmV4cG9ydHMucmVtb3ZlQmFja3NsYXNoZXMgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCwgbWF0Y2ggPT4ge1xuICAgIHJldHVybiBtYXRjaCA9PT0gJ1xcXFwnID8gJycgOiBtYXRjaDtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnN1cHBvcnRzTG9va2JlaGluZHMgPSAoKSA9PiB7XG4gIGNvbnN0IHNlZ3MgPSBwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkuc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgaWYgKHNlZ3MubGVuZ3RoID09PSAzICYmIHNlZ3NbMF0gPj0gOSB8fCAoc2Vnc1swXSA9PT0gOCAmJiBzZWdzWzFdID49IDEwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuaXNXaW5kb3dzID0gb3B0aW9ucyA9PiB7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLndpbmRvd3MgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBvcHRpb25zLndpbmRvd3M7XG4gIH1cbiAgcmV0dXJuIHdpbjMyID09PSB0cnVlIHx8IHBhdGguc2VwID09PSAnXFxcXCc7XG59O1xuXG5leHBvcnRzLmVzY2FwZUxhc3QgPSAoaW5wdXQsIGNoYXIsIGxhc3RJZHgpID0+IHtcbiAgY29uc3QgaWR4ID0gaW5wdXQubGFzdEluZGV4T2YoY2hhciwgbGFzdElkeCk7XG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gaW5wdXQ7XG4gIGlmIChpbnB1dFtpZHggLSAxXSA9PT0gJ1xcXFwnKSByZXR1cm4gZXhwb3J0cy5lc2NhcGVMYXN0KGlucHV0LCBjaGFyLCBpZHggLSAxKTtcbiAgcmV0dXJuIGAke2lucHV0LnNsaWNlKDAsIGlkeCl9XFxcXCR7aW5wdXQuc2xpY2UoaWR4KX1gO1xufTtcblxuZXhwb3J0cy5yZW1vdmVQcmVmaXggPSAoaW5wdXQsIHN0YXRlID0ge30pID0+IHtcbiAgbGV0IG91dHB1dCA9IGlucHV0O1xuICBpZiAob3V0cHV0LnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICBvdXRwdXQgPSBvdXRwdXQuc2xpY2UoMik7XG4gICAgc3RhdGUucHJlZml4ID0gJy4vJztcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuZXhwb3J0cy53cmFwT3V0cHV0ID0gKGlucHV0LCBzdGF0ZSA9IHt9LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcHJlcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICdeJztcbiAgY29uc3QgYXBwZW5kID0gb3B0aW9ucy5jb250YWlucyA/ICcnIDogJyQnO1xuXG4gIGxldCBvdXRwdXQgPSBgJHtwcmVwZW5kfSg/OiR7aW5wdXR9KSR7YXBwZW5kfWA7XG4gIGlmIChzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG4gICAgb3V0cHV0ID0gYCg/Ol4oPyEke291dHB1dH0pLiokKWA7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHtcbiAgQ0hBUl9BU1RFUklTSywgICAgICAgICAgICAgLyogKiAqL1xuICBDSEFSX0FULCAgICAgICAgICAgICAgICAgICAvKiBAICovXG4gIENIQVJfQkFDS1dBUkRfU0xBU0gsICAgICAgIC8qIFxcICovXG4gIENIQVJfQ09NTUEsICAgICAgICAgICAgICAgIC8qICwgKi9cbiAgQ0hBUl9ET1QsICAgICAgICAgICAgICAgICAgLyogLiAqL1xuICBDSEFSX0VYQ0xBTUFUSU9OX01BUkssICAgICAvKiAhICovXG4gIENIQVJfRk9SV0FSRF9TTEFTSCwgICAgICAgIC8qIC8gKi9cbiAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFLCAgICAgLyogeyAqL1xuICBDSEFSX0xFRlRfUEFSRU5USEVTRVMsICAgICAvKiAoICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCwgIC8qIFsgKi9cbiAgQ0hBUl9QTFVTLCAgICAgICAgICAgICAgICAgLyogKyAqL1xuICBDSEFSX1FVRVNUSU9OX01BUkssICAgICAgICAvKiA/ICovXG4gIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0UsICAgIC8qIH0gKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUywgICAgLyogKSAqL1xuICBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICAvKiBdICovXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgaXNQYXRoU2VwYXJhdG9yID0gY29kZSA9PiB7XG4gIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcbn07XG5cbmNvbnN0IGRlcHRoID0gdG9rZW4gPT4ge1xuICBpZiAodG9rZW4uaXNQcmVmaXggIT09IHRydWUpIHtcbiAgICB0b2tlbi5kZXB0aCA9IHRva2VuLmlzR2xvYnN0YXIgPyBJbmZpbml0eSA6IDE7XG4gIH1cbn07XG5cbi8qKlxuICogUXVpY2tseSBzY2FucyBhIGdsb2IgcGF0dGVybiBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIGhhbmRmdWwgb2ZcbiAqIHVzZWZ1bCBwcm9wZXJ0aWVzLCBsaWtlIGBpc0dsb2JgLCBgcGF0aGAgKHRoZSBsZWFkaW5nIG5vbi1nbG9iLCBpZiBpdCBleGlzdHMpLFxuICogYGdsb2JgICh0aGUgYWN0dWFsIHBhdHRlcm4pLCBgbmVnYXRlZGAgKHRydWUgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYCFgIGJ1dCBub3RcbiAqIHdpdGggYCEoYCkgYW5kIGBuZWdhdGVkRXh0Z2xvYmAgKHRydWUgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYCEoYCkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBtID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiBjb25zb2xlLmxvZyhwbS5zY2FuKCdmb28vYmFyLyouanMnKSk7XG4gKiB7IGlzR2xvYjogdHJ1ZSwgaW5wdXQ6ICdmb28vYmFyLyouanMnLCBiYXNlOiAnZm9vL2JhcicsIGdsb2I6ICcqLmpzJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRva2VucyBhbmQgcmVnZXggc291cmNlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3Qgc2NhbiA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGggLSAxO1xuICBjb25zdCBzY2FuVG9FbmQgPSBvcHRzLnBhcnRzID09PSB0cnVlIHx8IG9wdHMuc2NhblRvRW5kID09PSB0cnVlO1xuICBjb25zdCBzbGFzaGVzID0gW107XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGxldCBzdHIgPSBpbnB1dDtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICBsZXQgaXNCcmFjZSA9IGZhbHNlO1xuICBsZXQgaXNCcmFja2V0ID0gZmFsc2U7XG4gIGxldCBpc0dsb2IgPSBmYWxzZTtcbiAgbGV0IGlzRXh0Z2xvYiA9IGZhbHNlO1xuICBsZXQgaXNHbG9ic3RhciA9IGZhbHNlO1xuICBsZXQgYnJhY2VFc2NhcGVkID0gZmFsc2U7XG4gIGxldCBiYWNrc2xhc2hlcyA9IGZhbHNlO1xuICBsZXQgbmVnYXRlZCA9IGZhbHNlO1xuICBsZXQgbmVnYXRlZEV4dGdsb2IgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gIGxldCBicmFjZXMgPSAwO1xuICBsZXQgcHJldjtcbiAgbGV0IGNvZGU7XG4gIGxldCB0b2tlbiA9IHsgdmFsdWU6ICcnLCBkZXB0aDogMCwgaXNHbG9iOiBmYWxzZSB9O1xuXG4gIGNvbnN0IGVvcyA9ICgpID0+IGluZGV4ID49IGxlbmd0aDtcbiAgY29uc3QgcGVlayA9ICgpID0+IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gIGNvbnN0IGFkdmFuY2UgPSAoKSA9PiB7XG4gICAgcHJldiA9IGNvZGU7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICB9O1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNvZGUgPSBhZHZhbmNlKCk7XG4gICAgbGV0IG5leHQ7XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICBjb2RlID0gYWR2YW5jZSgpO1xuXG4gICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICAgIGJyYWNlRXNjYXBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYnJhY2VFc2NhcGVkID09PSB0cnVlIHx8IGNvZGUgPT09IENIQVJfTEVGVF9DVVJMWV9CUkFDRSkge1xuICAgICAgYnJhY2VzKys7XG5cbiAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICAgICAgYnJhY2VzKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnJhY2VFc2NhcGVkICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfRE9UICYmIChjb2RlID0gYWR2YW5jZSgpKSA9PT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicmFjZUVzY2FwZWQgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9DT01NQSkge1xuICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgICAgICBicmFjZXMtLTtcblxuICAgICAgICAgIGlmIChicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgIGJyYWNlRXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgIHNsYXNoZXMucHVzaChpbmRleCk7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB0b2tlbiA9IHsgdmFsdWU6ICcnLCBkZXB0aDogMCwgaXNHbG9iOiBmYWxzZSB9O1xuXG4gICAgICBpZiAoZmluaXNoZWQgPT09IHRydWUpIGNvbnRpbnVlO1xuICAgICAgaWYgKHByZXYgPT09IENIQVJfRE9UICYmIGluZGV4ID09PSAoc3RhcnQgKyAxKSkge1xuICAgICAgICBzdGFydCArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9leHQgIT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGlzRXh0Z2xvYkNoYXIgPSBjb2RlID09PSBDSEFSX1BMVVNcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9BVFxuICAgICAgICB8fCBjb2RlID09PSBDSEFSX0FTVEVSSVNLXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfUVVFU1RJT05fTUFSS1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUks7XG5cbiAgICAgIGlmIChpc0V4dGdsb2JDaGFyID09PSB0cnVlICYmIHBlZWsoKSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgIGlzRXh0Z2xvYiA9IHRva2VuLmlzRXh0Z2xvYiA9IHRydWU7XG4gICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSyAmJiBpbmRleCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICBuZWdhdGVkRXh0Z2xvYiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChjb2RlID0gYWR2YW5jZSgpKSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9BU1RFUklTSykge1xuICAgICAgaWYgKHByZXYgPT09IENIQVJfQVNURVJJU0spIGlzR2xvYnN0YXIgPSB0b2tlbi5pc0dsb2JzdGFyID0gdHJ1ZTtcbiAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9RVUVTVElPTl9NQVJLKSB7XG4gICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCkge1xuICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChuZXh0ID0gYWR2YW5jZSgpKSkge1xuICAgICAgICBpZiAobmV4dCA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICAgICAgaXNCcmFja2V0ID0gdG9rZW4uaXNCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub25lZ2F0ZSAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUksgJiYgaW5kZXggPT09IHN0YXJ0KSB7XG4gICAgICBuZWdhdGVkID0gdG9rZW4ubmVnYXRlZCA9IHRydWU7XG4gICAgICBzdGFydCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubm9wYXJlbiAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0xFRlRfUEFSRU5USEVTRVMpIHtcbiAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChjb2RlID0gYWR2YW5jZSgpKSkge1xuICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaXNHbG9iID09PSB0cnVlKSB7XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLm5vZXh0ID09PSB0cnVlKSB7XG4gICAgaXNFeHRnbG9iID0gZmFsc2U7XG4gICAgaXNHbG9iID0gZmFsc2U7XG4gIH1cblxuICBsZXQgYmFzZSA9IHN0cjtcbiAgbGV0IHByZWZpeCA9ICcnO1xuICBsZXQgZ2xvYiA9ICcnO1xuXG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3RhcnQpO1xuICAgIHN0ciA9IHN0ci5zbGljZShzdGFydCk7XG4gICAgbGFzdEluZGV4IC09IHN0YXJ0O1xuICB9XG5cbiAgaWYgKGJhc2UgJiYgaXNHbG9iID09PSB0cnVlICYmIGxhc3RJbmRleCA+IDApIHtcbiAgICBiYXNlID0gc3RyLnNsaWNlKDAsIGxhc3RJbmRleCk7XG4gICAgZ2xvYiA9IHN0ci5zbGljZShsYXN0SW5kZXgpO1xuICB9IGVsc2UgaWYgKGlzR2xvYiA9PT0gdHJ1ZSkge1xuICAgIGJhc2UgPSAnJztcbiAgICBnbG9iID0gc3RyO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBzdHI7XG4gIH1cblxuICBpZiAoYmFzZSAmJiBiYXNlICE9PSAnJyAmJiBiYXNlICE9PSAnLycgJiYgYmFzZSAhPT0gc3RyKSB7XG4gICAgaWYgKGlzUGF0aFNlcGFyYXRvcihiYXNlLmNoYXJDb2RlQXQoYmFzZS5sZW5ndGggLSAxKSkpIHtcbiAgICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuICAgIGlmIChnbG9iKSBnbG9iID0gdXRpbHMucmVtb3ZlQmFja3NsYXNoZXMoZ2xvYik7XG5cbiAgICBpZiAoYmFzZSAmJiBiYWNrc2xhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgYmFzZSA9IHV0aWxzLnJlbW92ZUJhY2tzbGFzaGVzKGJhc2UpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHByZWZpeCxcbiAgICBpbnB1dCxcbiAgICBzdGFydCxcbiAgICBiYXNlLFxuICAgIGdsb2IsXG4gICAgaXNCcmFjZSxcbiAgICBpc0JyYWNrZXQsXG4gICAgaXNHbG9iLFxuICAgIGlzRXh0Z2xvYixcbiAgICBpc0dsb2JzdGFyLFxuICAgIG5lZ2F0ZWQsXG4gICAgbmVnYXRlZEV4dGdsb2JcbiAgfTtcblxuICBpZiAob3B0cy50b2tlbnMgPT09IHRydWUpIHtcbiAgICBzdGF0ZS5tYXhEZXB0aCA9IDA7XG4gICAgaWYgKCFpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgaWYgKG9wdHMucGFydHMgPT09IHRydWUgfHwgb3B0cy50b2tlbnMgPT09IHRydWUpIHtcbiAgICBsZXQgcHJldkluZGV4O1xuXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2xhc2hlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBuID0gcHJldkluZGV4ID8gcHJldkluZGV4ICsgMSA6IHN0YXJ0O1xuICAgICAgY29uc3QgaSA9IHNsYXNoZXNbaWR4XTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2UobiwgaSk7XG4gICAgICBpZiAob3B0cy50b2tlbnMpIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gMCAmJiBzdGFydCAhPT0gMCkge1xuICAgICAgICAgIHRva2Vuc1tpZHhdLmlzUHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0b2tlbnNbaWR4XS52YWx1ZSA9IHByZWZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnNbaWR4XS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlcHRoKHRva2Vuc1tpZHhdKTtcbiAgICAgICAgc3RhdGUubWF4RGVwdGggKz0gdG9rZW5zW2lkeF0uZGVwdGg7XG4gICAgICB9XG4gICAgICBpZiAoaWR4ICE9PSAwIHx8IHZhbHVlICE9PSAnJykge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZJbmRleCAmJiBwcmV2SW5kZXggKyAxIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKHByZXZJbmRleCArIDEpO1xuICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzLnRva2Vucykge1xuICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGRlcHRoKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBzdGF0ZS5tYXhEZXB0aCArPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmRlcHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnNsYXNoZXMgPSBzbGFzaGVzO1xuICAgIHN0YXRlLnBhcnRzID0gcGFydHM7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNjYW47XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBQT1NJWF9SRUdFWF9TT1VSQ0UsXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsXG4gIFJFUExBQ0VNRU5UU1xufSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuY29uc3QgZXhwYW5kUmFuZ2UgPSAoYXJncywgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwYW5kUmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5leHBhbmRSYW5nZSguLi5hcmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFyZ3Muc29ydCgpO1xuICBjb25zdCB2YWx1ZSA9IGBbJHthcmdzLmpvaW4oJy0nKX1dYDtcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcgKi9cbiAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gYXJncy5tYXAodiA9PiB1dGlscy5lc2NhcGVSZWdleCh2KSkuam9pbignLi4nKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtZXNzYWdlIGZvciBhIHN5bnRheCBlcnJvclxuICovXG5cbmNvbnN0IHN5bnRheEVycm9yID0gKHR5cGUsIGNoYXIpID0+IHtcbiAgcmV0dXJuIGBNaXNzaW5nICR7dHlwZX06IFwiJHtjaGFyfVwiIC0gdXNlIFwiXFxcXFxcXFwke2NoYXJ9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5jb25zdCBwYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG5cbiAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gTWF0aC5taW4oTUFYX0xFTkdUSCwgb3B0cy5tYXhMZW5ndGgpIDogTUFYX0xFTkdUSDtcblxuICBsZXQgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBpZiAobGVuID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bGVufSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke21heH1gKTtcbiAgfVxuXG4gIGNvbnN0IGJvcyA9IHsgdHlwZTogJ2JvcycsIHZhbHVlOiAnJywgb3V0cHV0OiBvcHRzLnByZXBlbmQgfHwgJycgfTtcbiAgY29uc3QgdG9rZW5zID0gW2Jvc107XG5cbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcbiAgY29uc3Qgd2luMzIgPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIGNvbnN0YW50cyBiYXNlZCBvbiBwbGF0Zm9ybSwgZm9yIHdpbmRvd3Mgb3IgcG9zaXhcbiAgY29uc3QgUExBVEZPUk1fQ0hBUlMgPSBjb25zdGFudHMuZ2xvYkNoYXJzKHdpbjMyKTtcbiAgY29uc3QgRVhUR0xPQl9DSEFSUyA9IGNvbnN0YW50cy5leHRnbG9iQ2hhcnMoUExBVEZPUk1fQ0hBUlMpO1xuXG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBQTFVTX0xJVEVSQUwsXG4gICAgU0xBU0hfTElURVJBTCxcbiAgICBPTkVfQ0hBUixcbiAgICBET1RTX1NMQVNILFxuICAgIE5PX0RPVCxcbiAgICBOT19ET1RfU0xBU0gsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBRTUFSSyxcbiAgICBRTUFSS19OT19ET1QsXG4gICAgU1RBUixcbiAgICBTVEFSVF9BTkNIT1JcbiAgfSA9IFBMQVRGT1JNX0NIQVJTO1xuXG4gIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG4gICAgcmV0dXJuIGAoJHtjYXB0dXJlfSg/Oig/ISR7U1RBUlRfQU5DSE9SfSR7b3B0cy5kb3QgPyBET1RTX1NMQVNIIDogRE9UX0xJVEVSQUx9KS4pKj8pYDtcbiAgfTtcblxuICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gJycgOiBOT19ET1Q7XG4gIGNvbnN0IHFtYXJrTm9Eb3QgPSBvcHRzLmRvdCA/IFFNQVJLIDogUU1BUktfTk9fRE9UO1xuICBsZXQgc3RhciA9IG9wdHMuYmFzaCA9PT0gdHJ1ZSA/IGdsb2JzdGFyKG9wdHMpIDogU1RBUjtcblxuICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuICB9XG5cbiAgLy8gbWluaW1hdGNoIG9wdGlvbnMgc3VwcG9ydFxuICBpZiAodHlwZW9mIG9wdHMubm9leHQgPT09ICdib29sZWFuJykge1xuICAgIG9wdHMubm9leHRnbG9iID0gb3B0cy5ub2V4dDtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlucHV0LFxuICAgIGluZGV4OiAtMSxcbiAgICBzdGFydDogMCxcbiAgICBkb3Q6IG9wdHMuZG90ID09PSB0cnVlLFxuICAgIGNvbnN1bWVkOiAnJyxcbiAgICBvdXRwdXQ6ICcnLFxuICAgIHByZWZpeDogJycsXG4gICAgYmFja3RyYWNrOiBmYWxzZSxcbiAgICBuZWdhdGVkOiBmYWxzZSxcbiAgICBicmFja2V0czogMCxcbiAgICBicmFjZXM6IDAsXG4gICAgcGFyZW5zOiAwLFxuICAgIHF1b3RlczogMCxcbiAgICBnbG9ic3RhcjogZmFsc2UsXG4gICAgdG9rZW5zXG4gIH07XG5cbiAgaW5wdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcbiAgbGVuID0gaW5wdXQubGVuZ3RoO1xuXG4gIGNvbnN0IGV4dGdsb2JzID0gW107XG4gIGNvbnN0IGJyYWNlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgcHJldiA9IGJvcztcbiAgbGV0IHZhbHVlO1xuXG4gIC8qKlxuICAgKiBUb2tlbml6aW5nIGhlbHBlcnNcbiAgICovXG5cbiAgY29uc3QgZW9zID0gKCkgPT4gc3RhdGUuaW5kZXggPT09IGxlbiAtIDE7XG4gIGNvbnN0IHBlZWsgPSBzdGF0ZS5wZWVrID0gKG4gPSAxKSA9PiBpbnB1dFtzdGF0ZS5pbmRleCArIG5dO1xuICBjb25zdCBhZHZhbmNlID0gc3RhdGUuYWR2YW5jZSA9ICgpID0+IGlucHV0Wysrc3RhdGUuaW5kZXhdIHx8ICcnO1xuICBjb25zdCByZW1haW5pbmcgPSAoKSA9PiBpbnB1dC5zbGljZShzdGF0ZS5pbmRleCArIDEpO1xuICBjb25zdCBjb25zdW1lID0gKHZhbHVlID0gJycsIG51bSA9IDApID0+IHtcbiAgICBzdGF0ZS5jb25zdW1lZCArPSB2YWx1ZTtcbiAgICBzdGF0ZS5pbmRleCArPSBudW07XG4gIH07XG5cbiAgY29uc3QgYXBwZW5kID0gdG9rZW4gPT4ge1xuICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuICAgIGNvbnN1bWUodG9rZW4udmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IG5lZ2F0ZSA9ICgpID0+IHtcbiAgICBsZXQgY291bnQgPSAxO1xuXG4gICAgd2hpbGUgKHBlZWsoKSA9PT0gJyEnICYmIChwZWVrKDIpICE9PSAnKCcgfHwgcGVlaygzKSA9PT0gJz8nKSkge1xuICAgICAgYWR2YW5jZSgpO1xuICAgICAgc3RhdGUuc3RhcnQrKztcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRlLm5lZ2F0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgY29uc3QgaW5jcmVtZW50ID0gdHlwZSA9PiB7XG4gICAgc3RhdGVbdHlwZV0rKztcbiAgICBzdGFjay5wdXNoKHR5cGUpO1xuICB9O1xuXG4gIGNvbnN0IGRlY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdLS07XG4gICAgc3RhY2sucG9wKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggdG9rZW5zIG9udG8gdGhlIHRva2VucyBhcnJheS4gVGhpcyBoZWxwZXIgc3BlZWRzIHVwXG4gICAqIHRva2VuaXppbmcgYnkgMSkgaGVscGluZyB1cyBhdm9pZCBiYWNrdHJhY2tpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSxcbiAgICogYW5kIDIpIGhlbHBpbmcgdXMgYXZvaWQgY3JlYXRpbmcgZXh0cmEgdG9rZW5zIHdoZW4gY29uc2VjdXRpdmVcbiAgICogY2hhcmFjdGVycyBhcmUgcGxhaW4gdGV4dC4gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgc2ltcGxpZmllc1xuICAgKiBsb29rYmVoaW5kcy5cbiAgICovXG5cbiAgY29uc3QgcHVzaCA9IHRvayA9PiB7XG4gICAgaWYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJykge1xuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHRvay50eXBlID09PSAnY29tbWEnIHx8IHRvay50eXBlID09PSAnYnJhY2UnKTtcbiAgICAgIGNvbnN0IGlzRXh0Z2xvYiA9IHRvay5leHRnbG9iID09PSB0cnVlIHx8IChleHRnbG9icy5sZW5ndGggJiYgKHRvay50eXBlID09PSAncGlwZScgfHwgdG9rLnR5cGUgPT09ICdwYXJlbicpKTtcblxuICAgICAgaWYgKHRvay50eXBlICE9PSAnc2xhc2gnICYmIHRvay50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2Lm91dHB1dC5sZW5ndGgpO1xuICAgICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgPSAnKic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRnbG9icy5sZW5ndGggJiYgdG9rLnR5cGUgIT09ICdwYXJlbicpIHtcbiAgICAgIGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdLmlubmVyICs9IHRvay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rLnZhbHVlIHx8IHRvay5vdXRwdXQpIGFwcGVuZCh0b2spO1xuICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3RleHQnICYmIHRvay50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHByZXYudmFsdWUgKz0gdG9rLnZhbHVlO1xuICAgICAgcHJldi5vdXRwdXQgPSAocHJldi5vdXRwdXQgfHwgJycpICsgdG9rLnZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRvay5wcmV2ID0gcHJldjtcbiAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgIHByZXYgPSB0b2s7XG4gIH07XG5cbiAgY29uc3QgZXh0Z2xvYk9wZW4gPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IHsgLi4uRVhUR0xPQl9DSEFSU1t2YWx1ZV0sIGNvbmRpdGlvbnM6IDEsIGlubmVyOiAnJyB9O1xuXG4gICAgdG9rZW4ucHJldiA9IHByZXY7XG4gICAgdG9rZW4ucGFyZW5zID0gc3RhdGUucGFyZW5zO1xuICAgIHRva2VuLm91dHB1dCA9IHN0YXRlLm91dHB1dDtcbiAgICBjb25zdCBvdXRwdXQgPSAob3B0cy5jYXB0dXJlID8gJygnIDogJycpICsgdG9rZW4ub3BlbjtcblxuICAgIGluY3JlbWVudCgncGFyZW5zJyk7XG4gICAgcHVzaCh7IHR5cGUsIHZhbHVlLCBvdXRwdXQ6IHN0YXRlLm91dHB1dCA/ICcnIDogT05FX0NIQVIgfSk7XG4gICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIGV4dGdsb2I6IHRydWUsIHZhbHVlOiBhZHZhbmNlKCksIG91dHB1dCB9KTtcbiAgICBleHRnbG9icy5wdXNoKHRva2VuKTtcbiAgfTtcblxuICBjb25zdCBleHRnbG9iQ2xvc2UgPSB0b2tlbiA9PiB7XG4gICAgbGV0IG91dHB1dCA9IHRva2VuLmNsb3NlICsgKG9wdHMuY2FwdHVyZSA/ICcpJyA6ICcnKTtcbiAgICBsZXQgcmVzdDtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbmVnYXRlJykge1xuICAgICAgbGV0IGV4dGdsb2JTdGFyID0gc3RhcjtcblxuICAgICAgaWYgKHRva2VuLmlubmVyICYmIHRva2VuLmlubmVyLmxlbmd0aCA+IDEgJiYgdG9rZW4uaW5uZXIuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICBleHRnbG9iU3RhciA9IGdsb2JzdGFyKG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXh0Z2xvYlN0YXIgIT09IHN0YXIgfHwgZW9zKCkgfHwgL15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpIHtcbiAgICAgICAgb3V0cHV0ID0gdG9rZW4uY2xvc2UgPSBgKSQpKSR7ZXh0Z2xvYlN0YXJ9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLmlubmVyLmluY2x1ZGVzKCcqJykgJiYgKHJlc3QgPSByZW1haW5pbmcoKSkgJiYgL15cXC5bXlxcXFwvLl0rJC8udGVzdChyZXN0KSkge1xuICAgICAgICAvLyBBbnkgbm9uLW1hZ2ljYWwgc3RyaW5nIChgLnRzYCkgb3IgZXZlbiBuZXN0ZWQgZXhwcmVzc2lvbiAoYC57dHMsdHN4fWApIGNhbiBmb2xsb3cgYWZ0ZXIgdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBwYXJzZSB0aGUgc3RyaW5nIGFuZCB1c2UgaXQgaW4gdGhlIG91dHB1dCBvZiB0aGUgb3JpZ2luYWwgcGF0dGVybi5cbiAgICAgICAgLy8gU3VpdGFibGUgcGF0dGVybnM6IGAvISgqLmQpLnRzYCwgYC8hKCouZCkue3RzLHRzeH1gLCBgKiovISgqLWRiZykuQChqcylgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBEaXNhYmxpbmcgdGhlIGBmYXN0cGF0aHNgIG9wdGlvbiBkdWUgdG8gYSBwcm9ibGVtIHdpdGggcGFyc2luZyBzdHJpbmdzIGFzIGAudHNgIGluIHRoZSBwYXR0ZXJuIGxpa2UgYCoqLyEoKi5kKS50c2AuXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShyZXN0LCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSkub3V0cHV0O1xuXG4gICAgICAgIG91dHB1dCA9IHRva2VuLmNsb3NlID0gYCkke2V4cHJlc3Npb259KSR7ZXh0Z2xvYlN0YXJ9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5wcmV2LnR5cGUgPT09ICdib3MnKSB7XG4gICAgICAgIHN0YXRlLm5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dCB9KTtcbiAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGYXN0IHBhdGhzXG4gICAqL1xuXG4gIGlmIChvcHRzLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QoaW5wdXQpKSB7XG4gICAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG5cbiAgICBsZXQgb3V0cHV0ID0gaW5wdXQucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsIChtLCBlc2MsIGNoYXJzLCBmaXJzdCwgcmVzdCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChmaXJzdCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJz8nKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHFtYXJrTm9Eb3QgKyAocmVzdCA/IFFNQVJLLnJlcGVhdChyZXN0Lmxlbmd0aCkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFFNQVJLLnJlcGVhdChjaGFycy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gRE9UX0xJVEVSQUwucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJyonKSB7XG4gICAgICAgIGlmIChlc2MpIHtcbiAgICAgICAgICByZXR1cm4gZXNjICsgZmlyc3QgKyAocmVzdCA/IHN0YXIgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjID8gbSA6IGBcXFxcJHttfWA7XG4gICAgfSk7XG5cbiAgICBpZiAoYmFja3NsYXNoZXMgPT09IHRydWUpIHtcbiAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcKy9nLCBtID0+IHtcbiAgICAgICAgICByZXR1cm4gbS5sZW5ndGggJSAyID09PSAwID8gJ1xcXFxcXFxcJyA6IChtID8gJ1xcXFwnIDogJycpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3V0cHV0ID09PSBpbnB1dCAmJiBvcHRzLmNvbnRhaW5zID09PSB0cnVlKSB7XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBpbnB1dDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5vdXRwdXQgPSB1dGlscy53cmFwT3V0cHV0KG91dHB1dCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2tlbml6ZSBpbnB1dCB1bnRpbCB3ZSByZWFjaCBlbmQtb2Ytc3RyaW5nXG4gICAqL1xuXG4gIHdoaWxlICghZW9zKCkpIHtcbiAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJ1xcdTAwMDAnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1xcXFwnKSB7XG4gICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuXG4gICAgICBpZiAobmV4dCA9PT0gJy8nICYmIG9wdHMuYmFzaCAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgPT09ICcuJyB8fCBuZXh0ID09PSAnOycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmV4dCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29sbGFwc2Ugc2xhc2hlcyB0byByZWR1Y2UgcG90ZW50aWFsIGZvciBleHBsb2l0c1xuICAgICAgY29uc3QgbWF0Y2ggPSAvXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtcbiAgICAgIGxldCBzbGFzaGVzID0gMDtcblxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgc2xhc2hlcyA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgc3RhdGUuaW5kZXggKz0gc2xhc2hlcztcbiAgICAgICAgaWYgKHNsYXNoZXMgJSAyICE9PSAwKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJ1xcXFwnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgICAgIHZhbHVlID0gYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgKz0gYWR2YW5jZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuYnJhY2tldHMgPT09IDApIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGluc2lkZSBhIHJlZ2V4IGNoYXJhY3RlciBjbGFzcywgY29udGludWVcbiAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBicmFja2V0LlxuICAgICAqL1xuXG4gICAgaWYgKHN0YXRlLmJyYWNrZXRzID4gMCAmJiAodmFsdWUgIT09ICddJyB8fCBwcmV2LnZhbHVlID09PSAnWycgfHwgcHJldi52YWx1ZSA9PT0gJ1teJykpIHtcbiAgICAgIGlmIChvcHRzLnBvc2l4ICE9PSBmYWxzZSAmJiB2YWx1ZSA9PT0gJzonKSB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gcHJldi52YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgICBwcmV2LnBvc2l4ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChpbm5lci5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwcmV2LnZhbHVlLmxhc3RJbmRleE9mKCdbJyk7XG4gICAgICAgICAgICBjb25zdCBwcmUgPSBwcmV2LnZhbHVlLnNsaWNlKDAsIGlkeCk7XG4gICAgICAgICAgICBjb25zdCByZXN0ID0gcHJldi52YWx1ZS5zbGljZShpZHggKyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l4ID0gUE9TSVhfUkVHRVhfU09VUkNFW3Jlc3RdO1xuICAgICAgICAgICAgaWYgKHBvc2l4KSB7XG4gICAgICAgICAgICAgIHByZXYudmFsdWUgPSBwcmUgKyBwb3NpeDtcbiAgICAgICAgICAgICAgc3RhdGUuYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuXG4gICAgICAgICAgICAgIGlmICghYm9zLm91dHB1dCAmJiB0b2tlbnMuaW5kZXhPZihwcmV2KSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJvcy5vdXRwdXQgPSBPTkVfQ0hBUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2YWx1ZSA9PT0gJ1snICYmIHBlZWsoKSAhPT0gJzonKSB8fCAodmFsdWUgPT09ICctJyAmJiBwZWVrKCkgPT09ICddJykpIHtcbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAnXScgJiYgKHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5wb3NpeCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gJyEnICYmIHByZXYudmFsdWUgPT09ICdbJykge1xuICAgICAgICB2YWx1ZSA9ICdeJztcbiAgICAgIH1cblxuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW5zaWRlIGEgcXVvdGVkIHN0cmluZywgY29udGludWVcbiAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBkb3VibGUgcXVvdGUuXG4gICAgICovXG5cbiAgICBpZiAoc3RhdGUucXVvdGVzID09PSAxICYmIHZhbHVlICE9PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHV0aWxzLmVzY2FwZVJlZ2V4KHZhbHVlKTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICBhcHBlbmQoeyB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvdWJsZSBxdW90ZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ1wiJykge1xuICAgICAgc3RhdGUucXVvdGVzID0gc3RhdGUucXVvdGVzID09PSAxID8gMCA6IDE7XG4gICAgICBpZiAob3B0cy5rZWVwUXVvdGVzID09PSB0cnVlKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyZW50aGVzZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJygnKSB7XG4gICAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuICAgICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnKScpIHtcbiAgICAgIGlmIChzdGF0ZS5wYXJlbnMgPT09IDAgJiYgb3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ29wZW5pbmcnLCAnKCcpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXh0Z2xvYiA9IGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGV4dGdsb2IgJiYgc3RhdGUucGFyZW5zID09PSBleHRnbG9iLnBhcmVucyArIDEpIHtcbiAgICAgICAgZXh0Z2xvYkNsb3NlKGV4dGdsb2JzLnBvcCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZSwgb3V0cHV0OiBzdGF0ZS5wYXJlbnMgPyAnKScgOiAnXFxcXCknIH0pO1xuICAgICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSBicmFja2V0c1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnWycpIHtcbiAgICAgIGlmIChvcHRzLm5vYnJhY2tldCA9PT0gdHJ1ZSB8fCAhcmVtYWluaW5nKCkuaW5jbHVkZXMoJ10nKSkge1xuICAgICAgICBpZiAob3B0cy5ub2JyYWNrZXQgIT09IHRydWUgJiYgb3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluY3JlbWVudCgnYnJhY2tldHMnKTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdicmFja2V0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICddJykge1xuICAgICAgaWYgKG9wdHMubm9icmFja2V0ID09PSB0cnVlIHx8IChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnICYmIHByZXYudmFsdWUubGVuZ3RoID09PSAxKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiBgXFxcXCR7dmFsdWV9YCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5icmFja2V0cyA9PT0gMCkge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignb3BlbmluZycsICdbJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNyZW1lbnQoJ2JyYWNrZXRzJyk7XG5cbiAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHByZXYudmFsdWUuc2xpY2UoMSk7XG4gICAgICBpZiAocHJldi5wb3NpeCAhPT0gdHJ1ZSAmJiBwcmV2VmFsdWVbMF0gPT09ICdeJyAmJiAhcHJldlZhbHVlLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgICAgdmFsdWUgPSBgLyR7dmFsdWV9YDtcbiAgICAgIH1cblxuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuXG4gICAgICAvLyB3aGVuIGxpdGVyYWwgYnJhY2tldHMgYXJlIGV4cGxpY2l0bHkgZGlzYWJsZWRcbiAgICAgIC8vIGFzc3VtZSB3ZSBzaG91bGQgbWF0Y2ggd2l0aCBhIHJlZ2V4IGNoYXJhY3RlciBjbGFzc1xuICAgICAgaWYgKG9wdHMubGl0ZXJhbEJyYWNrZXRzID09PSBmYWxzZSB8fCB1dGlscy5oYXNSZWdleENoYXJzKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscy5lc2NhcGVSZWdleChwcmV2LnZhbHVlKTtcbiAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAvLyB3aGVuIGxpdGVyYWwgYnJhY2tldHMgYXJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgLy8gYXNzdW1lIHdlIHNob3VsZCBlc2NhcGUgdGhlIGJyYWNrZXRzIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc1xuICAgICAgaWYgKG9wdHMubGl0ZXJhbEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBlc2NhcGVkO1xuICAgICAgICBwcmV2LnZhbHVlID0gZXNjYXBlZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgc3BlY2lmaWVzIG5vdGhpbmcsIHRyeSB0byBtYXRjaCBib3RoXG4gICAgICBwcmV2LnZhbHVlID0gYCgke2NhcHR1cmV9JHtlc2NhcGVkfXwke3ByZXYudmFsdWV9KWA7XG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi52YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJyYWNlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAneycgJiYgb3B0cy5ub2JyYWNlICE9PSB0cnVlKSB7XG4gICAgICBpbmNyZW1lbnQoJ2JyYWNlcycpO1xuXG4gICAgICBjb25zdCBvcGVuID0ge1xuICAgICAgICB0eXBlOiAnYnJhY2UnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3V0cHV0OiAnKCcsXG4gICAgICAgIG91dHB1dEluZGV4OiBzdGF0ZS5vdXRwdXQubGVuZ3RoLFxuICAgICAgICB0b2tlbnNJbmRleDogc3RhdGUudG9rZW5zLmxlbmd0aFxuICAgICAgfTtcblxuICAgICAgYnJhY2VzLnB1c2gob3Blbik7XG4gICAgICBwdXNoKG9wZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnfScpIHtcbiAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKG9wdHMubm9icmFjZSA9PT0gdHJ1ZSB8fCAhYnJhY2UpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0ID0gJyknO1xuXG4gICAgICBpZiAoYnJhY2UuZG90cyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBhcnIgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICAgIGlmIChhcnJbaV0udHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcnJbaV0udHlwZSAhPT0gJ2RvdHMnKSB7XG4gICAgICAgICAgICByYW5nZS51bnNoaWZ0KGFycltpXS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gZXhwYW5kUmFuZ2UocmFuZ2UsIG9wdHMpO1xuICAgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJhY2UuY29tbWEgIT09IHRydWUgJiYgYnJhY2UuZG90cyAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBvdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgYnJhY2Uub3V0cHV0SW5kZXgpO1xuICAgICAgICBjb25zdCB0b2tzID0gc3RhdGUudG9rZW5zLnNsaWNlKGJyYWNlLnRva2Vuc0luZGV4KTtcbiAgICAgICAgYnJhY2UudmFsdWUgPSBicmFjZS5vdXRwdXQgPSAnXFxcXHsnO1xuICAgICAgICB2YWx1ZSA9IG91dHB1dCA9ICdcXFxcfSc7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9IG91dDtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRva3MpIHtcbiAgICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gKHQub3V0cHV0IHx8IHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnYnJhY2UnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgZGVjcmVtZW50KCdicmFjZXMnKTtcbiAgICAgIGJyYWNlcy5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpcGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICd8Jykge1xuICAgICAgaWYgKGV4dGdsb2JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV0uY29uZGl0aW9ucysrO1xuICAgICAgfVxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21tYXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJywnKSB7XG4gICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChicmFjZSAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gJ2JyYWNlcycpIHtcbiAgICAgICAgYnJhY2UuY29tbWEgPSB0cnVlO1xuICAgICAgICBvdXRwdXQgPSAnfCc7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAnY29tbWEnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2xhc2hlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLycpIHtcbiAgICAgIC8vIGlmIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdsb2IgaXMgXCIuL1wiLCBhZHZhbmNlIHRoZSBzdGFydFxuICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCBkb24ndCBhZGQgdGhlIFwiLi9cIiBjaGFyYWN0ZXJzXG4gICAgICAvLyB0byB0aGUgc3RhdGUuIFRoaXMgZ3JlYXRseSBzaW1wbGlmaWVzIGxvb2tiZWhpbmRzIHdoZW5cbiAgICAgIC8vIGNoZWNraW5nIGZvciBCT1MgY2hhcmFjdGVycyBsaWtlIFwiIVwiIGFuZCBcIi5cIiAobm90IFwiLi9cIilcbiAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdkb3QnICYmIHN0YXRlLmluZGV4ID09PSBzdGF0ZS5zdGFydCArIDEpIHtcbiAgICAgICAgc3RhdGUuc3RhcnQgPSBzdGF0ZS5pbmRleCArIDE7XG4gICAgICAgIHN0YXRlLmNvbnN1bWVkID0gJyc7XG4gICAgICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIHByZXYgPSBib3M7IC8vIHJlc2V0IFwicHJldlwiIHRvIHRoZSBmaXJzdCB0b2tlblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlLCBvdXRwdXQ6IFNMQVNIX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb3RzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcuJykge1xuICAgICAgaWYgKHN0YXRlLmJyYWNlcyA+IDAgJiYgcHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgICBpZiAocHJldi52YWx1ZSA9PT0gJy4nKSBwcmV2Lm91dHB1dCA9IERPVF9MSVRFUkFMO1xuICAgICAgICBjb25zdCBicmFjZSA9IGJyYWNlc1ticmFjZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHByZXYudHlwZSA9ICdkb3RzJztcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gdmFsdWU7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIGJyYWNlLmRvdHMgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzdGF0ZS5icmFjZXMgKyBzdGF0ZS5wYXJlbnMpID09PSAwICYmIHByZXYudHlwZSAhPT0gJ2JvcycgJiYgcHJldi50eXBlICE9PSAnc2xhc2gnKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdkb3QnLCB2YWx1ZSwgb3V0cHV0OiBET1RfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXN0aW9uIG1hcmtzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICc/Jykge1xuICAgICAgY29uc3QgaXNHcm91cCA9IHByZXYgJiYgcHJldi52YWx1ZSA9PT0gJygnO1xuICAgICAgaWYgKCFpc0dyb3VwICYmIG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBleHRnbG9iT3BlbigncW1hcmsnLCB2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdwYXJlbicpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHBlZWsoKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSAnPCcgJiYgIXV0aWxzLnN1cHBvcnRzTG9va2JlaGluZHMoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZS5qcyB2MTAgb3IgaGlnaGVyIGlzIHJlcXVpcmVkIGZvciByZWdleCBsb29rYmVoaW5kcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcmV2LnZhbHVlID09PSAnKCcgJiYgIS9bIT08Ol0vLnRlc3QobmV4dCkpIHx8IChuZXh0ID09PSAnPCcgJiYgIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSkpIHtcbiAgICAgICAgICBvdXRwdXQgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5kb3QgIT09IHRydWUgJiYgKHByZXYudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmV2LnR5cGUgPT09ICdib3MnKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3FtYXJrJywgdmFsdWUsIG91dHB1dDogUU1BUktfTk9fRE9UIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhjbGFtYXRpb25cbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJyEnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcpIHtcbiAgICAgICAgaWYgKHBlZWsoMikgIT09ICc/JyB8fCAhL1shPTw6XS8udGVzdChwZWVrKDMpKSkge1xuICAgICAgICAgIGV4dGdsb2JPcGVuKCduZWdhdGUnLCB2YWx1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgc3RhdGUuaW5kZXggPT09IDApIHtcbiAgICAgICAgbmVnYXRlKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsdXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJysnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdwbHVzJywgdmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIHByZXYudmFsdWUgPT09ICcoJykgfHwgb3B0cy5yZWdleCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUsIG91dHB1dDogUExVU19MSVRFUkFMIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdicmFja2V0JyB8fCBwcmV2LnR5cGUgPT09ICdwYXJlbicgfHwgcHJldi50eXBlID09PSAnYnJhY2UnKSkgfHwgc3RhdGUucGFyZW5zID4gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlOiBQTFVTX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0XG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdAJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ2F0JywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHRcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSAhPT0gJyonKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICckJyB8fCB2YWx1ZSA9PT0gJ14nKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlMuZXhlYyhyZW1haW5pbmcoKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFsdWUgKz0gbWF0Y2hbMF07XG4gICAgICAgIHN0YXRlLmluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFyc1xuICAgICAqL1xuXG4gICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJyB8fCBwcmV2LnN0YXIgPT09IHRydWUpKSB7XG4gICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICBwcmV2LnN0YXIgPSB0cnVlO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCByZXN0ID0gcmVtYWluaW5nKCk7XG4gICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIC9eXFwoW14/XS8udGVzdChyZXN0KSkge1xuICAgICAgZXh0Z2xvYk9wZW4oJ3N0YXInLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldi50eXBlID09PSAnc3RhcicpIHtcbiAgICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmlvciA9IHByZXYucHJldjtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHByaW9yLnByZXY7XG4gICAgICBjb25zdCBpc1N0YXJ0ID0gcHJpb3IudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmlvci50eXBlID09PSAnYm9zJztcbiAgICAgIGNvbnN0IGFmdGVyU3RhciA9IGJlZm9yZSAmJiAoYmVmb3JlLnR5cGUgPT09ICdzdGFyJyB8fCBiZWZvcmUudHlwZSA9PT0gJ2dsb2JzdGFyJyk7XG5cbiAgICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUgJiYgKCFpc1N0YXJ0IHx8IChyZXN0WzBdICYmIHJlc3RbMF0gIT09ICcvJykpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHByaW9yLnR5cGUgPT09ICdjb21tYScgfHwgcHJpb3IudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSBleHRnbG9icy5sZW5ndGggJiYgKHByaW9yLnR5cGUgPT09ICdwaXBlJyB8fCBwcmlvci50eXBlID09PSAncGFyZW4nKTtcbiAgICAgIGlmICghaXNTdGFydCAmJiBwcmlvci50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdHJpcCBjb25zZWN1dGl2ZSBgLyoqL2BcbiAgICAgIHdoaWxlIChyZXN0LnNsaWNlKDAsIDMpID09PSAnLyoqJykge1xuICAgICAgICBjb25zdCBhZnRlciA9IGlucHV0W3N0YXRlLmluZGV4ICsgNF07XG4gICAgICAgIGlmIChhZnRlciAmJiBhZnRlciAhPT0gJy8nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMyk7XG4gICAgICAgIGNvbnN1bWUoJy8qKicsIDMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgZW9zKCkpIHtcbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmICFhZnRlclN0YXIgJiYgZW9zKCkpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cykgKyAob3B0cy5zdHJpY3RTbGFzaGVzID8gJyknIDogJ3wkKScpO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dDtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuICAgICAgICBjb25zdCBlbmQgPSByZXN0WzFdICE9PSB2b2lkIDAgPyAnfCQnIDogJyc7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfXwke1NMQVNIX0xJVEVSQUx9JHtlbmR9KWA7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG5cbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlOiAnLycsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgcmVzdFswXSA9PT0gJy8nKSB7XG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCg/Ol58JHtTTEFTSF9MSVRFUkFMfXwke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pYDtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZTogJy8nLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHNpbmdsZSBzdGFyIGZyb20gb3V0cHV0XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLXByZXYub3V0cHV0Lmxlbmd0aCk7XG5cbiAgICAgIC8vIHJlc2V0IHByZXZpb3VzIHRva2VuIHRvIGdsb2JzdGFyXG4gICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgIC8vIHJlc2V0IG91dHB1dCB3aXRoIGdsb2JzdGFyXG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi5vdXRwdXQ7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0geyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6IHN0YXIgfTtcblxuICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUpIHtcbiAgICAgIHRva2VuLm91dHB1dCA9ICcuKj8nO1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2JvcycgfHwgcHJldi50eXBlID09PSAnc2xhc2gnKSB7XG4gICAgICAgIHRva2VuLm91dHB1dCA9IG5vZG90ICsgdG9rZW4ub3V0cHV0O1xuICAgICAgfVxuICAgICAgcHVzaCh0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldiAmJiAocHJldi50eXBlID09PSAnYnJhY2tldCcgfHwgcHJldi50eXBlID09PSAncGFyZW4nKSAmJiBvcHRzLnJlZ2V4ID09PSB0cnVlKSB7XG4gICAgICB0b2tlbi5vdXRwdXQgPSB2YWx1ZTtcbiAgICAgIHB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluZGV4ID09PSBzdGF0ZS5zdGFydCB8fCBwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gTk9fRE9UX1NMQVNIO1xuXG4gICAgICB9IGVsc2UgaWYgKG9wdHMuZG90ID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gbm9kb3Q7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IG5vZG90O1xuICAgICAgfVxuXG4gICAgICBpZiAocGVlaygpICE9PSAnKicpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE9ORV9DSEFSO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBPTkVfQ0hBUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHRva2VuKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFja2V0cyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ10nKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICdbJyk7XG4gICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJyknKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICcoJyk7XG4gICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFjZXMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICd9JykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAneycpO1xuICAgIGRlY3JlbWVudCgnYnJhY2VzJyk7XG4gIH1cblxuICBpZiAob3B0cy5zdHJpY3RTbGFzaGVzICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzdGFyJyB8fCBwcmV2LnR5cGUgPT09ICdicmFja2V0JykpIHtcbiAgICBwdXNoKHsgdHlwZTogJ21heWJlX3NsYXNoJywgdmFsdWU6ICcnLCBvdXRwdXQ6IGAke1NMQVNIX0xJVEVSQUx9P2AgfSk7XG4gIH1cblxuICAvLyByZWJ1aWxkIHRoZSBvdXRwdXQgaWYgd2UgaGFkIHRvIGJhY2t0cmFjayBhdCBhbnkgcG9pbnRcbiAgaWYgKHN0YXRlLmJhY2t0cmFjayA9PT0gdHJ1ZSkge1xuICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdGF0ZS50b2tlbnMpIHtcbiAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodG9rZW4uc3VmZml4KSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5zdWZmaXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBGYXN0IHBhdGhzIGZvciBjcmVhdGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbiAqIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgcHJvY2Vzc2luZyBhbmQgaGFzIHZlcnkgbGl0dGxlIGRvd25zaWRlXG4gKiBpbXBhY3Qgd2hlbiBub25lIG9mIHRoZSBmYXN0IHBhdGhzIG1hdGNoLlxuICovXG5cbnBhcnNlLmZhc3RwYXRocyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGlmIChsZW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsZW59LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7bWF4fWApO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuICBjb25zdCB3aW4zMiA9IHV0aWxzLmlzV2luZG93cyhvcHRpb25zKTtcblxuICAvLyBjcmVhdGUgY29uc3RhbnRzIGJhc2VkIG9uIHBsYXRmb3JtLCBmb3Igd2luZG93cyBvciBwb3NpeFxuICBjb25zdCB7XG4gICAgRE9UX0xJVEVSQUwsXG4gICAgU0xBU0hfTElURVJBTCxcbiAgICBPTkVfQ0hBUixcbiAgICBET1RTX1NMQVNILFxuICAgIE5PX0RPVCxcbiAgICBOT19ET1RTLFxuICAgIE5PX0RPVFNfU0xBU0gsXG4gICAgU1RBUixcbiAgICBTVEFSVF9BTkNIT1JcbiAgfSA9IGNvbnN0YW50cy5nbG9iQ2hhcnMod2luMzIpO1xuXG4gIGNvbnN0IG5vZG90ID0gb3B0cy5kb3QgPyBOT19ET1RTIDogTk9fRE9UO1xuICBjb25zdCBzbGFzaERvdCA9IG9wdHMuZG90ID8gTk9fRE9UU19TTEFTSCA6IE5PX0RPVDtcbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcbiAgY29uc3Qgc3RhdGUgPSB7IG5lZ2F0ZWQ6IGZhbHNlLCBwcmVmaXg6ICcnIH07XG4gIGxldCBzdGFyID0gb3B0cy5iYXNoID09PSB0cnVlID8gJy4qPycgOiBTVEFSO1xuXG4gIGlmIChvcHRzLmNhcHR1cmUpIHtcbiAgICBzdGFyID0gYCgke3N0YXJ9KWA7XG4gIH1cblxuICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPT4ge1xuICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHJldHVybiBzdGFyO1xuICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlID0gc3RyID0+IHtcbiAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcuKic6XG4gICAgICAgIHJldHVybiBgJHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqLionOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtzdGFyfSR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKi8qJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7c3Rhcn0ke1NMQVNIX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3NsYXNoRG90fSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKic6XG4gICAgICAgIHJldHVybiBub2RvdCArIGdsb2JzdGFyKG9wdHMpO1xuXG4gICAgICBjYXNlICcqKi8qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKi8qLionOlxuICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke3NsYXNoRG90fSR7c3Rhcn0ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyoqLy4qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL14oLio/KVxcLihcXHcrKSQvLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNyZWF0ZShtYXRjaFsxXSk7XG4gICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZSArIERPVF9MSVRFUkFMICsgbWF0Y2hbMl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IHV0aWxzLnJlbW92ZVByZWZpeChpbnB1dCwgc3RhdGUpO1xuICBsZXQgc291cmNlID0gY3JlYXRlKG91dHB1dCk7XG5cbiAgaWYgKHNvdXJjZSAmJiBvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUpIHtcbiAgICBzb3VyY2UgKz0gYCR7U0xBU0hfTElURVJBTH0/YDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHNjYW4gPSByZXF1aXJlKCcuL3NjYW4nKTtcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgaXNPYmplY3QgPSB2YWwgPT4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdGNoZXIgZnVuY3Rpb24gZnJvbSBvbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLiBUaGVcbiAqIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBpcyBhIG1hdGNoLiBUaGUgcmV0dXJuZWQgbWF0Y2hlclxuICogZnVuY3Rpb24gYWxzbyB0YWtlcyBhIGJvb2xlYW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0aGF0LCB3aGVuIHRydWUsXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoKGdsb2JbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgaXNNYXRjaCA9IHBpY29tYXRjaCgnKi4hKCphKScpO1xuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5hJykpOyAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmInKSk7IC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAbmFtZSBwaWNvbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBgZ2xvYnNgIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMuXG4gKiBAcGFyYW0ge09iamVjdD19IGBvcHRpb25zYFxuICogQHJldHVybiB7RnVuY3Rpb249fSBSZXR1cm5zIGEgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuY29uc3QgcGljb21hdGNoID0gKGdsb2IsIG9wdGlvbnMsIHJldHVyblN0YXRlID0gZmFsc2UpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYikpIHtcbiAgICBjb25zdCBmbnMgPSBnbG9iLm1hcChpbnB1dCA9PiBwaWNvbWF0Y2goaW5wdXQsIG9wdGlvbnMsIHJldHVyblN0YXRlKSk7XG4gICAgY29uc3QgYXJyYXlNYXRjaGVyID0gc3RyID0+IHtcbiAgICAgIGZvciAoY29uc3QgaXNNYXRjaCBvZiBmbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpc01hdGNoKHN0cik7XG4gICAgICAgIGlmIChzdGF0ZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5TWF0Y2hlcjtcbiAgfVxuXG4gIGNvbnN0IGlzU3RhdGUgPSBpc09iamVjdChnbG9iKSAmJiBnbG9iLnRva2VucyAmJiBnbG9iLmlucHV0O1xuXG4gIGlmIChnbG9iID09PSAnJyB8fCAodHlwZW9mIGdsb2IgIT09ICdzdHJpbmcnICYmICFpc1N0YXRlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gIH1cblxuICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcG9zaXggPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2V4ID0gaXNTdGF0ZVxuICAgID8gcGljb21hdGNoLmNvbXBpbGVSZShnbG9iLCBvcHRpb25zKVxuICAgIDogcGljb21hdGNoLm1ha2VSZShnbG9iLCBvcHRpb25zLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgY29uc3Qgc3RhdGUgPSByZWdleC5zdGF0ZTtcbiAgZGVsZXRlIHJlZ2V4LnN0YXRlO1xuXG4gIGxldCBpc0lnbm9yZWQgPSAoKSA9PiBmYWxzZTtcbiAgaWYgKG9wdHMuaWdub3JlKSB7XG4gICAgY29uc3QgaWdub3JlT3B0cyA9IHsgLi4ub3B0aW9ucywgaWdub3JlOiBudWxsLCBvbk1hdGNoOiBudWxsLCBvblJlc3VsdDogbnVsbCB9O1xuICAgIGlzSWdub3JlZCA9IHBpY29tYXRjaChvcHRzLmlnbm9yZSwgaWdub3JlT3B0cywgcmV0dXJuU3RhdGUpO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlciA9IChpbnB1dCwgcmV0dXJuT2JqZWN0ID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IGlzTWF0Y2gsIG1hdGNoLCBvdXRwdXQgfSA9IHBpY29tYXRjaC50ZXN0KGlucHV0LCByZWdleCwgb3B0aW9ucywgeyBnbG9iLCBwb3NpeCB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7IGdsb2IsIHN0YXRlLCByZWdleCwgcG9zaXgsIGlucHV0LCBvdXRwdXQsIG1hdGNoLCBpc01hdGNoIH07XG5cbiAgICBpZiAodHlwZW9mIG9wdHMub25SZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdHMub25SZXN1bHQocmVzdWx0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXRjaCA9PT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmV0dXJuT2JqZWN0ID8gcmVzdWx0IDogZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzSWdub3JlZChpbnB1dCkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5vbklnbm9yZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzLm9uSWdub3JlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5vbk1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLm9uTWF0Y2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IHRydWU7XG4gIH07XG5cbiAgaWYgKHJldHVyblN0YXRlKSB7XG4gICAgbWF0Y2hlci5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXI7XG59O1xuXG4vKipcbiAqIFRlc3QgYGlucHV0YCB3aXRoIHRoZSBnaXZlbiBgcmVnZXhgLiBUaGlzIGlzIHVzZWQgYnkgdGhlIG1haW5cbiAqIGBwaWNvbWF0Y2goKWAgZnVuY3Rpb24gdG8gdGVzdCB0aGUgaW5wdXQgc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC50ZXN0KGlucHV0LCByZWdleFssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gudGVzdCgnZm9vL2JhcicsIC9eKD86KFteL10qPylcXC8oW14vXSo/KSkkLykpO1xuICogLy8geyBpc01hdGNoOiB0cnVlLCBtYXRjaDogWyAnZm9vLycsICdmb28nLCAnYmFyJyBdLCBvdXRwdXQ6ICdmb28vYmFyJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIFN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtSZWdFeHB9IGByZWdleGBcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBtYXRjaGluZyBpbmZvLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gudGVzdCA9IChpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHsgZ2xvYiwgcG9zaXggfSA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICByZXR1cm4geyBpc01hdGNoOiBmYWxzZSwgb3V0cHV0OiAnJyB9O1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGZvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IChwb3NpeCA/IHV0aWxzLnRvUG9zaXhTbGFzaGVzIDogbnVsbCk7XG4gIGxldCBtYXRjaCA9IGlucHV0ID09PSBnbG9iO1xuICBsZXQgb3V0cHV0ID0gKG1hdGNoICYmIGZvcm1hdCkgPyBmb3JtYXQoaW5wdXQpIDogaW5wdXQ7XG5cbiAgaWYgKG1hdGNoID09PSBmYWxzZSkge1xuICAgIG91dHB1dCA9IGZvcm1hdCA/IGZvcm1hdChpbnB1dCkgOiBpbnB1dDtcbiAgICBtYXRjaCA9IG91dHB1dCA9PT0gZ2xvYjtcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gZmFsc2UgfHwgb3B0cy5jYXB0dXJlID09PSB0cnVlKSB7XG4gICAgaWYgKG9wdHMubWF0Y2hCYXNlID09PSB0cnVlIHx8IG9wdHMuYmFzZW5hbWUgPT09IHRydWUpIHtcbiAgICAgIG1hdGNoID0gcGljb21hdGNoLm1hdGNoQmFzZShpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHBvc2l4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSByZWdleC5leGVjKG91dHB1dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgaXNNYXRjaDogQm9vbGVhbihtYXRjaCksIG1hdGNoLCBvdXRwdXQgfTtcbn07XG5cbi8qKlxuICogTWF0Y2ggdGhlIGJhc2VuYW1lIG9mIGEgZmlsZXBhdGguXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLm1hdGNoQmFzZShpbnB1dCwgZ2xvYlssIG9wdGlvbnNdKTtcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5tYXRjaEJhc2UoJ2Zvby9iYXIuanMnLCAnKi5qcycpOyAvLyB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIFN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBgZ2xvYmAgR2xvYiBwYXR0ZXJuIG9yIHJlZ2V4IGNyZWF0ZWQgYnkgWy5tYWtlUmVdKCNtYWtlUmUpLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLm1hdGNoQmFzZSA9IChpbnB1dCwgZ2xvYiwgb3B0aW9ucywgcG9zaXggPSB1dGlscy5pc1dpbmRvd3Mob3B0aW9ucykpID0+IHtcbiAgY29uc3QgcmVnZXggPSBnbG9iIGluc3RhbmNlb2YgUmVnRXhwID8gZ2xvYiA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucyk7XG4gIHJldHVybiByZWdleC50ZXN0KHBhdGguYmFzZW5hbWUoaW5wdXQpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmICoqYW55Kiogb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYCBtYXRjaCB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5pc01hdGNoKHN0cmluZywgcGF0dGVybnNbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLmlzTWF0Y2goJ2EuYScsIFsnYi4qJywgJyouYSddKSk7IC8vPT4gdHJ1ZVxuICogY29uc29sZS5sb2cocGljb21hdGNoLmlzTWF0Y2goJ2EuYScsICdiLionKSk7IC8vPT4gZmFsc2VcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHN0ciBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGF0dGVybnMgT25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucyB0byB1c2UgZm9yIG1hdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBTZWUgYXZhaWxhYmxlIFtvcHRpb25zXSgjb3B0aW9ucykuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5pc01hdGNoID0gKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHBpY29tYXRjaChwYXR0ZXJucywgb3B0aW9ucykoc3RyKTtcblxuLyoqXG4gKiBQYXJzZSBhIGdsb2IgcGF0dGVybiB0byBjcmVhdGUgdGhlIHNvdXJjZSBzdHJpbmcgZm9yIGEgcmVndWxhclxuICogZXhwcmVzc2lvbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiBjb25zdCByZXN1bHQgPSBwaWNvbWF0Y2gucGFyc2UocGF0dGVyblssIG9wdGlvbnNdKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHVzZWZ1bCBwcm9wZXJ0aWVzIGFuZCBvdXRwdXQgdG8gYmUgdXNlZCBhcyBhIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5wYXJzZSA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSByZXR1cm4gcGF0dGVybi5tYXAocCA9PiBwaWNvbWF0Y2gucGFyc2UocCwgb3B0aW9ucykpO1xuICByZXR1cm4gcGFyc2UocGF0dGVybiwgeyAuLi5vcHRpb25zLCBmYXN0cGF0aHM6IGZhbHNlIH0pO1xufTtcblxuLyoqXG4gKiBTY2FuIGEgZ2xvYiBwYXR0ZXJuIHRvIHNlcGFyYXRlIHRoZSBwYXR0ZXJuIGludG8gc2VnbWVudHMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLnNjYW4oaW5wdXRbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gcGljb21hdGNoLnNjYW4oJyEuL2Zvby8qLmpzJyk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogeyBwcmVmaXg6ICchLi8nLFxuICogICBpbnB1dDogJyEuL2Zvby8qLmpzJyxcbiAqICAgc3RhcnQ6IDMsXG4gKiAgIGJhc2U6ICdmb28nLFxuICogICBnbG9iOiAnKi5qcycsXG4gKiAgIGlzQnJhY2U6IGZhbHNlLFxuICogICBpc0JyYWNrZXQ6IGZhbHNlLFxuICogICBpc0dsb2I6IHRydWUsXG4gKiAgIGlzRXh0Z2xvYjogZmFsc2UsXG4gKiAgIGlzR2xvYnN0YXI6IGZhbHNlLFxuICogICBuZWdhdGVkOiB0cnVlIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgR2xvYiBwYXR0ZXJuIHRvIHNjYW4uXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHNjYW4oaW5wdXQsIG9wdGlvbnMpO1xuXG4vKipcbiAqIENvbXBpbGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGUgYHN0YXRlYCBvYmplY3QgcmV0dXJuZWQgYnkgdGhlXG4gKiBbcGFyc2UoKV0oI3BhcnNlKSBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBzdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVybk91dHB1dGAgSW50ZW5kZWQgZm9yIGltcGxlbWVudG9ycywgdGhpcyBhcmd1bWVudCBhbGxvd3MgeW91IHRvIHJldHVybiB0aGUgcmF3IG91dHB1dCBmcm9tIHRoZSBwYXJzZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5TdGF0ZWAgQWRkcyB0aGUgc3RhdGUgdG8gYSBgc3RhdGVgIHByb3BlcnR5IG9uIHRoZSByZXR1cm5lZCByZWdleC4gVXNlZnVsIGZvciBpbXBsZW1lbnRvcnMgYW5kIGRlYnVnZ2luZy5cbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLmNvbXBpbGVSZSA9IChzdGF0ZSwgb3B0aW9ucywgcmV0dXJuT3V0cHV0ID0gZmFsc2UsIHJldHVyblN0YXRlID0gZmFsc2UpID0+IHtcbiAgaWYgKHJldHVybk91dHB1dCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzdGF0ZS5vdXRwdXQ7XG4gIH1cblxuICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcHJlcGVuZCA9IG9wdHMuY29udGFpbnMgPyAnJyA6ICdeJztcbiAgY29uc3QgYXBwZW5kID0gb3B0cy5jb250YWlucyA/ICcnIDogJyQnO1xuXG4gIGxldCBzb3VyY2UgPSBgJHtwcmVwZW5kfSg/OiR7c3RhdGUub3V0cHV0fSkke2FwcGVuZH1gO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUubmVnYXRlZCA9PT0gdHJ1ZSkge1xuICAgIHNvdXJjZSA9IGBeKD8hJHtzb3VyY2V9KS4qJGA7XG4gIH1cblxuICBjb25zdCByZWdleCA9IHBpY29tYXRjaC50b1JlZ2V4KHNvdXJjZSwgb3B0aW9ucyk7XG4gIGlmIChyZXR1cm5TdGF0ZSA9PT0gdHJ1ZSkge1xuICAgIHJlZ2V4LnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICByZXR1cm4gcmVnZXg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIGEgcGFyc2VkIGdsb2IgcGF0dGVybi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiBjb25zdCBzdGF0ZSA9IHBpY29tYXRjaC5wYXJzZSgnKi5qcycpO1xuICogLy8gcGljb21hdGNoLmNvbXBpbGVSZShzdGF0ZVssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guY29tcGlsZVJlKHN0YXRlKSk7XG4gKiAvLz0+IC9eKD86KD8hXFwuKSg/PS4pW14vXSo/XFwuanMpJC9cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdGF0ZWAgVGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBgLnBhcnNlYCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5PdXRwdXRgIEltcGxlbWVudG9ycyBtYXkgdXNlIHRoaXMgYXJndW1lbnQgdG8gcmV0dXJuIHRoZSBjb21waWxlZCBvdXRwdXQsIGluc3RlYWQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb24uIFRoaXMgaXMgbm90IGV4cG9zZWQgb24gdGhlIG9wdGlvbnMgdG8gcHJldmVudCBlbmQtdXNlcnMgZnJvbSBtdXRhdGluZyB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuU3RhdGVgIEltcGxlbWVudG9ycyBtYXkgdXNlIHRoaXMgYXJndW1lbnQgdG8gcmV0dXJuIHRoZSBzdGF0ZSBmcm9tIHRoZSBwYXJzZWQgZ2xvYiB3aXRoIHRoZSByZXR1cm5lZCByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAcmV0dXJuIHtSZWdFeHB9IFJldHVybnMgYSByZWdleCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHBhdHRlcm4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5tYWtlUmUgPSAoaW5wdXQsIG9wdGlvbnMgPSB7fSwgcmV0dXJuT3V0cHV0ID0gZmFsc2UsIHJldHVyblN0YXRlID0gZmFsc2UpID0+IHtcbiAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgcGFyc2VkID0geyBuZWdhdGVkOiBmYWxzZSwgZmFzdHBhdGhzOiB0cnVlIH07XG5cbiAgaWYgKG9wdGlvbnMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAoaW5wdXRbMF0gPT09ICcuJyB8fCBpbnB1dFswXSA9PT0gJyonKSkge1xuICAgIHBhcnNlZC5vdXRwdXQgPSBwYXJzZS5mYXN0cGF0aHMoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFwYXJzZWQub3V0cHV0KSB7XG4gICAgcGFyc2VkID0gcGFyc2UoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUocGFyc2VkLCBvcHRpb25zLCByZXR1cm5PdXRwdXQsIHJldHVyblN0YXRlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogLy8gcGljb21hdGNoLnRvUmVnZXgoc291cmNlWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IHsgb3V0cHV0IH0gPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC50b1JlZ2V4KG91dHB1dCkpO1xuICogLy89PiAvXig/Oig/IVxcLikoPz0uKVteL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc291cmNlYCBSZWd1bGFyIGV4cHJlc3Npb24gc291cmNlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnRvUmVnZXggPSAoc291cmNlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCBvcHRzLmZsYWdzIHx8IChvcHRzLm5vY2FzZSA/ICdpJyA6ICcnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcgPT09IHRydWUpIHRocm93IGVycjtcbiAgICByZXR1cm4gLyReLztcbiAgfVxufTtcblxuLyoqXG4gKiBQaWNvbWF0Y2ggY29uc3RhbnRzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbnBpY29tYXRjaC5jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbi8qKlxuICogRXhwb3NlIFwicGljb21hdGNoXCJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY29tYXRjaDtcbiIsICIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcGljb21hdGNoJyk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcG0gPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncGljb21hdGNoJykpO1xuXG5jb25zdCBhZGRFeHRlbnNpb24gPSBmdW5jdGlvbiBhZGRFeHRlbnNpb24oZmlsZW5hbWUsIGV4dCA9ICcuanMnKSB7XG4gICAgbGV0IHJlc3VsdCA9IGAke2ZpbGVuYW1lfWA7XG4gICAgaWYgKCFwYXRoLmV4dG5hbWUoZmlsZW5hbWUpKVxuICAgICAgICByZXN1bHQgKz0gZXh0O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB3YWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRyZXR1cm4gdmlzaXQoYXN0LCBudWxsLCBlbnRlciwgbGVhdmUpO1xufVxuXG5sZXQgc2hvdWxkX3NraXAgPSBmYWxzZTtcbmxldCBzaG91bGRfcmVtb3ZlID0gZmFsc2U7XG5sZXQgcmVwbGFjZW1lbnQgPSBudWxsO1xuY29uc3QgY29udGV4dCA9IHtcblx0c2tpcDogKCkgPT4gc2hvdWxkX3NraXAgPSB0cnVlLFxuXHRyZW1vdmU6ICgpID0+IHNob3VsZF9yZW1vdmUgPSB0cnVlLFxuXHRyZXBsYWNlOiAobm9kZSkgPT4gcmVwbGFjZW1lbnQgPSBub2RlXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpIHtcblx0aWYgKHBhcmVudCkge1xuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0cGFyZW50W3Byb3BdW2luZGV4XSA9IG5vZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmVudFtwcm9wXSA9IG5vZGU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShwYXJlbnQsIHByb3AsIGluZGV4KSB7XG5cdGlmIChwYXJlbnQpIHtcblx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdHBhcmVudFtwcm9wXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgcGFyZW50W3Byb3BdO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiB2aXNpdChcblx0bm9kZSxcblx0cGFyZW50LFxuXHRlbnRlcixcblx0bGVhdmUsXG5cdHByb3AsXG5cdGluZGV4XG4pIHtcblx0aWYgKG5vZGUpIHtcblx0XHRpZiAoZW50ZXIpIHtcblx0XHRcdGNvbnN0IF9zaG91bGRfc2tpcCA9IHNob3VsZF9za2lwO1xuXHRcdFx0Y29uc3QgX3Nob3VsZF9yZW1vdmUgPSBzaG91bGRfcmVtb3ZlO1xuXHRcdFx0Y29uc3QgX3JlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRzaG91bGRfc2tpcCA9IGZhbHNlO1xuXHRcdFx0c2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0cmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0XHRlbnRlci5jYWxsKGNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXG5cdFx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0bm9kZSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRyZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRyZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNraXBwZWQgPSBzaG91bGRfc2tpcDtcblx0XHRcdGNvbnN0IHJlbW92ZWQgPSBzaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRzaG91bGRfc2tpcCA9IF9zaG91bGRfc2tpcDtcblx0XHRcdHNob3VsZF9yZW1vdmUgPSBfc2hvdWxkX3JlbW92ZTtcblx0XHRcdHJlcGxhY2VtZW50ID0gX3JlcGxhY2VtZW50O1xuXG5cdFx0XHRpZiAoc2tpcHBlZCkgcmV0dXJuIG5vZGU7XG5cdFx0XHRpZiAocmVtb3ZlZCkgcmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSAobm9kZSApW2tleV07XG5cblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgayA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGogKz0gMSwgayArPSAxKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlW2pdICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZVtqXS50eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0aWYgKCF2aXNpdCh2YWx1ZVtqXSwgbm9kZSwgZW50ZXIsIGxlYXZlLCBrZXksIGspKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZWRcblx0XHRcdFx0XHRcdFx0ai0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmlzaXQodmFsdWUsIG5vZGUsIGVudGVyLCBsZWF2ZSwga2V5LCBudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGVhdmUpIHtcblx0XHRcdGNvbnN0IF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50O1xuXHRcdFx0Y29uc3QgX3Nob3VsZF9yZW1vdmUgPSBzaG91bGRfcmVtb3ZlO1xuXHRcdFx0cmVwbGFjZW1lbnQgPSBudWxsO1xuXHRcdFx0c2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRsZWF2ZS5jYWxsKGNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXG5cdFx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0bm9kZSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRyZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRyZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlbW92ZWQgPSBzaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRyZXBsYWNlbWVudCA9IF9yZXBsYWNlbWVudDtcblx0XHRcdHNob3VsZF9yZW1vdmUgPSBfc2hvdWxkX3JlbW92ZTtcblxuXHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBub2RlO1xufVxuXG5jb25zdCBleHRyYWN0b3JzID0ge1xuICAgIEFycmF5UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcmFtLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICBleHRyYWN0b3JzW2VsZW1lbnQudHlwZV0obmFtZXMsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBc3NpZ25tZW50UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZXh0cmFjdG9yc1twYXJhbS5sZWZ0LnR5cGVdKG5hbWVzLCBwYXJhbS5sZWZ0KTtcbiAgICB9LFxuICAgIElkZW50aWZpZXIobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIG5hbWVzLnB1c2gocGFyYW0ubmFtZSk7XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uKCkgeyB9LFxuICAgIE9iamVjdFBhdHRlcm4obmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFR5cGVzY3JpcHQgcmVwb3J0cyB0aGF0IHRoaXMgaXMgbm90IGEgdmFsaWQgdHlwZVxuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RvcnMuUmVzdEVsZW1lbnQobmFtZXMsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdG9yc1twcm9wLnZhbHVlLnR5cGVdKG5hbWVzLCBwcm9wLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgUmVzdEVsZW1lbnQobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGV4dHJhY3RvcnNbcGFyYW0uYXJndW1lbnQudHlwZV0obmFtZXMsIHBhcmFtLmFyZ3VtZW50KTtcbiAgICB9XG59O1xuY29uc3QgZXh0cmFjdEFzc2lnbmVkTmFtZXMgPSBmdW5jdGlvbiBleHRyYWN0QXNzaWduZWROYW1lcyhwYXJhbSkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgZXh0cmFjdG9yc1twYXJhbS50eXBlXShuYW1lcywgcGFyYW0pO1xuICAgIHJldHVybiBuYW1lcztcbn07XG5cbmNvbnN0IGJsb2NrRGVjbGFyYXRpb25zID0ge1xuICAgIGNvbnN0OiB0cnVlLFxuICAgIGxldDogdHJ1ZVxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrU2NvcGUgPSAhIW9wdGlvbnMuYmxvY2s7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RBc3NpZ25lZE5hbWVzKHBhcmFtKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKG5vZGUsIGlzQmxvY2tEZWNsYXJhdGlvbiwgaXNWYXIpIHtcbiAgICAgICAgaWYgKCFpc0Jsb2NrRGVjbGFyYXRpb24gJiYgdGhpcy5pc0Jsb2NrU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgYSBgdmFyYCBvciBmdW5jdGlvbiBub2RlLCBhbmQgdGhpc1xuICAgICAgICAgICAgLy8gaXMgYSBibG9jayBzY29wZSwgc28gd2UgbmVlZCB0byBnbyB1cFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYWRkRGVjbGFyYXRpb24obm9kZSwgaXNCbG9ja0RlY2xhcmF0aW9uLCBpc1Zhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5pZCkge1xuICAgICAgICAgICAgZXh0cmFjdEFzc2lnbmVkTmFtZXMobm9kZS5pZCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5zKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdIHx8ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNvbnRhaW5zKG5hbWUpIDogZmFsc2UpO1xuICAgIH1cbn1cbmNvbnN0IGF0dGFjaFNjb3BlcyA9IGZ1bmN0aW9uIGF0dGFjaFNjb3Blcyhhc3QsIHByb3BlcnR5TmFtZSA9ICdzY29wZScpIHtcbiAgICBsZXQgc2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICB3YWxrKGFzdCwge1xuICAgICAgICBlbnRlcihuLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuO1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24gZm9vICgpIHsuLi59XG4gICAgICAgICAgICAvLyBjbGFzcyBGb28gey4uLn1cbiAgICAgICAgICAgIGlmICgvKEZ1bmN0aW9ufENsYXNzKURlY2xhcmF0aW9uLy50ZXN0KG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5hZGREZWNsYXJhdGlvbihub2RlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIGZvbyA9IDFcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2luZCB9ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Jsb2NrRGVjbGFyYXRpb24gPSBibG9ja0RlY2xhcmF0aW9uc1traW5kXTtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgY29uc3QvbGV0IGRlY2xhcmF0aW9ucyBpbiB0aGUgYm9keSBvZiBhIGZvciBsb29wICMxMTNcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50ID8gcGFyZW50LnR5cGUgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoIShpc0Jsb2NrRGVjbGFyYXRpb24gJiYgL0Zvck9mU3RhdGVtZW50Ly50ZXN0KHBhcmVudFR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWRkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIGlzQmxvY2tEZWNsYXJhdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTY29wZTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZnVuY3Rpb24gc2NvcGVcbiAgICAgICAgICAgIGlmICgvRnVuY3Rpb24vLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gbmV3IFNjb3BlKHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGZ1bmMucGFyYW1zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbmFtZWQgZnVuY3Rpb24gZXhwcmVzc2lvbnMgLSB0aGUgbmFtZSBpcyBjb25zaWRlcmVkXG4gICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgZnVuY3Rpb24ncyBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChmdW5jLnR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nICYmIGZ1bmMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUuYWRkRGVjbGFyYXRpb24oZnVuYywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGJsb2NrIHNjb3BlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnICYmICEvRnVuY3Rpb24vLnRlc3QocGFyZW50LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2F0Y2ggY2xhdXNlIGhhcyBpdHMgb3duIGJsb2NrIHNjb3BlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQ2F0Y2hDbGF1c2UnKSB7XG4gICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IG5vZGUucGFyYW0gPyBbbm9kZS5wYXJhbV0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTY29wZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1Njb3BlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZShuKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbjtcbiAgICAgICAgICAgIGlmIChub2RlW3Byb3BlcnR5TmFtZV0pXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2NvcGU7XG59O1xuXG4vLyBIZWxwZXIgc2luY2UgVHlwZXNjcmlwdCBjYW4ndCBkZXRlY3QgcmVhZG9ubHkgYXJyYXlzIHdpdGggQXJyYXkuaXNBcnJheVxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xufVxuZnVuY3Rpb24gZW5zdXJlQXJyYXkodGhpbmcpIHtcbiAgICBpZiAoaXNBcnJheSh0aGluZykpXG4gICAgICAgIHJldHVybiB0aGluZztcbiAgICBpZiAodGhpbmcgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbdGhpbmddO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVyU3RyaW5nKGlkLCByZXNvbHV0aW9uQmFzZSkge1xuICAgIGlmIChyZXNvbHV0aW9uQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvLyByZXNvbHZlKCcnKSBpcyB2YWxpZCBhbmQgd2lsbCBkZWZhdWx0IHRvIHByb2Nlc3MuY3dkKClcbiAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGgucmVzb2x2ZShyZXNvbHV0aW9uQmFzZSB8fCAnJylcbiAgICAgICAgLnNwbGl0KHBhdGguc2VwKVxuICAgICAgICAuam9pbignLycpXG4gICAgICAgIC8vIGVzY2FwZSBhbGwgcG9zc2libGUgKHBvc2l4ICsgd2luKSBwYXRoIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBpbnRlcmZlcmUgd2l0aCByZWdleFxuICAgICAgICAucmVwbGFjZSgvWy1eJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgdXNlIHBvc2l4LmpvaW4gYmVjYXVzZTpcbiAgICAvLyAxLiB0aGUgYmFzZVBhdGggaGFzIGJlZW4gbm9ybWFsaXplZCB0byB1c2UgL1xuICAgIC8vIDIuIHRoZSBpbmNvbWluZyBnbG9iIChpZCkgbWF0Y2hlciwgYWxzbyB1c2VzIC9cbiAgICAvLyBvdGhlcndpc2UgTm9kZSB3aWxsIGZvcmNlIGJhY2tzbGFzaCAoXFwpIG9uIHdpbmRvd3NcbiAgICByZXR1cm4gcGF0aC5wb3NpeC5qb2luKGJhc2VQYXRoLCBpZCk7XG59XG5jb25zdCBjcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoaW5jbHVkZSwgZXhjbHVkZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdXRpb25CYXNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc29sdmU7XG4gICAgY29uc3QgZ2V0TWF0Y2hlciA9IChpZCkgPT4gaWQgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgPyBpZFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHRlc3Q6ICh3aGF0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyByZWZhY3RvciBpcyBhIHRhZCBvdmVybHkgdmVyYm9zZSBidXQgbWFrZXMgZm9yIGVhc3kgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGdldE1hdGNoZXJTdHJpbmcoaWQsIHJlc29sdXRpb25CYXNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHBtKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHdoYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgY29uc3QgaW5jbHVkZU1hdGNoZXJzID0gZW5zdXJlQXJyYXkoaW5jbHVkZSkubWFwKGdldE1hdGNoZXIpO1xuICAgIGNvbnN0IGV4Y2x1ZGVNYXRjaGVycyA9IGVuc3VyZUFycmF5KGV4Y2x1ZGUpLm1hcChnZXRNYXRjaGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVzdWx0KGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoL1xcMC8udGVzdChpZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhdGhJZCA9IGlkLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhjbHVkZU1hdGNoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gZXhjbHVkZU1hdGNoZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIudGVzdChwYXRoSWQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluY2x1ZGVNYXRjaGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IGluY2x1ZGVNYXRjaGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyLnRlc3QocGF0aElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWluY2x1ZGVNYXRjaGVycy5sZW5ndGg7XG4gICAgfTtcbn07XG5cbmNvbnN0IHJlc2VydmVkV29yZHMgPSAnYnJlYWsgY2FzZSBjbGFzcyBjYXRjaCBjb25zdCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRlbGV0ZSBkbyBlbHNlIGV4cG9ydCBleHRlbmRzIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGltcG9ydCBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN1cGVyIHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdmFyIHZvaWQgd2hpbGUgd2l0aCB5aWVsZCBlbnVtIGF3YWl0IGltcGxlbWVudHMgcGFja2FnZSBwcm90ZWN0ZWQgc3RhdGljIGludGVyZmFjZSBwcml2YXRlIHB1YmxpYyc7XG5jb25zdCBidWlsdGlucyA9ICdhcmd1bWVudHMgSW5maW5pdHkgTmFOIHVuZGVmaW5lZCBudWxsIHRydWUgZmFsc2UgZXZhbCB1bmV2YWwgaXNGaW5pdGUgaXNOYU4gcGFyc2VGbG9hdCBwYXJzZUludCBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgZXNjYXBlIHVuZXNjYXBlIE9iamVjdCBGdW5jdGlvbiBCb29sZWFuIFN5bWJvbCBFcnJvciBFdmFsRXJyb3IgSW50ZXJuYWxFcnJvciBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFN5bnRheEVycm9yIFR5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgSW50OEFycmF5IFVpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgSW50MTZBcnJheSBVaW50MTZBcnJheSBJbnQzMkFycmF5IFVpbnQzMkFycmF5IEZsb2F0MzJBcnJheSBGbG9hdDY0QXJyYXkgTWFwIFNldCBXZWFrTWFwIFdlYWtTZXQgU0lNRCBBcnJheUJ1ZmZlciBEYXRhVmlldyBKU09OIFByb21pc2UgR2VuZXJhdG9yIEdlbmVyYXRvckZ1bmN0aW9uIFJlZmxlY3QgUHJveHkgSW50bCc7XG5jb25zdCBmb3JiaWRkZW5JZGVudGlmaWVycyA9IG5ldyBTZXQoYCR7cmVzZXJ2ZWRXb3Jkc30gJHtidWlsdGluc31gLnNwbGl0KCcgJykpO1xuZm9yYmlkZGVuSWRlbnRpZmllcnMuYWRkKCcnKTtcbmNvbnN0IG1ha2VMZWdhbElkZW50aWZpZXIgPSBmdW5jdGlvbiBtYWtlTGVnYWxJZGVudGlmaWVyKHN0cikge1xuICAgIGxldCBpZGVudGlmaWVyID0gc3RyXG4gICAgICAgIC5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKC9bXiRfYS16QS1aMC05XS9nLCAnXycpO1xuICAgIGlmICgvXFxkLy50ZXN0KGlkZW50aWZpZXJbMF0pIHx8IGZvcmJpZGRlbklkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgICBpZGVudGlmaWVyID0gYF8ke2lkZW50aWZpZXJ9YDtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXIgfHwgJ18nO1xufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICAgIHJldHVybiAoSlNPTi5zdHJpbmdpZnkob2JqKSB8fCAndW5kZWZpbmVkJykucmVwbGFjZSgvW1xcdTIwMjhcXHUyMDI5XS9nLCAoY2hhcikgPT4gYFxcXFx1JHtgMDAwJHtjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTQpfWApO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoYXJyLCBpbmRlbnQsIGJhc2VJbmRlbnQpIHtcbiAgICBsZXQgb3V0cHV0ID0gJ1snO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IGluZGVudCA/IGBcXG4ke2Jhc2VJbmRlbnR9JHtpbmRlbnR9YCA6ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFycltpXTtcbiAgICAgICAgb3V0cHV0ICs9IGAke2kgPiAwID8gJywnIDogJyd9JHtzZXBhcmF0b3J9JHtzZXJpYWxpemUoa2V5LCBpbmRlbnQsIGJhc2VJbmRlbnQgKyBpbmRlbnQpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtvdXRwdXR9JHtpbmRlbnQgPyBgXFxuJHtiYXNlSW5kZW50fWAgOiAnJ31dYDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmosIGluZGVudCwgYmFzZUluZGVudCkge1xuICAgIGxldCBvdXRwdXQgPSAneyc7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gaW5kZW50ID8gYFxcbiR7YmFzZUluZGVudH0ke2luZGVudH1gIDogJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJpZXNbaV07XG4gICAgICAgIGNvbnN0IHN0cmluZ0tleSA9IG1ha2VMZWdhbElkZW50aWZpZXIoa2V5KSA9PT0ga2V5ID8ga2V5IDogc3RyaW5naWZ5KGtleSk7XG4gICAgICAgIG91dHB1dCArPSBgJHtpID4gMCA/ICcsJyA6ICcnfSR7c2VwYXJhdG9yfSR7c3RyaW5nS2V5fToke2luZGVudCA/ICcgJyA6ICcnfSR7c2VyaWFsaXplKHZhbHVlLCBpbmRlbnQsIGJhc2VJbmRlbnQgKyBpbmRlbnQpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtvdXRwdXR9JHtpbmRlbnQgPyBgXFxuJHtiYXNlSW5kZW50fWAgOiAnJ319YDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmosIGluZGVudCwgYmFzZUluZGVudCkge1xuICAgIGlmIChvYmogPT09IEluZmluaXR5KVxuICAgICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICBpZiAob2JqID09PSAtSW5maW5pdHkpXG4gICAgICAgIHJldHVybiAnLUluZmluaXR5JztcbiAgICBpZiAob2JqID09PSAwICYmIDEgLyBvYmogPT09IC1JbmZpbml0eSlcbiAgICAgICAgcmV0dXJuICctMCc7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgIHJldHVybiBgbmV3IERhdGUoJHtvYmouZ2V0VGltZSgpfSlgO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcbiAgICBpZiAob2JqICE9PSBvYmopXG4gICAgICAgIHJldHVybiAnTmFOJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplQXJyYXkob2JqLCBpbmRlbnQsIGJhc2VJbmRlbnQpO1xuICAgIGlmIChvYmogPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KG9iaiwgaW5kZW50LCBiYXNlSW5kZW50KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KG9iaik7XG59XG5jb25zdCBkYXRhVG9Fc20gPSBmdW5jdGlvbiBkYXRhVG9Fc20oZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdCA9IG9wdGlvbnMuY29tcGFjdCA/ICcnIDogJ2luZGVudCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaW5kZW50IDogJ1xcdCc7XG4gICAgY29uc3QgXyA9IG9wdGlvbnMuY29tcGFjdCA/ICcnIDogJyAnO1xuICAgIGNvbnN0IG4gPSBvcHRpb25zLmNvbXBhY3QgPyAnJyA6ICdcXG4nO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uVHlwZSA9IG9wdGlvbnMucHJlZmVyQ29uc3QgPyAnY29uc3QnIDogJ3Zhcic7XG4gICAgaWYgKG9wdGlvbnMubmFtZWRFeHBvcnRzID09PSBmYWxzZSB8fFxuICAgICAgICB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhKSB8fFxuICAgICAgICBkYXRhIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICBkYXRhIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgIGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHNlcmlhbGl6ZShkYXRhLCBvcHRpb25zLmNvbXBhY3QgPyBudWxsIDogdCwgJycpO1xuICAgICAgICBjb25zdCBtYWdpYyA9IF8gfHwgKC9eW3tbXFwtXFwvXS8udGVzdChjb2RlKSA/ICcnIDogJyAnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICByZXR1cm4gYGV4cG9ydCBkZWZhdWx0JHttYWdpY30ke2NvZGV9O2A7XG4gICAgfVxuICAgIGxldCBuYW1lZEV4cG9ydENvZGUgPSAnJztcbiAgICBjb25zdCBkZWZhdWx0RXhwb3J0Um93cyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IG1ha2VMZWdhbElkZW50aWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2JqZWN0U2hvcnRoYW5kKVxuICAgICAgICAgICAgICAgIGRlZmF1bHRFeHBvcnRSb3dzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXhwb3J0Um93cy5wdXNoKGAke2tleX06JHtffSR7a2V5fWApO1xuICAgICAgICAgICAgbmFtZWRFeHBvcnRDb2RlICs9IGBleHBvcnQgJHtkZWNsYXJhdGlvblR5cGV9ICR7a2V5fSR7X309JHtffSR7c2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLmNvbXBhY3QgPyBudWxsIDogdCwgJycpfTske259YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRFeHBvcnRSb3dzLnB1c2goYCR7c3RyaW5naWZ5KGtleSl9OiR7X30ke3NlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucy5jb21wYWN0ID8gbnVsbCA6IHQsICcnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZWRFeHBvcnRDb2RlfWV4cG9ydCBkZWZhdWx0JHtffXske259JHt0fSR7ZGVmYXVsdEV4cG9ydFJvd3Muam9pbihgLCR7bn0ke3R9YCl9JHtufX07JHtufWA7XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiBuZXh0IG1ham9yXG52YXIgaW5kZXggPSB7XG4gICAgYWRkRXh0ZW5zaW9uLFxuICAgIGF0dGFjaFNjb3BlcyxcbiAgICBjcmVhdGVGaWx0ZXIsXG4gICAgZGF0YVRvRXNtLFxuICAgIGV4dHJhY3RBc3NpZ25lZE5hbWVzLFxuICAgIG1ha2VMZWdhbElkZW50aWZpZXJcbn07XG5cbmV4cG9ydHMuYWRkRXh0ZW5zaW9uID0gYWRkRXh0ZW5zaW9uO1xuZXhwb3J0cy5hdHRhY2hTY29wZXMgPSBhdHRhY2hTY29wZXM7XG5leHBvcnRzLmNyZWF0ZUZpbHRlciA9IGNyZWF0ZUZpbHRlcjtcbmV4cG9ydHMuZGF0YVRvRXNtID0gZGF0YVRvRXNtO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG5leHBvcnRzLmV4dHJhY3RBc3NpZ25lZE5hbWVzID0gZXh0cmFjdEFzc2lnbmVkTmFtZXM7XG5leHBvcnRzLm1ha2VMZWdhbElkZW50aWZpZXIgPSBtYWtlTGVnYWxJZGVudGlmaWVyO1xuIiwgInZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiYXNlZGlyLCByZWxmaWxlcykge1xuICAgIGlmIChyZWxmaWxlcykge1xuICAgICAgICB2YXIgZmlsZXMgPSByZWxmaWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnJlc29sdmUoYmFzZWRpciwgcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGZpbGVzID0gYmFzZWRpcjtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlcyA9IGZpbGVzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbiAocHMsIGZpbGUpIHtcbiAgICAgICAgaWYgKCFmaWxlLm1hdGNoKC9eKFtBLVphLXpdOik/XFwvfFxcXFwvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBwYXRoIHdpdGhvdXQgYSBiYXNlZGlyJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB4cyA9IGZpbGUuc3BsaXQoL1xcLyt8XFxcXCsvKTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHBzW2ldID09PSB4c1tpXSAmJiBpIDwgTWF0aC5taW4ocHMubGVuZ3RoLCB4cy5sZW5ndGgpO1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwcy5zbGljZSgwLCBpKTtcbiAgICB9LCBmaWxlc1swXS5zcGxpdCgvXFwvK3xcXFxcKy8pKTtcbiAgICBcbiAgICAvLyBXaW5kb3dzIGNvcnJlY3RseSBoYW5kbGVzIHBhdGhzIHdpdGggZm9yd2FyZC1zbGFzaGVzXG4gICAgcmV0dXJuIHJlcy5sZW5ndGggPiAxID8gcmVzLmpvaW4oJy8nKSA6ICcvJ1xufTtcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbi8vIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgcmVhbHBhdGgsIHBvcnRlZCBmcm9tIG5vZGUgcHJlLXY2XG5cbnZhciBERUJVRyA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL2ZzLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpO1xuXG5mdW5jdGlvbiByZXRocm93KCkge1xuICAvLyBPbmx5IGVuYWJsZSBpbiBkZWJ1ZyBtb2RlLiBBIGJhY2t0cmFjZSB1c2VzIH4xMDAwIGJ5dGVzIG9mIGhlYXAgc3BhY2UgYW5kXG4gIC8vIGlzIGZhaXJseSBzbG93IHRvIGdlbmVyYXRlLlxuICB2YXIgY2FsbGJhY2s7XG4gIGlmIChERUJVRykge1xuICAgIHZhciBiYWNrdHJhY2UgPSBuZXcgRXJyb3I7XG4gICAgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xuICB9IGVsc2VcbiAgICBjYWxsYmFjayA9IG1pc3NpbmdDYWxsYmFjaztcblxuICByZXR1cm4gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gZGVidWdDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBiYWNrdHJhY2UubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgZXJyID0gYmFja3RyYWNlO1xuICAgICAgbWlzc2luZ0NhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWlzc2luZ0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pXG4gICAgICAgIHRocm93IGVycjsgIC8vIEZvcmdvdCBhIGNhbGxiYWNrIGJ1dCBkb24ndCBrbm93IHdoZXJlPyBVc2UgTk9ERV9ERUJVRz1mc1xuICAgICAgZWxzZSBpZiAoIXByb2Nlc3Mubm9EZXByZWNhdGlvbikge1xuICAgICAgICB2YXIgbXNnID0gJ2ZzOiBtaXNzaW5nIGNhbGxiYWNrICcgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbilcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/IGNiIDogcmV0aHJvdygpO1xufVxuXG52YXIgbm9ybWFsaXplID0gcGF0aE1vZHVsZS5ub3JtYWxpemU7XG5cbi8vIFJlZ2V4cCB0aGF0IGZpbmRzIHRoZSBuZXh0IHBhcnRpb24gb2YgYSAocGFydGlhbCkgcGF0aFxuLy8gcmVzdWx0IGlzIFtiYXNlX3dpdGhfc2xhc2gsIGJhc2VdLCBlLmcuIFsnc29tZWRpci8nLCAnc29tZWRpciddXG5pZiAoaXNXaW5kb3dzKSB7XG4gIHZhciBuZXh0UGFydFJlID0gLyguKj8pKD86W1xcL1xcXFxdK3wkKS9nO1xufSBlbHNlIHtcbiAgdmFyIG5leHRQYXJ0UmUgPSAvKC4qPykoPzpbXFwvXSt8JCkvZztcbn1cblxuLy8gUmVnZXggdG8gZmluZCB0aGUgZGV2aWNlIHJvb3QsIGluY2x1ZGluZyB0cmFpbGluZyBzbGFzaC4gRS5nLiAnYzpcXFxcJy5cbmlmIChpc1dpbmRvd3MpIHtcbiAgdmFyIHNwbGl0Um9vdFJlID0gL14oPzpbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL11bXlxcXFxcXC9dKyk/W1xcXFxcXC9dKi87XG59IGVsc2Uge1xuICB2YXIgc3BsaXRSb290UmUgPSAvXltcXC9dKi87XG59XG5cbmV4cG9ydHMucmVhbHBhdGhTeW5jID0gZnVuY3Rpb24gcmVhbHBhdGhTeW5jKHAsIGNhY2hlKSB7XG4gIC8vIG1ha2UgcCBpcyBhYnNvbHV0ZVxuICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHApO1xuXG4gIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIHApKSB7XG4gICAgcmV0dXJuIGNhY2hlW3BdO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsID0gcCxcbiAgICAgIHNlZW5MaW5rcyA9IHt9LFxuICAgICAga25vd25IYXJkID0ge307XG5cbiAgLy8gY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gcFxuICB2YXIgcG9zO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNvIGZhciwgaW5jbHVkaW5nIGEgdHJhaWxpbmcgc2xhc2ggaWYgYW55XG4gIHZhciBjdXJyZW50O1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCAoZXhjZXB0IHdoZW4gcG9pbnRpbmcgYXQgYSByb290KVxuICB2YXIgYmFzZTtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzY2FubmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCwgd2l0aCBzbGFzaFxuICB2YXIgcHJldmlvdXM7XG5cbiAgc3RhcnQoKTtcblxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAvLyBTa2lwIG92ZXIgcm9vdHNcbiAgICB2YXIgbSA9IHNwbGl0Um9vdFJlLmV4ZWMocCk7XG4gICAgcG9zID0gbVswXS5sZW5ndGg7XG4gICAgY3VycmVudCA9IG1bMF07XG4gICAgYmFzZSA9IG1bMF07XG4gICAgcHJldmlvdXMgPSAnJztcblxuICAgIC8vIE9uIHdpbmRvd3MsIGNoZWNrIHRoYXQgdGhlIHJvb3QgZXhpc3RzLiBPbiB1bml4IHRoZXJlIGlzIG5vIG5lZWQuXG4gICAgaWYgKGlzV2luZG93cyAmJiAha25vd25IYXJkW2Jhc2VdKSB7XG4gICAgICBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdhbGsgZG93biB0aGUgcGF0aCwgc3dhcHBpbmcgb3V0IGxpbmtlZCBwYXRocGFydHMgZm9yIHRoZWlyIHJlYWxcbiAgLy8gdmFsdWVzXG4gIC8vIE5COiBwLmxlbmd0aCBjaGFuZ2VzLlxuICB3aGlsZSAocG9zIDwgcC5sZW5ndGgpIHtcbiAgICAvLyBmaW5kIHRoZSBuZXh0IHBhcnRcbiAgICBuZXh0UGFydFJlLmxhc3RJbmRleCA9IHBvcztcbiAgICB2YXIgcmVzdWx0ID0gbmV4dFBhcnRSZS5leGVjKHApO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICBjdXJyZW50ICs9IHJlc3VsdFswXTtcbiAgICBiYXNlID0gcHJldmlvdXMgKyByZXN1bHRbMV07XG4gICAgcG9zID0gbmV4dFBhcnRSZS5sYXN0SW5kZXg7XG5cbiAgICAvLyBjb250aW51ZSBpZiBub3QgYSBzeW1saW5rXG4gICAgaWYgKGtub3duSGFyZFtiYXNlXSB8fCAoY2FjaGUgJiYgY2FjaGVbYmFzZV0gPT09IGJhc2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRMaW5rO1xuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBzb21lIGtub3duIHN5bWJvbGljIGxpbmsuICBubyBuZWVkIHRvIHN0YXQgYWdhaW4uXG4gICAgICByZXNvbHZlZExpbmsgPSBjYWNoZVtiYXNlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBpZiAoIXN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlYWQgdGhlIGxpbmsgaWYgaXQgd2Fzbid0IHJlYWQgYmVmb3JlXG4gICAgICAvLyBkZXYvaW5vIGFsd2F5cyByZXR1cm4gMCBvbiB3aW5kb3dzLCBzbyBza2lwIHRoZSBjaGVjay5cbiAgICAgIHZhciBsaW5rVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgaWYgKHNlZW5MaW5rcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBsaW5rVGFyZ2V0ID0gc2VlbkxpbmtzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmtUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgZnMuc3RhdFN5bmMoYmFzZSk7XG4gICAgICAgIGxpbmtUYXJnZXQgPSBmcy5yZWFkbGlua1N5bmMoYmFzZSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZExpbmsgPSBwYXRoTW9kdWxlLnJlc29sdmUocHJldmlvdXMsIGxpbmtUYXJnZXQpO1xuICAgICAgLy8gdHJhY2sgdGhpcywgaWYgZ2l2ZW4gYSBjYWNoZS5cbiAgICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSByZXNvbHZlZExpbms7XG4gICAgICBpZiAoIWlzV2luZG93cykgc2VlbkxpbmtzW2lkXSA9IGxpbmtUYXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgbGluaywgdGhlbiBzdGFydCBvdmVyXG4gICAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShyZXNvbHZlZExpbmssIHAuc2xpY2UocG9zKSk7XG4gICAgc3RhcnQoKTtcbiAgfVxuXG4gIGlmIChjYWNoZSkgY2FjaGVbb3JpZ2luYWxdID0gcDtcblxuICByZXR1cm4gcDtcbn07XG5cblxuZXhwb3J0cy5yZWFscGF0aCA9IGZ1bmN0aW9uIHJlYWxwYXRoKHAsIGNhY2hlLCBjYikge1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBtYXliZUNhbGxiYWNrKGNhY2hlKTtcbiAgICBjYWNoZSA9IG51bGw7XG4gIH1cblxuICAvLyBtYWtlIHAgaXMgYWJzb2x1dGVcbiAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShwKTtcblxuICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBwKSkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgY2FjaGVbcF0pKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbCA9IHAsXG4gICAgICBzZWVuTGlua3MgPSB7fSxcbiAgICAgIGtub3duSGFyZCA9IHt9O1xuXG4gIC8vIGN1cnJlbnQgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHBcbiAgdmFyIHBvcztcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzbyBmYXIsIGluY2x1ZGluZyBhIHRyYWlsaW5nIHNsYXNoIGlmIGFueVxuICB2YXIgY3VycmVudDtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2ggKGV4Y2VwdCB3aGVuIHBvaW50aW5nIGF0IGEgcm9vdClcbiAgdmFyIGJhc2U7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc2Nhbm5lZCBpbiB0aGUgcHJldmlvdXMgcm91bmQsIHdpdGggc2xhc2hcbiAgdmFyIHByZXZpb3VzO1xuXG4gIHN0YXJ0KCk7XG5cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgLy8gU2tpcCBvdmVyIHJvb3RzXG4gICAgdmFyIG0gPSBzcGxpdFJvb3RSZS5leGVjKHApO1xuICAgIHBvcyA9IG1bMF0ubGVuZ3RoO1xuICAgIGN1cnJlbnQgPSBtWzBdO1xuICAgIGJhc2UgPSBtWzBdO1xuICAgIHByZXZpb3VzID0gJyc7XG5cbiAgICAvLyBPbiB3aW5kb3dzLCBjaGVjayB0aGF0IHRoZSByb290IGV4aXN0cy4gT24gdW5peCB0aGVyZSBpcyBubyBuZWVkLlxuICAgIGlmIChpc1dpbmRvd3MgJiYgIWtub3duSGFyZFtiYXNlXSkge1xuICAgICAgZnMubHN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBMT09QKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhMT09QKTtcbiAgICB9XG4gIH1cblxuICAvLyB3YWxrIGRvd24gdGhlIHBhdGgsIHN3YXBwaW5nIG91dCBsaW5rZWQgcGF0aHBhcnRzIGZvciB0aGVpciByZWFsXG4gIC8vIHZhbHVlc1xuICBmdW5jdGlvbiBMT09QKCkge1xuICAgIC8vIHN0b3AgaWYgc2Nhbm5lZCBwYXN0IGVuZCBvZiBwYXRoXG4gICAgaWYgKHBvcyA+PSBwLmxlbmd0aCkge1xuICAgICAgaWYgKGNhY2hlKSBjYWNoZVtvcmlnaW5hbF0gPSBwO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHApO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIG5leHQgcGFydFxuICAgIG5leHRQYXJ0UmUubGFzdEluZGV4ID0gcG9zO1xuICAgIHZhciByZXN1bHQgPSBuZXh0UGFydFJlLmV4ZWMocCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQgKz0gcmVzdWx0WzBdO1xuICAgIGJhc2UgPSBwcmV2aW91cyArIHJlc3VsdFsxXTtcbiAgICBwb3MgPSBuZXh0UGFydFJlLmxhc3RJbmRleDtcblxuICAgIC8vIGNvbnRpbnVlIGlmIG5vdCBhIHN5bWxpbmtcbiAgICBpZiAoa25vd25IYXJkW2Jhc2VdIHx8IChjYWNoZSAmJiBjYWNoZVtiYXNlXSA9PT0gYmFzZSkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBrbm93biBzeW1ib2xpYyBsaW5rLiAgbm8gbmVlZCB0byBzdGF0IGFnYWluLlxuICAgICAgcmV0dXJuIGdvdFJlc29sdmVkTGluayhjYWNoZVtiYXNlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZzLmxzdGF0KGJhc2UsIGdvdFN0YXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290U3RhdChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGlmIG5vdCBhIHN5bWxpbmssIHNraXAgdG8gdGhlIG5leHQgcGF0aCBwYXJ0XG4gICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIC8vIHN0YXQgJiByZWFkIHRoZSBsaW5rIGlmIG5vdCByZWFkIGJlZm9yZVxuICAgIC8vIGNhbGwgZ290VGFyZ2V0IGFzIHNvb24gYXMgdGhlIGxpbmsgdGFyZ2V0IGlzIGtub3duXG4gICAgLy8gZGV2L2lubyBhbHdheXMgcmV0dXJuIDAgb24gd2luZG93cywgc28gc2tpcCB0aGUgY2hlY2suXG4gICAgaWYgKCFpc1dpbmRvd3MpIHtcbiAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgIGlmIChzZWVuTGlua3MuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHJldHVybiBnb3RUYXJnZXQobnVsbCwgc2VlbkxpbmtzW2lkXSwgYmFzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZzLnN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgZnMucmVhZGxpbmsoYmFzZSwgZnVuY3Rpb24oZXJyLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCFpc1dpbmRvd3MpIHNlZW5MaW5rc1tpZF0gPSB0YXJnZXQ7XG4gICAgICAgIGdvdFRhcmdldChlcnIsIHRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdFRhcmdldChlcnIsIHRhcmdldCwgYmFzZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgdmFyIHJlc29sdmVkTGluayA9IHBhdGhNb2R1bGUucmVzb2x2ZShwcmV2aW91cywgdGFyZ2V0KTtcbiAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gcmVzb2x2ZWRMaW5rO1xuICAgIGdvdFJlc29sdmVkTGluayhyZXNvbHZlZExpbmspO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290UmVzb2x2ZWRMaW5rKHJlc29sdmVkTGluaykge1xuICAgIC8vIHJlc29sdmUgdGhlIGxpbmssIHRoZW4gc3RhcnQgb3ZlclxuICAgIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocmVzb2x2ZWRMaW5rLCBwLnNsaWNlKHBvcykpO1xuICAgIHN0YXJ0KCk7XG4gIH1cbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZWFscGF0aFxucmVhbHBhdGgucmVhbHBhdGggPSByZWFscGF0aFxucmVhbHBhdGguc3luYyA9IHJlYWxwYXRoU3luY1xucmVhbHBhdGgucmVhbHBhdGhTeW5jID0gcmVhbHBhdGhTeW5jXG5yZWFscGF0aC5tb25rZXlwYXRjaCA9IG1vbmtleXBhdGNoXG5yZWFscGF0aC51bm1vbmtleXBhdGNoID0gdW5tb25rZXlwYXRjaFxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgb3JpZ1JlYWxwYXRoID0gZnMucmVhbHBhdGhcbnZhciBvcmlnUmVhbHBhdGhTeW5jID0gZnMucmVhbHBhdGhTeW5jXG5cbnZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uXG52YXIgb2sgPSAvXnZbMC01XVxcLi8udGVzdCh2ZXJzaW9uKVxudmFyIG9sZCA9IHJlcXVpcmUoJy4vb2xkLmpzJylcblxuZnVuY3Rpb24gbmV3RXJyb3IgKGVyKSB7XG4gIHJldHVybiBlciAmJiBlci5zeXNjYWxsID09PSAncmVhbHBhdGgnICYmIChcbiAgICBlci5jb2RlID09PSAnRUxPT1AnIHx8XG4gICAgZXIuY29kZSA9PT0gJ0VOT01FTScgfHxcbiAgICBlci5jb2RlID09PSAnRU5BTUVUT09MT05HJ1xuICApXG59XG5cbmZ1bmN0aW9uIHJlYWxwYXRoIChwLCBjYWNoZSwgY2IpIHtcbiAgaWYgKG9rKSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aChwLCBjYWNoZSwgY2IpXG4gIH1cblxuICBpZiAodHlwZW9mIGNhY2hlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjYWNoZVxuICAgIGNhY2hlID0gbnVsbFxuICB9XG4gIG9yaWdSZWFscGF0aChwLCBjYWNoZSwgZnVuY3Rpb24gKGVyLCByZXN1bHQpIHtcbiAgICBpZiAobmV3RXJyb3IoZXIpKSB7XG4gICAgICBvbGQucmVhbHBhdGgocCwgY2FjaGUsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihlciwgcmVzdWx0KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhbHBhdGhTeW5jIChwLCBjYWNoZSkge1xuICBpZiAob2spIHtcbiAgICByZXR1cm4gb3JpZ1JlYWxwYXRoU3luYyhwLCBjYWNoZSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKG5ld0Vycm9yKGVyKSkge1xuICAgICAgcmV0dXJuIG9sZC5yZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vbmtleXBhdGNoICgpIHtcbiAgZnMucmVhbHBhdGggPSByZWFscGF0aFxuICBmcy5yZWFscGF0aFN5bmMgPSByZWFscGF0aFN5bmNcbn1cblxuZnVuY3Rpb24gdW5tb25rZXlwYXRjaCAoKSB7XG4gIGZzLnJlYWxwYXRoID0gb3JpZ1JlYWxwYXRoXG4gIGZzLnJlYWxwYXRoU3luYyA9IG9yaWdSZWFscGF0aFN5bmNcbn1cbiIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGZuKHhzW2ldLCBpKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoeCkpIHJlcy5wdXNoLmFwcGx5KHJlcywgeCk7XG4gICAgICAgIGVsc2UgcmVzLnB1c2goeCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwgIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gYmFsYW5jZWQ7XG5mdW5jdGlvbiBiYWxhbmNlZChhLCBiLCBzdHIpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIGEgPSBtYXliZU1hdGNoKGEsIHN0cik7XG4gIGlmIChiIGluc3RhbmNlb2YgUmVnRXhwKSBiID0gbWF5YmVNYXRjaChiLCBzdHIpO1xuXG4gIHZhciByID0gcmFuZ2UoYSwgYiwgc3RyKTtcblxuICByZXR1cm4gciAmJiB7XG4gICAgc3RhcnQ6IHJbMF0sXG4gICAgZW5kOiByWzFdLFxuICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgIGJvZHk6IHN0ci5zbGljZShyWzBdICsgYS5sZW5ndGgsIHJbMV0pLFxuICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgYi5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1heWJlTWF0Y2gocmVnLCBzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cblxuYmFsYW5jZWQucmFuZ2UgPSByYW5nZTtcbmZ1bmN0aW9uIHJhbmdlKGEsIGIsIHN0cikge1xuICB2YXIgYmVncywgYmVnLCBsZWZ0LCByaWdodCwgcmVzdWx0O1xuICB2YXIgYWkgPSBzdHIuaW5kZXhPZihhKTtcbiAgdmFyIGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgdmFyIGkgPSBhaTtcblxuICBpZiAoYWkgPj0gMCAmJiBiaSA+IDApIHtcbiAgICBiZWdzID0gW107XG4gICAgbGVmdCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA+PSAwICYmICFyZXN1bHQpIHtcbiAgICAgIGlmIChpID09IGFpKSB7XG4gICAgICAgIGJlZ3MucHVzaChpKTtcbiAgICAgICAgYWkgPSBzdHIuaW5kZXhPZihhLCBpICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGJlZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gWyBiZWdzLnBvcCgpLCBiaSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgaWYgKGJlZyA8IGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgIHJpZ2h0ID0gYmk7XG4gICAgICAgIH1cblxuICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgIH1cblxuICAgICAgaSA9IGFpIDwgYmkgJiYgYWkgPj0gMCA/IGFpIDogYmk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBbIGxlZnQsIHJpZ2h0IF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJ2YXIgY29uY2F0TWFwID0gcmVxdWlyZSgnY29uY2F0LW1hcCcpO1xudmFyIGJhbGFuY2VkID0gcmVxdWlyZSgnYmFsYW5jZWQtbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRUb3A7XG5cbnZhciBlc2NTbGFzaCA9ICdcXDBTTEFTSCcrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NPcGVuID0gJ1xcME9QRU4nK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ2xvc2UgPSAnXFwwQ0xPU0UnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ29tbWEgPSAnXFwwQ09NTUEnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjUGVyaW9kID0gJ1xcMFBFUklPRCcrTWF0aC5yYW5kb20oKSsnXFwwJztcblxuZnVuY3Rpb24gbnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApID09IHN0clxuICAgID8gcGFyc2VJbnQoc3RyLCAxMClcbiAgICA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxcXFxcJykuam9pbihlc2NTbGFzaClcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXHsnKS5qb2luKGVzY09wZW4pXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx9Jykuam9pbihlc2NDbG9zZSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXCwnKS5qb2luKGVzY0NvbW1hKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLicpLmpvaW4oZXNjUGVyaW9kKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZXNjU2xhc2gpLmpvaW4oJ1xcXFwnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY09wZW4pLmpvaW4oJ3snKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0Nsb3NlKS5qb2luKCd9JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDb21tYSkuam9pbignLCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjUGVyaW9kKS5qb2luKCcuJyk7XG59XG5cblxuLy8gQmFzaWNhbGx5IGp1c3Qgc3RyLnNwbGl0KFwiLFwiKSwgYnV0IGhhbmRsaW5nIGNhc2VzXG4vLyB3aGVyZSB3ZSBoYXZlIG5lc3RlZCBicmFjZWQgc2VjdGlvbnMsIHdoaWNoIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBhcyBpbmRpdmlkdWFsIG1lbWJlcnMsIGxpa2Uge2Ese2IsY30sZH1cbmZ1bmN0aW9uIHBhcnNlQ29tbWFQYXJ0cyhzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFsnJ107XG5cbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG5cbiAgaWYgKCFtKVxuICAgIHJldHVybiBzdHIuc3BsaXQoJywnKTtcblxuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBib2R5ID0gbS5ib2R5O1xuICB2YXIgcG9zdCA9IG0ucG9zdDtcbiAgdmFyIHAgPSBwcmUuc3BsaXQoJywnKTtcblxuICBwW3AubGVuZ3RoLTFdICs9ICd7JyArIGJvZHkgKyAnfSc7XG4gIHZhciBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gIGlmIChwb3N0Lmxlbmd0aCkge1xuICAgIHBbcC5sZW5ndGgtMV0gKz0gcG9zdFBhcnRzLnNoaWZ0KCk7XG4gICAgcC5wdXNoLmFwcGx5KHAsIHBvc3RQYXJ0cyk7XG4gIH1cblxuICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvcChzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgLy8gQW55dGhpbmcgc3RhcnRpbmcgd2l0aCB7fSB3aWxsIGhhdmUgdGhlIGZpcnN0IHR3byBieXRlcyBwcmVzZXJ2ZWRcbiAgLy8gYnV0ICpvbmx5KiBhdCB0aGUgdG9wIGxldmVsLCBzbyB7fSxhfWIgd2lsbCBub3QgZXhwYW5kIHRvIGFueXRoaW5nLFxuICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgLy8gT25lIGNvdWxkIGFyZ3VlIHRoYXQgdGhpcyBpcyBhIGJ1ZyBpbiBCYXNoLCBidXQgc2luY2UgdGhlIGdvYWwgb2ZcbiAgLy8gdGhpcyBtb2R1bGUgaXMgdG8gbWF0Y2ggQmFzaCdzIHJ1bGVzLCB3ZSBlc2NhcGUgYSBsZWFkaW5nIHt9XG4gIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAne30nKSB7XG4gICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnN1YnN0cigyKTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmQoZXNjYXBlQnJhY2VzKHN0ciksIHRydWUpLm1hcCh1bmVzY2FwZUJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KGUpIHtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG59XG5mdW5jdGlvbiBpc1BhZGRlZChlbCkge1xuICByZXR1cm4gL14tPzBcXGQvLnRlc3QoZWwpO1xufVxuXG5mdW5jdGlvbiBsdGUoaSwgeSkge1xuICByZXR1cm4gaSA8PSB5O1xufVxuZnVuY3Rpb24gZ3RlKGksIHkpIHtcbiAgcmV0dXJuIGkgPj0geTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0ciwgaXNUb3ApIHtcbiAgdmFyIGV4cGFuc2lvbnMgPSBbXTtcblxuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICBpZiAoIW0gfHwgL1xcJCQvLnRlc3QobS5wcmUpKSByZXR1cm4gW3N0cl07XG5cbiAgdmFyIGlzTnVtZXJpY1NlcXVlbmNlID0gL14tP1xcZCtcXC5cXC4tP1xcZCsoPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzQWxwaGFTZXF1ZW5jZSA9IC9eW2EtekEtWl1cXC5cXC5bYS16QS1aXSg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgdmFyIGlzT3B0aW9ucyA9IG0uYm9keS5pbmRleE9mKCcsJykgPj0gMDtcbiAgaWYgKCFpc1NlcXVlbmNlICYmICFpc09wdGlvbnMpIHtcbiAgICAvLyB7YX0sYn1cbiAgICBpZiAobS5wb3N0Lm1hdGNoKC8sLipcXH0vKSkge1xuICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgdmFyIG47XG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8geHt7YSxifX15ID09PiB4e2F9eSB4e2J9eVxuICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgICAgICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgICAgICAgOiBbJyddO1xuICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgdmFyIE47XG5cbiAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgdmFyIHkgPSBudW1lcmljKG5bMV0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSlcbiAgICAgIDogMTtcbiAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICB2YXIgcmV2ZXJzZSA9IHkgPCB4O1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBpbmNyICo9IC0xO1xuICAgICAgdGVzdCA9IGd0ZTtcbiAgICB9XG4gICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICBOID0gW107XG5cbiAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmIChpc0FscGhhU2VxdWVuY2UpIHtcbiAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgYyA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgaWYgKHBhZCkge1xuICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgIHZhciB6ID0gbmV3IEFycmF5KG5lZWQgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTi5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOID0gY29uY2F0TWFwKG4sIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBleHBhbmQoZWwsIGZhbHNlKSB9KTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbilcbiAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cbiIsICJtb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG52YXIgcGF0aCA9IHsgc2VwOiAnLycgfVxudHJ5IHtcbiAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxufSBjYXRjaCAoZXIpIHt9XG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBhID0gYSB8fCB7fVxuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYltrXVxuICB9KVxuICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGFba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHJldHVybiBtaW5pbWF0Y2hcblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWluaW1hdGNoKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5NaW5pbWF0Y2ggPSBmdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IG9yaWcuTWluaW1hdGNoKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHJldHVybiBNaW5pbWF0Y2hcbiAgcmV0dXJuIG1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaFxufVxuXG5mdW5jdGlvbiBtaW5pbWF0Y2ggKHAsIHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2IgcGF0dGVybiBzdHJpbmcgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBcIlwiIG9ubHkgbWF0Y2hlcyBcIlwiXG4gIGlmIChwYXR0ZXJuLnRyaW0oKSA9PT0gJycpIHJldHVybiBwID09PSAnJ1xuXG4gIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApXG59XG5cbmZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSkge1xuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2xvYiBwYXR0ZXJuIHN0cmluZyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuICBwYXR0ZXJuID0gcGF0dGVybi50cmltKClcblxuICAvLyB3aW5kb3dzIHN1cHBvcnQ6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhpcy5zZXQgPSBbXVxuICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHRoaXMucmVnZXhwID0gbnVsbFxuICB0aGlzLm5lZ2F0ZSA9IGZhbHNlXG4gIHRoaXMuY29tbWVudCA9IGZhbHNlXG4gIHRoaXMuZW1wdHkgPSBmYWxzZVxuXG4gIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgdGhpcy5tYWtlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWFrZSA9IG1ha2VcbmZ1bmN0aW9uIG1ha2UgKCkge1xuICAvLyBkb24ndCBkbyBpdCBtb3JlIHRoYW4gb25jZS5cbiAgaWYgKHRoaXMuX21hZGUpIHJldHVyblxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBjb25zb2xlLmVycm9yXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBzdGVwIDM6IG5vdyB3ZSBoYXZlIGEgc2V0LCBzbyB0dXJuIGVhY2ggb25lIGludG8gYSBzZXJpZXMgb2YgcGF0aC1wb3J0aW9uXG4gIC8vIG1hdGNoaW5nIHBhdHRlcm5zLlxuICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gIC8vIHNldCB0byB0aGUgR0xPQlNUQVIgb2JqZWN0IGZvciBnbG9ic3RhciBiZWhhdmlvcixcbiAgLy8gYW5kIHdpbGwgbm90IGNvbnRhaW4gYW55IC8gY2hhcmFjdGVyc1xuICBzZXQgPSB0aGlzLmdsb2JQYXJ0cyA9IHNldC5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChzbGFzaFNwbGl0KVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZ2xvYiAtLT4gcmVnZXhwc1xuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uIChzLCBzaSwgc2V0KSB7XG4gICAgcmV0dXJuIHMubWFwKHRoaXMucGFyc2UsIHRoaXMpXG4gIH0sIHRoaXMpXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLmluZGV4T2YoZmFsc2UpID09PSAtMVxuICB9KVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgdGhpcy5zZXQgPSBzZXRcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZU5lZ2F0ZSA9IHBhcnNlTmVnYXRlXG5mdW5jdGlvbiBwYXJzZU5lZ2F0ZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBuZWdhdGUgPSBmYWxzZVxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICB2YXIgbmVnYXRlT2Zmc2V0ID0gMFxuXG4gIGlmIChvcHRpb25zLm5vbmVnYXRlKSByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgOyBpIDwgbCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnXG4gICAgOyBpKyspIHtcbiAgICBuZWdhdGUgPSAhbmVnYXRlXG4gICAgbmVnYXRlT2Zmc2V0KytcbiAgfVxuXG4gIGlmIChuZWdhdGVPZmZzZXQpIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKG5lZ2F0ZU9mZnNldClcbiAgdGhpcy5uZWdhdGUgPSBuZWdhdGVcbn1cblxuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gYnJhY2VFeHBhbmQocGF0dGVybiwgb3B0aW9ucylcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kXG5cbmZ1bmN0aW9uIGJyYWNlRXhwYW5kIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTWluaW1hdGNoKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cbiAgfVxuXG4gIHBhdHRlcm4gPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3VuZGVmaW5lZCdcbiAgICA/IHRoaXMucGF0dGVybiA6IHBhdHRlcm5cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5kZWZpbmVkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMubm9icmFjZSB8fFxuICAgICFwYXR0ZXJuLm1hdGNoKC9cXHsuKlxcfS8pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gMTAyNCAqIDY0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHNob3J0Y3V0c1xuICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhciAmJiBwYXR0ZXJuID09PSAnKionKSByZXR1cm4gR0xPQlNUQVJcbiAgaWYgKHBhdHRlcm4gPT09ICcnKSByZXR1cm4gJydcblxuICB2YXIgcmUgPSAnJ1xuICB2YXIgaGFzTWFnaWMgPSAhIW9wdGlvbnMubm9jYXNlXG4gIHZhciBlc2NhcGluZyA9IGZhbHNlXG4gIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgdmFyIHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICB2YXIgbmVnYXRpdmVMaXN0cyA9IFtdXG4gIHZhciBzdGF0ZUNoYXJcbiAgdmFyIGluQ2xhc3MgPSBmYWxzZVxuICB2YXIgcmVDbGFzc1N0YXJ0ID0gLTFcbiAgdmFyIGNsYXNzU3RhcnQgPSAtMVxuICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICB2YXIgcGF0dGVyblN0YXJ0ID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICcuJyA/ICcnIC8vIGFueXRoaW5nXG4gIC8vIG5vdCAoc3RhcnQgb3IgLyBmb2xsb3dlZCBieSAuIG9yIC4uIGZvbGxvd2VkIGJ5IC8gb3IgZW5kKVxuICA6IG9wdGlvbnMuZG90ID8gJyg/ISg/Ol58XFxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcXFwvKSknXG4gIDogJyg/IVxcXFwuKSdcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZUNoYXIgKCkge1xuICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgc3dpdGNoIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICByZSArPSBxbWFya1xuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2VsZi5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGgsIGNcbiAgICA7IChpIDwgbGVuKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKVxuICAgIDsgaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgIGlmIChlc2NhcGluZyAmJiByZVNwZWNpYWxzW2NdKSB7XG4gICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIC8vIGNvbXBsZXRlbHkgbm90IGFsbG93ZWQsIGV2ZW4gZXNjYXBlZC5cbiAgICAgICAgLy8gU2hvdWxkIGFscmVhZHkgYmUgcGF0aC1zcGxpdCBieSBub3cuXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBlc2NhcGluZyA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgIC8vIGZvciB0aGUgXCJleHRnbG9iXCIgc3R1ZmYuXG4gICAgICBjYXNlICc/JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICdAJzpcbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqIDwtLSBzdGF0ZUNoYXInLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgICAgICAvLyBhbGwgb2YgdGhvc2UgYXJlIGxpdGVyYWxzIGluc2lkZSBhIGNsYXNzLCBleGNlcHQgdGhhdFxuICAgICAgICAvLyB0aGUgZ2xvYiBbIWFdIG1lYW5zIFteYV0gaW4gcmVnZXhwXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnICBpbiBjbGFzcycpXG4gICAgICAgICAgaWYgKGMgPT09ICchJyAmJiBpID09PSBjbGFzc1N0YXJ0ICsgMSkgYyA9ICdeJ1xuICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdGVDaGFyLCB0aGVuIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIHNvbWV0aGluZyBsaWtlICoqIG9yICs/IGluIHRoZXJlLlxuICAgICAgICAvLyBIYW5kbGUgdGhlIHN0YXRlQ2hhciwgdGhlbiBwcm9jZWVkIHdpdGggdGhpcyBvbmUuXG4gICAgICAgIHNlbGYuZGVidWcoJ2NhbGwgY2xlYXJTdGF0ZUNoYXIgJWonLCBzdGF0ZUNoYXIpXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgc3RhdGVDaGFyID0gY1xuICAgICAgICAvLyBpZiBleHRnbG9iIGlzIGRpc2FibGVkLCB0aGVuICsoYXNkZnxmb28pIGlzbid0IGEgdGhpbmcuXG4gICAgICAgIC8vIGp1c3QgY2xlYXIgdGhlIHN0YXRlY2hhciAqbm93KiwgcmF0aGVyIHRoYW4gZXZlbiBkaXZpbmcgaW50b1xuICAgICAgICAvLyB0aGUgcGF0dGVybkxpc3Qgc3R1ZmYuXG4gICAgICAgIGlmIChvcHRpb25zLm5vZXh0KSBjbGVhclN0YXRlQ2hhcigpXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZUNoYXIpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCgnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucHVzaCh7XG4gICAgICAgICAgdHlwZTogc3RhdGVDaGFyLFxuICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICByZVN0YXJ0OiByZS5sZW5ndGgsXG4gICAgICAgICAgb3BlbjogcGxUeXBlc1tzdGF0ZUNoYXJdLm9wZW4sXG4gICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZVxuICAgICAgICB9KVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgcmUgKz0gc3RhdGVDaGFyID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonXG4gICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICcpJzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwpJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICB2YXIgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICAvLyBUaGUgb3RoZXJzIGFyZSAoPzo8cGF0dGVybj4pPHR5cGU+XG4gICAgICAgIHJlICs9IHBsLmNsb3NlXG4gICAgICAgIGlmIChwbC50eXBlID09PSAnIScpIHtcbiAgICAgICAgICBuZWdhdGl2ZUxpc3RzLnB1c2gocGwpXG4gICAgICAgIH1cbiAgICAgICAgcGwucmVFbmQgPSByZS5sZW5ndGhcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGggfHwgZXNjYXBpbmcpIHtcbiAgICAgICAgICByZSArPSAnXFxcXHwnXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHJlICs9ICd8J1xuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlc2UgYXJlIG1vc3RseSB0aGUgc2FtZSBpbiByZWdleHAgYW5kIGdsb2JcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZS10cmFja2luZyBjaGFyIGJlZm9yZSB0aGUgW1xuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGluQ2xhc3MgPSB0cnVlXG4gICAgICAgIGNsYXNzU3RhcnQgPSBpXG4gICAgICAgIHJlQ2xhc3NTdGFydCA9IHJlLmxlbmd0aFxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICddJzpcbiAgICAgICAgLy8gIGEgcmlnaHQgYnJhY2tldCBzaGFsbCBsb3NlIGl0cyBzcGVjaWFsXG4gICAgICAgIC8vICBtZWFuaW5nIGFuZCByZXByZXNlbnQgaXRzZWxmIGluXG4gICAgICAgIC8vICBhIGJyYWNrZXQgZXhwcmVzc2lvbiBpZiBpdCBvY2N1cnNcbiAgICAgICAgLy8gIGZpcnN0IGluIHRoZSBsaXN0LiAgLS0gUE9TSVguMiAyLjguMy4yXG4gICAgICAgIGlmIChpID09PSBjbGFzc1N0YXJ0ICsgMSB8fCAhaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgICAgICAgLy8gXCJbei1hXVwiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbei1hXFxdXCJcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBhbiBpbnZhbGlkIHJlLiBpZiBzbywgcmUtd2FsayB0aGUgY29udGVudHMgb2YgdGhlXG4gICAgICAgICAgLy8gd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlIGFueSBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgICAgLy8gVE9ETzogSXQgd291bGQgcHJvYmFibHkgYmUgZmFzdGVyIHRvIGRldGVybWluZSB0aGlzXG4gICAgICAgICAgLy8gd2l0aG91dCBhIHRyeS9jYXRjaCBhbmQgYSBuZXcgUmVnRXhwLCBidXQgaXQncyB0cmlja3lcbiAgICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICAgIHZhciBjcyA9IHBhdHRlcm4uc3Vic3RyaW5nKGNsYXNzU3RhcnQgKyAxLCBpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIHZhbGlkIGNsYXNzIVxuICAgICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdICsgJ1xcXFxdJ1xuICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICAgICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJy4nOlxuICAgIGNhc2UgJ1snOlxuICAgIGNhc2UgJygnOiBhZGRQYXR0ZXJuU3RhcnQgPSB0cnVlXG4gIH1cblxuICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxhY2sgb2YgbmVnYXRpdmUgbG9va2JlaGluZCBpbiBKU1xuICAvLyBBIHBhdHRlcm4gbGlrZTogKi4hKHgpLiEoeXx6KSBuZWVkcyB0byBlbnN1cmUgdGhhdCBhIG5hbWVcbiAgLy8gbGlrZSAnYS54eXoueXonIGRvZXNuJ3QgbWF0Y2guICBTbywgdGhlIGZpcnN0IG5lZ2F0aXZlXG4gIC8vIGxvb2thaGVhZCwgaGFzIHRvIGxvb2sgQUxMIHRoZSB3YXkgYWhlYWQsIHRvIHRoZSBlbmQgb2ZcbiAgLy8gdGhlIHBhdHRlcm4uXG4gIGZvciAodmFyIG4gPSBuZWdhdGl2ZUxpc3RzLmxlbmd0aCAtIDE7IG4gPiAtMTsgbi0tKSB7XG4gICAgdmFyIG5sID0gbmVnYXRpdmVMaXN0c1tuXVxuXG4gICAgdmFyIG5sQmVmb3JlID0gcmUuc2xpY2UoMCwgbmwucmVTdGFydClcbiAgICB2YXIgbmxGaXJzdCA9IHJlLnNsaWNlKG5sLnJlU3RhcnQsIG5sLnJlRW5kIC0gOClcbiAgICB2YXIgbmxMYXN0ID0gcmUuc2xpY2UobmwucmVFbmQgLSA4LCBubC5yZUVuZClcbiAgICB2YXIgbmxBZnRlciA9IHJlLnNsaWNlKG5sLnJlRW5kKVxuXG4gICAgbmxMYXN0ICs9IG5sQWZ0ZXJcblxuICAgIC8vIEhhbmRsZSBuZXN0ZWQgc3R1ZmYgbGlrZSAqKCouanN8ISgqLmpzb24pKSwgd2hlcmUgb3BlbiBwYXJlbnNcbiAgICAvLyBtZWFuIHRoYXQgd2Ugc2hvdWxkICpub3QqIGluY2x1ZGUgdGhlICkgaW4gdGhlIGJpdCB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgICAvLyBcImFmdGVyXCIgdGhlIG5lZ2F0ZWQgc2VjdGlvbi5cbiAgICB2YXIgb3BlblBhcmVuc0JlZm9yZSA9IG5sQmVmb3JlLnNwbGl0KCcoJykubGVuZ3RoIC0gMVxuICAgIHZhciBjbGVhbkFmdGVyID0gbmxBZnRlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvcGVuUGFyZW5zQmVmb3JlOyBpKyspIHtcbiAgICAgIGNsZWFuQWZ0ZXIgPSBjbGVhbkFmdGVyLnJlcGxhY2UoL1xcKVsrKj9dPy8sICcnKVxuICAgIH1cbiAgICBubEFmdGVyID0gY2xlYW5BZnRlclxuXG4gICAgdmFyIGRvbGxhciA9ICcnXG4gICAgaWYgKG5sQWZ0ZXIgPT09ICcnICYmIGlzU3ViICE9PSBTVUJQQVJTRSkge1xuICAgICAgZG9sbGFyID0gJyQnXG4gICAgfVxuICAgIHZhciBuZXdSZSA9IG5sQmVmb3JlICsgbmxGaXJzdCArIG5sQWZ0ZXIgKyBkb2xsYXIgKyBubExhc3RcbiAgICByZSA9IG5ld1JlXG4gIH1cblxuICAvLyBpZiB0aGUgcmUgaXMgbm90IFwiXCIgYXQgdGhpcyBwb2ludCwgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAvLyBpdCBkb2Vzbid0IG1hdGNoIGFnYWluc3QgYW4gZW1wdHkgcGF0aCBwYXJ0LlxuICAvLyBPdGhlcndpc2UgYS8qIHdpbGwgbWF0Y2ggYS8sIHdoaWNoIGl0IHNob3VsZCBub3QuXG4gIGlmIChyZSAhPT0gJycgJiYgaGFzTWFnaWMpIHtcbiAgICByZSA9ICcoPz0uKScgKyByZVxuICB9XG5cbiAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgIHJlID0gcGF0dGVyblN0YXJ0ICsgcmVcbiAgfVxuXG4gIC8vIHBhcnNpbmcganVzdCBhIHBpZWNlIG9mIGEgbGFyZ2VyIHBhdHRlcm4uXG4gIGlmIChpc1N1YiA9PT0gU1VCUEFSU0UpIHtcbiAgICByZXR1cm4gW3JlLCBoYXNNYWdpY11cbiAgfVxuXG4gIC8vIHNraXAgdGhlIHJlZ2V4cCBmb3Igbm9uLW1hZ2ljYWwgcGF0dGVybnNcbiAgLy8gdW5lc2NhcGUgYW55dGhpbmcgaW4gaXQsIHRob3VnaCwgc28gdGhhdCBpdCdsbCBiZVxuICAvLyBhbiBleGFjdCBtYXRjaCBhZ2FpbnN0IGEgZmlsZSBldGMuXG4gIGlmICghaGFzTWFnaWMpIHtcbiAgICByZXR1cm4gZ2xvYlVuZXNjYXBlKHBhdHRlcm4pXG4gIH1cblxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG4gIHRyeSB7XG4gICAgdmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmUgKyAnJCcsIGZsYWdzKVxuICB9IGNhdGNoIChlcikge1xuICAgIC8vIElmIGl0IHdhcyBhbiBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdGhlbiBpdCBjYW4ndCBtYXRjaFxuICAgIC8vIGFueXRoaW5nLiAgVGhpcyB0cmljayBsb29rcyBmb3IgYSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBzdHJpbmcsIHdoaWNoIGlzIG9mIGNvdXJzZSBpbXBvc3NpYmxlLCBleGNlcHQgaW4gbXVsdGktbGluZVxuICAgIC8vIG1vZGUsIGJ1dCBpdCdzIG5vdCBhIC9tIHJlZ2V4LlxuICAgIHJldHVybiBuZXcgUmVnRXhwKCckLicpXG4gIH1cblxuICByZWdFeHAuX2dsb2IgPSBwYXR0ZXJuXG4gIHJlZ0V4cC5fc3JjID0gcmVcblxuICByZXR1cm4gcmVnRXhwXG59XG5cbm1pbmltYXRjaC5tYWtlUmUgPSBmdW5jdGlvbiAocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zIHx8IHt9KS5tYWtlUmUoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2VSZSA9IG1ha2VSZVxuZnVuY3Rpb24gbWFrZVJlICgpIHtcbiAgaWYgKHRoaXMucmVnZXhwIHx8IHRoaXMucmVnZXhwID09PSBmYWxzZSkgcmV0dXJuIHRoaXMucmVnZXhwXG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgdGhpcy5zZXQgaXMgYSAyZCBhcnJheSBvZiBwYXJ0aWFsXG4gIC8vIHBhdHRlcm4gc3RyaW5ncywgb3IgXCIqKlwiLlxuICAvL1xuICAvLyBJdCdzIGJldHRlciB0byB1c2UgLm1hdGNoKCkuICBUaGlzIGZ1bmN0aW9uIHNob3VsZG4ndFxuICAvLyBiZSB1c2VkLCByZWFsbHksIGJ1dCBpdCdzIHByZXR0eSBjb252ZW5pZW50IHNvbWV0aW1lcyxcbiAgLy8gd2hlbiB5b3UganVzdCB3YW50IHRvIHdvcmsgd2l0aCBhIHJlZ2V4LlxuICB2YXIgc2V0ID0gdGhpcy5zZXRcblxuICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXMucmVnZXhwXG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB2YXIgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhciA/IHN0YXJcbiAgICA6IG9wdGlvbnMuZG90ID8gdHdvU3RhckRvdFxuICAgIDogdHdvU3Rhck5vRG90XG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcblxuICB2YXIgcmUgPSBzZXQubWFwKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKHAgPT09IEdMT0JTVEFSKSA/IHR3b1N0YXJcbiAgICAgIDogKHR5cGVvZiBwID09PSAnc3RyaW5nJykgPyByZWdFeHBFc2NhcGUocClcbiAgICAgIDogcC5fc3JjXG4gICAgfSkuam9pbignXFxcXFxcLycpXG4gIH0pLmpvaW4oJ3wnKVxuXG4gIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gIHJlID0gJ14oPzonICsgcmUgKyAnKSQnXG5cbiAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gIGlmICh0aGlzLm5lZ2F0ZSkgcmUgPSAnXig/IScgKyByZSArICcpLiokJ1xuXG4gIHRyeSB7XG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBmbGFncylcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gbWF0Y2hcbmZ1bmN0aW9uIG1hdGNoIChmLCBwYXJ0aWFsKSB7XG4gIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKVxuICAvLyBzaG9ydC1jaXJjdWl0IGluIHRoZSBjYXNlIG9mIGJ1c3RlZCB0aGluZ3MuXG4gIC8vIGNvbW1lbnRzLCBldGMuXG4gIGlmICh0aGlzLmNvbW1lbnQpIHJldHVybiBmYWxzZVxuICBpZiAodGhpcy5lbXB0eSkgcmV0dXJuIGYgPT09ICcnXG5cbiAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSByZXR1cm4gdHJ1ZVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmIChwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgZiA9IGYuc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgLy8gdHJlYXQgdGhlIHRlc3QgcGF0aCBhcyBhIHNldCBvZiBwYXRocGFydHMuXG4gIGYgPSBmLnNwbGl0KHNsYXNoU3BsaXQpXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmKVxuXG4gIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KVxuXG4gIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gIHZhciBmaWxlbmFtZVxuICB2YXIgaVxuICBmb3IgKGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZmlsZW5hbWUgPSBmW2ldXG4gICAgaWYgKGZpbGVuYW1lKSBicmVha1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXR0ZXJuID0gc2V0W2ldXG4gICAgdmFyIGZpbGUgPSBmXG4gICAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIHBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBmaWxlID0gW2ZpbGVuYW1lXVxuICAgIH1cbiAgICB2YXIgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gIXRoaXMubmVnYXRlXG4gICAgfVxuICB9XG5cbiAgLy8gZGlkbid0IGdldCBhbnkgaGl0cy4gIHRoaXMgaXMgc3VjY2VzcyBpZiBpdCdzIGEgbmVnYXRpdmVcbiAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gIGlmIChvcHRpb25zLmZsaXBOZWdhdGUpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdGhpcy5uZWdhdGVcbn1cblxuLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbi8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4vLyB0aGUgcGFydHMgbWF0Y2guXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoT25lID0gZnVuY3Rpb24gKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsXG4gICAgeyAndGhpcyc6IHRoaXMsIGZpbGU6IGZpbGUsIHBhdHRlcm46IHBhdHRlcm4gfSlcblxuICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aClcblxuICBmb3IgKHZhciBmaSA9IDAsXG4gICAgICBwaSA9IDAsXG4gICAgICBmbCA9IGZpbGUubGVuZ3RoLFxuICAgICAgcGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgICAgOyAoZmkgPCBmbCkgJiYgKHBpIDwgcGwpXG4gICAgICA7IGZpKyssIHBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJylcbiAgICB2YXIgcCA9IHBhdHRlcm5bcGldXG4gICAgdmFyIGYgPSBmaWxlW2ZpXVxuXG4gICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKVxuXG4gICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGUuXG4gICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgIGlmIChwID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgIHRoaXMuZGVidWcoJ0dMT0JTVEFSJywgW3BhdHRlcm4sIHAsIGZdKVxuXG4gICAgICAvLyBcIioqXCJcbiAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgLy8gYS94L3kvei9iL2NcbiAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAvLyBhL2IvY1xuICAgICAgLy8gVG8gZG8gdGhpcywgdGFrZSB0aGUgcmVzdCBvZiB0aGUgcGF0dGVybiBhZnRlclxuICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgIC8vIElmIG5vdCwgdGhlICoqIFwic3dhbGxvd3NcIiBhIHNlZ21lbnQsIGFuZCB0cnkgYWdhaW4uXG4gICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgLy9cbiAgICAgIC8vIGEvKiovYi8qKi9jIG1hdGNoaW5nIGEvYi94L3kvei9jXG4gICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgLSBtYXRjaE9uZShiL3gveS96L2MsIGIvKiovYylcbiAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHgveS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKGMsIGMpIHllcywgaGl0XG4gICAgICB2YXIgZnIgPSBmaVxuICAgICAgdmFyIHByID0gcGkgKyAxXG4gICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKVxuICAgICAgICAvLyBhICoqIGF0IHRoZSBlbmQgd2lsbCBqdXN0IHN3YWxsb3cgdGhlIHJlc3QuXG4gICAgICAgIC8vIFdlIGhhdmUgZm91bmQgYSBtYXRjaC5cbiAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAvLyBvcHRpb25zLmRvdCBpcyBzZXQuXG4gICAgICAgIC8vIC4gYW5kIC4uIGFyZSAqbmV2ZXIqIG1hdGNoZWQgYnkgKiosIGZvciBleHBsb3NpdmVseVxuICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICBmb3IgKDsgZmkgPCBmbDsgZmkrKykge1xuICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8IGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGxldCdzIHNlZSBpZiB3ZSBjYW4gc3dhbGxvdyB3aGF0ZXZlciB3ZSBjYW4uXG4gICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl1cblxuICAgICAgICB0aGlzLmRlYnVnKCdcXG5nbG9ic3RhciB3aGlsZScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwciwgc3dhbGxvd2VlKVxuXG4gICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSlcbiAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FuJ3Qgc3dhbGxvdyBcIi5cIiBvciBcIi4uXCIgZXZlci5cbiAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHwgc3dhbGxvd2VlID09PSAnLi4nIHx8XG4gICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIHN3YWxsb3cgYSBzZWdtZW50LCBhbmQgY29udGludWUnKVxuICAgICAgICAgIGZyKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgKnBhdHRlcm4qIGxlZnQsIHRoZW5cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0aW9ucy5ub2Nhc2UpIHtcbiAgICAgICAgaGl0ID0gZi50b0xvd2VyQ2FzZSgpID09PSBwLnRvTG93ZXJDYXNlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpdCA9IGYgPT09IHBcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9IGVsc2Uge1xuICAgICAgaGl0ID0gZi5tYXRjaChwKVxuICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdClcbiAgICB9XG5cbiAgICBpZiAoIWhpdCkgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuXG4gIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgaWYgKGZpID09PSBmbCAmJiBwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICByZXR1cm4gcGFydGlhbFxuICB9IGVsc2UgaWYgKHBpID09PSBwbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgcGF0dGVybiwgc3RpbGwgaGF2ZSBmaWxlIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBhLyogc2hvdWxkIG1hdGNoIGEvYi9cbiAgICB2YXIgZW1wdHlGaWxlRW5kID0gKGZpID09PSBmbCAtIDEpICYmIChmaWxlW2ZpXSA9PT0gJycpXG4gICAgcmV0dXJuIGVtcHR5RmlsZUVuZFxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbn1cbiIsICJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCAidHJ5IHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgdXRpbC5pbmhlcml0cyAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgJyc7XG4gIG1vZHVsZS5leHBvcnRzID0gdXRpbC5pbmhlcml0cztcbn0gY2F0Y2ggKGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2luaGVyaXRzX2Jyb3dzZXIuanMnKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcblx0cmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcblx0dmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL10rW15cXFxcXFwvXSspPyhbXFxcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuXHR2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuXHR2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuXHR2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG5cdC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG5cdHJldHVybiBCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy5wb3NpeCA9IHBvc2l4O1xubW9kdWxlLmV4cG9ydHMud2luMzIgPSB3aW4zMjtcbiIsICJleHBvcnRzLnNldG9wdHMgPSBzZXRvcHRzXG5leHBvcnRzLm93blByb3AgPSBvd25Qcm9wXG5leHBvcnRzLm1ha2VBYnMgPSBtYWtlQWJzXG5leHBvcnRzLmZpbmlzaCA9IGZpbmlzaFxuZXhwb3J0cy5tYXJrID0gbWFya1xuZXhwb3J0cy5pc0lnbm9yZWQgPSBpc0lnbm9yZWRcbmV4cG9ydHMuY2hpbGRyZW5JZ25vcmVkID0gY2hpbGRyZW5JZ25vcmVkXG5cbmZ1bmN0aW9uIG93blByb3AgKG9iaiwgZmllbGQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGZpZWxkKVxufVxuXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIilcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKFwibWluaW1hdGNoXCIpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoXCJwYXRoLWlzLWFic29sdXRlXCIpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxuXG5mdW5jdGlvbiBhbHBoYXNvcnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiLCAnZW4nKVxufVxuXG5mdW5jdGlvbiBzZXR1cElnbm9yZXMgKHNlbGYsIG9wdGlvbnMpIHtcbiAgc2VsZi5pZ25vcmUgPSBvcHRpb25zLmlnbm9yZSB8fCBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzZWxmLmlnbm9yZSkpXG4gICAgc2VsZi5pZ25vcmUgPSBbc2VsZi5pZ25vcmVdXG5cbiAgaWYgKHNlbGYuaWdub3JlLmxlbmd0aCkge1xuICAgIHNlbGYuaWdub3JlID0gc2VsZi5pZ25vcmUubWFwKGlnbm9yZU1hcClcbiAgfVxufVxuXG4vLyBpZ25vcmUgcGF0dGVybnMgYXJlIGFsd2F5cyBpbiBkb3Q6dHJ1ZSBtb2RlLlxuZnVuY3Rpb24gaWdub3JlTWFwIChwYXR0ZXJuKSB7XG4gIHZhciBnbWF0Y2hlciA9IG51bGxcbiAgaWYgKHBhdHRlcm4uc2xpY2UoLTMpID09PSAnLyoqJykge1xuICAgIHZhciBncGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvKFxcL1xcKlxcKikrJC8sICcnKVxuICAgIGdtYXRjaGVyID0gbmV3IE1pbmltYXRjaChncGF0dGVybiwgeyBkb3Q6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2hlcjogbmV3IE1pbmltYXRjaChwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KSxcbiAgICBnbWF0Y2hlcjogZ21hdGNoZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRvcHRzIChzZWxmLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge31cblxuICAvLyBiYXNlLW1hdGNoaW5nOiBqdXN0IHVzZSBnbG9ic3RhciBmb3IgdGhhdC5cbiAgaWYgKG9wdGlvbnMubWF0Y2hCYXNlICYmIC0xID09PSBwYXR0ZXJuLmluZGV4T2YoXCIvXCIpKSB7XG4gICAgaWYgKG9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZSBtYXRjaGluZyByZXF1aXJlcyBnbG9ic3RhclwiKVxuICAgIH1cbiAgICBwYXR0ZXJuID0gXCIqKi9cIiArIHBhdHRlcm5cbiAgfVxuXG4gIHNlbGYuc2lsZW50ID0gISFvcHRpb25zLnNpbGVudFxuICBzZWxmLnBhdHRlcm4gPSBwYXR0ZXJuXG4gIHNlbGYuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QgIT09IGZhbHNlXG4gIHNlbGYucmVhbHBhdGggPSAhIW9wdGlvbnMucmVhbHBhdGhcbiAgc2VsZi5yZWFscGF0aENhY2hlID0gb3B0aW9ucy5yZWFscGF0aENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5mb2xsb3cgPSAhIW9wdGlvbnMuZm9sbG93XG4gIHNlbGYuZG90ID0gISFvcHRpb25zLmRvdFxuICBzZWxmLm1hcmsgPSAhIW9wdGlvbnMubWFya1xuICBzZWxmLm5vZGlyID0gISFvcHRpb25zLm5vZGlyXG4gIGlmIChzZWxmLm5vZGlyKVxuICAgIHNlbGYubWFyayA9IHRydWVcbiAgc2VsZi5zeW5jID0gISFvcHRpb25zLnN5bmNcbiAgc2VsZi5ub3VuaXF1ZSA9ICEhb3B0aW9ucy5ub3VuaXF1ZVxuICBzZWxmLm5vbnVsbCA9ICEhb3B0aW9ucy5ub251bGxcbiAgc2VsZi5ub3NvcnQgPSAhIW9wdGlvbnMubm9zb3J0XG4gIHNlbGYubm9jYXNlID0gISFvcHRpb25zLm5vY2FzZVxuICBzZWxmLnN0YXQgPSAhIW9wdGlvbnMuc3RhdFxuICBzZWxmLm5vcHJvY2VzcyA9ICEhb3B0aW9ucy5ub3Byb2Nlc3NcbiAgc2VsZi5hYnNvbHV0ZSA9ICEhb3B0aW9ucy5hYnNvbHV0ZVxuICBzZWxmLmZzID0gb3B0aW9ucy5mcyB8fCBmc1xuXG4gIHNlbGYubWF4TGVuZ3RoID0gb3B0aW9ucy5tYXhMZW5ndGggfHwgSW5maW5pdHlcbiAgc2VsZi5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICBzZWxmLnN0YXRDYWNoZSA9IG9wdGlvbnMuc3RhdENhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zeW1saW5rcyA9IG9wdGlvbnMuc3ltbGlua3MgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIHNldHVwSWdub3JlcyhzZWxmLCBvcHRpb25zKVxuXG4gIHNlbGYuY2hhbmdlZEN3ZCA9IGZhbHNlXG4gIHZhciBjd2QgPSBwcm9jZXNzLmN3ZCgpXG4gIGlmICghb3duUHJvcChvcHRpb25zLCBcImN3ZFwiKSlcbiAgICBzZWxmLmN3ZCA9IGN3ZFxuICBlbHNlIHtcbiAgICBzZWxmLmN3ZCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZClcbiAgICBzZWxmLmNoYW5nZWRDd2QgPSBzZWxmLmN3ZCAhPT0gY3dkXG4gIH1cblxuICBzZWxmLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgcGF0aC5yZXNvbHZlKHNlbGYuY3dkLCBcIi9cIilcbiAgc2VsZi5yb290ID0gcGF0aC5yZXNvbHZlKHNlbGYucm9vdClcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIilcbiAgICBzZWxmLnJvb3QgPSBzZWxmLnJvb3QucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcblxuICAvLyBUT0RPOiBpcyBhbiBhYnNvbHV0ZSBgY3dkYCBzdXBwb3NlZCB0byBiZSByZXNvbHZlZCBhZ2FpbnN0IGByb290YD9cbiAgLy8gZS5nLiB7IGN3ZDogJy90ZXN0Jywgcm9vdDogX19kaXJuYW1lIH0gPT09IHBhdGguam9pbihfX2Rpcm5hbWUsICcvdGVzdCcpXG4gIHNlbGYuY3dkQWJzID0gaXNBYnNvbHV0ZShzZWxmLmN3ZCkgPyBzZWxmLmN3ZCA6IG1ha2VBYnMoc2VsZiwgc2VsZi5jd2QpXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG4gICAgc2VsZi5jd2RBYnMgPSBzZWxmLmN3ZEFicy5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuICBzZWxmLm5vbW91bnQgPSAhIW9wdGlvbnMubm9tb3VudFxuXG4gIC8vIGRpc2FibGUgY29tbWVudHMgYW5kIG5lZ2F0aW9uIGluIE1pbmltYXRjaC5cbiAgLy8gTm90ZSB0aGF0IHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gR2xvYiBpdHNlbGYgYW55d2F5LlxuICBvcHRpb25zLm5vbmVnYXRlID0gdHJ1ZVxuICBvcHRpb25zLm5vY29tbWVudCA9IHRydWVcblxuICBzZWxmLm1pbmltYXRjaCA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgc2VsZi5vcHRpb25zID0gc2VsZi5taW5pbWF0Y2gub3B0aW9uc1xufVxuXG5mdW5jdGlvbiBmaW5pc2ggKHNlbGYpIHtcbiAgdmFyIG5vdSA9IHNlbGYubm91bmlxdWVcbiAgdmFyIGFsbCA9IG5vdSA/IFtdIDogT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5tYXRjaGVzLmxlbmd0aDsgaSA8IGw7IGkgKyspIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHNlbGYubWF0Y2hlc1tpXVxuICAgIGlmICghbWF0Y2hlcyB8fCBPYmplY3Qua2V5cyhtYXRjaGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChzZWxmLm5vbnVsbCkge1xuICAgICAgICAvLyBkbyBsaWtlIHRoZSBzaGVsbCwgYW5kIHNwaXQgb3V0IHRoZSBsaXRlcmFsIGdsb2JcbiAgICAgICAgdmFyIGxpdGVyYWwgPSBzZWxmLm1pbmltYXRjaC5nbG9iU2V0W2ldXG4gICAgICAgIGlmIChub3UpXG4gICAgICAgICAgYWxsLnB1c2gobGl0ZXJhbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFsbFtsaXRlcmFsXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFkIG1hdGNoZXNcbiAgICAgIHZhciBtID0gT2JqZWN0LmtleXMobWF0Y2hlcylcbiAgICAgIGlmIChub3UpXG4gICAgICAgIGFsbC5wdXNoLmFwcGx5KGFsbCwgbSlcbiAgICAgIGVsc2VcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgYWxsW21dID0gdHJ1ZVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghbm91KVxuICAgIGFsbCA9IE9iamVjdC5rZXlzKGFsbClcblxuICBpZiAoIXNlbGYubm9zb3J0KVxuICAgIGFsbCA9IGFsbC5zb3J0KGFscGhhc29ydClcblxuICAvLyBhdCAqc29tZSogcG9pbnQgd2Ugc3RhdHRlZCBhbGwgb2YgdGhlc2VcbiAgaWYgKHNlbGYubWFyaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbGxbaV0gPSBzZWxmLl9tYXJrKGFsbFtpXSlcbiAgICB9XG4gICAgaWYgKHNlbGYubm9kaXIpIHtcbiAgICAgIGFsbCA9IGFsbC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIG5vdERpciA9ICEoL1xcLyQvLnRlc3QoZSkpXG4gICAgICAgIHZhciBjID0gc2VsZi5jYWNoZVtlXSB8fCBzZWxmLmNhY2hlW21ha2VBYnMoc2VsZiwgZSldXG4gICAgICAgIGlmIChub3REaXIgJiYgYylcbiAgICAgICAgICBub3REaXIgPSBjICE9PSAnRElSJyAmJiAhQXJyYXkuaXNBcnJheShjKVxuICAgICAgICByZXR1cm4gbm90RGlyXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgYWxsID0gYWxsLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gIWlzSWdub3JlZChzZWxmLCBtKVxuICAgIH0pXG5cbiAgc2VsZi5mb3VuZCA9IGFsbFxufVxuXG5mdW5jdGlvbiBtYXJrIChzZWxmLCBwKSB7XG4gIHZhciBhYnMgPSBtYWtlQWJzKHNlbGYsIHApXG4gIHZhciBjID0gc2VsZi5jYWNoZVthYnNdXG4gIHZhciBtID0gcFxuICBpZiAoYykge1xuICAgIHZhciBpc0RpciA9IGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYylcbiAgICB2YXIgc2xhc2ggPSBwLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgICBpZiAoaXNEaXIgJiYgIXNsYXNoKVxuICAgICAgbSArPSAnLydcbiAgICBlbHNlIGlmICghaXNEaXIgJiYgc2xhc2gpXG4gICAgICBtID0gbS5zbGljZSgwLCAtMSlcblxuICAgIGlmIChtICE9PSBwKSB7XG4gICAgICB2YXIgbWFicyA9IG1ha2VBYnMoc2VsZiwgbSlcbiAgICAgIHNlbGYuc3RhdENhY2hlW21hYnNdID0gc2VsZi5zdGF0Q2FjaGVbYWJzXVxuICAgICAgc2VsZi5jYWNoZVttYWJzXSA9IHNlbGYuY2FjaGVbYWJzXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbi8vIGxvdHRhIHNpdHVwcy4uLlxuZnVuY3Rpb24gbWFrZUFicyAoc2VsZiwgZikge1xuICB2YXIgYWJzID0gZlxuICBpZiAoZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIGFicyA9IHBhdGguam9pbihzZWxmLnJvb3QsIGYpXG4gIH0gZWxzZSBpZiAoaXNBYnNvbHV0ZShmKSB8fCBmID09PSAnJykge1xuICAgIGFicyA9IGZcbiAgfSBlbHNlIGlmIChzZWxmLmNoYW5nZWRDd2QpIHtcbiAgICBhYnMgPSBwYXRoLnJlc29sdmUoc2VsZi5jd2QsIGYpXG4gIH0gZWxzZSB7XG4gICAgYWJzID0gcGF0aC5yZXNvbHZlKGYpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcbiAgICBhYnMgPSBhYnMucmVwbGFjZSgvXFxcXC9nLCAnLycpXG5cbiAgcmV0dXJuIGFic1xufVxuXG5cbi8vIFJldHVybiB0cnVlLCBpZiBwYXR0ZXJuIGVuZHMgd2l0aCBnbG9ic3RhciAnKionLCBmb3IgdGhlIGFjY29tcGFueWluZyBwYXJlbnQgZGlyZWN0b3J5LlxuLy8gRXg6LSBJZiBub2RlX21vZHVsZXMvKiogaXMgdGhlIHBhdHRlcm4sIGFkZCAnbm9kZV9tb2R1bGVzJyB0byBpZ25vcmUgbGlzdCBhbG9uZyB3aXRoIGl0J3MgY29udGVudHNcbmZ1bmN0aW9uIGlzSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0ubWF0Y2hlci5tYXRjaChwYXRoKSB8fCAhIShpdGVtLmdtYXRjaGVyICYmIGl0ZW0uZ21hdGNoZXIubWF0Y2gocGF0aCkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuSWdub3JlZCAoc2VsZiwgcGF0aCkge1xuICBpZiAoIXNlbGYuaWdub3JlLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gc2VsZi5pZ25vcmUuc29tZShmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuICEhKGl0ZW0uZ21hdGNoZXIgJiYgaXRlbS5nbWF0Y2hlci5tYXRjaChwYXRoKSlcbiAgfSlcbn1cbiIsICJtb2R1bGUuZXhwb3J0cyA9IGdsb2JTeW5jXG5nbG9iU3luYy5HbG9iU3luYyA9IEdsb2JTeW5jXG5cbnZhciBycCA9IHJlcXVpcmUoJ2ZzLnJlYWxwYXRoJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBHbG9iID0gcmVxdWlyZSgnLi9nbG9iLmpzJykuR2xvYlxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIHNldG9wdHMgPSBjb21tb24uc2V0b3B0c1xudmFyIG93blByb3AgPSBjb21tb24ub3duUHJvcFxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcbnZhciBpc0lnbm9yZWQgPSBjb21tb24uaXNJZ25vcmVkXG5cbmZ1bmN0aW9uIGdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIHByb3ZpZGVkIHRvIHN5bmMgZ2xvYlxcbicrXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMTY3JylcblxuICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpLmZvdW5kXG59XG5cbmZ1bmN0aW9uIEdsb2JTeW5jIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghcGF0dGVybilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBwYXR0ZXJuJylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKSlcbiAgICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIGlmICh0aGlzLm5vcHJvY2VzcylcbiAgICByZXR1cm4gdGhpc1xuXG4gIHZhciBuID0gdGhpcy5taW5pbWF0Y2guc2V0Lmxlbmd0aFxuICB0aGlzLm1hdGNoZXMgPSBuZXcgQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlKVxuICB9XG4gIHRoaXMuX2ZpbmlzaCgpXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2JTeW5jKVxuICBpZiAodGhpcy5yZWFscGF0aCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMubWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaHNldCwgaW5kZXgpIHtcbiAgICAgIHZhciBzZXQgPSBzZWxmLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgZm9yICh2YXIgcCBpbiBtYXRjaHNldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBzZWxmLl9tYWtlQWJzKHApXG4gICAgICAgICAgdmFyIHJlYWwgPSBycC5yZWFscGF0aFN5bmMocCwgc2VsZi5yZWFscGF0aENhY2hlKVxuICAgICAgICAgIHNldFtyZWFsXSA9IHRydWVcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBpZiAoZXIuc3lzY2FsbCA9PT0gJ3N0YXQnKVxuICAgICAgICAgICAgc2V0W3NlbGYuX21ha2VBYnMocCldID0gdHJ1ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGNvbW1vbi5maW5pc2godGhpcylcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcblxuICAvLyBHZXQgdGhlIGZpcnN0IFtuXSBwYXJ0cyBvZiBwYXR0ZXJuIHRoYXQgYXJlIGFsbCBzdHJpbmdzLlxuICB2YXIgbiA9IDBcbiAgd2hpbGUgKHR5cGVvZiBwYXR0ZXJuW25dID09PSAnc3RyaW5nJykge1xuICAgIG4gKytcbiAgfVxuICAvLyBub3cgbiBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9uZSB0aGF0IGlzICpub3QqIGEgc3RyaW5nLlxuXG4gIC8vIFNlZSBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2VcbiAgdmFyIHByZWZpeFxuICBzd2l0Y2ggKG4pIHtcbiAgICAvLyBpZiBub3QsIHRoZW4gdGhpcyBpcyByYXRoZXIgc2ltcGxlXG4gICAgY2FzZSBwYXR0ZXJuLmxlbmd0aDpcbiAgICAgIHRoaXMuX3Byb2Nlc3NTaW1wbGUocGF0dGVybi5qb2luKCcvJyksIGluZGV4KVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBwYXR0ZXJuICpzdGFydHMqIHdpdGggc29tZSBub24tdHJpdmlhbCBpdGVtLlxuICAgICAgLy8gZ29pbmcgdG8gcmVhZGRpcihjd2QpLCBidXQgbm90IGluY2x1ZGUgdGhlIHByZWZpeCBpbiBtYXRjaGVzLlxuICAgICAgcHJlZml4ID0gbnVsbFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXR0ZXJuIGhhcyBzb21lIHN0cmluZyBiaXRzIGluIHRoZSBmcm9udC5cbiAgICAgIC8vIHdoYXRldmVyIGl0IHN0YXJ0cyB3aXRoLCB3aGV0aGVyIHRoYXQncyAnYWJzb2x1dGUnIGxpa2UgL2Zvby9iYXIsXG4gICAgICAvLyBvciAncmVsYXRpdmUnIGxpa2UgJy4uL2JheidcbiAgICAgIHByZWZpeCA9IHBhdHRlcm4uc2xpY2UoMCwgbikuam9pbignLycpXG4gICAgICBicmVha1xuICB9XG5cbiAgdmFyIHJlbWFpbiA9IHBhdHRlcm4uc2xpY2UobilcblxuICAvLyBnZXQgdGhlIGxpc3Qgb2YgZW50cmllcy5cbiAgdmFyIHJlYWRcbiAgaWYgKHByZWZpeCA9PT0gbnVsbClcbiAgICByZWFkID0gJy4nXG4gIGVsc2UgaWYgKGlzQWJzb2x1dGUocHJlZml4KSB8fCBpc0Fic29sdXRlKHBhdHRlcm4uam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBwcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcilcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyID0gZnVuY3Rpb24gKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIEl0IHdpbGwgb25seSBtYXRjaCBkb3QgZW50cmllcyBpZiBpdCBzdGFydHMgd2l0aCBhIGRvdCwgb3IgaWZcbiAgLy8gZG90IGlzIHNldC4gIFN0dWZmIGxpa2UgQCguZm9vfC5iYXIpIGlzbid0IGFsbG93ZWQuXG4gIHZhciBwbiA9IHJlbWFpblswXVxuICB2YXIgbmVnYXRlID0gISF0aGlzLm1pbmltYXRjaC5uZWdhdGVcbiAgdmFyIHJhd0dsb2IgPSBwbi5fZ2xvYlxuICB2YXIgZG90T2sgPSB0aGlzLmRvdCB8fCByYXdHbG9iLmNoYXJBdCgwKSA9PT0gJy4nXG5cbiAgdmFyIG1hdGNoZWRFbnRyaWVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgaWYgKGUuY2hhckF0KDApICE9PSAnLicgfHwgZG90T2spIHtcbiAgICAgIHZhciBtXG4gICAgICBpZiAobmVnYXRlICYmICFwcmVmaXgpIHtcbiAgICAgICAgbSA9ICFlLm1hdGNoKHBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGUubWF0Y2gocG4pXG4gICAgICB9XG4gICAgICBpZiAobSlcbiAgICAgICAgbWF0Y2hlZEVudHJpZXMucHVzaChlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuXG5cbiAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmcgcGF0dGVybiBiaXQsIHRoZW4gbm8gbmVlZCBmb3JcbiAgLy8gYW4gYWRkaXRpb25hbCBzdGF0ICp1bmxlc3MqIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgbWFyayBvclxuICAvLyBzdGF0IGV4cGxpY2l0bHkuICBXZSBrbm93IHRoZXkgZXhpc3QsIHNpbmNlIHJlYWRkaXIgcmV0dXJuZWRcbiAgLy8gdGhlbS5cblxuICBpZiAocmVtYWluLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5tYXJrICYmICF0aGlzLnN0YXQpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHByZWZpeC5zbGljZSgtMSkgIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeClcbiAgICAgIG5ld1BhdHRlcm4gPSBbcHJlZml4LCBlXVxuICAgIGVsc2VcbiAgICAgIG5ld1BhdHRlcm4gPSBbZV1cbiAgICB0aGlzLl9wcm9jZXNzKG5ld1BhdHRlcm4uY29uY2F0KHJlbWFpbiksIGluZGV4LCBpbkdsb2JTdGFyKVxuICB9XG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9lbWl0TWF0Y2ggPSBmdW5jdGlvbiAoaW5kZXgsIGUpIHtcbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSkge1xuICAgIGUgPSBhYnNcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICBpZiAodGhpcy5zdGF0KVxuICAgIHRoaXMuX3N0YXQoZSlcbn1cblxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicykge1xuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSlcblxuICB2YXIgZW50cmllc1xuICB2YXIgbHN0YXRcbiAgdmFyIHN0YXRcbiAgdHJ5IHtcbiAgICBsc3RhdCA9IHRoaXMuZnMubHN0YXRTeW5jKGFicylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIC8vIGxzdGF0IGZhaWxlZCwgZG9lc24ndCBleGlzdFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gIHRoaXMuc3ltbGlua3NbYWJzXSA9IGlzU3ltXG5cbiAgLy8gSWYgaXQncyBub3QgYSBzeW1saW5rIG9yIGEgZGlyLCB0aGVuIGl0J3MgZGVmaW5pdGVseSBhIHJlZ3VsYXIgZmlsZS5cbiAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gIGlmICghaXNTeW0gJiYgbHN0YXQgJiYgIWxzdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gIGVsc2VcbiAgICBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlKVxuXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpciA9IGZ1bmN0aW9uIChhYnMsIGluR2xvYlN0YXIpIHtcbiAgdmFyIGVudHJpZXNcblxuICBpZiAoaW5HbG9iU3RhciAmJiAhb3duUHJvcCh0aGlzLnN5bWxpbmtzLCBhYnMpKVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlySW5HbG9iU3RhcihhYnMpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyRW50cmllcyhhYnMsIHRoaXMuZnMucmVhZGRpclN5bmMoYWJzKSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aGlzLl9yZWFkZGlyRXJyb3IoYWJzLCBlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzKSB7XG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcblxuICAvLyBtYXJrIGFuZCBjYWNoZSBkaXItbmVzc1xuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlcikge1xuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2JTeW5jLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKCFzdGF0KSB7XG4gICAgdmFyIGxzdGF0XG4gICAgdHJ5IHtcbiAgICAgIGxzdGF0ID0gdGhpcy5mcy5sc3RhdFN5bmMoYWJzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVyLmNvZGUgPT09ICdFTk9URElSJykpIHtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0ID0gdGhpcy5mcy5zdGF0U3luYyhhYnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBzdGF0ID0gbHN0YXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdCA9IGxzdGF0XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IHN0YXRcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG5cbiAgdGhpcy5jYWNoZVthYnNdID0gdGhpcy5jYWNoZVthYnNdIHx8IGNcblxuICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIGNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fbWFrZUFicyA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBjb21tb24ubWFrZUFicyh0aGlzLCBmKVxufVxuIiwgIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwgInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcbm1vZHVsZS5leHBvcnRzLnN0cmljdCA9IHdyYXBweShvbmNlU3RyaWN0KVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlU3RyaWN0KHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG5cbmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcilcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICB2YXIgbmFtZSA9IGZuLm5hbWUgfHwgJ0Z1bmN0aW9uIHdyYXBwZWQgd2l0aCBgb25jZWAnXG4gIGYub25jZUVycm9yID0gbmFtZSArIFwiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcIlxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCAidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG52YXIgcmVxcyA9IE9iamVjdC5jcmVhdGUobnVsbClcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KGluZmxpZ2h0KVxuXG5mdW5jdGlvbiBpbmZsaWdodCAoa2V5LCBjYikge1xuICBpZiAocmVxc1trZXldKSB7XG4gICAgcmVxc1trZXldLnB1c2goY2IpXG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICByZXFzW2tleV0gPSBbY2JdXG4gICAgcmV0dXJuIG1ha2VyZXMoa2V5KVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VyZXMgKGtleSkge1xuICByZXR1cm4gb25jZShmdW5jdGlvbiBSRVMgKCkge1xuICAgIHZhciBjYnMgPSByZXFzW2tleV1cbiAgICB2YXIgbGVuID0gY2JzLmxlbmd0aFxuICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKVxuXG4gICAgLy8gWFhYIEl0J3Mgc29tZXdoYXQgYW1iaWd1b3VzIHdoZXRoZXIgYSBuZXcgY2FsbGJhY2sgYWRkZWQgaW4gdGhpc1xuICAgIC8vIHBhc3Mgc2hvdWxkIGJlIHF1ZXVlZCBmb3IgbGF0ZXIgZXhlY3V0aW9uIGlmIHNvbWV0aGluZyBpbiB0aGVcbiAgICAvLyBsaXN0IG9mIGNhbGxiYWNrcyB0aHJvd3MsIG9yIGlmIGl0IHNob3VsZCBqdXN0IGJlIGRpc2NhcmRlZC5cbiAgICAvLyBIb3dldmVyLCBpdCdzIHN1Y2ggYW4gZWRnZSBjYXNlIHRoYXQgaXQgaGFyZGx5IG1hdHRlcnMsIGFuZCBlaXRoZXJcbiAgICAvLyBjaG9pY2UgaXMgbGlrZWx5IGFzIHN1cnByaXNpbmcgYXMgdGhlIG90aGVyLlxuICAgIC8vIEFzIGl0IGhhcHBlbnMsIHdlIGRvIGdvIGFoZWFkIGFuZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIgZXhlY3V0aW9uLlxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseShudWxsLCBhcmdzKVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoY2JzLmxlbmd0aCA+IGxlbikge1xuICAgICAgICAvLyBhZGRlZCBtb3JlIGluIHRoZSBpbnRlcmltLlxuICAgICAgICAvLyBkZS16YWxnbywganVzdCBpbiBjYXNlLCBidXQgZG9uJ3QgY2FsbCBhZ2Fpbi5cbiAgICAgICAgY2JzLnNwbGljZSgwLCBsZW4pXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFJFUy5hcHBseShudWxsLCBhcmdzKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHJlcXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gc2xpY2UgKGFyZ3MpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoXG4gIHZhciBhcnJheSA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaV0gPSBhcmdzW2ldXG4gIHJldHVybiBhcnJheVxufVxuIiwgIi8vIEFwcHJvYWNoOlxuLy9cbi8vIDEuIEdldCB0aGUgbWluaW1hdGNoIHNldFxuLy8gMi4gRm9yIGVhY2ggcGF0dGVybiBpbiB0aGUgc2V0LCBQUk9DRVNTKHBhdHRlcm4sIGZhbHNlKVxuLy8gMy4gU3RvcmUgbWF0Y2hlcyBwZXItc2V0LCB0aGVuIHVuaXEgdGhlbVxuLy9cbi8vIFBST0NFU1MocGF0dGVybiwgaW5HbG9iU3Rhcilcbi8vIEdldCB0aGUgZmlyc3QgW25dIGl0ZW1zIGZyb20gcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5nc1xuLy8gSm9pbiB0aGVzZSB0b2dldGhlci4gIFRoaXMgaXMgUFJFRklYLlxuLy8gICBJZiB0aGVyZSBpcyBubyBtb3JlIHJlbWFpbmluZywgdGhlbiBzdGF0KFBSRUZJWCkgYW5kXG4vLyAgIGFkZCB0byBtYXRjaGVzIGlmIGl0IHN1Y2NlZWRzLiAgRU5ELlxuLy9cbi8vIElmIGluR2xvYlN0YXIgYW5kIFBSRUZJWCBpcyBzeW1saW5rIGFuZCBwb2ludHMgdG8gZGlyXG4vLyAgIHNldCBFTlRSSUVTID0gW11cbi8vIGVsc2UgcmVhZGRpcihQUkVGSVgpIGFzIEVOVFJJRVNcbi8vICAgSWYgZmFpbCwgRU5EXG4vL1xuLy8gd2l0aCBFTlRSSUVTXG4vLyAgIElmIHBhdHRlcm5bbl0gaXMgR0xPQlNUQVJcbi8vICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGdsb2JzdGFyIG1hdGNoIGlzIGVtcHR5XG4vLyAgICAgLy8gYnkgcHJ1bmluZyBpdCBvdXQsIGFuZCB0ZXN0aW5nIHRoZSByZXN1bHRpbmcgcGF0dGVyblxuLy8gICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIHBhdHRlcm5bbisxIC4uICRdLCBmYWxzZSlcbi8vICAgICAvLyBoYW5kbGUgb3RoZXIgY2FzZXMuXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcylcbi8vICAgICAgIC8vIGF0dGFjaCBnbG9ic3RhciArIHRhaWwgb250byB0aGUgZW50cnlcbi8vICAgICAgIC8vIE1hcmsgdGhhdCB0aGlzIGVudHJ5IGlzIGEgZ2xvYnN0YXIgbWF0Y2hcbi8vICAgICAgIFBST0NFU1MocGF0dGVyblswLi5uXSArIEVOVFJZICsgcGF0dGVybltuIC4uICRdLCB0cnVlKVxuLy9cbi8vICAgZWxzZSAvLyBub3QgZ2xvYnN0YXJcbi8vICAgICBmb3IgRU5UUlkgaW4gRU5UUklFUyAobm90IGRvdGZpbGVzLCB1bmxlc3MgcGF0dGVybltuXSBpcyBkb3QpXG4vLyAgICAgICBUZXN0IEVOVFJZIGFnYWluc3QgcGF0dGVybltuXVxuLy8gICAgICAgSWYgZmFpbHMsIGNvbnRpbnVlXG4vLyAgICAgICBJZiBwYXNzZXMsIFBST0NFU1MocGF0dGVyblswLi5uXSArIGl0ZW0gKyBwYXR0ZXJuW24rMSAuLiAkXSlcbi8vXG4vLyBDYXZlYXQ6XG4vLyAgIENhY2hlIGFsbCBzdGF0cyBhbmQgcmVhZGRpcnMgcmVzdWx0cyB0byBtaW5pbWl6ZSBzeXNjYWxsLiAgU2luY2UgYWxsXG4vLyAgIHdlIGV2ZXIgY2FyZSBhYm91dCBpcyBleGlzdGVuY2UgYW5kIGRpcmVjdG9yeS1uZXNzLCB3ZSBjYW4ganVzdCBrZWVwXG4vLyAgIGB0cnVlYCBmb3IgZmlsZXMsIGFuZCBbY2hpbGRyZW4sLi4uXSBmb3IgZGlyZWN0b3JpZXMsIG9yIGBmYWxzZWAgZm9yXG4vLyAgIHRoaW5ncyB0aGF0IGRvbid0IGV4aXN0LlxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JcblxudmFyIHJwID0gcmVxdWlyZSgnZnMucmVhbHBhdGgnKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoJ21pbmltYXRjaCcpXG52YXIgTWluaW1hdGNoID0gbWluaW1hdGNoLk1pbmltYXRjaFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgaXNBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKVxudmFyIGdsb2JTeW5jID0gcmVxdWlyZSgnLi9zeW5jLmpzJylcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbi5qcycpXG52YXIgc2V0b3B0cyA9IGNvbW1vbi5zZXRvcHRzXG52YXIgb3duUHJvcCA9IGNvbW1vbi5vd25Qcm9wXG52YXIgaW5mbGlnaHQgPSByZXF1aXJlKCdpbmZsaWdodCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIGNoaWxkcmVuSWdub3JlZCA9IGNvbW1vbi5jaGlsZHJlbklnbm9yZWRcbnZhciBpc0lnbm9yZWQgPSBjb21tb24uaXNJZ25vcmVkXG5cbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbmZ1bmN0aW9uIGdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgY2IgPSBvcHRpb25zLCBvcHRpb25zID0ge31cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBpZiAob3B0aW9ucy5zeW5jKSB7XG4gICAgaWYgKGNiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iJylcbiAgICByZXR1cm4gZ2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYilcbn1cblxuZ2xvYi5zeW5jID0gZ2xvYlN5bmNcbnZhciBHbG9iU3luYyA9IGdsb2IuR2xvYlN5bmMgPSBnbG9iU3luYy5HbG9iU3luY1xuXG4vLyBvbGQgYXBpIHN1cmZhY2Vcbmdsb2IuZ2xvYiA9IGdsb2JcblxuZnVuY3Rpb24gZXh0ZW5kIChvcmlnaW4sIGFkZCkge1xuICBpZiAoYWRkID09PSBudWxsIHx8IHR5cGVvZiBhZGQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9yaWdpblxuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpXG4gIHZhciBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXVxuICB9XG4gIHJldHVybiBvcmlnaW5cbn1cblxuZ2xvYi5oYXNNYWdpYyA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zXykge1xuICB2YXIgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9uc18pXG4gIG9wdGlvbnMubm9wcm9jZXNzID0gdHJ1ZVxuXG4gIHZhciBnID0gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucylcbiAgdmFyIHNldCA9IGcubWluaW1hdGNoLnNldFxuXG4gIGlmICghcGF0dGVybilcbiAgICByZXR1cm4gZmFsc2VcblxuICBpZiAoc2V0Lmxlbmd0aCA+IDEpXG4gICAgcmV0dXJuIHRydWVcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNldFswXS5sZW5ndGg7IGorKykge1xuICAgIGlmICh0eXBlb2Ygc2V0WzBdW2pdICE9PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZ2xvYi5HbG9iID0gR2xvYlxuaW5oZXJpdHMoR2xvYiwgRUUpXG5mdW5jdGlvbiBHbG9iIChwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gbnVsbFxuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jKSB7XG4gICAgaWYgKGNiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iJylcbiAgICByZXR1cm4gbmV3IEdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2xvYikpXG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcbiAgdGhpcy5fZGlkUmVhbFBhdGggPSBmYWxzZVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBwYXR0ZXJuIGluIHRoZSBtaW5pbWF0Y2ggc2V0XG4gIHZhciBuID0gdGhpcy5taW5pbWF0Y2guc2V0Lmxlbmd0aFxuXG4gIC8vIFRoZSBtYXRjaGVzIGFyZSBzdG9yZWQgYXMgezxmaWxlbmFtZT46IHRydWUsLi4ufSBzbyB0aGF0XG4gIC8vIGR1cGxpY2F0ZXMgYXJlIGF1dG9tYWdpY2FsbHkgcHJ1bmVkLlxuICAvLyBMYXRlciwgd2UgZG8gYW4gT2JqZWN0LmtleXMoKSBvbiB0aGVzZS5cbiAgLy8gS2VlcCB0aGVtIGFzIGEgbGlzdCBzbyB3ZSBjYW4gZmlsbCBpbiB3aGVuIG5vbnVsbCBpcyBzZXQuXG4gIHRoaXMubWF0Y2hlcyA9IG5ldyBBcnJheShuKVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9uY2UoY2IpXG4gICAgdGhpcy5vbignZXJyb3InLCBjYilcbiAgICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAobWF0Y2hlcykge1xuICAgICAgY2IobnVsbCwgbWF0Y2hlcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3Byb2Nlc3NpbmcgPSAwXG5cbiAgdGhpcy5fZW1pdFF1ZXVlID0gW11cbiAgdGhpcy5fcHJvY2Vzc1F1ZXVlID0gW11cbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuXG4gIGlmICh0aGlzLm5vcHJvY2VzcylcbiAgICByZXR1cm4gdGhpc1xuXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiBkb25lKClcblxuICB2YXIgc3luYyA9IHRydWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpICsrKSB7XG4gICAgdGhpcy5fcHJvY2Vzcyh0aGlzLm1pbmltYXRjaC5zZXRbaV0sIGksIGZhbHNlLCBkb25lKVxuICB9XG4gIHN5bmMgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIC0tc2VsZi5fcHJvY2Vzc2luZ1xuICAgIGlmIChzZWxmLl9wcm9jZXNzaW5nIDw9IDApIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9maW5pc2goKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2IpXG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMucmVhbHBhdGggJiYgIXRoaXMuX2RpZFJlYWxwYXRoKVxuICAgIHJldHVybiB0aGlzLl9yZWFscGF0aCgpXG5cbiAgY29tbW9uLmZpbmlzaCh0aGlzKVxuICB0aGlzLmVtaXQoJ2VuZCcsIHRoaXMuZm91bmQpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFscGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RpZFJlYWxwYXRoKVxuICAgIHJldHVyblxuXG4gIHRoaXMuX2RpZFJlYWxwYXRoID0gdHJ1ZVxuXG4gIHZhciBuID0gdGhpcy5tYXRjaGVzLmxlbmd0aFxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoKClcblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5fcmVhbHBhdGhTZXQoaSwgbmV4dClcblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBpZiAoLS1uID09PSAwKVxuICAgICAgc2VsZi5fZmluaXNoKClcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhbHBhdGhTZXQgPSBmdW5jdGlvbiAoaW5kZXgsIGNiKSB7XG4gIHZhciBtYXRjaHNldCA9IHRoaXMubWF0Y2hlc1tpbmRleF1cbiAgaWYgKCFtYXRjaHNldClcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBmb3VuZCA9IE9iamVjdC5rZXlzKG1hdGNoc2V0KVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG4gPSBmb3VuZC5sZW5ndGhcblxuICBpZiAobiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIHZhciBzZXQgPSB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBmb3VuZC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgLy8gSWYgdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgc3RhdCwgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgLy8gb25lIG9yIG1vcmUgb2YgdGhlIGxpbmtzIGluIHRoZSByZWFscGF0aCBjb3VsZG4ndCBiZVxuICAgIC8vIHJlc29sdmVkLiAganVzdCByZXR1cm4gdGhlIGFicyB2YWx1ZSBpbiB0aGF0IGNhc2UuXG4gICAgcCA9IHNlbGYuX21ha2VBYnMocClcbiAgICBycC5yZWFscGF0aChwLCBzZWxmLnJlYWxwYXRoQ2FjaGUsIGZ1bmN0aW9uIChlciwgcmVhbCkge1xuICAgICAgaWYgKCFlcilcbiAgICAgICAgc2V0W3JlYWxdID0gdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXIuc3lzY2FsbCA9PT0gJ3N0YXQnKVxuICAgICAgICBzZXRbcF0gPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcikgLy8gc3JzbHkgd3RmIHJpZ2h0IGhlcmVcblxuICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICBzZWxmLm1hdGNoZXNbaW5kZXhdID0gc2V0XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5HbG9iLnByb3RvdHlwZS5fbWFyayA9IGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBjb21tb24ubWFyayh0aGlzLCBwKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fbWFrZUFicyA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBjb21tb24ubWFrZUFicyh0aGlzLCBmKVxufVxuXG5HbG9iLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICB0aGlzLmVtaXQoJ2Fib3J0Jylcbn1cblxuR2xvYi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJylcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2VtaXRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBlcSA9IHRoaXMuX2VtaXRRdWV1ZS5zbGljZSgwKVxuICAgICAgdGhpcy5fZW1pdFF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBlID0gZXFbaV1cbiAgICAgICAgdGhpcy5fZW1pdE1hdGNoKGVbMF0sIGVbMV0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcm9jZXNzUXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgcHEgPSB0aGlzLl9wcm9jZXNzUXVldWUuc2xpY2UoMClcbiAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZS5sZW5ndGggPSAwXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBxLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIgcCA9IHBxW2ldXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmctLVxuICAgICAgICB0aGlzLl9wcm9jZXNzKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYikge1xuICBhc3NlcnQodGhpcyBpbnN0YW5jZW9mIEdsb2IpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICB0aGlzLl9wcm9jZXNzaW5nKytcbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlLnB1c2goW3BhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyLCBjYl0pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ1BST0NFU1MgJWQnLCB0aGlzLl9wcm9jZXNzaW5nLCBwYXR0ZXJuKVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgW25dIHBhcnRzIG9mIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3MuXG4gIHZhciBuID0gMFxuICB3aGlsZSAodHlwZW9mIHBhdHRlcm5bbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgbiArK1xuICB9XG4gIC8vIG5vdyBuIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgKm5vdCogYSBzdHJpbmcuXG5cbiAgLy8gc2VlIGlmIHRoZXJlJ3MgYW55dGhpbmcgZWxzZVxuICB2YXIgcHJlZml4XG4gIHN3aXRjaCAobikge1xuICAgIC8vIGlmIG5vdCwgdGhlbiB0aGlzIGlzIHJhdGhlciBzaW1wbGVcbiAgICBjYXNlIHBhdHRlcm4ubGVuZ3RoOlxuICAgICAgdGhpcy5fcHJvY2Vzc1NpbXBsZShwYXR0ZXJuLmpvaW4oJy8nKSwgaW5kZXgsIGNiKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlIDA6XG4gICAgICAvLyBwYXR0ZXJuICpzdGFydHMqIHdpdGggc29tZSBub24tdHJpdmlhbCBpdGVtLlxuICAgICAgLy8gZ29pbmcgdG8gcmVhZGRpcihjd2QpLCBidXQgbm90IGluY2x1ZGUgdGhlIHByZWZpeCBpbiBtYXRjaGVzLlxuICAgICAgcHJlZml4ID0gbnVsbFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBwYXR0ZXJuIGhhcyBzb21lIHN0cmluZyBiaXRzIGluIHRoZSBmcm9udC5cbiAgICAgIC8vIHdoYXRldmVyIGl0IHN0YXJ0cyB3aXRoLCB3aGV0aGVyIHRoYXQncyAnYWJzb2x1dGUnIGxpa2UgL2Zvby9iYXIsXG4gICAgICAvLyBvciAncmVsYXRpdmUnIGxpa2UgJy4uL2JheidcbiAgICAgIHByZWZpeCA9IHBhdHRlcm4uc2xpY2UoMCwgbikuam9pbignLycpXG4gICAgICBicmVha1xuICB9XG5cbiAgdmFyIHJlbWFpbiA9IHBhdHRlcm4uc2xpY2UobilcblxuICAvLyBnZXQgdGhlIGxpc3Qgb2YgZW50cmllcy5cbiAgdmFyIHJlYWRcbiAgaWYgKHByZWZpeCA9PT0gbnVsbClcbiAgICByZWFkID0gJy4nXG4gIGVsc2UgaWYgKGlzQWJzb2x1dGUocHJlZml4KSB8fCBpc0Fic29sdXRlKHBhdHRlcm4uam9pbignLycpKSkge1xuICAgIGlmICghcHJlZml4IHx8ICFpc0Fic29sdXRlKHByZWZpeCkpXG4gICAgICBwcmVmaXggPSAnLycgKyBwcmVmaXhcbiAgICByZWFkID0gcHJlZml4XG4gIH0gZWxzZVxuICAgIHJlYWQgPSBwcmVmaXhcblxuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhyZWFkKVxuXG4gIC8vaWYgaWdub3JlZCwgc2tpcCBfcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGlzR2xvYlN0YXIgPSByZW1haW5bMF0gPT09IG1pbmltYXRjaC5HTE9CU1RBUlxuICBpZiAoaXNHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzR2xvYlN0YXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1JlYWRkaXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgcmV0dXJuIHNlbGYuX3Byb2Nlc3NSZWFkZGlyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG5cbiAgLy8gaWYgdGhlIGFicyBpc24ndCBhIGRpciwgdGhlbiBub3RoaW5nIGNhbiBtYXRjaCFcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gSXQgd2lsbCBvbmx5IG1hdGNoIGRvdCBlbnRyaWVzIGlmIGl0IHN0YXJ0cyB3aXRoIGEgZG90LCBvciBpZlxuICAvLyBkb3QgaXMgc2V0LiAgU3R1ZmYgbGlrZSBAKC5mb298LmJhcikgaXNuJ3QgYWxsb3dlZC5cbiAgdmFyIHBuID0gcmVtYWluWzBdXG4gIHZhciBuZWdhdGUgPSAhIXRoaXMubWluaW1hdGNoLm5lZ2F0ZVxuICB2YXIgcmF3R2xvYiA9IHBuLl9nbG9iXG4gIHZhciBkb3RPayA9IHRoaXMuZG90IHx8IHJhd0dsb2IuY2hhckF0KDApID09PSAnLidcblxuICB2YXIgbWF0Y2hlZEVudHJpZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgIT09ICcuJyB8fCBkb3RPaykge1xuICAgICAgdmFyIG1cbiAgICAgIGlmIChuZWdhdGUgJiYgIXByZWZpeCkge1xuICAgICAgICBtID0gIWUubWF0Y2gocG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZS5tYXRjaChwbilcbiAgICAgIH1cbiAgICAgIGlmIChtKVxuICAgICAgICBtYXRjaGVkRW50cmllcy5wdXNoKGUpXG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwcmQyJywgcHJlZml4LCBlbnRyaWVzLCByZW1haW5bMF0uX2dsb2IsIG1hdGNoZWRFbnRyaWVzKVxuXG4gIHZhciBsZW4gPSBtYXRjaGVkRW50cmllcy5sZW5ndGhcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIG1hdGNoZWQgZW50cmllcywgdGhlbiBub3RoaW5nIG1hdGNoZXMuXG4gIGlmIChsZW4gPT09IDApXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHJlbWFpbmluZyBwYXR0ZXJuIGJpdCwgdGhlbiBubyBuZWVkIGZvclxuICAvLyBhbiBhZGRpdGlvbmFsIHN0YXQgKnVubGVzcyogdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBtYXJrIG9yXG4gIC8vIHN0YXQgZXhwbGljaXRseS4gIFdlIGtub3cgdGhleSBleGlzdCwgc2luY2UgcmVhZGRpciByZXR1cm5lZFxuICAvLyB0aGVtLlxuXG4gIGlmIChyZW1haW4ubGVuZ3RoID09PSAxICYmICF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICAgIHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIC8vIG5vdyB0ZXN0IGFsbCBtYXRjaGVkIGVudHJpZXMgYXMgc3RhbmQtaW5zIGZvciB0aGF0IHBhcnRcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIHJlbWFpbi5zaGlmdCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgdmFyIGUgPSBtYXRjaGVkRW50cmllc1tpXVxuICAgIHZhciBuZXdQYXR0ZXJuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeCAhPT0gJy8nKVxuICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gcHJlZml4ICsgZVxuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzKFtlXS5jb25jYXQocmVtYWluKSwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKVxuICB9XG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX2VtaXRNYXRjaCA9IGZ1bmN0aW9uIChpbmRleCwgZSkge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5fZW1pdFF1ZXVlLnB1c2goW2luZGV4LCBlXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBhYnMgPSBpc0Fic29sdXRlKGUpID8gZSA6IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpXG4gICAgZSA9IGFic1xuXG4gIGlmICh0aGlzLm1hdGNoZXNbaW5kZXhdW2VdKVxuICAgIHJldHVyblxuXG4gIGlmICh0aGlzLm5vZGlyKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoYyA9PT0gJ0RJUicgfHwgQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5tYXRjaGVzW2luZGV4XVtlXSA9IHRydWVcblxuICB2YXIgc3QgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdClcbiAgICB0aGlzLmVtaXQoJ3N0YXQnLCBlLCBzdClcblxuICB0aGlzLmVtaXQoJ21hdGNoJywgZSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJJbkdsb2JTdGFyID0gZnVuY3Rpb24gKGFicywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBmb2xsb3cgYWxsIHN5bWxpbmtlZCBkaXJlY3RvcmllcyBmb3JldmVyXG4gIC8vIGp1c3QgcHJvY2VlZCBhcyBpZiB0aGlzIGlzIGEgbm9uLWdsb2JzdGFyIHNpdHVhdGlvblxuICBpZiAodGhpcy5mb2xsb3cpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXIoYWJzLCBmYWxzZSwgY2IpXG5cbiAgdmFyIGxzdGF0a2V5ID0gJ2xzdGF0XFwwJyArIGFic1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGxzdGF0Y2IgPSBpbmZsaWdodChsc3RhdGtleSwgbHN0YXRjYl8pXG5cbiAgaWYgKGxzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZnMucmVhZGRpcihhYnMsIHJlYWRkaXJDYih0aGlzLCBhYnMsIGNiKSlcbn1cblxuZnVuY3Rpb24gcmVhZGRpckNiIChzZWxmLCBhYnMsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICBzZWxmLl9yZWFkZGlyRXJyb3IoYWJzLCBlciwgY2IpXG4gICAgZWxzZVxuICAgICAgc2VsZi5fcmVhZGRpckVudHJpZXMoYWJzLCBlbnRyaWVzLCBjYilcbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcbiAgcmV0dXJuIGNiKG51bGwsIGVudHJpZXMpXG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyRXJyb3IgPSBmdW5jdGlvbiAoZiwgZXIsIGNiKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgLy8gaGFuZGxlIGVycm9ycywgYW5kIGNhY2hlIHRoZSBpbmZvcm1hdGlvblxuICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICBjYXNlICdFTk9UU1VQJzogLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzIwNVxuICAgIGNhc2UgJ0VOT1RESVInOiAvLyB0b3RhbGx5IG5vcm1hbC4gbWVhbnMgaXQgKmRvZXMqIGV4aXN0LlxuICAgICAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgICAgIHRoaXMuY2FjaGVbYWJzXSA9ICdGSUxFJ1xuICAgICAgaWYgKGFicyA9PT0gdGhpcy5jd2RBYnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVyLmNvZGUgKyAnIGludmFsaWQgY3dkICcgKyB0aGlzLmN3ZClcbiAgICAgICAgZXJyb3IucGF0aCA9IHRoaXMuY3dkXG4gICAgICAgIGVycm9yLmNvZGUgPSBlci5jb2RlXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnRU5PRU5UJzogLy8gbm90IHRlcnJpYmx5IHVudXN1YWxcbiAgICBjYXNlICdFTE9PUCc6XG4gICAgY2FzZSAnRU5BTUVUT09MT05HJzpcbiAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6IC8vIHNvbWUgdW51c3VhbCBlcnJvci4gIFRyZWF0IGFzIGZhaWx1cmUuXG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBoYW5kbGVkLCB0aGVuIHdlIGFib3J0XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgdGhyZXcgb3V0IG9mIGhlcmVcbiAgICAgICAgdGhpcy5hYm9ydCgpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2lsZW50KVxuICAgICAgICBjb25zb2xlLmVycm9yKCdnbG9iIGVycm9yJywgZXIpXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICBzZWxmLl9wcm9jZXNzR2xvYlN0YXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc0dsb2JTdGFyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcbiAgLy9jb25zb2xlLmVycm9yKCdwZ3MyJywgcHJlZml4LCByZW1haW5bMF0sIGVudHJpZXMpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVybiBjYigpXG5cbiAgLy8gdGVzdCB3aXRob3V0IHRoZSBnbG9ic3RhciwgYW5kIHdpdGggZXZlcnkgY2hpbGQgYm90aCBiZWxvd1xuICAvLyBhbmQgcmVwbGFjaW5nIHRoZSBnbG9ic3Rhci5cbiAgdmFyIHJlbWFpbldpdGhvdXRHbG9iU3RhciA9IHJlbWFpbi5zbGljZSgxKVxuICB2YXIgZ3NwcmVmID0gcHJlZml4ID8gWyBwcmVmaXggXSA6IFtdXG4gIHZhciBub0dsb2JTdGFyID0gZ3NwcmVmLmNvbmNhdChyZW1haW5XaXRob3V0R2xvYlN0YXIpXG5cbiAgLy8gdGhlIG5vR2xvYlN0YXIgcGF0dGVybiBleGl0cyB0aGUgaW5HbG9iU3RhciBzdGF0ZVxuICB0aGlzLl9wcm9jZXNzKG5vR2xvYlN0YXIsIGluZGV4LCBmYWxzZSwgY2IpXG5cbiAgdmFyIGlzU3ltID0gdGhpcy5zeW1saW5rc1thYnNdXG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aFxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVybiBjYigpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy4nICYmICF0aGlzLmRvdClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAvLyB0aGVzZSB0d28gY2FzZXMgZW50ZXIgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgICB2YXIgaW5zdGVhZCA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluV2l0aG91dEdsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3MoaW5zdGVhZCwgaW5kZXgsIHRydWUsIGNiKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUsIGNiKVxuICB9XG5cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGluZGV4LCBjYikge1xuICAvLyBYWFggcmV2aWV3IHRoaXMuICBTaG91bGRuJ3QgaXQgYmUgZG9pbmcgdGhlIG1vdW50aW5nIGV0Y1xuICAvLyBiZWZvcmUgZG9pbmcgc3RhdD8gIGtpbmRhIHdlaXJkP1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fc3RhdChwcmVmaXgsIGZ1bmN0aW9uIChlciwgZXhpc3RzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc1NpbXBsZTIocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpXG4gIH0pXG59XG5HbG9iLnByb3RvdHlwZS5fcHJvY2Vzc1NpbXBsZTIgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgZXIsIGV4aXN0cywgY2IpIHtcblxuICAvL2NvbnNvbGUuZXJyb3IoJ3BzMicsIHByZWZpeCwgZXhpc3RzKVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAocHJlZml4ICYmIGlzQWJzb2x1dGUocHJlZml4KSAmJiAhdGhpcy5ub21vdW50KSB7XG4gICAgdmFyIHRyYWlsID0gL1tcXC9cXFxcXSQvLnRlc3QocHJlZml4KVxuICAgIGlmIChwcmVmaXguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHByZWZpeCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHByZWZpeClcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gcGF0aC5yZXNvbHZlKHRoaXMucm9vdCwgcHJlZml4KVxuICAgICAgaWYgKHRyYWlsKVxuICAgICAgICBwcmVmaXggKz0gJy8nXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIC8vIE1hcmsgdGhpcyBhcyBhIG1hdGNoXG4gIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgcHJlZml4KVxuICBjYigpXG59XG5cbi8vIFJldHVybnMgZWl0aGVyICdESVInLCAnRklMRScsIG9yIGZhbHNlXG5HbG9iLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmLCBjYikge1xuICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICB2YXIgbmVlZERpciA9IGYuc2xpY2UoLTEpID09PSAnLydcblxuICBpZiAoZi5sZW5ndGggPiB0aGlzLm1heExlbmd0aClcbiAgICByZXR1cm4gY2IoKVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGMpXG5cbiAgICBpZiAobmVlZERpciAmJiBjID09PSAnRklMRScpXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0YXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ID09PSBmYWxzZSlcbiAgICAgIHJldHVybiBjYihudWxsLCBzdGF0KVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRElSJyA6ICdGSUxFJ1xuICAgICAgaWYgKG5lZWREaXIgJiYgdHlwZSA9PT0gJ0ZJTEUnKVxuICAgICAgICByZXR1cm4gY2IoKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgdHlwZSwgc3RhdClcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRjYiA9IGluZmxpZ2h0KCdzdGF0XFwwJyArIGFicywgbHN0YXRjYl8pXG4gIGlmIChzdGF0Y2IpXG4gICAgc2VsZi5mcy5sc3RhdChhYnMsIHN0YXRjYilcblxuICBmdW5jdGlvbiBsc3RhdGNiXyAoZXIsIGxzdGF0KSB7XG4gICAgaWYgKGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYSBzeW1saW5rLCB0aGVuIHRyZWF0IGl0IGFzIHRoZSB0YXJnZXQsIHVubGVzc1xuICAgICAgLy8gdGhlIHRhcmdldCBkb2VzIG5vdCBleGlzdCwgdGhlbiB0cmVhdCBpdCBhcyBhIGZpbGUuXG4gICAgICByZXR1cm4gc2VsZi5mcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iLCAiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmVzdHJlZVdhbGtlciA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0Ly8gQHRzLWNoZWNrXG5cdC8qKiBAdHlwZWRlZiB7IGltcG9ydCgnZXN0cmVlJykuQmFzZU5vZGV9IEJhc2VOb2RlICovXG5cblx0LyoqIEB0eXBlZGVmIHt7XG5cdFx0c2tpcDogKCkgPT4gdm9pZDtcblx0XHRyZW1vdmU6ICgpID0+IHZvaWQ7XG5cdFx0cmVwbGFjZTogKG5vZGU6IEJhc2VOb2RlKSA9PiB2b2lkO1xuXHR9fSBXYWxrZXJDb250ZXh0ICovXG5cblx0Y2xhc3MgV2Fsa2VyQmFzZSB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdFx0XHR0aGlzLnNob3VsZF9za2lwID0gZmFsc2U7XG5cblx0XHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXG5cdFx0XHQvKiogQHR5cGUge0Jhc2VOb2RlIHwgbnVsbH0gKi9cblx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0XHQvKiogQHR5cGUge1dhbGtlckNvbnRleHR9ICovXG5cdFx0XHR0aGlzLmNvbnRleHQgPSB7XG5cdFx0XHRcdHNraXA6ICgpID0+ICh0aGlzLnNob3VsZF9za2lwID0gdHJ1ZSksXG5cdFx0XHRcdHJlbW92ZTogKCkgPT4gKHRoaXMuc2hvdWxkX3JlbW92ZSA9IHRydWUpLFxuXHRcdFx0XHRyZXBsYWNlOiAobm9kZSkgPT4gKHRoaXMucmVwbGFjZW1lbnQgPSBub2RlKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7YW55fSBwYXJlbnRcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHRcdCAqIEBwYXJhbSB7QmFzZU5vZGV9IG5vZGVcblx0XHQgKi9cblx0XHRyZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpIHtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cGFyZW50W3Byb3BdW2luZGV4XSA9IG5vZGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyZW50W3Byb3BdID0gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthbnl9IHBhcmVudFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdFx0ICovXG5cdFx0cmVtb3ZlKHBhcmVudCwgcHJvcCwgaW5kZXgpIHtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKGluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cGFyZW50W3Byb3BdLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHBhcmVudFtwcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEB0cy1jaGVja1xuXG5cdC8qKiBAdHlwZWRlZiB7IGltcG9ydCgnZXN0cmVlJykuQmFzZU5vZGV9IEJhc2VOb2RlICovXG5cdC8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi93YWxrZXIuanMnKS5XYWxrZXJDb250ZXh0fSBXYWxrZXJDb250ZXh0ICovXG5cblx0LyoqIEB0eXBlZGVmIHsoXG5cdCAqICAgIHRoaXM6IFdhbGtlckNvbnRleHQsXG5cdCAqICAgIG5vZGU6IEJhc2VOb2RlLFxuXHQgKiAgICBwYXJlbnQ6IEJhc2VOb2RlLFxuXHQgKiAgICBrZXk6IHN0cmluZyxcblx0ICogICAgaW5kZXg6IG51bWJlclxuXHQgKiApID0+IHZvaWR9IFN5bmNIYW5kbGVyICovXG5cblx0Y2xhc3MgU3luY1dhbGtlciBleHRlbmRzIFdhbGtlckJhc2Uge1xuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTeW5jSGFuZGxlcn0gZW50ZXJcblx0XHQgKiBAcGFyYW0ge1N5bmNIYW5kbGVyfSBsZWF2ZVxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKGVudGVyLCBsZWF2ZSkge1xuXHRcdFx0c3VwZXIoKTtcblxuXHRcdFx0LyoqIEB0eXBlIHtTeW5jSGFuZGxlcn0gKi9cblx0XHRcdHRoaXMuZW50ZXIgPSBlbnRlcjtcblxuXHRcdFx0LyoqIEB0eXBlIHtTeW5jSGFuZGxlcn0gKi9cblx0XHRcdHRoaXMubGVhdmUgPSBsZWF2ZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7QmFzZU5vZGV9IG5vZGVcblx0XHQgKiBAcGFyYW0ge0Jhc2VOb2RlfSBwYXJlbnRcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BdXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0XHQgKiBAcmV0dXJucyB7QmFzZU5vZGV9XG5cdFx0ICovXG5cdFx0dmlzaXQobm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCkge1xuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuZW50ZXIpIHtcblx0XHRcdFx0XHRjb25zdCBfc2hvdWxkX3NraXAgPSB0aGlzLnNob3VsZF9za2lwO1xuXHRcdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHRcdGNvbnN0IF9yZXBsYWNlbWVudCA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zaG91bGRfc2tpcCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0XHRcdFx0dGhpcy5lbnRlci5jYWxsKHRoaXMuY29udGV4dCwgbm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0XHR0aGlzLnJlcGxhY2UocGFyZW50LCBwcm9wLCBpbmRleCwgbm9kZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3Qgc2tpcHBlZCA9IHRoaXMuc2hvdWxkX3NraXA7XG5cdFx0XHRcdFx0Y29uc3QgcmVtb3ZlZCA9IHRoaXMuc2hvdWxkX3JlbW92ZTtcblxuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3NraXAgPSBfc2hvdWxkX3NraXA7XG5cdFx0XHRcdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gX3Nob3VsZF9yZW1vdmU7XG5cdFx0XHRcdFx0dGhpcy5yZXBsYWNlbWVudCA9IF9yZXBsYWNlbWVudDtcblxuXHRcdFx0XHRcdGlmIChza2lwcGVkKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBub2RlW2tleV07XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZVtpXSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbaV0udHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXRoaXMudmlzaXQodmFsdWVbaV0sIG5vZGUsIGtleSwgaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlbW92ZWRcblx0XHRcdFx0XHRcdFx0XHRcdGktLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZpc2l0KHZhbHVlLCBub2RlLCBrZXksIG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmxlYXZlKSB7XG5cdFx0XHRcdFx0Y29uc3QgX3JlcGxhY2VtZW50ID0gdGhpcy5yZXBsYWNlbWVudDtcblx0XHRcdFx0XHRjb25zdCBfc2hvdWxkX3JlbW92ZSA9IHRoaXMuc2hvdWxkX3JlbW92ZTtcblx0XHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLnNob3VsZF9yZW1vdmUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHRoaXMubGVhdmUuY2FsbCh0aGlzLmNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMucmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdFx0dGhpcy5yZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aGlzLnNob3VsZF9yZW1vdmUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlKHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlbW92ZWQgPSB0aGlzLnNob3VsZF9yZW1vdmU7XG5cblx0XHRcdFx0XHR0aGlzLnJlcGxhY2VtZW50ID0gX3JlcGxhY2VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IF9zaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH1cblx0fVxuXG5cdC8vIEB0cy1jaGVja1xuXG5cdC8qKiBAdHlwZWRlZiB7IGltcG9ydCgnZXN0cmVlJykuQmFzZU5vZGV9IEJhc2VOb2RlICovXG5cdC8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi93YWxrZXInKS5XYWxrZXJDb250ZXh0fSBXYWxrZXJDb250ZXh0ICovXG5cblx0LyoqIEB0eXBlZGVmIHsoXG5cdCAqICAgIHRoaXM6IFdhbGtlckNvbnRleHQsXG5cdCAqICAgIG5vZGU6IEJhc2VOb2RlLFxuXHQgKiAgICBwYXJlbnQ6IEJhc2VOb2RlLFxuXHQgKiAgICBrZXk6IHN0cmluZyxcblx0ICogICAgaW5kZXg6IG51bWJlclxuXHQgKiApID0+IFByb21pc2U8dm9pZD59IEFzeW5jSGFuZGxlciAqL1xuXG5cdGNsYXNzIEFzeW5jV2Fsa2VyIGV4dGVuZHMgV2Fsa2VyQmFzZSB7XG5cdFx0LyoqXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FzeW5jSGFuZGxlcn0gZW50ZXJcblx0XHQgKiBAcGFyYW0ge0FzeW5jSGFuZGxlcn0gbGVhdmVcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcihlbnRlciwgbGVhdmUpIHtcblx0XHRcdHN1cGVyKCk7XG5cblx0XHRcdC8qKiBAdHlwZSB7QXN5bmNIYW5kbGVyfSAqL1xuXHRcdFx0dGhpcy5lbnRlciA9IGVudGVyO1xuXG5cdFx0XHQvKiogQHR5cGUge0FzeW5jSGFuZGxlcn0gKi9cblx0XHRcdHRoaXMubGVhdmUgPSBsZWF2ZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7QmFzZU5vZGV9IG5vZGVcblx0XHQgKiBAcGFyYW0ge0Jhc2VOb2RlfSBwYXJlbnRcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BdXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZTxCYXNlTm9kZT59XG5cdFx0ICovXG5cdFx0YXN5bmMgdmlzaXQobm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCkge1xuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuZW50ZXIpIHtcblx0XHRcdFx0XHRjb25zdCBfc2hvdWxkX3NraXAgPSB0aGlzLnNob3VsZF9za2lwO1xuXHRcdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHRcdGNvbnN0IF9yZXBsYWNlbWVudCA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zaG91bGRfc2tpcCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5lbnRlci5jYWxsKHRoaXMuY29udGV4dCwgbm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0XHR0aGlzLnJlcGxhY2UocGFyZW50LCBwcm9wLCBpbmRleCwgbm9kZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3Qgc2tpcHBlZCA9IHRoaXMuc2hvdWxkX3NraXA7XG5cdFx0XHRcdFx0Y29uc3QgcmVtb3ZlZCA9IHRoaXMuc2hvdWxkX3JlbW92ZTtcblxuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3NraXAgPSBfc2hvdWxkX3NraXA7XG5cdFx0XHRcdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gX3Nob3VsZF9yZW1vdmU7XG5cdFx0XHRcdFx0dGhpcy5yZXBsYWNlbWVudCA9IF9yZXBsYWNlbWVudDtcblxuXHRcdFx0XHRcdGlmIChza2lwcGVkKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBub2RlW2tleV07XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZVtpXSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbaV0udHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIShhd2FpdCB0aGlzLnZpc2l0KHZhbHVlW2ldLCBub2RlLCBrZXksIGkpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlZFxuXHRcdFx0XHRcdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMudmlzaXQodmFsdWUsIG5vZGUsIGtleSwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMubGVhdmUpIHtcblx0XHRcdFx0XHRjb25zdCBfcmVwbGFjZW1lbnQgPSB0aGlzLnJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdGNvbnN0IF9zaG91bGRfcmVtb3ZlID0gdGhpcy5zaG91bGRfcmVtb3ZlO1xuXHRcdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMuc2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5sZWF2ZS5jYWxsKHRoaXMuY29udGV4dCwgbm9kZSwgcGFyZW50LCBwcm9wLCBpbmRleCk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5yZXBsYWNlbWVudCkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHRoaXMucmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0XHR0aGlzLnJlcGxhY2UocGFyZW50LCBwcm9wLCBpbmRleCwgbm9kZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgcmVtb3ZlZCA9IHRoaXMuc2hvdWxkX3JlbW92ZTtcblxuXHRcdFx0XHRcdHRoaXMucmVwbGFjZW1lbnQgPSBfcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zaG91bGRfcmVtb3ZlID0gX3Nob3VsZF9yZW1vdmU7XG5cblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQHRzLWNoZWNrXG5cblx0LyoqIEB0eXBlZGVmIHsgaW1wb3J0KCdlc3RyZWUnKS5CYXNlTm9kZX0gQmFzZU5vZGUgKi9cblx0LyoqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL3N5bmMuanMnKS5TeW5jSGFuZGxlcn0gU3luY0hhbmRsZXIgKi9cblx0LyoqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2FzeW5jLmpzJykuQXN5bmNIYW5kbGVyfSBBc3luY0hhbmRsZXIgKi9cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtCYXNlTm9kZX0gYXN0XG5cdCAqIEBwYXJhbSB7e1xuXHQgKiAgIGVudGVyPzogU3luY0hhbmRsZXJcblx0ICogICBsZWF2ZT86IFN5bmNIYW5kbGVyXG5cdCAqIH19IHdhbGtlclxuXHQgKiBAcmV0dXJucyB7QmFzZU5vZGV9XG5cdCAqL1xuXHRmdW5jdGlvbiB3YWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gbmV3IFN5bmNXYWxrZXIoZW50ZXIsIGxlYXZlKTtcblx0XHRyZXR1cm4gaW5zdGFuY2UudmlzaXQoYXN0LCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jhc2VOb2RlfSBhc3Rcblx0ICogQHBhcmFtIHt7XG5cdCAqICAgZW50ZXI/OiBBc3luY0hhbmRsZXJcblx0ICogICBsZWF2ZT86IEFzeW5jSGFuZGxlclxuXHQgKiB9fSB3YWxrZXJcblx0ICogQHJldHVybnMge1Byb21pc2U8QmFzZU5vZGU+fVxuXHQgKi9cblx0YXN5bmMgZnVuY3Rpb24gYXN5bmNXYWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gbmV3IEFzeW5jV2Fsa2VyKGVudGVyLCBsZWF2ZSk7XG5cdFx0cmV0dXJuIGF3YWl0IGluc3RhbmNlLnZpc2l0KGFzdCwgbnVsbCk7XG5cdH1cblxuXHRleHBvcnRzLmFzeW5jV2FsayA9IGFzeW5jV2Fsaztcblx0ZXhwb3J0cy53YWxrID0gd2FsaztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwgImV4cG9ydCB0eXBlIFNvdXJjZU1hcFNlZ21lbnQgPVxuXHR8IFtudW1iZXJdXG5cdHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cblx0fCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuZXhwb3J0IHR5cGUgU291cmNlTWFwTGluZSA9IFNvdXJjZU1hcFNlZ21lbnRbXTtcbmV4cG9ydCB0eXBlIFNvdXJjZU1hcE1hcHBpbmdzID0gU291cmNlTWFwTGluZVtdO1xuXG5jb25zdCBjaGFyVG9JbnRlZ2VyOiB7IFtjaGFyQ29kZTogbnVtYmVyXTogbnVtYmVyIH0gPSB7fTtcbmNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuXHRjaGFyVG9JbnRlZ2VyW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShtYXBwaW5nczogc3RyaW5nKTogU291cmNlTWFwTWFwcGluZ3Mge1xuXHRjb25zdCBkZWNvZGVkOiBTb3VyY2VNYXBNYXBwaW5ncyA9IFtdO1xuXHRsZXQgbGluZTogU291cmNlTWFwTGluZSA9IFtdO1xuXHRjb25zdCBzZWdtZW50OiBTb3VyY2VNYXBTZWdtZW50ID0gW1xuXHRcdDAsIC8vIGdlbmVyYXRlZCBjb2RlIGNvbHVtblxuXHRcdDAsIC8vIHNvdXJjZSBmaWxlIGluZGV4XG5cdFx0MCwgLy8gc291cmNlIGNvZGUgbGluZVxuXHRcdDAsIC8vIHNvdXJjZSBjb2RlIGNvbHVtblxuXHRcdDAsIC8vIG5hbWUgaW5kZXhcblx0XTtcblxuXHRsZXQgaiA9IDA7XG5cdGZvciAobGV0IGkgPSAwLCBzaGlmdCA9IDAsIHZhbHVlID0gMDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgYyA9IG1hcHBpbmdzLmNoYXJDb2RlQXQoaSk7XG5cblx0XHRpZiAoYyA9PT0gNDQpIHsgLy8gXCIsXCJcblx0XHRcdHNlZ21lbnRpZnkobGluZSwgc2VnbWVudCwgaik7XG5cdFx0XHRqID0gMDtcblxuXHRcdH0gZWxzZSBpZiAoYyA9PT0gNTkpIHsgLy8gXCI7XCJcblx0XHRcdHNlZ21lbnRpZnkobGluZSwgc2VnbWVudCwgaik7XG5cdFx0XHRqID0gMDtcblx0XHRcdGRlY29kZWQucHVzaChsaW5lKTtcblx0XHRcdGxpbmUgPSBbXTtcblx0XHRcdHNlZ21lbnRbMF0gPSAwO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpbnRlZ2VyID0gY2hhclRvSW50ZWdlcltjXTtcblx0XHRcdGlmIChpbnRlZ2VyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciAoJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykgKyAnKScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBoYXNDb250aW51YXRpb25CaXQgPSBpbnRlZ2VyICYgMzI7XG5cblx0XHRcdGludGVnZXIgJj0gMzE7XG5cdFx0XHR2YWx1ZSArPSBpbnRlZ2VyIDw8IHNoaWZ0O1xuXG5cdFx0XHRpZiAoaGFzQ29udGludWF0aW9uQml0KSB7XG5cdFx0XHRcdHNoaWZ0ICs9IDU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBzaG91bGROZWdhdGUgPSB2YWx1ZSAmIDE7XG5cdFx0XHRcdHZhbHVlID4+Pj0gMTtcblxuXHRcdFx0XHRpZiAoc2hvdWxkTmVnYXRlKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSA9PT0gMCA/IC0weDgwMDAwMDAwIDogLXZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VnbWVudFtqXSArPSB2YWx1ZTtcblx0XHRcdFx0aisrO1xuXHRcdFx0XHR2YWx1ZSA9IHNoaWZ0ID0gMDsgLy8gcmVzZXRcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzZWdtZW50aWZ5KGxpbmUsIHNlZ21lbnQsIGopO1xuXHRkZWNvZGVkLnB1c2gobGluZSk7XG5cblx0cmV0dXJuIGRlY29kZWQ7XG59XG5cbmZ1bmN0aW9uIHNlZ21lbnRpZnkobGluZTogU291cmNlTWFwU2VnbWVudFtdLCBzZWdtZW50OiBTb3VyY2VNYXBTZWdtZW50LCBqOiBudW1iZXIpIHtcblx0Ly8gVGhpcyBsb29rcyB1Z2x5LCBidXQgd2UncmUgY3JlYXRpbmcgc3BlY2lhbGl6ZWQgYXJyYXlzIHdpdGggYSBzcGVjaWZpY1xuXHQvLyBsZW5ndGguIFRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBhcnJheSAod2hpY2ggdjggZXhwYW5kcyB0b1xuXHQvLyBhIGNhcGFjaXR5IG9mIDE3IGFmdGVyIHB1c2hpbmcgdGhlIGZpcnN0IGl0ZW0pLCBvciBzbGljaW5nIG91dCBhIHN1YmFycmF5XG5cdC8vICh3aGljaCBpcyBzbG93KS4gTGVuZ3RoIDQgaXMgYXNzdW1lZCB0byBiZSB0aGUgbW9zdCBmcmVxdWVudCwgZm9sbG93ZWQgYnlcblx0Ly8gbGVuZ3RoIDUgKHNpbmNlIG5vdCBldmVyeXRoaW5nIHdpbGwgaGF2ZSBhbiBhc3NvY2lhdGVkIG5hbWUpLCBmb2xsb3dlZCBieVxuXHQvLyBsZW5ndGggMSAoaXQncyBwcm9iYWJseSByYXJlIGZvciBhIHNvdXJjZSBzdWJzdHJpbmcgdG8gbm90IGhhdmUgYW5cblx0Ly8gYXNzb2NpYXRlZCBzZWdtZW50IGRhdGEpLlxuXHRpZiAoaiA9PT0gNCkgbGluZS5wdXNoKFtzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCBzZWdtZW50WzNdXSk7XG5cdGVsc2UgaWYgKGogPT09IDUpIGxpbmUucHVzaChbc2VnbWVudFswXSwgc2VnbWVudFsxXSwgc2VnbWVudFsyXSwgc2VnbWVudFszXSwgc2VnbWVudFs0XV0pO1xuXHRlbHNlIGlmIChqID09PSAxKSBsaW5lLnB1c2goW3NlZ21lbnRbMF1dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShkZWNvZGVkOiBTb3VyY2VNYXBNYXBwaW5ncyk6IHN0cmluZyB7XG5cdGxldCBzb3VyY2VGaWxlSW5kZXggPSAwOyAgLy8gc2Vjb25kIGZpZWxkXG5cdGxldCBzb3VyY2VDb2RlTGluZSA9IDA7ICAgLy8gdGhpcmQgZmllbGRcblx0bGV0IHNvdXJjZUNvZGVDb2x1bW4gPSAwOyAvLyBmb3VydGggZmllbGRcblx0bGV0IG5hbWVJbmRleCA9IDA7ICAgICAgICAvLyBmaWZ0aCBmaWVsZFxuXHRsZXQgbWFwcGluZ3MgPSAnJztcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcblx0XHRpZiAoaSA+IDApIG1hcHBpbmdzICs9ICc7Jztcblx0XHRpZiAobGluZS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG5cdFx0bGV0IGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwOyAvLyBmaXJzdCBmaWVsZFxuXG5cdFx0Y29uc3QgbGluZU1hcHBpbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdFx0Zm9yIChjb25zdCBzZWdtZW50IG9mIGxpbmUpIHtcblx0XHRcdGxldCBzZWdtZW50TWFwcGluZ3MgPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMF0gLSBnZW5lcmF0ZWRDb2RlQ29sdW1uKTtcblx0XHRcdGdlbmVyYXRlZENvZGVDb2x1bW4gPSBzZWdtZW50WzBdO1xuXG5cdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHNlZ21lbnRNYXBwaW5ncyArPVxuXHRcdFx0XHRcdGVuY29kZUludGVnZXIoc2VnbWVudFsxXSAtIHNvdXJjZUZpbGVJbmRleCkgK1xuXHRcdFx0XHRcdGVuY29kZUludGVnZXIoc2VnbWVudFsyXSAtIHNvdXJjZUNvZGVMaW5lKSArXG5cdFx0XHRcdFx0ZW5jb2RlSW50ZWdlcihzZWdtZW50WzNdIC0gc291cmNlQ29kZUNvbHVtbik7XG5cblx0XHRcdFx0c291cmNlRmlsZUluZGV4ID0gc2VnbWVudFsxXTtcblx0XHRcdFx0c291cmNlQ29kZUxpbmUgPSBzZWdtZW50WzJdO1xuXHRcdFx0XHRzb3VyY2VDb2RlQ29sdW1uID0gc2VnbWVudFszXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlZ21lbnQubGVuZ3RoID09PSA1KSB7XG5cdFx0XHRcdHNlZ21lbnRNYXBwaW5ncyArPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbNF0gLSBuYW1lSW5kZXgpO1xuXHRcdFx0XHRuYW1lSW5kZXggPSBzZWdtZW50WzRdO1xuXHRcdFx0fVxuXG5cdFx0XHRsaW5lTWFwcGluZ3MucHVzaChzZWdtZW50TWFwcGluZ3MpO1xuXHRcdH1cblxuXHRcdG1hcHBpbmdzICs9IGxpbmVNYXBwaW5ncy5qb2luKCcsJyk7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGluZ3M7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUludGVnZXIobnVtOiBudW1iZXIpOiBzdHJpbmcge1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdG51bSA9IG51bSA8IDAgPyAoLW51bSA8PCAxKSB8IDEgOiBudW0gPDwgMTtcblx0ZG8ge1xuXHRcdHZhciBjbGFtcGVkID0gbnVtICYgMzE7XG5cdFx0bnVtID4+Pj0gNTtcblx0XHRpZiAobnVtID4gMCkge1xuXHRcdFx0Y2xhbXBlZCB8PSAzMjtcblx0XHR9XG5cdFx0cmVzdWx0ICs9IGNoYXJzW2NsYW1wZWRdO1xuXHR9IHdoaWxlIChudW0gPiAwKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpdFNldCB7XG5cdGNvbnN0cnVjdG9yKGFyZykge1xuXHRcdHRoaXMuYml0cyA9IGFyZyBpbnN0YW5jZW9mIEJpdFNldCA/IGFyZy5iaXRzLnNsaWNlKCkgOiBbXTtcblx0fVxuXG5cdGFkZChuKSB7XG5cdFx0dGhpcy5iaXRzW24gPj4gNV0gfD0gMSA8PCAobiAmIDMxKTtcblx0fVxuXG5cdGhhcyhuKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuYml0c1tuID4+IDVdICYgKDEgPDwgKG4gJiAzMSkpKTtcblx0fVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIENodW5rIHtcblx0Y29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgY29udGVudCkge1xuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLm9yaWdpbmFsID0gY29udGVudDtcblxuXHRcdHRoaXMuaW50cm8gPSAnJztcblx0XHR0aGlzLm91dHJvID0gJyc7XG5cblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdHRoaXMuc3RvcmVOYW1lID0gZmFsc2U7XG5cdFx0dGhpcy5lZGl0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIHdlIG1ha2UgdGhlc2Ugbm9uLWVudW1lcmFibGUsIGZvciBzYW5pdHkgd2hpbGUgZGVidWdnaW5nXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdFx0cHJldmlvdXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbnVsbCB9LFxuXHRcdH0pO1xuXHR9XG5cblx0YXBwZW5kTGVmdChjb250ZW50KSB7XG5cdFx0dGhpcy5vdXRybyArPSBjb250ZW50O1xuXHR9XG5cblx0YXBwZW5kUmlnaHQoY29udGVudCkge1xuXHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvICsgY29udGVudDtcblx0fVxuXG5cdGNsb25lKCkge1xuXHRcdGNvbnN0IGNodW5rID0gbmV3IENodW5rKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLm9yaWdpbmFsKTtcblxuXHRcdGNodW5rLmludHJvID0gdGhpcy5pbnRybztcblx0XHRjaHVuay5vdXRybyA9IHRoaXMub3V0cm87XG5cdFx0Y2h1bmsuY29udGVudCA9IHRoaXMuY29udGVudDtcblx0XHRjaHVuay5zdG9yZU5hbWUgPSB0aGlzLnN0b3JlTmFtZTtcblx0XHRjaHVuay5lZGl0ZWQgPSB0aGlzLmVkaXRlZDtcblxuXHRcdHJldHVybiBjaHVuaztcblx0fVxuXG5cdGNvbnRhaW5zKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQgPCBpbmRleCAmJiBpbmRleCA8IHRoaXMuZW5kO1xuXHR9XG5cblx0ZWFjaE5leHQoZm4pIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzO1xuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Zm4oY2h1bmspO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblx0fVxuXG5cdGVhY2hQcmV2aW91cyhmbikge1xuXHRcdGxldCBjaHVuayA9IHRoaXM7XG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRmbihjaHVuayk7XG5cdFx0XHRjaHVuayA9IGNodW5rLnByZXZpb3VzO1xuXHRcdH1cblx0fVxuXG5cdGVkaXQoY29udGVudCwgc3RvcmVOYW1lLCBjb250ZW50T25seSkge1xuXHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0aWYgKCFjb250ZW50T25seSkge1xuXHRcdFx0dGhpcy5pbnRybyA9ICcnO1xuXHRcdFx0dGhpcy5vdXRybyA9ICcnO1xuXHRcdH1cblx0XHR0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcblxuXHRcdHRoaXMuZWRpdGVkID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cHJlcGVuZExlZnQoY29udGVudCkge1xuXHRcdHRoaXMub3V0cm8gPSBjb250ZW50ICsgdGhpcy5vdXRybztcblx0fVxuXG5cdHByZXBlbmRSaWdodChjb250ZW50KSB7XG5cdFx0dGhpcy5pbnRybyA9IGNvbnRlbnQgKyB0aGlzLmludHJvO1xuXHR9XG5cblx0c3BsaXQoaW5kZXgpIHtcblx0XHRjb25zdCBzbGljZUluZGV4ID0gaW5kZXggLSB0aGlzLnN0YXJ0O1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxCZWZvcmUgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKDAsIHNsaWNlSW5kZXgpO1xuXHRcdGNvbnN0IG9yaWdpbmFsQWZ0ZXIgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHNsaWNlSW5kZXgpO1xuXG5cdFx0dGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsQmVmb3JlO1xuXG5cdFx0Y29uc3QgbmV3Q2h1bmsgPSBuZXcgQ2h1bmsoaW5kZXgsIHRoaXMuZW5kLCBvcmlnaW5hbEFmdGVyKTtcblx0XHRuZXdDaHVuay5vdXRybyA9IHRoaXMub3V0cm87XG5cdFx0dGhpcy5vdXRybyA9ICcnO1xuXG5cdFx0dGhpcy5lbmQgPSBpbmRleDtcblxuXHRcdGlmICh0aGlzLmVkaXRlZCkge1xuXHRcdFx0Ly8gVE9ETyBpcyB0aGlzIGJsb2NrIG5lY2Vzc2FyeT8uLi5cblx0XHRcdG5ld0NodW5rLmVkaXQoJycsIGZhbHNlKTtcblx0XHRcdHRoaXMuY29udGVudCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbnRlbnQgPSBvcmlnaW5hbEJlZm9yZTtcblx0XHR9XG5cblx0XHRuZXdDaHVuay5uZXh0ID0gdGhpcy5uZXh0O1xuXHRcdGlmIChuZXdDaHVuay5uZXh0KSBuZXdDaHVuay5uZXh0LnByZXZpb3VzID0gbmV3Q2h1bms7XG5cdFx0bmV3Q2h1bmsucHJldmlvdXMgPSB0aGlzO1xuXHRcdHRoaXMubmV4dCA9IG5ld0NodW5rO1xuXG5cdFx0cmV0dXJuIG5ld0NodW5rO1xuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW50cm8gKyB0aGlzLmNvbnRlbnQgKyB0aGlzLm91dHJvO1xuXHR9XG5cblx0dHJpbUVuZChyeCkge1xuXHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5vdXRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0Y29uc3QgdHJpbW1lZCA9IHRoaXMuY29udGVudC5yZXBsYWNlKHJ4LCAnJyk7XG5cblx0XHRpZiAodHJpbW1lZC5sZW5ndGgpIHtcblx0XHRcdGlmICh0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQpIHtcblx0XHRcdFx0dGhpcy5zcGxpdCh0aGlzLnN0YXJ0ICsgdHJpbW1lZC5sZW5ndGgpLmVkaXQoJycsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdFx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdHRyaW1TdGFydChyeCkge1xuXHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0Y29uc3QgdHJpbW1lZCA9IHRoaXMuY29udGVudC5yZXBsYWNlKHJ4LCAnJyk7XG5cblx0XHRpZiAodHJpbW1lZC5sZW5ndGgpIHtcblx0XHRcdGlmICh0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQpIHtcblx0XHRcdFx0dGhpcy5zcGxpdCh0aGlzLmVuZCAtIHRyaW1tZWQubGVuZ3RoKTtcblx0XHRcdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWRpdCgnJywgdW5kZWZpbmVkLCB0cnVlKTtcblxuXHRcdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBlbmNvZGUgfSBmcm9tICdzb3VyY2VtYXAtY29kZWMnO1xuXG5sZXQgYnRvYSA9ICgpID0+IHtcblx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbnZpcm9ubWVudDogYHdpbmRvdy5idG9hYCBvciBgQnVmZmVyYCBzaG91bGQgYmUgc3VwcG9ydGVkLicpO1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0YnRvYSA9IChzdHIpID0+IHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG59IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcblx0YnRvYSA9IChzdHIpID0+IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb3VyY2VNYXAge1xuXHRjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG5cdFx0dGhpcy52ZXJzaW9uID0gMztcblx0XHR0aGlzLmZpbGUgPSBwcm9wZXJ0aWVzLmZpbGU7XG5cdFx0dGhpcy5zb3VyY2VzID0gcHJvcGVydGllcy5zb3VyY2VzO1xuXHRcdHRoaXMuc291cmNlc0NvbnRlbnQgPSBwcm9wZXJ0aWVzLnNvdXJjZXNDb250ZW50O1xuXHRcdHRoaXMubmFtZXMgPSBwcm9wZXJ0aWVzLm5hbWVzO1xuXHRcdHRoaXMubWFwcGluZ3MgPSBlbmNvZGUocHJvcGVydGllcy5tYXBwaW5ncyk7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG5cdH1cblxuXHR0b1VybCgpIHtcblx0XHRyZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYnRvYSh0aGlzLnRvU3RyaW5nKCkpO1xuXHR9XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3Vlc3NJbmRlbnQoY29kZSkge1xuXHRjb25zdCBsaW5lcyA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuXG5cdGNvbnN0IHRhYmJlZCA9IGxpbmVzLmZpbHRlcigobGluZSkgPT4gL15cXHQrLy50ZXN0KGxpbmUpKTtcblx0Y29uc3Qgc3BhY2VkID0gbGluZXMuZmlsdGVyKChsaW5lKSA9PiAvXiB7Mix9Ly50ZXN0KGxpbmUpKTtcblxuXHRpZiAodGFiYmVkLmxlbmd0aCA9PT0gMCAmJiBzcGFjZWQubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBNb3JlIGxpbmVzIHRhYmJlZCB0aGFuIHNwYWNlZD8gQXNzdW1lIHRhYnMsIGFuZFxuXHQvLyBkZWZhdWx0IHRvIHRhYnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWUgKG9yIG5vdGhpbmdcblx0Ly8gdG8gZ28gb24pXG5cdGlmICh0YWJiZWQubGVuZ3RoID49IHNwYWNlZC5sZW5ndGgpIHtcblx0XHRyZXR1cm4gJ1xcdCc7XG5cdH1cblxuXHQvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gZ3Vlc3MgdGhlIG11bHRpcGxlXG5cdGNvbnN0IG1pbiA9IHNwYWNlZC5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG5cdFx0Y29uc3QgbnVtU3BhY2VzID0gL14gKy8uZXhlYyhjdXJyZW50KVswXS5sZW5ndGg7XG5cdFx0cmV0dXJuIE1hdGgubWluKG51bVNwYWNlcywgcHJldmlvdXMpO1xuXHR9LCBJbmZpbml0eSk7XG5cblx0cmV0dXJuIG5ldyBBcnJheShtaW4gKyAxKS5qb2luKCcgJyk7XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoKGZyb20sIHRvKSB7XG5cdGNvbnN0IGZyb21QYXJ0cyA9IGZyb20uc3BsaXQoL1svXFxcXF0vKTtcblx0Y29uc3QgdG9QYXJ0cyA9IHRvLnNwbGl0KC9bL1xcXFxdLyk7XG5cblx0ZnJvbVBhcnRzLnBvcCgpOyAvLyBnZXQgZGlybmFtZVxuXG5cdHdoaWxlIChmcm9tUGFydHNbMF0gPT09IHRvUGFydHNbMF0pIHtcblx0XHRmcm9tUGFydHMuc2hpZnQoKTtcblx0XHR0b1BhcnRzLnNoaWZ0KCk7XG5cdH1cblxuXHRpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuXHRcdGxldCBpID0gZnJvbVBhcnRzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSBmcm9tUGFydHNbaV0gPSAnLi4nO1xuXHR9XG5cblx0cmV0dXJuIGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cykuam9pbignLycpO1xufVxuIiwgImNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMb2NhdG9yKHNvdXJjZSkge1xuXHRjb25zdCBvcmlnaW5hbExpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcblx0Y29uc3QgbGluZU9mZnNldHMgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IG9yaWdpbmFsTGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRsaW5lT2Zmc2V0cy5wdXNoKHBvcyk7XG5cdFx0cG9zICs9IG9yaWdpbmFsTGluZXNbaV0ubGVuZ3RoICsgMTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiBsb2NhdGUoaW5kZXgpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IGogPSBsaW5lT2Zmc2V0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGkgPCBqKSB7XG5cdFx0XHRjb25zdCBtID0gKGkgKyBqKSA+PiAxO1xuXHRcdFx0aWYgKGluZGV4IDwgbGluZU9mZnNldHNbbV0pIHtcblx0XHRcdFx0aiA9IG07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gbSArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGxpbmUgPSBpIC0gMTtcblx0XHRjb25zdCBjb2x1bW4gPSBpbmRleCAtIGxpbmVPZmZzZXRzW2xpbmVdO1xuXHRcdHJldHVybiB7IGxpbmUsIGNvbHVtbiB9O1xuXHR9O1xufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcHBpbmdzIHtcblx0Y29uc3RydWN0b3IoaGlyZXMpIHtcblx0XHR0aGlzLmhpcmVzID0gaGlyZXM7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSA9IDA7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblx0XHR0aGlzLnJhdyA9IFtdO1xuXHRcdHRoaXMucmF3U2VnbWVudHMgPSB0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXSA9IFtdO1xuXHRcdHRoaXMucGVuZGluZyA9IG51bGw7XG5cdH1cblxuXHRhZGRFZGl0KHNvdXJjZUluZGV4LCBjb250ZW50LCBsb2MsIG5hbWVJbmRleCkge1xuXHRcdGlmIChjb250ZW50Lmxlbmd0aCkge1xuXHRcdFx0Y29uc3Qgc2VnbWVudCA9IFt0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUluZGV4LCBsb2MubGluZSwgbG9jLmNvbHVtbl07XG5cdFx0XHRpZiAobmFtZUluZGV4ID49IDApIHtcblx0XHRcdFx0c2VnbWVudC5wdXNoKG5hbWVJbmRleCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJhd1NlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnBlbmRpbmcpIHtcblx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaCh0aGlzLnBlbmRpbmcpO1xuXHRcdH1cblxuXHRcdHRoaXMuYWR2YW5jZShjb250ZW50KTtcblx0XHR0aGlzLnBlbmRpbmcgPSBudWxsO1xuXHR9XG5cblx0YWRkVW5lZGl0ZWRDaHVuayhzb3VyY2VJbmRleCwgY2h1bmssIG9yaWdpbmFsLCBsb2MsIHNvdXJjZW1hcExvY2F0aW9ucykge1xuXHRcdGxldCBvcmlnaW5hbENoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXHRcdGxldCBmaXJzdCA9IHRydWU7XG5cblx0XHR3aGlsZSAob3JpZ2luYWxDaGFySW5kZXggPCBjaHVuay5lbmQpIHtcblx0XHRcdGlmICh0aGlzLmhpcmVzIHx8IGZpcnN0IHx8IHNvdXJjZW1hcExvY2F0aW9ucy5oYXMob3JpZ2luYWxDaGFySW5kZXgpKSB7XG5cdFx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9yaWdpbmFsW29yaWdpbmFsQ2hhckluZGV4XSA9PT0gJ1xcbicpIHtcblx0XHRcdFx0bG9jLmxpbmUgKz0gMTtcblx0XHRcdFx0bG9jLmNvbHVtbiA9IDA7XG5cdFx0XHRcdHRoaXMuZ2VuZXJhdGVkQ29kZUxpbmUgKz0gMTtcblx0XHRcdFx0dGhpcy5yYXdbdGhpcy5nZW5lcmF0ZWRDb2RlTGluZV0gPSB0aGlzLnJhd1NlZ21lbnRzID0gW107XG5cdFx0XHRcdHRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7XG5cdFx0XHRcdGZpcnN0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvYy5jb2x1bW4gKz0gMTtcblx0XHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uICs9IDE7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdG9yaWdpbmFsQ2hhckluZGV4ICs9IDE7XG5cdFx0fVxuXG5cdFx0dGhpcy5wZW5kaW5nID0gbnVsbDtcblx0fVxuXG5cdGFkdmFuY2Uoc3RyKSB7XG5cdFx0aWYgKCFzdHIpIHJldHVybjtcblxuXHRcdGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKTtcblxuXHRcdGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lKys7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gKz0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuXHR9XG59XG4iLCAiaW1wb3J0IEJpdFNldCBmcm9tICcuL0JpdFNldC5qcyc7XG5pbXBvcnQgQ2h1bmsgZnJvbSAnLi9DaHVuay5qcyc7XG5pbXBvcnQgU291cmNlTWFwIGZyb20gJy4vU291cmNlTWFwLmpzJztcbmltcG9ydCBndWVzc0luZGVudCBmcm9tICcuL3V0aWxzL2d1ZXNzSW5kZW50LmpzJztcbmltcG9ydCBnZXRSZWxhdGl2ZVBhdGggZnJvbSAnLi91dGlscy9nZXRSZWxhdGl2ZVBhdGguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vdXRpbHMvaXNPYmplY3QuanMnO1xuaW1wb3J0IGdldExvY2F0b3IgZnJvbSAnLi91dGlscy9nZXRMb2NhdG9yLmpzJztcbmltcG9ydCBNYXBwaW5ncyBmcm9tICcuL3V0aWxzL01hcHBpbmdzLmpzJztcbmltcG9ydCBTdGF0cyBmcm9tICcuL3V0aWxzL1N0YXRzLmpzJztcblxuY29uc3QgbiA9ICdcXG4nO1xuXG5jb25zdCB3YXJuZWQgPSB7XG5cdGluc2VydExlZnQ6IGZhbHNlLFxuXHRpbnNlcnRSaWdodDogZmFsc2UsXG5cdHN0b3JlTmFtZTogZmFsc2UsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWdpY1N0cmluZyB7XG5cdGNvbnN0cnVjdG9yKHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG5cdFx0Y29uc3QgY2h1bmsgPSBuZXcgQ2h1bmsoMCwgc3RyaW5nLmxlbmd0aCwgc3RyaW5nKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRcdG9yaWdpbmFsOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RyaW5nIH0sXG5cdFx0XHRvdXRybzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0XHRpbnRybzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0XHRmaXJzdENodW5rOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRcdGxhc3RDaHVuazogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0XHRsYXN0U2VhcmNoZWRDaHVuazogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0XHRieVN0YXJ0OiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRcdGJ5RW5kOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRcdGZpbGVuYW1lOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5maWxlbmFtZSB9LFxuXHRcdFx0aW5kZW50RXhjbHVzaW9uUmFuZ2VzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5pbmRlbnRFeGNsdXNpb25SYW5nZXMgfSxcblx0XHRcdHNvdXJjZW1hcExvY2F0aW9uczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBCaXRTZXQoKSB9LFxuXHRcdFx0c3RvcmVkTmFtZXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdFx0aW5kZW50U3RyOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZ3Vlc3NJbmRlbnQoc3RyaW5nKSB9LFxuXHRcdH0pO1xuXG5cdFx0aWYgKERFQlVHKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YXRzJywgeyB2YWx1ZTogbmV3IFN0YXRzKCkgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ieVN0YXJ0WzBdID0gY2h1bms7XG5cdFx0dGhpcy5ieUVuZFtzdHJpbmcubGVuZ3RoXSA9IGNodW5rO1xuXHR9XG5cblx0YWRkU291cmNlbWFwTG9jYXRpb24oY2hhcikge1xuXHRcdHRoaXMuc291cmNlbWFwTG9jYXRpb25zLmFkZChjaGFyKTtcblx0fVxuXG5cdGFwcGVuZChjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignb3V0cm8gY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRhcHBlbmRMZWZ0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHRpZiAoREVCVUcpIHRoaXMuc3RhdHMudGltZSgnYXBwZW5kTGVmdCcpO1xuXG5cdFx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuXHRcdGlmIChjaHVuaykge1xuXHRcdFx0Y2h1bmsuYXBwZW5kTGVmdChjb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbnRybyArPSBjb250ZW50O1xuXHRcdH1cblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lRW5kKCdhcHBlbmRMZWZ0Jyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRhcHBlbmRSaWdodChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0aWYgKERFQlVHKSB0aGlzLnN0YXRzLnRpbWUoJ2FwcGVuZFJpZ2h0Jyk7XG5cblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLmFwcGVuZFJpZ2h0KGNvbnRlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKERFQlVHKSB0aGlzLnN0YXRzLnRpbWVFbmQoJ2FwcGVuZFJpZ2h0Jyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRjbG9uZSgpIHtcblx0XHRjb25zdCBjbG9uZWQgPSBuZXcgTWFnaWNTdHJpbmcodGhpcy5vcmlnaW5hbCwgeyBmaWxlbmFtZTogdGhpcy5maWxlbmFtZSB9KTtcblxuXHRcdGxldCBvcmlnaW5hbENodW5rID0gdGhpcy5maXJzdENodW5rO1xuXHRcdGxldCBjbG9uZWRDaHVuayA9IChjbG9uZWQuZmlyc3RDaHVuayA9IGNsb25lZC5sYXN0U2VhcmNoZWRDaHVuayA9IG9yaWdpbmFsQ2h1bmsuY2xvbmUoKSk7XG5cblx0XHR3aGlsZSAob3JpZ2luYWxDaHVuaykge1xuXHRcdFx0Y2xvbmVkLmJ5U3RhcnRbY2xvbmVkQ2h1bmsuc3RhcnRdID0gY2xvbmVkQ2h1bms7XG5cdFx0XHRjbG9uZWQuYnlFbmRbY2xvbmVkQ2h1bmsuZW5kXSA9IGNsb25lZENodW5rO1xuXG5cdFx0XHRjb25zdCBuZXh0T3JpZ2luYWxDaHVuayA9IG9yaWdpbmFsQ2h1bmsubmV4dDtcblx0XHRcdGNvbnN0IG5leHRDbG9uZWRDaHVuayA9IG5leHRPcmlnaW5hbENodW5rICYmIG5leHRPcmlnaW5hbENodW5rLmNsb25lKCk7XG5cblx0XHRcdGlmIChuZXh0Q2xvbmVkQ2h1bmspIHtcblx0XHRcdFx0Y2xvbmVkQ2h1bmsubmV4dCA9IG5leHRDbG9uZWRDaHVuaztcblx0XHRcdFx0bmV4dENsb25lZENodW5rLnByZXZpb3VzID0gY2xvbmVkQ2h1bms7XG5cblx0XHRcdFx0Y2xvbmVkQ2h1bmsgPSBuZXh0Q2xvbmVkQ2h1bms7XG5cdFx0XHR9XG5cblx0XHRcdG9yaWdpbmFsQ2h1bmsgPSBuZXh0T3JpZ2luYWxDaHVuaztcblx0XHR9XG5cblx0XHRjbG9uZWQubGFzdENodW5rID0gY2xvbmVkQ2h1bms7XG5cblx0XHRpZiAodGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMpIHtcblx0XHRcdGNsb25lZC5pbmRlbnRFeGNsdXNpb25SYW5nZXMgPSB0aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlcy5zbGljZSgpO1xuXHRcdH1cblxuXHRcdGNsb25lZC5zb3VyY2VtYXBMb2NhdGlvbnMgPSBuZXcgQml0U2V0KHRoaXMuc291cmNlbWFwTG9jYXRpb25zKTtcblxuXHRcdGNsb25lZC5pbnRybyA9IHRoaXMuaW50cm87XG5cdFx0Y2xvbmVkLm91dHJvID0gdGhpcy5vdXRybztcblxuXHRcdHJldHVybiBjbG9uZWQ7XG5cdH1cblxuXHRnZW5lcmF0ZURlY29kZWRNYXAob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Y29uc3Qgc291cmNlSW5kZXggPSAwO1xuXHRcdGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5zdG9yZWROYW1lcyk7XG5cdFx0Y29uc3QgbWFwcGluZ3MgPSBuZXcgTWFwcGluZ3Mob3B0aW9ucy5oaXJlcyk7XG5cblx0XHRjb25zdCBsb2NhdGUgPSBnZXRMb2NhdG9yKHRoaXMub3JpZ2luYWwpO1xuXG5cdFx0aWYgKHRoaXMuaW50cm8pIHtcblx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcy5pbnRybyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJzdENodW5rLmVhY2hOZXh0KChjaHVuaykgPT4ge1xuXHRcdFx0Y29uc3QgbG9jID0gbG9jYXRlKGNodW5rLnN0YXJ0KTtcblxuXHRcdFx0aWYgKGNodW5rLmludHJvLmxlbmd0aCkgbWFwcGluZ3MuYWR2YW5jZShjaHVuay5pbnRybyk7XG5cblx0XHRcdGlmIChjaHVuay5lZGl0ZWQpIHtcblx0XHRcdFx0bWFwcGluZ3MuYWRkRWRpdChcblx0XHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0XHRjaHVuay5jb250ZW50LFxuXHRcdFx0XHRcdGxvYyxcblx0XHRcdFx0XHRjaHVuay5zdG9yZU5hbWUgPyBuYW1lcy5pbmRleE9mKGNodW5rLm9yaWdpbmFsKSA6IC0xXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXBwaW5ncy5hZGRVbmVkaXRlZENodW5rKHNvdXJjZUluZGV4LCBjaHVuaywgdGhpcy5vcmlnaW5hbCwgbG9jLCB0aGlzLnNvdXJjZW1hcExvY2F0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsub3V0cm8pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGZpbGU6IG9wdGlvbnMuZmlsZSA/IG9wdGlvbnMuZmlsZS5zcGxpdCgvWy9cXFxcXS8pLnBvcCgpIDogbnVsbCxcblx0XHRcdHNvdXJjZXM6IFtvcHRpb25zLnNvdXJjZSA/IGdldFJlbGF0aXZlUGF0aChvcHRpb25zLmZpbGUgfHwgJycsIG9wdGlvbnMuc291cmNlKSA6IG51bGxdLFxuXHRcdFx0c291cmNlc0NvbnRlbnQ6IG9wdGlvbnMuaW5jbHVkZUNvbnRlbnQgPyBbdGhpcy5vcmlnaW5hbF0gOiBbbnVsbF0sXG5cdFx0XHRuYW1lcyxcblx0XHRcdG1hcHBpbmdzOiBtYXBwaW5ncy5yYXcsXG5cdFx0fTtcblx0fVxuXG5cdGdlbmVyYXRlTWFwKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IFNvdXJjZU1hcCh0aGlzLmdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zKSk7XG5cdH1cblxuXHRnZXRJbmRlbnRTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZW50U3RyID09PSBudWxsID8gJ1xcdCcgOiB0aGlzLmluZGVudFN0cjtcblx0fVxuXG5cdGluZGVudChpbmRlbnRTdHIsIG9wdGlvbnMpIHtcblx0XHRjb25zdCBwYXR0ZXJuID0gL15bXlxcclxcbl0vZ207XG5cblx0XHRpZiAoaXNPYmplY3QoaW5kZW50U3RyKSkge1xuXHRcdFx0b3B0aW9ucyA9IGluZGVudFN0cjtcblx0XHRcdGluZGVudFN0ciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpbmRlbnRTdHIgPSBpbmRlbnRTdHIgIT09IHVuZGVmaW5lZCA/IGluZGVudFN0ciA6IHRoaXMuaW5kZW50U3RyIHx8ICdcXHQnO1xuXG5cdFx0aWYgKGluZGVudFN0ciA9PT0gJycpIHJldHVybiB0aGlzOyAvLyBub29wXG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIFByb2Nlc3MgZXhjbHVzaW9uIHJhbmdlc1xuXHRcdGNvbnN0IGlzRXhjbHVkZWQgPSB7fTtcblxuXHRcdGlmIChvcHRpb25zLmV4Y2x1ZGUpIHtcblx0XHRcdGNvbnN0IGV4Y2x1c2lvbnMgPVxuXHRcdFx0XHR0eXBlb2Ygb3B0aW9ucy5leGNsdWRlWzBdID09PSAnbnVtYmVyJyA/IFtvcHRpb25zLmV4Y2x1ZGVdIDogb3B0aW9ucy5leGNsdWRlO1xuXHRcdFx0ZXhjbHVzaW9ucy5mb3JFYWNoKChleGNsdXNpb24pID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IGV4Y2x1c2lvblswXTsgaSA8IGV4Y2x1c2lvblsxXTsgaSArPSAxKSB7XG5cdFx0XHRcdFx0aXNFeGNsdWRlZFtpXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGxldCBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gb3B0aW9ucy5pbmRlbnRTdGFydCAhPT0gZmFsc2U7XG5cdFx0Y29uc3QgcmVwbGFjZXIgPSAobWF0Y2gpID0+IHtcblx0XHRcdGlmIChzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyKSByZXR1cm4gYCR7aW5kZW50U3RyfSR7bWF0Y2h9YDtcblx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH07XG5cblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VyKTtcblxuXHRcdGxldCBjaGFySW5kZXggPSAwO1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Y29uc3QgZW5kID0gY2h1bmsuZW5kO1xuXG5cdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdFx0Y2h1bmsuY29udGVudCA9IGNodW5rLmNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlcik7XG5cblx0XHRcdFx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBjaHVuay5jb250ZW50W2NodW5rLmNvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhckluZGV4ID0gY2h1bmsuc3RhcnQ7XG5cblx0XHRcdFx0d2hpbGUgKGNoYXJJbmRleCA8IGVuZCkge1xuXHRcdFx0XHRcdGlmICghaXNFeGNsdWRlZFtjaGFySW5kZXhdKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjaGFyID0gdGhpcy5vcmlnaW5hbFtjaGFySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRpZiAoY2hhciA9PT0gJ1xcbicpIHtcblx0XHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNoYXIgIT09ICdcXHInICYmIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIpIHtcblx0XHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjaGFySW5kZXggPT09IGNodW5rLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGluZGVudFN0cik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3BsaXRDaHVuayhjaHVuaywgY2hhckluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGluZGVudFN0cik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFySW5kZXggPSBjaHVuay5lbmQ7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlcik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGluc2VydCgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHQnbWFnaWNTdHJpbmcuaW5zZXJ0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIHByZXBlbmRSaWdodCguLi4pIG9yIGFwcGVuZExlZnQoLi4uKSdcblx0XHQpO1xuXHR9XG5cblx0aW5zZXJ0TGVmdChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICghd2FybmVkLmluc2VydExlZnQpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0J21hZ2ljU3RyaW5nLmluc2VydExlZnQoLi4uKSBpcyBkZXByZWNhdGVkLiBVc2UgbWFnaWNTdHJpbmcuYXBwZW5kTGVmdCguLi4pIGluc3RlYWQnXG5cdFx0XHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHdhcm5lZC5pbnNlcnRMZWZ0ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBlbmRMZWZ0KGluZGV4LCBjb250ZW50KTtcblx0fVxuXG5cdGluc2VydFJpZ2h0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKCF3YXJuZWQuaW5zZXJ0UmlnaHQpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0J21hZ2ljU3RyaW5nLmluc2VydFJpZ2h0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIG1hZ2ljU3RyaW5nLnByZXBlbmRSaWdodCguLi4pIGluc3RlYWQnXG5cdFx0XHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHdhcm5lZC5pbnNlcnRSaWdodCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZFJpZ2h0KGluZGV4LCBjb250ZW50KTtcblx0fVxuXG5cdG1vdmUoc3RhcnQsIGVuZCwgaW5kZXgpIHtcblx0XHRpZiAoaW5kZXggPj0gc3RhcnQgJiYgaW5kZXggPD0gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtb3ZlIGEgc2VsZWN0aW9uIGluc2lkZSBpdHNlbGYnKTtcblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lKCdtb3ZlJyk7XG5cblx0XHR0aGlzLl9zcGxpdChzdGFydCk7XG5cdFx0dGhpcy5fc3BsaXQoZW5kKTtcblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBmaXJzdCA9IHRoaXMuYnlTdGFydFtzdGFydF07XG5cdFx0Y29uc3QgbGFzdCA9IHRoaXMuYnlFbmRbZW5kXTtcblxuXHRcdGNvbnN0IG9sZExlZnQgPSBmaXJzdC5wcmV2aW91cztcblx0XHRjb25zdCBvbGRSaWdodCA9IGxhc3QubmV4dDtcblxuXHRcdGNvbnN0IG5ld1JpZ2h0ID0gdGhpcy5ieVN0YXJ0W2luZGV4XTtcblx0XHRpZiAoIW5ld1JpZ2h0ICYmIGxhc3QgPT09IHRoaXMubGFzdENodW5rKSByZXR1cm4gdGhpcztcblx0XHRjb25zdCBuZXdMZWZ0ID0gbmV3UmlnaHQgPyBuZXdSaWdodC5wcmV2aW91cyA6IHRoaXMubGFzdENodW5rO1xuXG5cdFx0aWYgKG9sZExlZnQpIG9sZExlZnQubmV4dCA9IG9sZFJpZ2h0O1xuXHRcdGlmIChvbGRSaWdodCkgb2xkUmlnaHQucHJldmlvdXMgPSBvbGRMZWZ0O1xuXG5cdFx0aWYgKG5ld0xlZnQpIG5ld0xlZnQubmV4dCA9IGZpcnN0O1xuXHRcdGlmIChuZXdSaWdodCkgbmV3UmlnaHQucHJldmlvdXMgPSBsYXN0O1xuXG5cdFx0aWYgKCFmaXJzdC5wcmV2aW91cykgdGhpcy5maXJzdENodW5rID0gbGFzdC5uZXh0O1xuXHRcdGlmICghbGFzdC5uZXh0KSB7XG5cdFx0XHR0aGlzLmxhc3RDaHVuayA9IGZpcnN0LnByZXZpb3VzO1xuXHRcdFx0dGhpcy5sYXN0Q2h1bmsubmV4dCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Zmlyc3QucHJldmlvdXMgPSBuZXdMZWZ0O1xuXHRcdGxhc3QubmV4dCA9IG5ld1JpZ2h0IHx8IG51bGw7XG5cblx0XHRpZiAoIW5ld0xlZnQpIHRoaXMuZmlyc3RDaHVuayA9IGZpcnN0O1xuXHRcdGlmICghbmV3UmlnaHQpIHRoaXMubGFzdENodW5rID0gbGFzdDtcblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lRW5kKCdtb3ZlJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRvdmVyd3JpdGUoc3RhcnQsIGVuZCwgY29udGVudCwgb3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcGxhY2VtZW50IGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0d2hpbGUgKHN0YXJ0IDwgMCkgc3RhcnQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7XG5cdFx0d2hpbGUgKGVuZCA8IDApIGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblxuXHRcdGlmIChlbmQgPiB0aGlzLm9yaWdpbmFsLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgaXMgb3V0IG9mIGJvdW5kcycpO1xuXHRcdGlmIChzdGFydCA9PT0gZW5kKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnQ2Fubm90IG92ZXJ3cml0ZSBhIHplcm8tbGVuZ3RoIHJhbmdlIOKAkyB1c2UgYXBwZW5kTGVmdCBvciBwcmVwZW5kUmlnaHQgaW5zdGVhZCdcblx0XHRcdCk7XG5cblx0XHRpZiAoREVCVUcpIHRoaXMuc3RhdHMudGltZSgnb3ZlcndyaXRlJyk7XG5cblx0XHR0aGlzLl9zcGxpdChzdGFydCk7XG5cdFx0dGhpcy5fc3BsaXQoZW5kKTtcblxuXHRcdGlmIChvcHRpb25zID09PSB0cnVlKSB7XG5cdFx0XHRpZiAoIXdhcm5lZC5zdG9yZU5hbWUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdCdUaGUgZmluYWwgYXJndW1lbnQgdG8gbWFnaWNTdHJpbmcub3ZlcndyaXRlKC4uLikgc2hvdWxkIGJlIGFuIG9wdGlvbnMgb2JqZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JpY2gtaGFycmlzL21hZ2ljLXN0cmluZydcblx0XHRcdFx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdHdhcm5lZC5zdG9yZU5hbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0geyBzdG9yZU5hbWU6IHRydWUgfTtcblx0XHR9XG5cdFx0Y29uc3Qgc3RvcmVOYW1lID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdG9yZU5hbWUgOiBmYWxzZTtcblx0XHRjb25zdCBjb250ZW50T25seSA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29udGVudE9ubHkgOiBmYWxzZTtcblxuXHRcdGlmIChzdG9yZU5hbWUpIHtcblx0XHRcdGNvbnN0IG9yaWdpbmFsID0gdGhpcy5vcmlnaW5hbC5zbGljZShzdGFydCwgZW5kKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnN0b3JlZE5hbWVzLCBvcmlnaW5hbCwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmlyc3QgPSB0aGlzLmJ5U3RhcnRbc3RhcnRdO1xuXHRcdGNvbnN0IGxhc3QgPSB0aGlzLmJ5RW5kW2VuZF07XG5cblx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdGxldCBjaHVuayA9IGZpcnN0O1xuXHRcdFx0d2hpbGUgKGNodW5rICE9PSBsYXN0KSB7XG5cdFx0XHRcdGlmIChjaHVuay5uZXh0ICE9PSB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJ3cml0ZSBhY3Jvc3MgYSBzcGxpdCBwb2ludCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHRcdFx0Y2h1bmsuZWRpdCgnJywgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdC5lZGl0KGNvbnRlbnQsIHN0b3JlTmFtZSwgY29udGVudE9ubHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtdXN0IGJlIGluc2VydGluZyBhdCB0aGUgZW5kXG5cdFx0XHRjb25zdCBuZXdDaHVuayA9IG5ldyBDaHVuayhzdGFydCwgZW5kLCAnJykuZWRpdChjb250ZW50LCBzdG9yZU5hbWUpO1xuXG5cdFx0XHQvLyBUT0RPIGxhc3QgY2h1bmsgaW4gdGhlIGFycmF5IG1heSBub3QgYmUgdGhlIGxhc3QgY2h1bmssIGlmIGl0J3MgbW92ZWQuLi5cblx0XHRcdGxhc3QubmV4dCA9IG5ld0NodW5rO1xuXHRcdFx0bmV3Q2h1bmsucHJldmlvdXMgPSBsYXN0O1xuXHRcdH1cblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lRW5kKCdvdmVyd3JpdGUnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmQoY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHJvIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5pbnRybyA9IGNvbnRlbnQgKyB0aGlzLmludHJvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cHJlcGVuZExlZnQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lKCdpbnNlcnRSaWdodCcpO1xuXG5cdFx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuXHRcdGlmIChjaHVuaykge1xuXHRcdFx0Y2h1bmsucHJlcGVuZExlZnQoY29udGVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0XHR9XG5cblx0XHRpZiAoREVCVUcpIHRoaXMuc3RhdHMudGltZUVuZCgnaW5zZXJ0UmlnaHQnKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmRSaWdodChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0aWYgKERFQlVHKSB0aGlzLnN0YXRzLnRpbWUoJ2luc2VydFJpZ2h0Jyk7XG5cblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBjaHVuayA9IHRoaXMuYnlTdGFydFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLnByZXBlbmRSaWdodChjb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRybyA9IGNvbnRlbnQgKyB0aGlzLm91dHJvO1xuXHRcdH1cblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lRW5kKCdpbnNlcnRSaWdodCcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmVtb3ZlKHN0YXJ0LCBlbmQpIHtcblx0XHR3aGlsZSAoc3RhcnQgPCAwKSBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR3aGlsZSAoZW5kIDwgMCkgZW5kICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXG5cdFx0aWYgKHN0YXJ0ID09PSBlbmQpIHJldHVybiB0aGlzO1xuXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLm9yaWdpbmFsLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaXMgb3V0IG9mIGJvdW5kcycpO1xuXHRcdGlmIChzdGFydCA+IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnQnKTtcblxuXHRcdGlmIChERUJVRykgdGhpcy5zdGF0cy50aW1lKCdyZW1vdmUnKTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Y2h1bmsuaW50cm8gPSAnJztcblx0XHRcdGNodW5rLm91dHJvID0gJyc7XG5cdFx0XHRjaHVuay5lZGl0KCcnKTtcblxuXHRcdFx0Y2h1bmsgPSBlbmQgPiBjaHVuay5lbmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKERFQlVHKSB0aGlzLnN0YXRzLnRpbWVFbmQoJ3JlbW92ZScpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bGFzdENoYXIoKSB7XG5cdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdGhpcy5vdXRyb1t0aGlzLm91dHJvLmxlbmd0aCAtIDFdO1xuXHRcdGxldCBjaHVuayA9IHRoaXMubGFzdENodW5rO1xuXHRcdGRvIHtcblx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIHJldHVybiBjaHVuay5vdXRyb1tjaHVuay5vdXRyby5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCkgcmV0dXJuIGNodW5rLmNvbnRlbnRbY2h1bmsuY29udGVudC5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIHJldHVybiBjaHVuay5pbnRyb1tjaHVuay5pbnRyby5sZW5ndGggLSAxXTtcblx0XHR9IHdoaWxlICgoY2h1bmsgPSBjaHVuay5wcmV2aW91cykpO1xuXHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRoaXMuaW50cm9bdGhpcy5pbnRyby5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRsYXN0TGluZSgpIHtcblx0XHRsZXQgbGluZUluZGV4ID0gdGhpcy5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIHRoaXMub3V0cm8uc3Vic3RyKGxpbmVJbmRleCArIDEpO1xuXHRcdGxldCBsaW5lU3RyID0gdGhpcy5vdXRybztcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblx0XHRkbyB7XG5cdFx0XHRpZiAoY2h1bmsub3V0cm8ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsaW5lSW5kZXggPSBjaHVuay5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRcdFx0aWYgKGxpbmVJbmRleCAhPT0gLTEpIHJldHVybiBjaHVuay5vdXRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsub3V0cm8gKyBsaW5lU3RyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmNvbnRlbnQubGFzdEluZGV4T2Yobik7XG5cdFx0XHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gY2h1bmsuY29udGVudC5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsuY29udGVudCArIGxpbmVTdHI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdFx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIGNodW5rLmludHJvLnN1YnN0cihsaW5lSW5kZXggKyAxKSArIGxpbmVTdHI7XG5cdFx0XHRcdGxpbmVTdHIgPSBjaHVuay5pbnRybyArIGxpbmVTdHI7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoKGNodW5rID0gY2h1bmsucHJldmlvdXMpKTtcblx0XHRsaW5lSW5kZXggPSB0aGlzLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gdGhpcy5pbnRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdHJldHVybiB0aGlzLmludHJvICsgbGluZVN0cjtcblx0fVxuXG5cdHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHtcblx0XHR3aGlsZSAoc3RhcnQgPCAwKSBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR3aGlsZSAoZW5kIDwgMCkgZW5kICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXG5cdFx0bGV0IHJlc3VsdCA9ICcnO1xuXG5cdFx0Ly8gZmluZCBzdGFydCBjaHVua1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHR3aGlsZSAoY2h1bmsgJiYgKGNodW5rLnN0YXJ0ID4gc3RhcnQgfHwgY2h1bmsuZW5kIDw9IHN0YXJ0KSkge1xuXHRcdFx0Ly8gZm91bmQgZW5kIGNodW5rIGJlZm9yZSBzdGFydFxuXHRcdFx0aWYgKGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdGlmIChjaHVuayAmJiBjaHVuay5lZGl0ZWQgJiYgY2h1bmsuc3RhcnQgIT09IHN0YXJ0KVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlIHJlcGxhY2VkIGNoYXJhY3RlciAke3N0YXJ0fSBhcyBzbGljZSBzdGFydCBhbmNob3IuYCk7XG5cblx0XHRjb25zdCBzdGFydENodW5rID0gY2h1bms7XG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRpZiAoY2h1bmsuaW50cm8gJiYgKHN0YXJ0Q2h1bmsgIT09IGNodW5rIHx8IGNodW5rLnN0YXJ0ID09PSBzdGFydCkpIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNodW5rLmludHJvO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjb250YWluc0VuZCA9IGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQ7XG5cdFx0XHRpZiAoY29udGFpbnNFbmQgJiYgY2h1bmsuZWRpdGVkICYmIGNodW5rLmVuZCAhPT0gZW5kKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1c2UgcmVwbGFjZWQgY2hhcmFjdGVyICR7ZW5kfSBhcyBzbGljZSBlbmQgYW5jaG9yLmApO1xuXG5cdFx0XHRjb25zdCBzbGljZVN0YXJ0ID0gc3RhcnRDaHVuayA9PT0gY2h1bmsgPyBzdGFydCAtIGNodW5rLnN0YXJ0IDogMDtcblx0XHRcdGNvbnN0IHNsaWNlRW5kID0gY29udGFpbnNFbmQgPyBjaHVuay5jb250ZW50Lmxlbmd0aCArIGVuZCAtIGNodW5rLmVuZCA6IGNodW5rLmNvbnRlbnQubGVuZ3RoO1xuXG5cdFx0XHRyZXN1bHQgKz0gY2h1bmsuY29udGVudC5zbGljZShzbGljZVN0YXJ0LCBzbGljZUVuZCk7XG5cblx0XHRcdGlmIChjaHVuay5vdXRybyAmJiAoIWNvbnRhaW5zRW5kIHx8IGNodW5rLmVuZCA9PT0gZW5kKSkge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2h1bmsub3V0cm87XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250YWluc0VuZCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzPyBub3QgcmVhbGx5IHZlcnkgdXNlZnVsXG5cdHNuaXAoc3RhcnQsIGVuZCkge1xuXHRcdGNvbnN0IGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXHRcdGNsb25lLnJlbW92ZSgwLCBzdGFydCk7XG5cdFx0Y2xvbmUucmVtb3ZlKGVuZCwgY2xvbmUub3JpZ2luYWwubGVuZ3RoKTtcblxuXHRcdHJldHVybiBjbG9uZTtcblx0fVxuXG5cdF9zcGxpdChpbmRleCkge1xuXHRcdGlmICh0aGlzLmJ5U3RhcnRbaW5kZXhdIHx8IHRoaXMuYnlFbmRbaW5kZXhdKSByZXR1cm47XG5cblx0XHRpZiAoREVCVUcpIHRoaXMuc3RhdHMudGltZSgnX3NwbGl0Jyk7XG5cblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RTZWFyY2hlZENodW5rO1xuXHRcdGNvbnN0IHNlYXJjaEZvcndhcmQgPSBpbmRleCA+IGNodW5rLmVuZDtcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0aWYgKGNodW5rLmNvbnRhaW5zKGluZGV4KSkgcmV0dXJuIHRoaXMuX3NwbGl0Q2h1bmsoY2h1bmssIGluZGV4KTtcblxuXHRcdFx0Y2h1bmsgPSBzZWFyY2hGb3J3YXJkID8gdGhpcy5ieVN0YXJ0W2NodW5rLmVuZF0gOiB0aGlzLmJ5RW5kW2NodW5rLnN0YXJ0XTtcblx0XHR9XG5cdH1cblxuXHRfc3BsaXRDaHVuayhjaHVuaywgaW5kZXgpIHtcblx0XHRpZiAoY2h1bmsuZWRpdGVkICYmIGNodW5rLmNvbnRlbnQubGVuZ3RoKSB7XG5cdFx0XHQvLyB6ZXJvLWxlbmd0aCBlZGl0ZWQgY2h1bmtzIGFyZSBhIHNwZWNpYWwgY2FzZSAob3ZlcmxhcHBpbmcgcmVwbGFjZW1lbnRzKVxuXHRcdFx0Y29uc3QgbG9jID0gZ2V0TG9jYXRvcih0aGlzLm9yaWdpbmFsKShpbmRleCk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGBDYW5ub3Qgc3BsaXQgYSBjaHVuayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZWRpdGVkICgke2xvYy5saW5lfToke2xvYy5jb2x1bW59IOKAkyBcIiR7Y2h1bmsub3JpZ2luYWx9XCIpYFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBuZXdDaHVuayA9IGNodW5rLnNwbGl0KGluZGV4KTtcblxuXHRcdHRoaXMuYnlFbmRbaW5kZXhdID0gY2h1bms7XG5cdFx0dGhpcy5ieVN0YXJ0W2luZGV4XSA9IG5ld0NodW5rO1xuXHRcdHRoaXMuYnlFbmRbbmV3Q2h1bmsuZW5kXSA9IG5ld0NodW5rO1xuXG5cdFx0aWYgKGNodW5rID09PSB0aGlzLmxhc3RDaHVuaykgdGhpcy5sYXN0Q2h1bmsgPSBuZXdDaHVuaztcblxuXHRcdHRoaXMubGFzdFNlYXJjaGVkQ2h1bmsgPSBjaHVuaztcblx0XHRpZiAoREVCVUcpIHRoaXMuc3RhdHMudGltZUVuZCgnX3NwbGl0Jyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRsZXQgc3RyID0gdGhpcy5pbnRybztcblxuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdHN0ciArPSBjaHVuay50b1N0cmluZygpO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHIgKyB0aGlzLm91dHJvO1xuXHR9XG5cblx0aXNFbXB0eSgpIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQoY2h1bmsuaW50cm8ubGVuZ3RoICYmIGNodW5rLmludHJvLnRyaW0oKSkgfHxcblx0XHRcdFx0KGNodW5rLmNvbnRlbnQubGVuZ3RoICYmIGNodW5rLmNvbnRlbnQudHJpbSgpKSB8fFxuXHRcdFx0XHQoY2h1bmsub3V0cm8ubGVuZ3RoICYmIGNodW5rLm91dHJvLnRyaW0oKSlcblx0XHRcdClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gd2hpbGUgKChjaHVuayA9IGNodW5rLm5leHQpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0bGV0IGxlbmd0aCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0bGVuZ3RoICs9IGNodW5rLmludHJvLmxlbmd0aCArIGNodW5rLmNvbnRlbnQubGVuZ3RoICsgY2h1bmsub3V0cm8ubGVuZ3RoO1xuXHRcdH0gd2hpbGUgKChjaHVuayA9IGNodW5rLm5leHQpKTtcblx0XHRyZXR1cm4gbGVuZ3RoO1xuXHR9XG5cblx0dHJpbUxpbmVzKCkge1xuXHRcdHJldHVybiB0aGlzLnRyaW0oJ1tcXFxcclxcXFxuXScpO1xuXHR9XG5cblx0dHJpbShjaGFyVHlwZSkge1xuXHRcdHJldHVybiB0aGlzLnRyaW1TdGFydChjaGFyVHlwZSkudHJpbUVuZChjaGFyVHlwZSk7XG5cdH1cblxuXHR0cmltRW5kQWJvcnRlZChjaGFyVHlwZSkge1xuXHRcdGNvbnN0IHJ4ID0gbmV3IFJlZ0V4cCgoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKyQnKTtcblxuXHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5vdXRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5sYXN0Q2h1bms7XG5cblx0XHRkbyB7XG5cdFx0XHRjb25zdCBlbmQgPSBjaHVuay5lbmQ7XG5cdFx0XHRjb25zdCBhYm9ydGVkID0gY2h1bmsudHJpbUVuZChyeCk7XG5cblx0XHRcdC8vIGlmIGNodW5rIHdhcyB0cmltbWVkLCB3ZSBoYXZlIGEgbmV3IGxhc3RDaHVua1xuXHRcdFx0aWYgKGNodW5rLmVuZCAhPT0gZW5kKSB7XG5cdFx0XHRcdGlmICh0aGlzLmxhc3RDaHVuayA9PT0gY2h1bmspIHtcblx0XHRcdFx0XHR0aGlzLmxhc3RDaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLmVuZF0gPSBjaHVuaztcblx0XHRcdFx0dGhpcy5ieVN0YXJ0W2NodW5rLm5leHQuc3RhcnRdID0gY2h1bmsubmV4dDtcblx0XHRcdFx0dGhpcy5ieUVuZFtjaHVuay5uZXh0LmVuZF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuIHRydWU7XG5cdFx0XHRjaHVuayA9IGNodW5rLnByZXZpb3VzO1xuXHRcdH0gd2hpbGUgKGNodW5rKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHRyaW1FbmQoY2hhclR5cGUpIHtcblx0XHR0aGlzLnRyaW1FbmRBYm9ydGVkKGNoYXJUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKSB7XG5cdFx0Y29uc3QgcnggPSBuZXcgUmVnRXhwKCdeJyArIChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJyk7XG5cblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0aWYgKHRoaXMuaW50cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRcdGRvIHtcblx0XHRcdGNvbnN0IGVuZCA9IGNodW5rLmVuZDtcblx0XHRcdGNvbnN0IGFib3J0ZWQgPSBjaHVuay50cmltU3RhcnQocngpO1xuXG5cdFx0XHRpZiAoY2h1bmsuZW5kICE9PSBlbmQpIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlLi4uXG5cdFx0XHRcdGlmIChjaHVuayA9PT0gdGhpcy5sYXN0Q2h1bmspIHRoaXMubGFzdENodW5rID0gY2h1bmsubmV4dDtcblxuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLmVuZF0gPSBjaHVuaztcblx0XHRcdFx0dGhpcy5ieVN0YXJ0W2NodW5rLm5leHQuc3RhcnRdID0gY2h1bmsubmV4dDtcblx0XHRcdFx0dGhpcy5ieUVuZFtjaHVuay5uZXh0LmVuZF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuIHRydWU7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fSB3aGlsZSAoY2h1bmspO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dHJpbVN0YXJ0KGNoYXJUeXBlKSB7XG5cdFx0dGhpcy50cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuIiwgImltcG9ydCBNYWdpY1N0cmluZyBmcm9tICcuL01hZ2ljU3RyaW5nLmpzJztcbmltcG9ydCBTb3VyY2VNYXAgZnJvbSAnLi9Tb3VyY2VNYXAuanMnO1xuaW1wb3J0IGdldFJlbGF0aXZlUGF0aCBmcm9tICcuL3V0aWxzL2dldFJlbGF0aXZlUGF0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi91dGlscy9pc09iamVjdC5qcyc7XG5pbXBvcnQgZ2V0TG9jYXRvciBmcm9tICcuL3V0aWxzL2dldExvY2F0b3IuanMnO1xuaW1wb3J0IE1hcHBpbmdzIGZyb20gJy4vdXRpbHMvTWFwcGluZ3MuanMnO1xuXG5jb25zdCBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVuZGxlIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5pbnRybyA9IG9wdGlvbnMuaW50cm8gfHwgJyc7XG5cdFx0dGhpcy5zZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAnXFxuJztcblx0XHR0aGlzLnNvdXJjZXMgPSBbXTtcblx0XHR0aGlzLnVuaXF1ZVNvdXJjZXMgPSBbXTtcblx0XHR0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSA9IHt9O1xuXHR9XG5cblx0YWRkU291cmNlKHNvdXJjZSkge1xuXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYWdpY1N0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkU291cmNlKHtcblx0XHRcdFx0Y29udGVudDogc291cmNlLFxuXHRcdFx0XHRmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLFxuXHRcdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFzb3VyY2UuY29udGVudCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnYnVuZGxlLmFkZFNvdXJjZSgpIHRha2VzIGFuIG9iamVjdCB3aXRoIGEgYGNvbnRlbnRgIHByb3BlcnR5LCB3aGljaCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTWFnaWNTdHJpbmcsIGFuZCBhbiBvcHRpb25hbCBgZmlsZW5hbWVgJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRbJ2ZpbGVuYW1lJywgJ2luZGVudEV4Y2x1c2lvblJhbmdlcycsICdzZXBhcmF0b3InXS5mb3JFYWNoKChvcHRpb24pID0+IHtcblx0XHRcdGlmICghaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgb3B0aW9uKSkgc291cmNlW29wdGlvbl0gPSBzb3VyY2UuY29udGVudFtvcHRpb25dO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNvdXJjZS5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gVE9ETyB0aGVyZSdzIGEgYnVuY2ggb2YgdGhpcyBzb3J0IG9mIHRoaW5nLCBuZWVkcyBjbGVhbmluZyB1cFxuXHRcdFx0c291cmNlLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuXHRcdH1cblxuXHRcdGlmIChzb3VyY2UuZmlsZW5hbWUpIHtcblx0XHRcdGlmICghaGFzT3duUHJvcC5jYWxsKHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lLCBzb3VyY2UuZmlsZW5hbWUpKSB7XG5cdFx0XHRcdHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV0gPSB0aGlzLnVuaXF1ZVNvdXJjZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnVuaXF1ZVNvdXJjZXMucHVzaCh7IGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsIGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50Lm9yaWdpbmFsIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlU291cmNlID0gdGhpcy51bmlxdWVTb3VyY2VzW3RoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV1dO1xuXHRcdFx0XHRpZiAoc291cmNlLmNvbnRlbnQub3JpZ2luYWwgIT09IHVuaXF1ZVNvdXJjZS5jb250ZW50KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIHNvdXJjZTogc2FtZSBmaWxlbmFtZSAoJHtzb3VyY2UuZmlsZW5hbWV9KSwgZGlmZmVyZW50IGNvbnRlbnRzYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YXBwZW5kKHN0ciwgb3B0aW9ucykge1xuXHRcdHRoaXMuYWRkU291cmNlKHtcblx0XHRcdGNvbnRlbnQ6IG5ldyBNYWdpY1N0cmluZyhzdHIpLFxuXHRcdFx0c2VwYXJhdG9yOiAob3B0aW9ucyAmJiBvcHRpb25zLnNlcGFyYXRvcikgfHwgJycsXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGNsb25lKCkge1xuXHRcdGNvbnN0IGJ1bmRsZSA9IG5ldyBCdW5kbGUoe1xuXHRcdFx0aW50cm86IHRoaXMuaW50cm8sXG5cdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuXHRcdFx0YnVuZGxlLmFkZFNvdXJjZSh7XG5cdFx0XHRcdGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsXG5cdFx0XHRcdGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50LmNsb25lKCksXG5cdFx0XHRcdHNlcGFyYXRvcjogc291cmNlLnNlcGFyYXRvcixcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGJ1bmRsZTtcblx0fVxuXG5cdGdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCBuYW1lcyA9IFtdO1xuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcblx0XHRcdE9iamVjdC5rZXlzKHNvdXJjZS5jb250ZW50LnN0b3JlZE5hbWVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRcdGlmICghfm5hbWVzLmluZGV4T2YobmFtZSkpIG5hbWVzLnB1c2gobmFtZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMpO1xuXG5cdFx0aWYgKHRoaXMuaW50cm8pIHtcblx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcy5pbnRybyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSwgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcy5zZXBhcmF0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzb3VyY2VJbmRleCA9IHNvdXJjZS5maWxlbmFtZSA/IHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV0gOiAtMTtcblx0XHRcdGNvbnN0IG1hZ2ljU3RyaW5nID0gc291cmNlLmNvbnRlbnQ7XG5cdFx0XHRjb25zdCBsb2NhdGUgPSBnZXRMb2NhdG9yKG1hZ2ljU3RyaW5nLm9yaWdpbmFsKTtcblxuXHRcdFx0aWYgKG1hZ2ljU3RyaW5nLmludHJvKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UobWFnaWNTdHJpbmcuaW50cm8pO1xuXHRcdFx0fVxuXG5cdFx0XHRtYWdpY1N0cmluZy5maXJzdENodW5rLmVhY2hOZXh0KChjaHVuaykgPT4ge1xuXHRcdFx0XHRjb25zdCBsb2MgPSBsb2NhdGUoY2h1bmsuc3RhcnQpO1xuXG5cdFx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsuaW50cm8pO1xuXG5cdFx0XHRcdGlmIChzb3VyY2UuZmlsZW5hbWUpIHtcblx0XHRcdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdFx0XHRtYXBwaW5ncy5hZGRFZGl0KFxuXHRcdFx0XHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0XHRcdFx0Y2h1bmsuY29udGVudCxcblx0XHRcdFx0XHRcdFx0bG9jLFxuXHRcdFx0XHRcdFx0XHRjaHVuay5zdG9yZU5hbWUgPyBuYW1lcy5pbmRleE9mKGNodW5rLm9yaWdpbmFsKSA6IC0xXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXBwaW5ncy5hZGRVbmVkaXRlZENodW5rKFxuXHRcdFx0XHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0XHRcdFx0Y2h1bmssXG5cdFx0XHRcdFx0XHRcdG1hZ2ljU3RyaW5nLm9yaWdpbmFsLFxuXHRcdFx0XHRcdFx0XHRsb2MsXG5cdFx0XHRcdFx0XHRcdG1hZ2ljU3RyaW5nLnNvdXJjZW1hcExvY2F0aW9uc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWFwcGluZ3MuYWR2YW5jZShjaHVuay5jb250ZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsub3V0cm8pO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChtYWdpY1N0cmluZy5vdXRybykge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKG1hZ2ljU3RyaW5nLm91dHJvKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRmaWxlOiBvcHRpb25zLmZpbGUgPyBvcHRpb25zLmZpbGUuc3BsaXQoL1svXFxcXF0vKS5wb3AoKSA6IG51bGwsXG5cdFx0XHRzb3VyY2VzOiB0aGlzLnVuaXF1ZVNvdXJjZXMubWFwKChzb3VyY2UpID0+IHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuZmlsZSA/IGdldFJlbGF0aXZlUGF0aChvcHRpb25zLmZpbGUsIHNvdXJjZS5maWxlbmFtZSkgOiBzb3VyY2UuZmlsZW5hbWU7XG5cdFx0XHR9KSxcblx0XHRcdHNvdXJjZXNDb250ZW50OiB0aGlzLnVuaXF1ZVNvdXJjZXMubWFwKChzb3VyY2UpID0+IHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuaW5jbHVkZUNvbnRlbnQgPyBzb3VyY2UuY29udGVudCA6IG51bGw7XG5cdFx0XHR9KSxcblx0XHRcdG5hbWVzLFxuXHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLnJhdyxcblx0XHR9O1xuXHR9XG5cblx0Z2VuZXJhdGVNYXAob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgU291cmNlTWFwKHRoaXMuZ2VuZXJhdGVEZWNvZGVkTWFwKG9wdGlvbnMpKTtcblx0fVxuXG5cdGdldEluZGVudFN0cmluZygpIHtcblx0XHRjb25zdCBpbmRlbnRTdHJpbmdDb3VudHMgPSB7fTtcblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcblx0XHRcdGNvbnN0IGluZGVudFN0ciA9IHNvdXJjZS5jb250ZW50LmluZGVudFN0cjtcblxuXHRcdFx0aWYgKGluZGVudFN0ciA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIWluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdKSBpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSA9IDA7XG5cdFx0XHRpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSArPSAxO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdE9iamVjdC5rZXlzKGluZGVudFN0cmluZ0NvdW50cykuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRyZXR1cm4gaW5kZW50U3RyaW5nQ291bnRzW2FdIC0gaW5kZW50U3RyaW5nQ291bnRzW2JdO1xuXHRcdFx0fSlbMF0gfHwgJ1xcdCdcblx0XHQpO1xuXHR9XG5cblx0aW5kZW50KGluZGVudFN0cikge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aW5kZW50U3RyID0gdGhpcy5nZXRJbmRlbnRTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRpZiAoaW5kZW50U3RyID09PSAnJykgcmV0dXJuIHRoaXM7IC8vIG5vb3BcblxuXHRcdGxldCB0cmFpbGluZ05ld2xpbmUgPSAhdGhpcy5pbnRybyB8fCB0aGlzLmludHJvLnNsaWNlKC0xKSA9PT0gJ1xcbic7XG5cblx0XHR0aGlzLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBzZXBhcmF0b3IgPSBzb3VyY2Uuc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBzb3VyY2Uuc2VwYXJhdG9yIDogdGhpcy5zZXBhcmF0b3I7XG5cdFx0XHRjb25zdCBpbmRlbnRTdGFydCA9IHRyYWlsaW5nTmV3bGluZSB8fCAoaSA+IDAgJiYgL1xccj9cXG4kLy50ZXN0KHNlcGFyYXRvcikpO1xuXG5cdFx0XHRzb3VyY2UuY29udGVudC5pbmRlbnQoaW5kZW50U3RyLCB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHNvdXJjZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMsXG5cdFx0XHRcdGluZGVudFN0YXJ0LCAvLzogdHJhaWxpbmdOZXdsaW5lIHx8IC9cXHI/XFxuJC8udGVzdCggc2VwYXJhdG9yICkgIC8vdHJ1ZS8vL1xccj9cXG4vLnRlc3QoIHNlcGFyYXRvciApXG5cdFx0XHR9KTtcblxuXHRcdFx0dHJhaWxpbmdOZXdsaW5lID0gc291cmNlLmNvbnRlbnQubGFzdENoYXIoKSA9PT0gJ1xcbic7XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5pbnRybykge1xuXHRcdFx0dGhpcy5pbnRybyA9XG5cdFx0XHRcdGluZGVudFN0ciArXG5cdFx0XHRcdHRoaXMuaW50cm8ucmVwbGFjZSgvXlteXFxuXS9nbSwgKG1hdGNoLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCA+IDAgPyBpbmRlbnRTdHIgKyBtYXRjaCA6IG1hdGNoO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmQoc3RyKSB7XG5cdFx0dGhpcy5pbnRybyA9IHN0ciArIHRoaXMuaW50cm87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRjb25zdCBib2R5ID0gdGhpcy5zb3VyY2VzXG5cdFx0XHQubWFwKChzb3VyY2UsIGkpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdG9yID0gc291cmNlLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gc291cmNlLnNlcGFyYXRvciA6IHRoaXMuc2VwYXJhdG9yO1xuXHRcdFx0XHRjb25zdCBzdHIgPSAoaSA+IDAgPyBzZXBhcmF0b3IgOiAnJykgKyBzb3VyY2UuY29udGVudC50b1N0cmluZygpO1xuXG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9KVxuXHRcdFx0LmpvaW4oJycpO1xuXG5cdFx0cmV0dXJuIHRoaXMuaW50cm8gKyBib2R5O1xuXHR9XG5cblx0aXNFbXB0eSgpIHtcblx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGggJiYgdGhpcy5pbnRyby50cmltKCkpIHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5zb3VyY2VzLnNvbWUoKHNvdXJjZSkgPT4gIXNvdXJjZS5jb250ZW50LmlzRW1wdHkoKSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zb3VyY2VzLnJlZHVjZShcblx0XHRcdChsZW5ndGgsIHNvdXJjZSkgPT4gbGVuZ3RoICsgc291cmNlLmNvbnRlbnQubGVuZ3RoKCksXG5cdFx0XHR0aGlzLmludHJvLmxlbmd0aFxuXHRcdCk7XG5cdH1cblxuXHR0cmltTGluZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJpbSgnW1xcXFxyXFxcXG5dJyk7XG5cdH1cblxuXHR0cmltKGNoYXJUeXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcblx0fVxuXG5cdHRyaW1TdGFydChjaGFyVHlwZSkge1xuXHRcdGNvbnN0IHJ4ID0gbmV3IFJlZ0V4cCgnXicgKyAoY2hhclR5cGUgfHwgJ1xcXFxzJykgKyAnKycpO1xuXHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblxuXHRcdGlmICghdGhpcy5pbnRybykge1xuXHRcdFx0bGV0IHNvdXJjZTtcblx0XHRcdGxldCBpID0gMDtcblxuXHRcdFx0ZG8ge1xuXHRcdFx0XHRzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaSsrXTtcblx0XHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIXNvdXJjZS5jb250ZW50LnRyaW1TdGFydEFib3J0ZWQoY2hhclR5cGUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHRyaW1FbmQoY2hhclR5cGUpIHtcblx0XHRjb25zdCByeCA9IG5ldyBSZWdFeHAoKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJyskJyk7XG5cblx0XHRsZXQgc291cmNlO1xuXHRcdGxldCBpID0gdGhpcy5zb3VyY2VzLmxlbmd0aCAtIDE7XG5cblx0XHRkbyB7XG5cdFx0XHRzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaS0tXTtcblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIXNvdXJjZS5jb250ZW50LnRyaW1FbmRBYm9ydGVkKGNoYXJUeXBlKSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuIiwgImltcG9ydCBNYWdpY1N0cmluZyBmcm9tICcuL01hZ2ljU3RyaW5nLmpzJztcbmltcG9ydCBCdW5kbGUgZnJvbSAnLi9CdW5kbGUuanMnO1xuaW1wb3J0IFNvdXJjZU1hcCBmcm9tICcuL1NvdXJjZU1hcC5qcyc7XG5cbk1hZ2ljU3RyaW5nLkJ1bmRsZSA9IEJ1bmRsZTtcbk1hZ2ljU3RyaW5nLlNvdXJjZU1hcCA9IFNvdXJjZU1hcDtcbk1hZ2ljU3RyaW5nLmRlZmF1bHQgPSBNYWdpY1N0cmluZzsgLy8gd29yayBhcm91bmQgVHlwZVNjcmlwdCBidWcgaHR0cHM6Ly9naXRodWIuY29tL1JpY2gtSGFycmlzL21hZ2ljLXN0cmluZy9wdWxsLzEyMVxuXG5leHBvcnQgZGVmYXVsdCBNYWdpY1N0cmluZztcbiIsICIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmlzUmVmZXJlbmNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdGZ1bmN0aW9uIGlzUmVmZXJlbmNlKG5vZGUsIHBhcmVudCkge1xuXHQgICAgaWYgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG5cdCAgICAgICAgcmV0dXJuICFub2RlLmNvbXB1dGVkICYmIGlzUmVmZXJlbmNlKG5vZGUub2JqZWN0LCBub2RlKTtcblx0ICAgIH1cblx0ICAgIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuXHQgICAgICAgIGlmICghcGFyZW50KVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgIC8vIGRpc3JlZ2FyZCBgYmFyYCBpbiBgZm9vLmJhcmBcblx0ICAgICAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50Lm9iamVjdDtcblx0ICAgICAgICAgICAgLy8gZGlzcmVnYXJkIHRoZSBgZm9vYCBpbiBgY2xhc3Mge2Zvbygpe319YCBidXQga2VlcCBpdCBpbiBgY2xhc3Mge1tmb29dKCl7fX1gXG5cdCAgICAgICAgICAgIGNhc2UgJ01ldGhvZERlZmluaXRpb24nOiByZXR1cm4gcGFyZW50LmNvbXB1dGVkO1xuXHQgICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGhlIGBmb29gIGluIGBjbGFzcyB7Zm9vPWJhcn1gIGJ1dCBrZWVwIGl0IGluIGBjbGFzcyB7W2Zvb109YmFyfWAgYW5kIGBjbGFzcyB7YmFyPWZvb31gXG5cdCAgICAgICAgICAgIGNhc2UgJ0ZpZWxkRGVmaW5pdGlvbic6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50LnZhbHVlO1xuXHQgICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGhlIGBiYXJgIGluIGB7IGJhcjogZm9vIH1gLCBidXQga2VlcCBpdCBpbiBgeyBbYmFyXTogZm9vIH1gXG5cdCAgICAgICAgICAgIGNhc2UgJ1Byb3BlcnR5JzogcmV0dXJuIHBhcmVudC5jb21wdXRlZCB8fCBub2RlID09PSBwYXJlbnQudmFsdWU7XG5cdCAgICAgICAgICAgIC8vIGRpc3JlZ2FyZCB0aGUgYGJhcmAgaW4gYGV4cG9ydCB7IGZvbyBhcyBiYXIgfWAgb3Jcblx0ICAgICAgICAgICAgLy8gdGhlIGZvbyBpbiBgaW1wb3J0IHsgZm9vIGFzIGJhciB9YFxuXHQgICAgICAgICAgICBjYXNlICdFeHBvcnRTcGVjaWZpZXInOlxuXHQgICAgICAgICAgICBjYXNlICdJbXBvcnRTcGVjaWZpZXInOiByZXR1cm4gbm9kZSA9PT0gcGFyZW50LmxvY2FsO1xuXHQgICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGhlIGBmb29gIGluIGBmb286IHdoaWxlICguLi4pIHsgLi4uIGJyZWFrIGZvbzsgLi4uIGNvbnRpbnVlIGZvbzt9YFxuXHQgICAgICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50Jzpcblx0ICAgICAgICAgICAgY2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuXHQgICAgICAgICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6IHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIGlzUmVmZXJlbmNlO1xuXG59KSkpO1xuIiwgImV4cG9ydCBmdW5jdGlvbiB0cnlQYXJzZShwYXJzZSwgY29kZSwgaWQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGFyc2UoY29kZSwgeyBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgKz0gYCBpbiAke2lkfWA7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmNvbnN0IGZpcnN0cGFzc0dsb2JhbCA9IC9cXGIoPzpyZXF1aXJlfG1vZHVsZXxleHBvcnRzfGdsb2JhbClcXGIvO1xuXG5jb25zdCBmaXJzdHBhc3NOb0dsb2JhbCA9IC9cXGIoPzpyZXF1aXJlfG1vZHVsZXxleHBvcnRzKVxcYi87XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDanNLZXl3b3Jkcyhjb2RlLCBpZ25vcmVHbG9iYWwpIHtcbiAgY29uc3QgZmlyc3RwYXNzID0gaWdub3JlR2xvYmFsID8gZmlyc3RwYXNzTm9HbG9iYWwgOiBmaXJzdHBhc3NHbG9iYWw7XG4gIHJldHVybiBmaXJzdHBhc3MudGVzdChjb2RlKTtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuXG5pbXBvcnQgeyB0cnlQYXJzZSB9IGZyb20gJy4vcGFyc2UnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhbmFseXplVG9wTGV2ZWxTdGF0ZW1lbnRzKHBhcnNlLCBjb2RlLCBpZCkge1xuICBjb25zdCBhc3QgPSB0cnlQYXJzZShwYXJzZSwgY29kZSwgaWQpO1xuXG4gIGxldCBpc0VzTW9kdWxlID0gZmFsc2U7XG4gIGxldCBoYXNEZWZhdWx0RXhwb3J0ID0gZmFsc2U7XG4gIGxldCBoYXNOYW1lZEV4cG9ydHMgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0LmJvZHkpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJzpcbiAgICAgICAgaXNFc01vZHVsZSA9IHRydWU7XG4gICAgICAgIGhhc0RlZmF1bHRFeHBvcnQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nOlxuICAgICAgICBpc0VzTW9kdWxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBoYXNOYW1lZEV4cG9ydHMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIG5vZGUuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgaWYgKHNwZWNpZmllci5leHBvcnRlZC5uYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgaGFzRGVmYXVsdEV4cG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYXNOYW1lZEV4cG9ydHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0V4cG9ydEFsbERlY2xhcmF0aW9uJzpcbiAgICAgICAgaXNFc01vZHVsZSA9IHRydWU7XG4gICAgICAgIGlmIChub2RlLmV4cG9ydGVkICYmIG5vZGUuZXhwb3J0ZWQubmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgaGFzRGVmYXVsdEV4cG9ydCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzTmFtZWRFeHBvcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ltcG9ydERlY2xhcmF0aW9uJzpcbiAgICAgICAgaXNFc01vZHVsZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBpc0VzTW9kdWxlLCBoYXNEZWZhdWx0RXhwb3J0LCBoYXNOYW1lZEV4cG9ydHMsIGFzdCB9O1xufVxuIiwgImV4cG9ydCBjb25zdCBpc1dyYXBwZWRJZCA9IChpZCwgc3VmZml4KSA9PiBpZC5lbmRzV2l0aChzdWZmaXgpO1xuZXhwb3J0IGNvbnN0IHdyYXBJZCA9IChpZCwgc3VmZml4KSA9PiBgXFwwJHtpZH0ke3N1ZmZpeH1gO1xuZXhwb3J0IGNvbnN0IHVud3JhcElkID0gKHdyYXBwZWRJZCwgc3VmZml4KSA9PiB3cmFwcGVkSWQuc2xpY2UoMSwgLXN1ZmZpeC5sZW5ndGgpO1xuXG5leHBvcnQgY29uc3QgUFJPWFlfU1VGRklYID0gJz9jb21tb25qcy1wcm94eSc7XG5leHBvcnQgY29uc3QgUkVRVUlSRV9TVUZGSVggPSAnP2NvbW1vbmpzLXJlcXVpcmUnO1xuZXhwb3J0IGNvbnN0IEVYVEVSTkFMX1NVRkZJWCA9ICc/Y29tbW9uanMtZXh0ZXJuYWwnO1xuZXhwb3J0IGNvbnN0IEVYUE9SVFNfU1VGRklYID0gJz9jb21tb25qcy1leHBvcnRzJztcbmV4cG9ydCBjb25zdCBNT0RVTEVfU1VGRklYID0gJz9jb21tb25qcy1tb2R1bGUnO1xuXG5leHBvcnQgY29uc3QgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVggPSAnP2NvbW1vbmpzLWR5bmFtaWMtcmVnaXN0ZXInO1xuZXhwb3J0IGNvbnN0IERZTkFNSUNfSlNPTl9QUkVGSVggPSAnXFwwY29tbW9uanMtZHluYW1pYy1qc29uOic7XG5leHBvcnQgY29uc3QgRFlOQU1JQ19QQUNLQUdFU19JRCA9ICdcXDBjb21tb25qcy1keW5hbWljLXBhY2thZ2VzJztcblxuZXhwb3J0IGNvbnN0IEhFTFBFUlNfSUQgPSAnXFwwY29tbW9uanNIZWxwZXJzLmpzJztcblxuLy8gYHhbJ2RlZmF1bHQnXWAgaXMgdXNlZCBpbnN0ZWFkIG9mIGB4LmRlZmF1bHRgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggRVMzIGJyb3dzZXJzLlxuLy8gTWluaWZpZXJzIGxpa2UgdWdsaWZ5IHdpbGwgdXN1YWxseSB0cmFuc3BpbGUgaXQgYmFjayBpZiBjb21wYXRpYmlsaXR5IHdpdGggRVMzIGlzIG5vdCBlbmFibGVkLlxuLy8gVGhpcyB3aWxsIG5vIGxvbmdlciBiZSBuZWNlc3Nhcnkgb25jZSBSb2xsdXAgc3dpdGNoZXMgdG8gRVM2IG91dHB1dCwgbGlrZWx5XG4vLyBpbiBSb2xsdXAgM1xuXG5jb25zdCBIRUxQRVJTID0gYFxuZXhwb3J0IHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IChuKSB7XG5cdHJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpID8gblsnZGVmYXVsdCddIDogbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcblx0aWYgKG4uX19lc01vZHVsZSkgcmV0dXJuIG47XG5cdHZhciBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xuXHRPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBuW2tdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIGE7XG59XG5gO1xuXG5jb25zdCBGQUlMRURfUkVRVUlSRV9FUlJPUiA9IGB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHBhdGggKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO2A7XG5cbmNvbnN0IEhFTFBFUl9OT05fRFlOQU1JQyA9IGBcbmV4cG9ydCBmdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKHBhdGgpIHtcblx0JHtGQUlMRURfUkVRVUlSRV9FUlJPUn1cbn1cbmA7XG5cbmNvbnN0IGdldER5bmFtaWNIZWxwZXJzID0gKGlnbm9yZUR5bmFtaWNSZXF1aXJlcykgPT4gYFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vZHVsZShtb2R1bGVQYXRoKSB7XG5cdHJldHVybiB7XG5cdFx0cGF0aDogbW9kdWxlUGF0aCxcblx0XHRleHBvcnRzOiB7fSxcblx0XHRyZXF1aXJlOiBmdW5jdGlvbiAocGF0aCwgYmFzZSkge1xuXHRcdFx0cmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLCBiYXNlID09IG51bGwgPyBtb2R1bGVQYXRoIDogYmFzZSk7XG5cdFx0fVxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uanNSZWdpc3RlciAocGF0aCwgbG9hZGVyKSB7XG5cdERZTkFNSUNfUkVRVUlSRV9MT0FERVJTW3BhdGhdID0gbG9hZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uanNSZWdpc3Rlck9yU2hvcnQgKHBhdGgsIHRvKSB7XG5cdHZhciByZXNvbHZlZFBhdGggPSBjb21tb25qc1Jlc29sdmVJbXBsKHBhdGgsIG51bGwsIHRydWUpO1xuXHRpZiAocmVzb2x2ZWRQYXRoICE9PSBudWxsICYmIERZTkFNSUNfUkVRVUlSRV9DQUNIRVtyZXNvbHZlZFBhdGhdKSB7XG5cdCAgRFlOQU1JQ19SRVFVSVJFX0NBQ0hFW3BhdGhdID0gRFlOQU1JQ19SRVFVSVJFX0NBQ0hFW3Jlc29sdmVkUGF0aF07XG5cdH0gZWxzZSB7XG5cdCAgRFlOQU1JQ19SRVFVSVJFX1NIT1JUU1twYXRoXSA9IHRvO1xuXHR9XG59XG5cbnZhciBEWU5BTUlDX1JFUVVJUkVfTE9BREVSUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgRFlOQU1JQ19SRVFVSVJFX0NBQ0hFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBEWU5BTUlDX1JFUVVJUkVfU0hPUlRTID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBERUZBVUxUX1BBUkVOVF9NT0RVTEUgPSB7XG5cdGlkOiAnPCcgKyAncm9sbHVwPicsIGV4cG9ydHM6IHt9LCBwYXJlbnQ6IHVuZGVmaW5lZCwgZmlsZW5hbWU6IG51bGwsIGxvYWRlZDogZmFsc2UsIGNoaWxkcmVuOiBbXSwgcGF0aHM6IFtdXG59O1xudmFyIENIRUNLRURfRVhURU5TSU9OUyA9IFsnJywgJy5qcycsICcuanNvbiddO1xuXG5mdW5jdGlvbiBub3JtYWxpemUgKHBhdGgpIHtcblx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXFxcXFwvZywgJy8nKTtcblx0dmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuXHR2YXIgc2xhc2hlZCA9IHBhcnRzWzBdID09PSAnJztcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChwYXJ0c1tpXSA9PT0gJy4nIHx8IHBhcnRzW2ldID09PSAnJykge1xuXHRcdFx0cGFydHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAocGFydHNbaV0gIT09ICcuLicpIGNvbnRpbnVlO1xuXHRcdGlmIChpID4gMCAmJiBwYXJ0c1tpIC0gMV0gIT09ICcuLicgJiYgcGFydHNbaSAtIDFdICE9PSAnLicpIHtcblx0XHRcdHBhcnRzLnNwbGljZSgtLWksIDIpO1xuXHRcdFx0aS0tO1xuXHRcdH1cblx0fVxuXHRwYXRoID0gcGFydHMuam9pbignLycpO1xuXHRpZiAoc2xhc2hlZCAmJiBwYXRoWzBdICE9PSAnLycpXG5cdCAgcGF0aCA9ICcvJyArIHBhdGg7XG5cdGVsc2UgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuXHQgIHBhdGggPSAnLic7XG5cdHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBqb2luICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG5cdCAgcmV0dXJuICcuJztcblx0dmFyIGpvaW5lZDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcblx0ICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHQgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuXHRcdGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcblx0XHQgIGpvaW5lZCA9IGFyZztcblx0XHRlbHNlXG5cdFx0ICBqb2luZWQgKz0gJy8nICsgYXJnO1xuXHQgIH1cblx0fVxuXHRpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG5cdCAgcmV0dXJuICcuJztcblxuXHRyZXR1cm4gam9pbmVkO1xufVxuXG5mdW5jdGlvbiBpc1Bvc3NpYmxlTm9kZU1vZHVsZXNQYXRoIChtb2R1bGVQYXRoKSB7XG5cdHZhciBjMCA9IG1vZHVsZVBhdGhbMF07XG5cdGlmIChjMCA9PT0gJy8nIHx8IGMwID09PSAnXFxcXFxcXFwnKSByZXR1cm4gZmFsc2U7XG5cdHZhciBjMSA9IG1vZHVsZVBhdGhbMV0sIGMyID0gbW9kdWxlUGF0aFsyXTtcblx0aWYgKChjMCA9PT0gJy4nICYmICghYzEgfHwgYzEgPT09ICcvJyB8fCBjMSA9PT0gJ1xcXFxcXFxcJykpIHx8XG5cdFx0KGMwID09PSAnLicgJiYgYzEgPT09ICcuJyAmJiAoIWMyIHx8IGMyID09PSAnLycgfHwgYzIgPT09ICdcXFxcXFxcXCcpKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYzEgPT09ICc6JyAmJiAoYzIgPT09ICcvJyB8fCBjMiA9PT0gJ1xcXFxcXFxcJykpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGlybmFtZSAocGF0aCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICcuJztcblxuICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGkgPiAwKSB7XG4gICAgdmFyIGMgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKChjID09PSA0NyB8fCBjID09PSA5MikgJiYgaSAhPT0gcGF0aC5sZW5ndGggLSAxKVxuICAgICAgYnJlYWs7XG4gICAgaS0tO1xuICB9XG5cbiAgaWYgKGkgPiAwKVxuICAgIHJldHVybiBwYXRoLnN1YnN0cigwLCBpKTtcblxuICBpZiAocGF0aC5jaGFydENvZGVBdCgwKSA9PT0gNDcgfHwgcGF0aC5jaGFydENvZGVBdCgwKSA9PT0gOTIpXG4gICAgcmV0dXJuIHBhdGguY2hhckF0KDApO1xuXG4gIHJldHVybiAnLic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25qc1Jlc29sdmVJbXBsIChwYXRoLCBvcmlnaW5hbE1vZHVsZURpciwgdGVzdENhY2hlKSB7XG5cdHZhciBzaG91bGRUcnlOb2RlTW9kdWxlcyA9IGlzUG9zc2libGVOb2RlTW9kdWxlc1BhdGgocGF0aCk7XG5cdHBhdGggPSBub3JtYWxpemUocGF0aCk7XG5cdHZhciByZWxQYXRoO1xuXHRpZiAocGF0aFswXSA9PT0gJy8nKSB7XG5cdFx0b3JpZ2luYWxNb2R1bGVEaXIgPSAnLyc7XG5cdH1cblx0d2hpbGUgKHRydWUpIHtcblx0XHRpZiAoIXNob3VsZFRyeU5vZGVNb2R1bGVzKSB7XG5cdFx0XHRyZWxQYXRoID0gb3JpZ2luYWxNb2R1bGVEaXIgPyBub3JtYWxpemUob3JpZ2luYWxNb2R1bGVEaXIgKyAnLycgKyBwYXRoKSA6IHBhdGg7XG5cdFx0fSBlbHNlIGlmIChvcmlnaW5hbE1vZHVsZURpcikge1xuXHRcdFx0cmVsUGF0aCA9IG5vcm1hbGl6ZShvcmlnaW5hbE1vZHVsZURpciArICcvbm9kZV9tb2R1bGVzLycgKyBwYXRoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVsUGF0aCA9IG5vcm1hbGl6ZShqb2luKCdub2RlX21vZHVsZXMnLCBwYXRoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlbFBhdGguZW5kc1dpdGgoJy8uLicpKSB7XG5cdFx0XHRicmVhazsgLy8gVHJhdmVsbGVkIHRvbyBmYXIgdXAsIGF2b2lkIGluZmluaXRlIGxvb3Bcblx0XHR9XG5cblx0XHRmb3IgKHZhciBleHRlbnNpb25JbmRleCA9IDA7IGV4dGVuc2lvbkluZGV4IDwgQ0hFQ0tFRF9FWFRFTlNJT05TLmxlbmd0aDsgZXh0ZW5zaW9uSW5kZXgrKykge1xuXHRcdFx0dmFyIHJlc29sdmVkUGF0aCA9IHJlbFBhdGggKyBDSEVDS0VEX0VYVEVOU0lPTlNbZXh0ZW5zaW9uSW5kZXhdO1xuXHRcdFx0aWYgKERZTkFNSUNfUkVRVUlSRV9DQUNIRVtyZXNvbHZlZFBhdGhdKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlZFBhdGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAoRFlOQU1JQ19SRVFVSVJFX1NIT1JUU1tyZXNvbHZlZFBhdGhdKSB7XG5cdFx0XHQgIHJldHVybiByZXNvbHZlZFBhdGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAoRFlOQU1JQ19SRVFVSVJFX0xPQURFUlNbcmVzb2x2ZWRQYXRoXSkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWRQYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXNob3VsZFRyeU5vZGVNb2R1bGVzKSBicmVhaztcblx0XHR2YXIgbmV4dERpciA9IG5vcm1hbGl6ZShvcmlnaW5hbE1vZHVsZURpciArICcvLi4nKTtcblx0XHRpZiAobmV4dERpciA9PT0gb3JpZ2luYWxNb2R1bGVEaXIpIGJyZWFrO1xuXHRcdG9yaWdpbmFsTW9kdWxlRGlyID0gbmV4dERpcjtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vbmpzUmVzb2x2ZSAocGF0aCwgb3JpZ2luYWxNb2R1bGVEaXIpIHtcblx0dmFyIHJlc29sdmVkUGF0aCA9IGNvbW1vbmpzUmVzb2x2ZUltcGwocGF0aCwgb3JpZ2luYWxNb2R1bGVEaXIpO1xuXHRpZiAocmVzb2x2ZWRQYXRoICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIHJlc29sdmVkUGF0aDtcblx0fVxuXHRyZXR1cm4gcmVxdWlyZS5yZXNvbHZlKHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlIChwYXRoLCBvcmlnaW5hbE1vZHVsZURpcikge1xuXHR2YXIgcmVzb2x2ZWRQYXRoID0gY29tbW9uanNSZXNvbHZlSW1wbChwYXRoLCBvcmlnaW5hbE1vZHVsZURpciwgdHJ1ZSk7XG5cdGlmIChyZXNvbHZlZFBhdGggIT09IG51bGwpIHtcbiAgICB2YXIgY2FjaGVkTW9kdWxlID0gRFlOQU1JQ19SRVFVSVJFX0NBQ0hFW3Jlc29sdmVkUGF0aF07XG4gICAgaWYgKGNhY2hlZE1vZHVsZSkgcmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuICAgIHZhciBzaG9ydFRvID0gRFlOQU1JQ19SRVFVSVJFX1NIT1JUU1tyZXNvbHZlZFBhdGhdO1xuICAgIGlmIChzaG9ydFRvKSB7XG4gICAgICBjYWNoZWRNb2R1bGUgPSBEWU5BTUlDX1JFUVVJUkVfQ0FDSEVbc2hvcnRUb107XG4gICAgICBpZiAoY2FjaGVkTW9kdWxlKVxuICAgICAgICByZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4gICAgICByZXNvbHZlZFBhdGggPSBjb21tb25qc1Jlc29sdmVJbXBsKHNob3J0VG8sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB2YXIgbG9hZGVyID0gRFlOQU1JQ19SRVFVSVJFX0xPQURFUlNbcmVzb2x2ZWRQYXRoXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBEWU5BTUlDX1JFUVVJUkVfQ0FDSEVbcmVzb2x2ZWRQYXRoXSA9IGNhY2hlZE1vZHVsZSA9IHtcbiAgICAgICAgaWQ6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgZmlsZW5hbWU6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcGF0aDogZGlybmFtZShyZXNvbHZlZFBhdGgpLFxuICAgICAgICBleHBvcnRzOiB7fSxcbiAgICAgICAgcGFyZW50OiBERUZBVUxUX1BBUkVOVF9NT0RVTEUsXG4gICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgcGF0aHM6IFtdLFxuICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAocGF0aCwgYmFzZSkge1xuICAgICAgICAgIHJldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCwgKGJhc2UgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSBudWxsKSA/IGNhY2hlZE1vZHVsZS5wYXRoIDogYmFzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBsb2FkZXIuY2FsbChjb21tb25qc0dsb2JhbCwgY2FjaGVkTW9kdWxlLCBjYWNoZWRNb2R1bGUuZXhwb3J0cyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWxldGUgRFlOQU1JQ19SRVFVSVJFX0NBQ0hFW3Jlc29sdmVkUGF0aF07XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY2FjaGVkTW9kdWxlLmxvYWRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4gICAgfTtcblx0fVxuXHQke2lnbm9yZUR5bmFtaWNSZXF1aXJlcyA/ICdyZXR1cm4gcmVxdWlyZShwYXRoKTsnIDogRkFJTEVEX1JFUVVJUkVfRVJST1J9XG59XG5cbmNvbW1vbmpzUmVxdWlyZS5jYWNoZSA9IERZTkFNSUNfUkVRVUlSRV9DQUNIRTtcbmNvbW1vbmpzUmVxdWlyZS5yZXNvbHZlID0gY29tbW9uanNSZXNvbHZlO1xuYDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlbHBlcnNNb2R1bGUoaXNEeW5hbWljUmVxdWlyZU1vZHVsZXNFbmFibGVkLCBpZ25vcmVEeW5hbWljUmVxdWlyZXMpIHtcbiAgcmV0dXJuIGAke0hFTFBFUlN9JHtcbiAgICBpc0R5bmFtaWNSZXF1aXJlTW9kdWxlc0VuYWJsZWQgPyBnZXREeW5hbWljSGVscGVycyhpZ25vcmVEeW5hbWljUmVxdWlyZXMpIDogSEVMUEVSX05PTl9EWU5BTUlDXG4gIH1gO1xufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cblxuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGV4dG5hbWUgfSBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgbWFrZUxlZ2FsSWRlbnRpZmllciB9IGZyb20gJ0Byb2xsdXAvcGx1Z2ludXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb25mbGljdChzY29wZXMsIGdsb2JhbHMsIGlkZW50aWZpZXIpIHtcbiAgbGV0IGkgPSAxO1xuICBsZXQgZGVjb25mbGljdGVkID0gbWFrZUxlZ2FsSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgY29uc3QgaGFzQ29uZmxpY3RzID0gKCkgPT5cbiAgICBzY29wZXMuc29tZSgoc2NvcGUpID0+IHNjb3BlLmNvbnRhaW5zKGRlY29uZmxpY3RlZCkpIHx8IGdsb2JhbHMuaGFzKGRlY29uZmxpY3RlZCk7XG5cbiAgd2hpbGUgKGhhc0NvbmZsaWN0cygpKSB7XG4gICAgZGVjb25mbGljdGVkID0gbWFrZUxlZ2FsSWRlbnRpZmllcihgJHtpZGVudGlmaWVyfV8ke2l9YCk7XG4gICAgaSArPSAxO1xuICB9XG5cbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBzY29wZS5kZWNsYXJhdGlvbnNbZGVjb25mbGljdGVkXSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVjb25mbGljdGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZShpZCkge1xuICBjb25zdCBuYW1lID0gbWFrZUxlZ2FsSWRlbnRpZmllcihiYXNlbmFtZShpZCwgZXh0bmFtZShpZCkpKTtcbiAgaWYgKG5hbWUgIT09ICdpbmRleCcpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICByZXR1cm4gbWFrZUxlZ2FsSWRlbnRpZmllcihiYXNlbmFtZShkaXJuYW1lKGlkKSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGF0aFNsYXNoZXMocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG59XG5cbmNvbnN0IFZJUlRVQUxfUEFUSF9CQVNFID0gJy8kJHJvbGx1cF9iYXNlJCQnO1xuZXhwb3J0IGNvbnN0IGdldFZpcnR1YWxQYXRoRm9yRHluYW1pY1JlcXVpcmVQYXRoID0gKHBhdGgsIGNvbW1vbkRpcikgPT4ge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGhTbGFzaGVzKHBhdGgpO1xuICByZXR1cm4gbm9ybWFsaXplZFBhdGguc3RhcnRzV2l0aChjb21tb25EaXIpXG4gICAgPyBWSVJUVUFMX1BBVEhfQkFTRSArIG5vcm1hbGl6ZWRQYXRoLnNsaWNlKGNvbW1vbkRpci5sZW5ndGgpXG4gICAgOiBub3JtYWxpemVkUGF0aDtcbn07XG4iLCAiaW1wb3J0IHsgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBEWU5BTUlDX1BBQ0tBR0VTX0lELCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCwgSEVMUEVSU19JRCwgd3JhcElkIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGdldFZpcnR1YWxQYXRoRm9yRHluYW1pY1JlcXVpcmVQYXRoLCBub3JtYWxpemVQYXRoU2xhc2hlcyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFja2FnZUVudHJ5UG9pbnQoZGlyUGF0aCkge1xuICBsZXQgZW50cnlQb2ludCA9ICdpbmRleC5qcyc7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZXhpc3RzU3luYyhqb2luKGRpclBhdGgsICdwYWNrYWdlLmpzb24nKSkpIHtcbiAgICAgIGVudHJ5UG9pbnQgPVxuICAgICAgICBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhqb2luKGRpclBhdGgsICdwYWNrYWdlLmpzb24nKSwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pKS5tYWluIHx8XG4gICAgICAgIGVudHJ5UG9pbnQ7XG4gICAgfVxuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgLy8gaWdub3JlZFxuICB9XG5cbiAgcmV0dXJuIGVudHJ5UG9pbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREeW5hbWljUGFja2FnZXNNb2R1bGUoZHluYW1pY1JlcXVpcmVNb2R1bGVEaXJQYXRocywgY29tbW9uRGlyKSB7XG4gIGxldCBjb2RlID0gYGNvbnN0IGNvbW1vbmpzUmVnaXN0ZXJPclNob3J0ID0gcmVxdWlyZSgnJHtIRUxQRVJTX0lEfT9jb21tb25qc1JlZ2lzdGVyT3JTaG9ydCcpO2A7XG4gIGZvciAoY29uc3QgZGlyIG9mIGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMpIHtcbiAgICBjb25zdCBlbnRyeVBvaW50ID0gZ2V0UGFja2FnZUVudHJ5UG9pbnQoZGlyKTtcblxuICAgIGNvZGUgKz0gYFxcbmNvbW1vbmpzUmVnaXN0ZXJPclNob3J0KCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBnZXRWaXJ0dWFsUGF0aEZvckR5bmFtaWNSZXF1aXJlUGF0aChkaXIsIGNvbW1vbkRpcilcbiAgICApfSwgJHtKU09OLnN0cmluZ2lmeShnZXRWaXJ0dWFsUGF0aEZvckR5bmFtaWNSZXF1aXJlUGF0aChqb2luKGRpciwgZW50cnlQb2ludCksIGNvbW1vbkRpcikpfSk7YDtcbiAgfVxuICByZXR1cm4gY29kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldER5bmFtaWNQYWNrYWdlc0VudHJ5SW50cm8oXG4gIGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMsXG4gIGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0XG4pIHtcbiAgbGV0IGR5bmFtaWNJbXBvcnRzID0gQXJyYXkuZnJvbShcbiAgICBkeW5hbWljUmVxdWlyZU1vZHVsZVNldCxcbiAgICAoZHluYW1pY0lkKSA9PiBgcmVxdWlyZSgke0pTT04uc3RyaW5naWZ5KHdyYXBJZChkeW5hbWljSWQsIERZTkFNSUNfUkVHSVNURVJfU1VGRklYKSl9KTtgXG4gICkuam9pbignXFxuJyk7XG5cbiAgaWYgKGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMubGVuZ3RoKSB7XG4gICAgZHluYW1pY0ltcG9ydHMgKz0gYHJlcXVpcmUoJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHdyYXBJZChEWU5BTUlDX1BBQ0tBR0VTX0lELCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWClcbiAgICApfSk7YDtcbiAgfVxuXG4gIHJldHVybiBkeW5hbWljSW1wb3J0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY01vZHVsZUltcG9ydChpZCwgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoU2xhc2hlcyhpZCk7XG4gIHJldHVybiBkeW5hbWljUmVxdWlyZU1vZHVsZVNldC5oYXMobm9ybWFsaXplZFBhdGgpICYmICFub3JtYWxpemVkUGF0aC5lbmRzV2l0aCgnLmpzb24nKTtcbn1cbiIsICJpbXBvcnQgeyBzdGF0U3luYyB9IGZyb20gJ2ZzJztcblxuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgZ2xvYiBmcm9tICdnbG9iJztcblxuaW1wb3J0IHsgbm9ybWFsaXplUGF0aFNsYXNoZXMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGdldFBhY2thZ2VFbnRyeVBvaW50IH0gZnJvbSAnLi9keW5hbWljLXBhY2thZ2VzLW1hbmFnZXInO1xuXG5mdW5jdGlvbiBpc0RpcmVjdG9yeShwYXRoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkpIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlXG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREeW5hbWljUmVxdWlyZVBhdGhzKHBhdHRlcm5zKSB7XG4gIGNvbnN0IGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgIXBhdHRlcm5zIHx8IEFycmF5LmlzQXJyYXkocGF0dGVybnMpID8gcGF0dGVybnMgfHwgW10gOiBbcGF0dGVybnNdKSB7XG4gICAgY29uc3QgaXNOZWdhdGVkID0gcGF0dGVybi5zdGFydHNXaXRoKCchJyk7XG4gICAgY29uc3QgbW9kaWZ5U2V0ID0gU2V0LnByb3RvdHlwZVtpc05lZ2F0ZWQgPyAnZGVsZXRlJyA6ICdhZGQnXS5iaW5kKGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0KTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgZ2xvYi5zeW5jKGlzTmVnYXRlZCA/IHBhdHRlcm4uc3Vic3RyKDEpIDogcGF0dGVybikpIHtcbiAgICAgIG1vZGlmeVNldChub3JtYWxpemVQYXRoU2xhc2hlcyhyZXNvbHZlKHBhdGgpKSk7XG4gICAgICBpZiAoaXNEaXJlY3RvcnkocGF0aCkpIHtcbiAgICAgICAgbW9kaWZ5U2V0KG5vcm1hbGl6ZVBhdGhTbGFzaGVzKHJlc29sdmUoam9pbihwYXRoLCBnZXRQYWNrYWdlRW50cnlQb2ludChwYXRoKSkpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMgPSBBcnJheS5mcm9tKGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0LnZhbHVlcygpKS5maWx0ZXIoKHBhdGgpID0+XG4gICAgaXNEaXJlY3RvcnkocGF0aClcbiAgKTtcbiAgcmV0dXJuIHsgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQsIGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMgfTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0Q29tbW9uSlNNZXRhUHJvbWlzZShjb21tb25KU01ldGFQcm9taXNlcywgaWQpIHtcbiAgbGV0IGNvbW1vbkpTTWV0YVByb21pc2UgPSBjb21tb25KU01ldGFQcm9taXNlcy5nZXQoaWQpO1xuICBpZiAoY29tbW9uSlNNZXRhUHJvbWlzZSkgcmV0dXJuIGNvbW1vbkpTTWV0YVByb21pc2UucHJvbWlzZTtcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb21tb25KU01ldGFQcm9taXNlID0ge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHByb21pc2U6IG51bGxcbiAgICB9O1xuICAgIGNvbW1vbkpTTWV0YVByb21pc2VzLnNldChpZCwgY29tbW9uSlNNZXRhUHJvbWlzZSk7XG4gIH0pO1xuICBjb21tb25KU01ldGFQcm9taXNlLnByb21pc2UgPSBwcm9taXNlO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29tbW9uSlNNZXRhUHJvbWlzZShjb21tb25KU01ldGFQcm9taXNlcywgaWQsIGNvbW1vbmpzTWV0YSkge1xuICBjb25zdCBjb21tb25KU01ldGFQcm9taXNlID0gY29tbW9uSlNNZXRhUHJvbWlzZXMuZ2V0KGlkKTtcbiAgaWYgKGNvbW1vbkpTTWV0YVByb21pc2UpIHtcbiAgICBpZiAoY29tbW9uSlNNZXRhUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgICBjb21tb25KU01ldGFQcm9taXNlLnJlc29sdmUoY29tbW9uanNNZXRhKTtcbiAgICAgIGNvbW1vbkpTTWV0YVByb21pc2UucmVzb2x2ZSA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbW1vbkpTTWV0YVByb21pc2VzLnNldChpZCwgeyBwcm9taXNlOiBQcm9taXNlLnJlc29sdmUoY29tbW9uanNNZXRhKSwgcmVzb2x2ZTogbnVsbCB9KTtcbiAgfVxufVxuIiwgImltcG9ydCB7IHJlYWRGaWxlU3luYyB9IGZyb20gJ2ZzJztcblxuaW1wb3J0IHsgRFlOQU1JQ19KU09OX1BSRUZJWCwgSEVMUEVSU19JRCB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBnZXRDb21tb25KU01ldGFQcm9taXNlIH0gZnJvbSAnLi9pcy1janMnO1xuaW1wb3J0IHsgZ2V0TmFtZSwgZ2V0VmlydHVhbFBhdGhGb3JEeW5hbWljUmVxdWlyZVBhdGgsIG5vcm1hbGl6ZVBhdGhTbGFzaGVzIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIGUuZy4gaWQgPT09IFwiY29tbW9uanNIZWxwZXJzP2NvbW1vbmpzUmVnaXN0ZXJcIlxuZXhwb3J0IGZ1bmN0aW9uIGdldFNwZWNpZmljSGVscGVyUHJveHkoaWQpIHtcbiAgcmV0dXJuIGBleHBvcnQgeyR7aWQuc3BsaXQoJz8nKVsxXX0gYXMgZGVmYXVsdH0gZnJvbSBcIiR7SEVMUEVSU19JRH1cIjtgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5rbm93blJlcXVpcmVQcm94eShpZCwgcmVxdWlyZVJldHVybnNEZWZhdWx0KSB7XG4gIGlmIChyZXF1aXJlUmV0dXJuc0RlZmF1bHQgPT09IHRydWUgfHwgaWQuZW5kc1dpdGgoJy5qc29uJykpIHtcbiAgICByZXR1cm4gYGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KGlkKX07YDtcbiAgfVxuICBjb25zdCBuYW1lID0gZ2V0TmFtZShpZCk7XG4gIGNvbnN0IGV4cG9ydGVkID1cbiAgICByZXF1aXJlUmV0dXJuc0RlZmF1bHQgPT09ICdhdXRvJ1xuICAgICAgPyBgaW1wb3J0IHtnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWR9IGZyb20gXCIke0hFTFBFUlNfSUR9XCI7IGV4cG9ydCBkZWZhdWx0IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWQoJHtuYW1lfSk7YFxuICAgICAgOiByZXF1aXJlUmV0dXJuc0RlZmF1bHQgPT09ICdwcmVmZXJyZWQnXG4gICAgICA/IGBpbXBvcnQge2dldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50fSBmcm9tIFwiJHtIRUxQRVJTX0lEfVwiOyBleHBvcnQgZGVmYXVsdCAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQoJHtuYW1lfSk7YFxuICAgICAgOiAhcmVxdWlyZVJldHVybnNEZWZhdWx0XG4gICAgICA/IGBpbXBvcnQge2dldEF1Z21lbnRlZE5hbWVzcGFjZX0gZnJvbSBcIiR7SEVMUEVSU19JRH1cIjsgZXhwb3J0IGRlZmF1bHQgLypAX19QVVJFX18qL2dldEF1Z21lbnRlZE5hbWVzcGFjZSgke25hbWV9KTtgXG4gICAgICA6IGBleHBvcnQgZGVmYXVsdCAke25hbWV9O2A7XG4gIHJldHVybiBgaW1wb3J0ICogYXMgJHtuYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoaWQpfTsgJHtleHBvcnRlZH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHluYW1pY0pzb25Qcm94eShpZCwgY29tbW9uRGlyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aFNsYXNoZXMoaWQuc2xpY2UoRFlOQU1JQ19KU09OX1BSRUZJWC5sZW5ndGgpKTtcbiAgcmV0dXJuIGBjb25zdCBjb21tb25qc1JlZ2lzdGVyID0gcmVxdWlyZSgnJHtIRUxQRVJTX0lEfT9jb21tb25qc1JlZ2lzdGVyJyk7XFxuY29tbW9uanNSZWdpc3Rlcigke0pTT04uc3RyaW5naWZ5KFxuICAgIGdldFZpcnR1YWxQYXRoRm9yRHluYW1pY1JlcXVpcmVQYXRoKG5vcm1hbGl6ZWRQYXRoLCBjb21tb25EaXIpXG4gICl9LCBmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRQYXRoKX0pO1xufSk7YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldER5bmFtaWNSZXF1aXJlUHJveHkobm9ybWFsaXplZFBhdGgsIGNvbW1vbkRpcikge1xuICByZXR1cm4gYGNvbnN0IGNvbW1vbmpzUmVnaXN0ZXIgPSByZXF1aXJlKCcke0hFTFBFUlNfSUR9P2NvbW1vbmpzUmVnaXN0ZXInKTtcXG5jb21tb25qc1JlZ2lzdGVyKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgZ2V0VmlydHVhbFBhdGhGb3JEeW5hbWljUmVxdWlyZVBhdGgobm9ybWFsaXplZFBhdGgsIGNvbW1vbkRpcilcbiAgKX0sIGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJHtyZWFkRmlsZVN5bmMobm9ybWFsaXplZFBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KX1cbn0pO2A7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGF0aWNSZXF1aXJlUHJveHkoXG4gIGlkLFxuICByZXF1aXJlUmV0dXJuc0RlZmF1bHQsXG4gIGVzTW9kdWxlc1dpdGhEZWZhdWx0RXhwb3J0LFxuICBlc01vZHVsZXNXaXRoTmFtZWRFeHBvcnRzLFxuICBjb21tb25Kc01ldGFQcm9taXNlc1xuKSB7XG4gIGNvbnN0IG5hbWUgPSBnZXROYW1lKGlkKTtcbiAgY29uc3QgY29tbW9uanNNZXRhID0gYXdhaXQgZ2V0Q29tbW9uSlNNZXRhUHJvbWlzZShjb21tb25Kc01ldGFQcm9taXNlcywgaWQpO1xuICBpZiAoY29tbW9uanNNZXRhICYmIGNvbW1vbmpzTWV0YS5pc0NvbW1vbkpTKSB7XG4gICAgcmV0dXJuIGBleHBvcnQgeyBfX21vZHVsZUV4cG9ydHMgYXMgZGVmYXVsdCB9IGZyb20gJHtKU09OLnN0cmluZ2lmeShpZCl9O2A7XG4gIH0gZWxzZSBpZiAoY29tbW9uanNNZXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFVua25vd25SZXF1aXJlUHJveHkoaWQsIHJlcXVpcmVSZXR1cm5zRGVmYXVsdCk7XG4gIH0gZWxzZSBpZiAoIXJlcXVpcmVSZXR1cm5zRGVmYXVsdCkge1xuICAgIHJldHVybiBgaW1wb3J0IHsgZ2V0QXVnbWVudGVkTmFtZXNwYWNlIH0gZnJvbSBcIiR7SEVMUEVSU19JRH1cIjsgaW1wb3J0ICogYXMgJHtuYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBpZFxuICAgICl9OyBleHBvcnQgZGVmYXVsdCAvKkBfX1BVUkVfXyovZ2V0QXVnbWVudGVkTmFtZXNwYWNlKCR7bmFtZX0pO2A7XG4gIH0gZWxzZSBpZiAoXG4gICAgcmVxdWlyZVJldHVybnNEZWZhdWx0ICE9PSB0cnVlICYmXG4gICAgKHJlcXVpcmVSZXR1cm5zRGVmYXVsdCA9PT0gJ25hbWVzcGFjZScgfHxcbiAgICAgICFlc01vZHVsZXNXaXRoRGVmYXVsdEV4cG9ydC5oYXMoaWQpIHx8XG4gICAgICAocmVxdWlyZVJldHVybnNEZWZhdWx0ID09PSAnYXV0bycgJiYgZXNNb2R1bGVzV2l0aE5hbWVkRXhwb3J0cy5oYXMoaWQpKSlcbiAgKSB7XG4gICAgcmV0dXJuIGBpbXBvcnQgKiBhcyAke25hbWV9IGZyb20gJHtKU09OLnN0cmluZ2lmeShpZCl9OyBleHBvcnQgZGVmYXVsdCAke25hbWV9O2A7XG4gIH1cbiAgcmV0dXJuIGBleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KGlkKX07YDtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tdW5kZWZpbmVkICovXG5cbmltcG9ydCB7IHN0YXRTeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgZGlybmFtZSwgcmVzb2x2ZSwgc2VwIH0gZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7XG4gIERZTkFNSUNfSlNPTl9QUkVGSVgsXG4gIERZTkFNSUNfUEFDS0FHRVNfSUQsXG4gIERZTkFNSUNfUkVHSVNURVJfU1VGRklYLFxuICBFWFBPUlRTX1NVRkZJWCxcbiAgRVhURVJOQUxfU1VGRklYLFxuICBIRUxQRVJTX0lELFxuICBpc1dyYXBwZWRJZCxcbiAgTU9EVUxFX1NVRkZJWCxcbiAgUFJPWFlfU1VGRklYLFxuICBSRVFVSVJFX1NVRkZJWCxcbiAgdW53cmFwSWQsXG4gIHdyYXBJZFxufSBmcm9tICcuL2hlbHBlcnMnO1xuXG5mdW5jdGlvbiBnZXRDYW5kaWRhdGVzRm9yRXh0ZW5zaW9uKHJlc29sdmVkLCBleHRlbnNpb24pIHtcbiAgcmV0dXJuIFtyZXNvbHZlZCArIGV4dGVuc2lvbiwgYCR7cmVzb2x2ZWR9JHtzZXB9aW5kZXgke2V4dGVuc2lvbn1gXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhyZXNvbHZlZCwgZXh0ZW5zaW9ucykge1xuICByZXR1cm4gZXh0ZW5zaW9ucy5yZWR1Y2UoXG4gICAgKHBhdGhzLCBleHRlbnNpb24pID0+IHBhdGhzLmNvbmNhdChnZXRDYW5kaWRhdGVzRm9yRXh0ZW5zaW9uKHJlc29sdmVkLCBleHRlbnNpb24pKSxcbiAgICBbcmVzb2x2ZWRdXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlc29sdmVJZChleHRlbnNpb25zKSB7XG4gIGZ1bmN0aW9uIHJlc29sdmVFeHRlbnNpb25zKGltcG9ydGVlLCBpbXBvcnRlcikge1xuICAgIC8vIG5vdCBvdXIgcHJvYmxlbVxuICAgIGlmIChpbXBvcnRlZVswXSAhPT0gJy4nIHx8ICFpbXBvcnRlcikgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZShkaXJuYW1lKGltcG9ydGVyKSwgaW1wb3J0ZWUpO1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKHJlc29sdmVkLCBleHRlbnNpb25zKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhjYW5kaWRhdGVzW2ldKTtcbiAgICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSByZXR1cm4geyBpZDogY2FuZGlkYXRlc1tpXSB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIG5vb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlc29sdmVJZChpbXBvcnRlZSwgcmF3SW1wb3J0ZXIsIHJlc29sdmVPcHRpb25zKSB7XG4gICAgaWYgKGlzV3JhcHBlZElkKGltcG9ydGVlLCBNT0RVTEVfU1VGRklYKSB8fCBpc1dyYXBwZWRJZChpbXBvcnRlZSwgRVhQT1JUU19TVUZGSVgpKSB7XG4gICAgICByZXR1cm4gaW1wb3J0ZWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW1wb3J0ZXIgPVxuICAgICAgcmF3SW1wb3J0ZXIgJiYgaXNXcmFwcGVkSWQocmF3SW1wb3J0ZXIsIERZTkFNSUNfUkVHSVNURVJfU1VGRklYKVxuICAgICAgICA/IHVud3JhcElkKHJhd0ltcG9ydGVyLCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWClcbiAgICAgICAgOiByYXdJbXBvcnRlcjtcblxuICAgIC8vIEV4Y2VwdCBmb3IgZXhwb3J0cywgcHJveGllcyBhcmUgb25seSBpbXBvcnRpbmcgcmVzb2x2ZWQgaWRzLFxuICAgIC8vIG5vIG5lZWQgdG8gcmVzb2x2ZSBhZ2FpblxuICAgIGlmIChpbXBvcnRlciAmJiBpc1dyYXBwZWRJZChpbXBvcnRlciwgUFJPWFlfU1VGRklYKSkge1xuICAgICAgcmV0dXJuIGltcG9ydGVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzUHJveHlNb2R1bGUgPSBpc1dyYXBwZWRJZChpbXBvcnRlZSwgUFJPWFlfU1VGRklYKTtcbiAgICBjb25zdCBpc1JlcXVpcmVkTW9kdWxlID0gaXNXcmFwcGVkSWQoaW1wb3J0ZWUsIFJFUVVJUkVfU1VGRklYKTtcbiAgICBsZXQgaXNNb2R1bGVSZWdpc3RyYXRpb24gPSBmYWxzZTtcblxuICAgIGlmIChpc1Byb3h5TW9kdWxlKSB7XG4gICAgICBpbXBvcnRlZSA9IHVud3JhcElkKGltcG9ydGVlLCBQUk9YWV9TVUZGSVgpO1xuICAgIH0gZWxzZSBpZiAoaXNSZXF1aXJlZE1vZHVsZSkge1xuICAgICAgaW1wb3J0ZWUgPSB1bndyYXBJZChpbXBvcnRlZSwgUkVRVUlSRV9TVUZGSVgpO1xuXG4gICAgICBpc01vZHVsZVJlZ2lzdHJhdGlvbiA9IGlzV3JhcHBlZElkKGltcG9ydGVlLCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCk7XG4gICAgICBpZiAoaXNNb2R1bGVSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaW1wb3J0ZWUgPSB1bndyYXBJZChpbXBvcnRlZSwgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGltcG9ydGVlLnN0YXJ0c1dpdGgoSEVMUEVSU19JRCkgfHxcbiAgICAgIGltcG9ydGVlID09PSBEWU5BTUlDX1BBQ0tBR0VTX0lEIHx8XG4gICAgICBpbXBvcnRlZS5zdGFydHNXaXRoKERZTkFNSUNfSlNPTl9QUkVGSVgpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaW1wb3J0ZWU7XG4gICAgfVxuXG4gICAgaWYgKGltcG9ydGVlLnN0YXJ0c1dpdGgoJ1xcMCcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFxuICAgICAgaW1wb3J0ZWUsXG4gICAgICBpbXBvcnRlcixcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVPcHRpb25zLCB7XG4gICAgICAgIHNraXBTZWxmOiB0cnVlLFxuICAgICAgICBjdXN0b206IE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVPcHRpb25zLmN1c3RvbSwge1xuICAgICAgICAgICdub2RlLXJlc29sdmUnOiB7IGlzUmVxdWlyZTogaXNQcm94eU1vZHVsZSB8fCBpc1JlcXVpcmVkTW9kdWxlIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgKS50aGVuKChyZXNvbHZlZCkgPT4ge1xuICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVFeHRlbnNpb25zKGltcG9ydGVlLCBpbXBvcnRlcik7XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWQgJiYgaXNQcm94eU1vZHVsZSkge1xuICAgICAgICByZXNvbHZlZC5pZCA9IHdyYXBJZChyZXNvbHZlZC5pZCwgcmVzb2x2ZWQuZXh0ZXJuYWwgPyBFWFRFUk5BTF9TVUZGSVggOiBQUk9YWV9TVUZGSVgpO1xuICAgICAgICByZXNvbHZlZC5leHRlcm5hbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChyZXNvbHZlZCAmJiBpc01vZHVsZVJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZXNvbHZlZC5pZCA9IHdyYXBJZChyZXNvbHZlZC5pZCwgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVgpO1xuICAgICAgfSBlbHNlIGlmICghcmVzb2x2ZWQgJiYgKGlzUHJveHlNb2R1bGUgfHwgaXNSZXF1aXJlZE1vZHVsZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaWQ6IHdyYXBJZChpbXBvcnRlZSwgRVhURVJOQUxfU1VGRklYKSwgZXh0ZXJuYWw6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfSk7XG4gIH07XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGVSb2xsdXBWZXJzaW9uKHJvbGx1cFZlcnNpb24sIHBlZXJEZXBlbmRlbmN5VmVyc2lvbikge1xuICBjb25zdCBbbWFqb3IsIG1pbm9yXSA9IHJvbGx1cFZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgY29uc3QgdmVyc2lvblJlZ2V4cCA9IC9cXF4oXFxkK1xcLlxcZCspXFwuXFxkKy9nO1xuICBsZXQgbWluTWFqb3IgPSBJbmZpbml0eTtcbiAgbGV0IG1pbk1pbm9yID0gSW5maW5pdHk7XG4gIGxldCBmb3VuZFZlcnNpb247XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICB3aGlsZSAoKGZvdW5kVmVyc2lvbiA9IHZlcnNpb25SZWdleHAuZXhlYyhwZWVyRGVwZW5kZW5jeVZlcnNpb24pKSkge1xuICAgIGNvbnN0IFtmb3VuZE1ham9yLCBmb3VuZE1pbm9yXSA9IGZvdW5kVmVyc2lvblsxXS5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICAgIGlmIChmb3VuZE1ham9yIDwgbWluTWFqb3IpIHtcbiAgICAgIG1pbk1ham9yID0gZm91bmRNYWpvcjtcbiAgICAgIG1pbk1pbm9yID0gZm91bmRNaW5vcjtcbiAgICB9XG4gIH1cbiAgaWYgKG1ham9yIDwgbWluTWFqb3IgfHwgKG1ham9yID09PSBtaW5NYWpvciAmJiBtaW5vciA8IG1pbk1pbm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnN1ZmZpY2llbnQgUm9sbHVwIHZlcnNpb246IFwiQHJvbGx1cC9wbHVnaW4tY29tbW9uanNcIiByZXF1aXJlcyBhdCBsZWFzdCByb2xsdXBAJHttaW5NYWpvcn0uJHttaW5NaW5vcn0gYnV0IGZvdW5kIHJvbGx1cEAke3JvbGx1cFZlcnNpb259LmBcbiAgICApO1xuICB9XG59XG4iLCAiZXhwb3J0IHsgZGVmYXVsdCBhcyBpc1JlZmVyZW5jZSB9IGZyb20gJ2lzLXJlZmVyZW5jZSc7XG5cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgJz09JzogKHgpID0+IGVxdWFscyh4LmxlZnQsIHgucmlnaHQsIGZhbHNlKSxcblxuICAnIT0nOiAoeCkgPT4gbm90KG9wZXJhdG9yc1snPT0nXSh4KSksXG5cbiAgJz09PSc6ICh4KSA9PiBlcXVhbHMoeC5sZWZ0LCB4LnJpZ2h0LCB0cnVlKSxcblxuICAnIT09JzogKHgpID0+IG5vdChvcGVyYXRvcnNbJz09PSddKHgpKSxcblxuICAnISc6ICh4KSA9PiBpc0ZhbHN5KHguYXJndW1lbnQpLFxuXG4gICcmJic6ICh4KSA9PiBpc1RydXRoeSh4LmxlZnQpICYmIGlzVHJ1dGh5KHgucmlnaHQpLFxuXG4gICd8fCc6ICh4KSA9PiBpc1RydXRoeSh4LmxlZnQpIHx8IGlzVHJ1dGh5KHgucmlnaHQpXG59O1xuXG5mdW5jdGlvbiBub3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdmFsdWUgOiAhdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiLCBzdHJpY3QpIHtcbiAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSByZXR1cm4gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICBpZiAoYS50eXBlID09PSAnTGl0ZXJhbCcpIHJldHVybiBzdHJpY3QgPyBhLnZhbHVlID09PSBiLnZhbHVlIDogYS52YWx1ZSA9PSBiLnZhbHVlO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1dGh5KG5vZGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgPT09ICdMaXRlcmFsJykgcmV0dXJuICEhbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJykgcmV0dXJuIGlzVHJ1dGh5KG5vZGUuZXhwcmVzc2lvbik7XG4gIGlmIChub2RlLm9wZXJhdG9yIGluIG9wZXJhdG9ycykgcmV0dXJuIG9wZXJhdG9yc1tub2RlLm9wZXJhdG9yXShub2RlKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZhbHN5KG5vZGUpIHtcbiAgcmV0dXJuIG5vdChpc1RydXRoeShub2RlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlwYXRoKG5vZGUpIHtcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICB3aGlsZSAobm9kZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICBpZiAobm9kZS5jb21wdXRlZCkgcmV0dXJuIG51bGw7XG5cbiAgICBwYXJ0cy51bnNoaWZ0KG5vZGUucHJvcGVydHkubmFtZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgbm9kZSA9IG5vZGUub2JqZWN0O1xuICB9XG5cbiAgaWYgKG5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB7IG5hbWUgfSA9IG5vZGU7XG4gIHBhcnRzLnVuc2hpZnQobmFtZSk7XG5cbiAgcmV0dXJuIHsgbmFtZSwga2V5cGF0aDogcGFydHMuam9pbignLicpIH07XG59XG5cbmV4cG9ydCBjb25zdCBLRVlfQ09NUElMRURfRVNNID0gJ19fZXNNb2R1bGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVDb21waWxlZEVzbShub2RlKSB7XG4gIGNvbnN0IGRlZmluZWRQcm9wZXJ0eSA9XG4gICAgZ2V0RGVmaW5lUHJvcGVydHlDYWxsTmFtZShub2RlLCAnZXhwb3J0cycpIHx8IGdldERlZmluZVByb3BlcnR5Q2FsbE5hbWUobm9kZSwgJ21vZHVsZS5leHBvcnRzJyk7XG4gIGlmIChkZWZpbmVkUHJvcGVydHkgJiYgZGVmaW5lZFByb3BlcnR5LmtleSA9PT0gS0VZX0NPTVBJTEVEX0VTTSkge1xuICAgIHJldHVybiBpc1RydXRoeShkZWZpbmVkUHJvcGVydHkudmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmaW5lUHJvcGVydHlDYWxsTmFtZShub2RlLCB0YXJnZXROYW1lKSB7XG4gIGNvbnN0IHtcbiAgICBjYWxsZWU6IHsgb2JqZWN0LCBwcm9wZXJ0eSB9XG4gIH0gPSBub2RlO1xuICBpZiAoIW9iamVjdCB8fCBvYmplY3QudHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8IG9iamVjdC5uYW1lICE9PSAnT2JqZWN0JykgcmV0dXJuO1xuICBpZiAoIXByb3BlcnR5IHx8IHByb3BlcnR5LnR5cGUgIT09ICdJZGVudGlmaWVyJyB8fCBwcm9wZXJ0eS5uYW1lICE9PSAnZGVmaW5lUHJvcGVydHknKSByZXR1cm47XG4gIGlmIChub2RlLmFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHJldHVybjtcblxuICBjb25zdCB0YXJnZXROYW1lcyA9IHRhcmdldE5hbWUuc3BsaXQoJy4nKTtcbiAgY29uc3QgW3RhcmdldCwga2V5LCB2YWx1ZV0gPSBub2RlLmFyZ3VtZW50cztcbiAgaWYgKHRhcmdldE5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0YXJnZXQudHlwZSAhPT0gJ0lkZW50aWZpZXInIHx8IHRhcmdldC5uYW1lICE9PSB0YXJnZXROYW1lc1swXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YXJnZXROYW1lcy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoXG4gICAgICB0YXJnZXQudHlwZSAhPT0gJ01lbWJlckV4cHJlc3Npb24nIHx8XG4gICAgICB0YXJnZXQub2JqZWN0Lm5hbWUgIT09IHRhcmdldE5hbWVzWzBdIHx8XG4gICAgICB0YXJnZXQucHJvcGVydHkubmFtZSAhPT0gdGFyZ2V0TmFtZXNbMV1cbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUudHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nIHx8ICF2YWx1ZS5wcm9wZXJ0aWVzKSByZXR1cm47XG5cbiAgY29uc3QgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlLnByb3BlcnRpZXMuZmluZCgocCkgPT4gcC5rZXkgJiYgcC5rZXkubmFtZSA9PT0gJ3ZhbHVlJyk7XG4gIGlmICghdmFsdWVQcm9wZXJ0eSB8fCAhdmFsdWVQcm9wZXJ0eS52YWx1ZSkgcmV0dXJuO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICByZXR1cm4geyBrZXk6IGtleS52YWx1ZSwgdmFsdWU6IHZhbHVlUHJvcGVydHkudmFsdWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hvcnRoYW5kUHJvcGVydHkocGFyZW50KSB7XG4gIHJldHVybiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdQcm9wZXJ0eScgJiYgcGFyZW50LnNob3J0aGFuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0RlZmluZUVzbVByb3BlcnR5KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5zb21lKChwcm9wZXJ0eSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHByb3BlcnR5LnR5cGUgPT09ICdQcm9wZXJ0eScgJiZcbiAgICAgIHByb3BlcnR5LmtleS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIHByb3BlcnR5LmtleS5uYW1lID09PSAnX19lc01vZHVsZScgJiZcbiAgICAgIGlzVHJ1dGh5KHByb3BlcnR5LnZhbHVlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb2RlKG1hZ2ljU3RyaW5nLCB1c2VzLCBtb2R1bGVOYW1lLCBleHBvcnRzTmFtZSkge1xuICBjb25zdCBhcmdzID0gW107XG4gIGNvbnN0IHBhc3NlZEFyZ3MgPSBbXTtcbiAgaWYgKHVzZXMubW9kdWxlKSB7XG4gICAgYXJncy5wdXNoKCdtb2R1bGUnKTtcbiAgICBwYXNzZWRBcmdzLnB1c2gobW9kdWxlTmFtZSk7XG4gIH1cbiAgaWYgKHVzZXMuZXhwb3J0cykge1xuICAgIGFyZ3MucHVzaCgnZXhwb3J0cycpO1xuICAgIHBhc3NlZEFyZ3MucHVzaChleHBvcnRzTmFtZSk7XG4gIH1cbiAgbWFnaWNTdHJpbmdcbiAgICAudHJpbSgpXG4gICAgLnByZXBlbmQoYChmdW5jdGlvbiAoJHthcmdzLmpvaW4oJywgJyl9KSB7XFxuYClcbiAgICAuYXBwZW5kKGBcXG59KCR7cGFzc2VkQXJncy5qb2luKCcsICcpfSkpO2ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZUV4cG9ydHNBbmRHZXRFeHBvcnRzQmxvY2soXG4gIG1hZ2ljU3RyaW5nLFxuICBtb2R1bGVOYW1lLFxuICBleHBvcnRzTmFtZSxcbiAgd3JhcHBlZCxcbiAgbW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnRzLFxuICBmaXJzdFRvcExldmVsTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQsXG4gIGV4cG9ydHNBc3NpZ25tZW50c0J5TmFtZSxcbiAgdG9wTGV2ZWxBc3NpZ25tZW50cyxcbiAgZGVmaW5lQ29tcGlsZWRFc21FeHByZXNzaW9ucyxcbiAgZGVjb25mbGljdGVkRXhwb3J0TmFtZXMsXG4gIGNvZGUsXG4gIEhFTFBFUlNfTkFNRSxcbiAgZXhwb3J0TW9kZSxcbiAgZGV0ZWN0V3JhcHBlZERlZmF1bHQsXG4gIGRlZmF1bHRJc01vZHVsZUV4cG9ydHNcbikge1xuICBjb25zdCBleHBvcnRzID0gW107XG4gIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9ucyA9IFtdO1xuXG4gIGlmIChleHBvcnRNb2RlID09PSAncmVwbGFjZScpIHtcbiAgICBnZXRFeHBvcnRzRm9yUmVwbGFjZWRNb2R1bGVFeHBvcnRzKFxuICAgICAgbWFnaWNTdHJpbmcsXG4gICAgICBleHBvcnRzLFxuICAgICAgZXhwb3J0RGVjbGFyYXRpb25zLFxuICAgICAgbW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnRzLFxuICAgICAgZmlyc3RUb3BMZXZlbE1vZHVsZUV4cG9ydHNBc3NpZ25tZW50LFxuICAgICAgZXhwb3J0c05hbWVcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMucHVzaChgJHtleHBvcnRzTmFtZX0gYXMgX19tb2R1bGVFeHBvcnRzYCk7XG4gICAgaWYgKHdyYXBwZWQpIHtcbiAgICAgIGdldEV4cG9ydHNXaGVuV3JhcHBpbmcoXG4gICAgICAgIGV4cG9ydERlY2xhcmF0aW9ucyxcbiAgICAgICAgZXhwb3J0c05hbWUsXG4gICAgICAgIGRldGVjdFdyYXBwZWREZWZhdWx0LFxuICAgICAgICBIRUxQRVJTX05BTUUsXG4gICAgICAgIGRlZmF1bHRJc01vZHVsZUV4cG9ydHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldEV4cG9ydHMoXG4gICAgICAgIG1hZ2ljU3RyaW5nLFxuICAgICAgICBleHBvcnRzLFxuICAgICAgICBleHBvcnREZWNsYXJhdGlvbnMsXG4gICAgICAgIG1vZHVsZUV4cG9ydHNBc3NpZ25tZW50cyxcbiAgICAgICAgZXhwb3J0c0Fzc2lnbm1lbnRzQnlOYW1lLFxuICAgICAgICBkZWNvbmZsaWN0ZWRFeHBvcnROYW1lcyxcbiAgICAgICAgdG9wTGV2ZWxBc3NpZ25tZW50cyxcbiAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgZXhwb3J0c05hbWUsXG4gICAgICAgIGRlZmluZUNvbXBpbGVkRXNtRXhwcmVzc2lvbnMsXG4gICAgICAgIEhFTFBFUlNfTkFNRSxcbiAgICAgICAgZGVmYXVsdElzTW9kdWxlRXhwb3J0c1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cG9ydHMubGVuZ3RoKSB7XG4gICAgZXhwb3J0RGVjbGFyYXRpb25zLnB1c2goYGV4cG9ydCB7ICR7ZXhwb3J0cy5qb2luKCcsICcpfSB9O2ApO1xuICB9XG5cbiAgcmV0dXJuIGBcXG5cXG4ke2V4cG9ydERlY2xhcmF0aW9ucy5qb2luKCdcXG4nKX1gO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBvcnRzRm9yUmVwbGFjZWRNb2R1bGVFeHBvcnRzKFxuICBtYWdpY1N0cmluZyxcbiAgZXhwb3J0cyxcbiAgZXhwb3J0RGVjbGFyYXRpb25zLFxuICBtb2R1bGVFeHBvcnRzQXNzaWdubWVudHMsXG4gIGZpcnN0VG9wTGV2ZWxNb2R1bGVFeHBvcnRzQXNzaWdubWVudCxcbiAgZXhwb3J0c05hbWVcbikge1xuICBmb3IgKGNvbnN0IHsgbGVmdCB9IG9mIG1vZHVsZUV4cG9ydHNBc3NpZ25tZW50cykge1xuICAgIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZShsZWZ0LnN0YXJ0LCBsZWZ0LmVuZCwgZXhwb3J0c05hbWUpO1xuICB9XG4gIG1hZ2ljU3RyaW5nLnByZXBlbmRSaWdodChmaXJzdFRvcExldmVsTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQubGVmdC5zdGFydCwgJ3ZhciAnKTtcbiAgZXhwb3J0cy5wdXNoKGAke2V4cG9ydHNOYW1lfSBhcyBfX21vZHVsZUV4cG9ydHNgKTtcbiAgZXhwb3J0RGVjbGFyYXRpb25zLnB1c2goYGV4cG9ydCBkZWZhdWx0ICR7ZXhwb3J0c05hbWV9O2ApO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBvcnRzV2hlbldyYXBwaW5nKFxuICBleHBvcnREZWNsYXJhdGlvbnMsXG4gIGV4cG9ydHNOYW1lLFxuICBkZXRlY3RXcmFwcGVkRGVmYXVsdCxcbiAgSEVMUEVSU19OQU1FLFxuICBkZWZhdWx0SXNNb2R1bGVFeHBvcnRzXG4pIHtcbiAgZXhwb3J0RGVjbGFyYXRpb25zLnB1c2goXG4gICAgYGV4cG9ydCBkZWZhdWx0ICR7XG4gICAgICBkZXRlY3RXcmFwcGVkRGVmYXVsdCAmJiBkZWZhdWx0SXNNb2R1bGVFeHBvcnRzID09PSAnYXV0bydcbiAgICAgICAgPyBgLypAX19QVVJFX18qLyR7SEVMUEVSU19OQU1FfS5nZXREZWZhdWx0RXhwb3J0RnJvbUNqcygke2V4cG9ydHNOYW1lfSlgXG4gICAgICAgIDogZGVmYXVsdElzTW9kdWxlRXhwb3J0cyA9PT0gZmFsc2VcbiAgICAgICAgPyBgJHtleHBvcnRzTmFtZX0uZGVmYXVsdGBcbiAgICAgICAgOiBleHBvcnRzTmFtZVxuICAgIH07YFxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBvcnRzKFxuICBtYWdpY1N0cmluZyxcbiAgZXhwb3J0cyxcbiAgZXhwb3J0RGVjbGFyYXRpb25zLFxuICBtb2R1bGVFeHBvcnRzQXNzaWdubWVudHMsXG4gIGV4cG9ydHNBc3NpZ25tZW50c0J5TmFtZSxcbiAgZGVjb25mbGljdGVkRXhwb3J0TmFtZXMsXG4gIHRvcExldmVsQXNzaWdubWVudHMsXG4gIG1vZHVsZU5hbWUsXG4gIGV4cG9ydHNOYW1lLFxuICBkZWZpbmVDb21waWxlZEVzbUV4cHJlc3Npb25zLFxuICBIRUxQRVJTX05BTUUsXG4gIGRlZmF1bHRJc01vZHVsZUV4cG9ydHNcbikge1xuICBsZXQgZGVjb25mbGljdGVkRGVmYXVsdEV4cG9ydE5hbWU7XG4gIC8vIENvbGxlY3QgYW5kIHJld3JpdGUgbW9kdWxlLmV4cG9ydHMgYXNzaWdubWVudHNcbiAgZm9yIChjb25zdCB7IGxlZnQgfSBvZiBtb2R1bGVFeHBvcnRzQXNzaWdubWVudHMpIHtcbiAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUobGVmdC5zdGFydCwgbGVmdC5lbmQsIGAke21vZHVsZU5hbWV9LmV4cG9ydHNgKTtcbiAgfVxuXG4gIC8vIENvbGxlY3QgYW5kIHJld3JpdGUgbmFtZWQgZXhwb3J0c1xuICBmb3IgKGNvbnN0IFtleHBvcnROYW1lLCB7IG5vZGVzIH1dIG9mIGV4cG9ydHNBc3NpZ25tZW50c0J5TmFtZSkge1xuICAgIGNvbnN0IGRlY29uZmxpY3RlZCA9IGRlY29uZmxpY3RlZEV4cG9ydE5hbWVzW2V4cG9ydE5hbWVdO1xuICAgIGxldCBuZWVkc0RlY2xhcmF0aW9uID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGxldCByZXBsYWNlbWVudCA9IGAke2RlY29uZmxpY3RlZH0gPSAke2V4cG9ydHNOYW1lfS4ke2V4cG9ydE5hbWV9YDtcbiAgICAgIGlmIChuZWVkc0RlY2xhcmF0aW9uICYmIHRvcExldmVsQXNzaWdubWVudHMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gYHZhciAke3JlcGxhY2VtZW50fWA7XG4gICAgICAgIG5lZWRzRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZShub2RlLnN0YXJ0LCBub2RlLmxlZnQuZW5kLCByZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGlmIChuZWVkc0RlY2xhcmF0aW9uKSB7XG4gICAgICBtYWdpY1N0cmluZy5wcmVwZW5kKGB2YXIgJHtkZWNvbmZsaWN0ZWR9O1xcbmApO1xuICAgIH1cblxuICAgIGlmIChleHBvcnROYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIGRlY29uZmxpY3RlZERlZmF1bHRFeHBvcnROYW1lID0gZGVjb25mbGljdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnB1c2goZXhwb3J0TmFtZSA9PT0gZGVjb25mbGljdGVkID8gZXhwb3J0TmFtZSA6IGAke2RlY29uZmxpY3RlZH0gYXMgJHtleHBvcnROYW1lfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbGxlY3QgYW5kIHJld3JpdGUgZXhwb3J0cy5fX2VzTW9kdWxlIGFzc2lnbm1lbnRzXG4gIGxldCBpc1Jlc3RvcmFibGVDb21waWxlZEVzbSA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgZGVmaW5lQ29tcGlsZWRFc21FeHByZXNzaW9ucykge1xuICAgIGlzUmVzdG9yYWJsZUNvbXBpbGVkRXNtID0gdHJ1ZTtcbiAgICBjb25zdCBtb2R1bGVFeHBvcnRzRXhwcmVzc2lvbiA9XG4gICAgICBleHByZXNzaW9uLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicgPyBleHByZXNzaW9uLmFyZ3VtZW50c1swXSA6IGV4cHJlc3Npb24ubGVmdC5vYmplY3Q7XG4gICAgbWFnaWNTdHJpbmcub3ZlcndyaXRlKG1vZHVsZUV4cG9ydHNFeHByZXNzaW9uLnN0YXJ0LCBtb2R1bGVFeHBvcnRzRXhwcmVzc2lvbi5lbmQsIGV4cG9ydHNOYW1lKTtcbiAgfVxuXG4gIGlmICghaXNSZXN0b3JhYmxlQ29tcGlsZWRFc20gfHwgZGVmYXVsdElzTW9kdWxlRXhwb3J0cyA9PT0gdHJ1ZSkge1xuICAgIGV4cG9ydERlY2xhcmF0aW9ucy5wdXNoKGBleHBvcnQgZGVmYXVsdCAke2V4cG9ydHNOYW1lfTtgKTtcbiAgfSBlbHNlIGlmIChtb2R1bGVFeHBvcnRzQXNzaWdubWVudHMubGVuZ3RoID09PSAwIHx8IGRlZmF1bHRJc01vZHVsZUV4cG9ydHMgPT09IGZhbHNlKSB7XG4gICAgZXhwb3J0cy5wdXNoKGAke2RlY29uZmxpY3RlZERlZmF1bHRFeHBvcnROYW1lIHx8IGV4cG9ydHNOYW1lfSBhcyBkZWZhdWx0YCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0RGVjbGFyYXRpb25zLnB1c2goXG4gICAgICBgZXhwb3J0IGRlZmF1bHQgLypAX19QVVJFX18qLyR7SEVMUEVSU19OQU1FfS5nZXREZWZhdWx0RXhwb3J0RnJvbUNqcygke2V4cG9ydHNOYW1lfSk7YFxuICAgICk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkaXJuYW1lLCByZXNvbHZlIH0gZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IHN5bmMgYXMgbm9kZVJlc29sdmVTeW5jIH0gZnJvbSAncmVzb2x2ZSc7XG5cbmltcG9ydCB7XG4gIEVYUE9SVFNfU1VGRklYLFxuICBIRUxQRVJTX0lELFxuICBNT0RVTEVfU1VGRklYLFxuICBQUk9YWV9TVUZGSVgsXG4gIFJFUVVJUkVfU1VGRklYLFxuICB3cmFwSWRcbn0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGhTbGFzaGVzIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlcXVpcmVTdGF0ZW1lbnQobm9kZSwgc2NvcGUpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHJldHVybiBmYWxzZTtcblxuICAvLyBXZWlyZCBjYXNlIG9mIGByZXF1aXJlKClgIG9yIGBtb2R1bGUucmVxdWlyZSgpYCB3aXRob3V0IGFyZ3VtZW50c1xuICBpZiAobm9kZS5hcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGlzUmVxdWlyZShub2RlLmNhbGxlZSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVpcmUobm9kZSwgc2NvcGUpIHtcbiAgcmV0dXJuIChcbiAgICAobm9kZS50eXBlID09PSAnSWRlbnRpZmllcicgJiYgbm9kZS5uYW1lID09PSAncmVxdWlyZScgJiYgIXNjb3BlLmNvbnRhaW5zKCdyZXF1aXJlJykpIHx8XG4gICAgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIGlzTW9kdWxlUmVxdWlyZShub2RlLCBzY29wZSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01vZHVsZVJlcXVpcmUoeyBvYmplY3QsIHByb3BlcnR5IH0sIHNjb3BlKSB7XG4gIHJldHVybiAoXG4gICAgb2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgIG9iamVjdC5uYW1lID09PSAnbW9kdWxlJyAmJlxuICAgIHByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgIHByb3BlcnR5Lm5hbWUgPT09ICdyZXF1aXJlJyAmJlxuICAgICFzY29wZS5jb250YWlucygnbW9kdWxlJylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhdGljUmVxdWlyZVN0YXRlbWVudChub2RlLCBzY29wZSkge1xuICBpZiAoIWlzUmVxdWlyZVN0YXRlbWVudChub2RlLCBzY29wZSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICFoYXNEeW5hbWljQXJndW1lbnRzKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBoYXNEeW5hbWljQXJndW1lbnRzKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAxIHx8XG4gICAgKG5vZGUuYXJndW1lbnRzWzBdLnR5cGUgIT09ICdMaXRlcmFsJyAmJlxuICAgICAgKG5vZGUuYXJndW1lbnRzWzBdLnR5cGUgIT09ICdUZW1wbGF0ZUxpdGVyYWwnIHx8IG5vZGUuYXJndW1lbnRzWzBdLmV4cHJlc3Npb25zLmxlbmd0aCA+IDApKVxuICApO1xufVxuXG5jb25zdCByZXNlcnZlZE1ldGhvZCA9IHsgcmVzb2x2ZTogdHJ1ZSwgY2FjaGU6IHRydWUsIG1haW46IHRydWUgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVJlcXVpcmVQcm9wZXJ0eUFjY2VzcyhwYXJlbnQpIHtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQucHJvcGVydHkgJiYgcmVzZXJ2ZWRNZXRob2RbcGFyZW50LnByb3BlcnR5Lm5hbWVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJZ25vcmVkUmVxdWlyZVN0YXRlbWVudChyZXF1aXJlZE5vZGUsIGlnbm9yZVJlcXVpcmUpIHtcbiAgcmV0dXJuIGlnbm9yZVJlcXVpcmUocmVxdWlyZWROb2RlLmFyZ3VtZW50c1swXS52YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1aXJlU3RyaW5nQXJnKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuYXJndW1lbnRzWzBdLnR5cGUgPT09ICdMaXRlcmFsJ1xuICAgID8gbm9kZS5hcmd1bWVudHNbMF0udmFsdWVcbiAgICA6IG5vZGUuYXJndW1lbnRzWzBdLnF1YXNpc1swXS52YWx1ZS5jb29rZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNEeW5hbWljTW9kdWxlRm9yUGF0aChzb3VyY2UsIGlkLCBkeW5hbWljUmVxdWlyZU1vZHVsZVNldCkge1xuICBpZiAoIS9eKD86XFwuezAsMn1bL1xcXFxdfFtBLVphLXpdOlsvXFxcXF0pLy50ZXN0KHNvdXJjZSkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplUGF0aFNsYXNoZXMobm9kZVJlc29sdmVTeW5jKHNvdXJjZSwgeyBiYXNlZGlyOiBkaXJuYW1lKGlkKSB9KSk7XG4gICAgICBpZiAoZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQuaGFzKHJlc29sdmVkUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIC8vIFByb2JhYmx5IGEgbm9kZS5qcyBpbnRlcm5hbCBtb2R1bGVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGF0dGVtcHRFeHQgb2YgWycnLCAnLmpzJywgJy5qc29uJ10pIHtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSBub3JtYWxpemVQYXRoU2xhc2hlcyhyZXNvbHZlKGRpcm5hbWUoaWQpLCBzb3VyY2UgKyBhdHRlbXB0RXh0KSk7XG4gICAgaWYgKGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0LmhhcyhyZXNvbHZlZFBhdGgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1aXJlSGFuZGxlcnMoKSB7XG4gIGNvbnN0IHJlcXVpcmVkU291cmNlcyA9IFtdO1xuICBjb25zdCByZXF1aXJlZEJ5U291cmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgcmVxdWlyZWRCeU5vZGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlcXVpcmVFeHByZXNzaW9uc1dpdGhVc2VkUmV0dXJuVmFsdWUgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRSZXF1aXJlU3RhdGVtZW50KHNvdXJjZUlkLCBub2RlLCBzY29wZSwgdXNlc1JldHVyblZhbHVlKSB7XG4gICAgY29uc3QgcmVxdWlyZWQgPSBnZXRSZXF1aXJlZChzb3VyY2VJZCk7XG4gICAgcmVxdWlyZWRCeU5vZGUuc2V0KG5vZGUsIHsgc2NvcGUsIHJlcXVpcmVkIH0pO1xuICAgIGlmICh1c2VzUmV0dXJuVmFsdWUpIHtcbiAgICAgIHJlcXVpcmVkLm5vZGVzVXNpbmdSZXF1aXJlZC5wdXNoKG5vZGUpO1xuICAgICAgcmVxdWlyZUV4cHJlc3Npb25zV2l0aFVzZWRSZXR1cm5WYWx1ZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcXVpcmVkKHNvdXJjZUlkKSB7XG4gICAgaWYgKCFyZXF1aXJlZEJ5U291cmNlW3NvdXJjZUlkXSkge1xuICAgICAgcmVxdWlyZWRTb3VyY2VzLnB1c2goc291cmNlSWQpO1xuXG4gICAgICByZXF1aXJlZEJ5U291cmNlW3NvdXJjZUlkXSA9IHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VJZCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgbm9kZXNVc2luZ1JlcXVpcmVkOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWlyZWRCeVNvdXJjZVtzb3VyY2VJZF07XG4gIH1cblxuICBmdW5jdGlvbiByZXdyaXRlUmVxdWlyZUV4cHJlc3Npb25zQW5kR2V0SW1wb3J0QmxvY2soXG4gICAgbWFnaWNTdHJpbmcsXG4gICAgdG9wTGV2ZWxEZWNsYXJhdGlvbnMsXG4gICAgdG9wTGV2ZWxSZXF1aXJlRGVjbGFyYXRvcnMsXG4gICAgcmVhc3NpZ25lZE5hbWVzLFxuICAgIGhlbHBlcnNOYW1lLFxuICAgIGR5bmFtaWNSZWdpc3RlclNvdXJjZXMsXG4gICAgbW9kdWxlTmFtZSxcbiAgICBleHBvcnRzTmFtZSxcbiAgICBpZCxcbiAgICBleHBvcnRNb2RlXG4gICkge1xuICAgIHNldFJlbWFpbmluZ0ltcG9ydE5hbWVzQW5kUmV3cml0ZVJlcXVpcmVzKFxuICAgICAgcmVxdWlyZUV4cHJlc3Npb25zV2l0aFVzZWRSZXR1cm5WYWx1ZSxcbiAgICAgIHJlcXVpcmVkQnlOb2RlLFxuICAgICAgbWFnaWNTdHJpbmdcbiAgICApO1xuICAgIGNvbnN0IGltcG9ydHMgPSBbXTtcbiAgICBpbXBvcnRzLnB1c2goYGltcG9ydCAqIGFzICR7aGVscGVyc05hbWV9IGZyb20gXCIke0hFTFBFUlNfSUR9XCI7YCk7XG4gICAgaWYgKGV4cG9ydE1vZGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICBpbXBvcnRzLnB1c2goXG4gICAgICAgIGBpbXBvcnQgeyBfX21vZHVsZSBhcyAke21vZHVsZU5hbWV9LCBleHBvcnRzIGFzICR7ZXhwb3J0c05hbWV9IH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHdyYXBJZChpZCwgTU9EVUxFX1NVRkZJWClcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0TW9kZSA9PT0gJ2V4cG9ydHMnKSB7XG4gICAgICBpbXBvcnRzLnB1c2goXG4gICAgICAgIGBpbXBvcnQgeyBfX2V4cG9ydHMgYXMgJHtleHBvcnRzTmFtZX0gfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkod3JhcElkKGlkLCBFWFBPUlRTX1NVRkZJWCkpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGR5bmFtaWNSZWdpc3RlclNvdXJjZXMpIHtcbiAgICAgIGltcG9ydHMucHVzaChgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkod3JhcElkKHNvdXJjZSwgUkVRVUlSRV9TVUZGSVgpKX07YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHJlcXVpcmVkU291cmNlcykge1xuICAgICAgaWYgKCFzb3VyY2Uuc3RhcnRzV2l0aCgnXFwwJykpIHtcbiAgICAgICAgaW1wb3J0cy5wdXNoKGBpbXBvcnQgJHtKU09OLnN0cmluZ2lmeSh3cmFwSWQoc291cmNlLCBSRVFVSVJFX1NVRkZJWCkpfTtgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbmFtZSwgbm9kZXNVc2luZ1JlcXVpcmVkIH0gPSByZXF1aXJlZEJ5U291cmNlW3NvdXJjZV07XG4gICAgICBpbXBvcnRzLnB1c2goXG4gICAgICAgIGBpbXBvcnQgJHtub2Rlc1VzaW5nUmVxdWlyZWQubGVuZ3RoID8gYCR7bmFtZX0gZnJvbSBgIDogJyd9JHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzb3VyY2Uuc3RhcnRzV2l0aCgnXFwwJykgPyBzb3VyY2UgOiB3cmFwSWQoc291cmNlLCBQUk9YWV9TVUZGSVgpXG4gICAgICAgICl9O2BcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRzLmxlbmd0aCA/IGAke2ltcG9ydHMuam9pbignXFxuJyl9XFxuXFxuYCA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZGRSZXF1aXJlU3RhdGVtZW50LFxuICAgIHJlcXVpcmVkU291cmNlcyxcbiAgICByZXdyaXRlUmVxdWlyZUV4cHJlc3Npb25zQW5kR2V0SW1wb3J0QmxvY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0UmVtYWluaW5nSW1wb3J0TmFtZXNBbmRSZXdyaXRlUmVxdWlyZXMoXG4gIHJlcXVpcmVFeHByZXNzaW9uc1dpdGhVc2VkUmV0dXJuVmFsdWUsXG4gIHJlcXVpcmVkQnlOb2RlLFxuICBtYWdpY1N0cmluZ1xuKSB7XG4gIGxldCB1aWQgPSAwO1xuICBmb3IgKGNvbnN0IHJlcXVpcmVFeHByZXNzaW9uIG9mIHJlcXVpcmVFeHByZXNzaW9uc1dpdGhVc2VkUmV0dXJuVmFsdWUpIHtcbiAgICBjb25zdCB7IHJlcXVpcmVkIH0gPSByZXF1aXJlZEJ5Tm9kZS5nZXQocmVxdWlyZUV4cHJlc3Npb24pO1xuICAgIGlmICghcmVxdWlyZWQubmFtZSkge1xuICAgICAgbGV0IHBvdGVudGlhbE5hbWU7XG4gICAgICBjb25zdCBpc1VzZWROYW1lID0gKG5vZGUpID0+IHJlcXVpcmVkQnlOb2RlLmdldChub2RlKS5zY29wZS5jb250YWlucyhwb3RlbnRpYWxOYW1lKTtcbiAgICAgIGRvIHtcbiAgICAgICAgcG90ZW50aWFsTmFtZSA9IGByZXF1aXJlJCQke3VpZH1gO1xuICAgICAgICB1aWQgKz0gMTtcbiAgICAgIH0gd2hpbGUgKHJlcXVpcmVkLm5vZGVzVXNpbmdSZXF1aXJlZC5zb21lKGlzVXNlZE5hbWUpKTtcbiAgICAgIHJlcXVpcmVkLm5hbWUgPSBwb3RlbnRpYWxOYW1lO1xuICAgIH1cbiAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUocmVxdWlyZUV4cHJlc3Npb24uc3RhcnQsIHJlcXVpcmVFeHByZXNzaW9uLmVuZCwgcmVxdWlyZWQubmFtZSk7XG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tc2hhZG93LCBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tY29udGludWUgKi9cblxuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBhdHRhY2hTY29wZXMsIGV4dHJhY3RBc3NpZ25lZE5hbWVzIH0gZnJvbSAnQHJvbGx1cC9wbHVnaW51dGlscyc7XG5pbXBvcnQgeyB3YWxrIH0gZnJvbSAnZXN0cmVlLXdhbGtlcic7XG5pbXBvcnQgTWFnaWNTdHJpbmcgZnJvbSAnbWFnaWMtc3RyaW5nJztcblxuaW1wb3J0IHtcbiAgZ2V0S2V5cGF0aCxcbiAgaXNEZWZpbmVDb21waWxlZEVzbSxcbiAgaGFzRGVmaW5lRXNtUHJvcGVydHksXG4gIGlzRmFsc3ksXG4gIGlzUmVmZXJlbmNlLFxuICBpc1Nob3J0aGFuZFByb3BlcnR5LFxuICBpc1RydXRoeSxcbiAgS0VZX0NPTVBJTEVEX0VTTVxufSBmcm9tICcuL2FzdC11dGlscyc7XG5pbXBvcnQgeyByZXdyaXRlRXhwb3J0c0FuZEdldEV4cG9ydHNCbG9jaywgd3JhcENvZGUgfSBmcm9tICcuL2dlbmVyYXRlLWV4cG9ydHMnO1xuaW1wb3J0IHtcbiAgZ2V0UmVxdWlyZUhhbmRsZXJzLFxuICBnZXRSZXF1aXJlU3RyaW5nQXJnLFxuICBoYXNEeW5hbWljTW9kdWxlRm9yUGF0aCxcbiAgaXNJZ25vcmVkUmVxdWlyZVN0YXRlbWVudCxcbiAgaXNNb2R1bGVSZXF1aXJlLFxuICBpc05vZGVSZXF1aXJlUHJvcGVydHlBY2Nlc3MsXG4gIGlzUmVxdWlyZVN0YXRlbWVudCxcbiAgaXNTdGF0aWNSZXF1aXJlU3RhdGVtZW50XG59IGZyb20gJy4vZ2VuZXJhdGUtaW1wb3J0cyc7XG5pbXBvcnQge1xuICBEWU5BTUlDX0pTT05fUFJFRklYLFxuICBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCxcbiAgaXNXcmFwcGVkSWQsXG4gIHVud3JhcElkLFxuICB3cmFwSWRcbn0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHRyeVBhcnNlIH0gZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQgeyBkZWNvbmZsaWN0LCBnZXROYW1lLCBnZXRWaXJ0dWFsUGF0aEZvckR5bmFtaWNSZXF1aXJlUGF0aCB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBleHBvcnRzUGF0dGVybiA9IC9eKD86bW9kdWxlXFwuKT9leHBvcnRzKD86XFwuKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikpPyQvO1xuXG5jb25zdCBmdW5jdGlvblR5cGUgPSAvXig/OkZ1bmN0aW9uRGVjbGFyYXRpb258RnVuY3Rpb25FeHByZXNzaW9ufEFycm93RnVuY3Rpb25FeHByZXNzaW9uKSQvO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1Db21tb25qcyhcbiAgcGFyc2UsXG4gIGNvZGUsXG4gIGlkLFxuICBpc0VzTW9kdWxlLFxuICBpZ25vcmVHbG9iYWwsXG4gIGlnbm9yZVJlcXVpcmUsXG4gIGlnbm9yZUR5bmFtaWNSZXF1aXJlcyxcbiAgZ2V0SWdub3JlVHJ5Q2F0Y2hSZXF1aXJlU3RhdGVtZW50TW9kZSxcbiAgc291cmNlTWFwLFxuICBpc0R5bmFtaWNSZXF1aXJlTW9kdWxlc0VuYWJsZWQsXG4gIGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0LFxuICBkaXNhYmxlV3JhcCxcbiAgY29tbW9uRGlyLFxuICBhc3RDYWNoZSxcbiAgZGVmYXVsdElzTW9kdWxlRXhwb3J0c1xuKSB7XG4gIGNvbnN0IGFzdCA9IGFzdENhY2hlIHx8IHRyeVBhcnNlKHBhcnNlLCBjb2RlLCBpZCk7XG4gIGNvbnN0IG1hZ2ljU3RyaW5nID0gbmV3IE1hZ2ljU3RyaW5nKGNvZGUpO1xuICBjb25zdCB1c2VzID0ge1xuICAgIG1vZHVsZTogZmFsc2UsXG4gICAgZXhwb3J0czogZmFsc2UsXG4gICAgZ2xvYmFsOiBmYWxzZSxcbiAgICByZXF1aXJlOiBmYWxzZVxuICB9O1xuICBsZXQgdXNlc0R5bmFtaWNSZXF1aXJlID0gZmFsc2U7XG4gIGNvbnN0IHZpcnR1YWxEeW5hbWljUmVxdWlyZVBhdGggPVxuICAgIGlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCAmJiBnZXRWaXJ0dWFsUGF0aEZvckR5bmFtaWNSZXF1aXJlUGF0aChkaXJuYW1lKGlkKSwgY29tbW9uRGlyKTtcbiAgbGV0IHNjb3BlID0gYXR0YWNoU2NvcGVzKGFzdCwgJ3Njb3BlJyk7XG4gIGxldCBsZXhpY2FsRGVwdGggPSAwO1xuICBsZXQgcHJvZ3JhbURlcHRoID0gMDtcbiAgbGV0IGN1cnJlbnRUcnlCbG9ja0VuZCA9IG51bGw7XG4gIGxldCBzaG91bGRXcmFwID0gZmFsc2U7XG5cbiAgY29uc3QgZ2xvYmFscyA9IG5ldyBTZXQoKTtcblxuICAvLyBUT0RPIHRlY2huaWNhbGx5IHdyb25nIHNpbmNlIGdsb2JhbHMgaXNuJ3QgcG9wdWxhdGVkIHlldCwgYnV0IMKvXFxfKOODhClfL8KvXG4gIGNvbnN0IEhFTFBFUlNfTkFNRSA9IGRlY29uZmxpY3QoW3Njb3BlXSwgZ2xvYmFscywgJ2NvbW1vbmpzSGVscGVycycpO1xuICBjb25zdCBkeW5hbWljUmVnaXN0ZXJTb3VyY2VzID0gbmV3IFNldCgpO1xuICBsZXQgaGFzUmVtb3ZlZFJlcXVpcmUgPSBmYWxzZTtcblxuICBjb25zdCB7XG4gICAgYWRkUmVxdWlyZVN0YXRlbWVudCxcbiAgICByZXF1aXJlZFNvdXJjZXMsXG4gICAgcmV3cml0ZVJlcXVpcmVFeHByZXNzaW9uc0FuZEdldEltcG9ydEJsb2NrXG4gIH0gPSBnZXRSZXF1aXJlSGFuZGxlcnMoKTtcblxuICAvLyBTZWUgd2hpY2ggbmFtZXMgYXJlIGFzc2lnbmVkIHRvLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50XG4gIC8vIGlsbGVnYWxseSByZXBsYWNpbmcgYHZhciBmb28gPSByZXF1aXJlKCdmb28nKWAgd2l0aCBgaW1wb3J0IGZvbyBmcm9tICdmb28nYCxcbiAgLy8gd2hlcmUgYGZvb2AgaXMgbGF0ZXIgcmVhc3NpZ25lZC4gKFRoaXMgaGFwcGVucyBpbiB0aGUgd2lsZC4gQ29tbW9uSlMsIHNpZ2gpXG4gIGNvbnN0IHJlYXNzaWduZWROYW1lcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdG9wTGV2ZWxEZWNsYXJhdGlvbnMgPSBbXTtcbiAgY29uc3QgdG9wTGV2ZWxSZXF1aXJlRGVjbGFyYXRvcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHNraXBwZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgbW9kdWxlQWNjZXNzU2NvcGVzID0gbmV3IFNldChbc2NvcGVdKTtcbiAgY29uc3QgZXhwb3J0c0FjY2Vzc1Njb3BlcyA9IG5ldyBTZXQoW3Njb3BlXSk7XG4gIGNvbnN0IG1vZHVsZUV4cG9ydHNBc3NpZ25tZW50cyA9IFtdO1xuICBsZXQgZmlyc3RUb3BMZXZlbE1vZHVsZUV4cG9ydHNBc3NpZ25tZW50ID0gbnVsbDtcbiAgY29uc3QgZXhwb3J0c0Fzc2lnbm1lbnRzQnlOYW1lID0gbmV3IE1hcCgpO1xuICBjb25zdCB0b3BMZXZlbEFzc2lnbm1lbnRzID0gbmV3IFNldCgpO1xuICBjb25zdCB0b3BMZXZlbERlZmluZUNvbXBpbGVkRXNtRXhwcmVzc2lvbnMgPSBbXTtcblxuICB3YWxrKGFzdCwge1xuICAgIGVudGVyKG5vZGUsIHBhcmVudCkge1xuICAgICAgaWYgKHNraXBwZWROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRUcnlCbG9ja0VuZCAhPT0gbnVsbCAmJiBub2RlLnN0YXJ0ID4gY3VycmVudFRyeUJsb2NrRW5kKSB7XG4gICAgICAgIGN1cnJlbnRUcnlCbG9ja0VuZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHByb2dyYW1EZXB0aCArPSAxO1xuICAgICAgaWYgKG5vZGUuc2NvcGUpICh7IHNjb3BlIH0gPSBub2RlKTtcbiAgICAgIGlmIChmdW5jdGlvblR5cGUudGVzdChub2RlLnR5cGUpKSBsZXhpY2FsRGVwdGggKz0gMTtcbiAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgbWFnaWNTdHJpbmcuYWRkU291cmNlbWFwTG9jYXRpb24obm9kZS5zdGFydCk7XG4gICAgICAgIG1hZ2ljU3RyaW5nLmFkZFNvdXJjZW1hcExvY2F0aW9uKG5vZGUuZW5kKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgICAgICBpZiAoY3VycmVudFRyeUJsb2NrRW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJ5QmxvY2tFbmQgPSBub2RlLmJsb2NrLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGdldEtleXBhdGgobm9kZS5sZWZ0KTtcbiAgICAgICAgICAgIGlmICghZmxhdHRlbmVkIHx8IHNjb3BlLmNvbnRhaW5zKGZsYXR0ZW5lZC5uYW1lKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBleHBvcnRzUGF0dGVybk1hdGNoID0gZXhwb3J0c1BhdHRlcm4uZXhlYyhmbGF0dGVuZWQua2V5cGF0aCk7XG4gICAgICAgICAgICBpZiAoIWV4cG9ydHNQYXR0ZXJuTWF0Y2ggfHwgZmxhdHRlbmVkLmtleXBhdGggPT09ICdleHBvcnRzJykgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBbLCBleHBvcnROYW1lXSA9IGV4cG9ydHNQYXR0ZXJuTWF0Y2g7XG4gICAgICAgICAgICB1c2VzW2ZsYXR0ZW5lZC5uYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlYWxpbmcgd2l0aCBgbW9kdWxlLmV4cG9ydHMgPSAuLi5gIG9yIGBbbW9kdWxlLl1leHBvcnRzLmZvbyA9IC4uLmAg4oCTXG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkLmtleXBhdGggPT09ICdtb2R1bGUuZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIGlmIChwcm9ncmFtRGVwdGggPiAzKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQWNjZXNzU2NvcGVzLmFkZChzY29wZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpcnN0VG9wTGV2ZWxNb2R1bGVFeHBvcnRzQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZpcnN0VG9wTGV2ZWxNb2R1bGVFeHBvcnRzQXNzaWdubWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGVmYXVsdElzTW9kdWxlRXhwb3J0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0SXNNb2R1bGVFeHBvcnRzID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yaWdodC50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNEZWZpbmVFc21Qcm9wZXJ0eShub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRJc01vZHVsZUV4cG9ydHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0TmFtZSA9PT0gS0VZX0NPTVBJTEVEX0VTTSkge1xuICAgICAgICAgICAgICBpZiAocHJvZ3JhbURlcHRoID4gMykge1xuICAgICAgICAgICAgICAgIHNob3VsZFdyYXAgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcExldmVsRGVmaW5lQ29tcGlsZWRFc21FeHByZXNzaW9ucy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBleHBvcnRzQXNzaWdubWVudHMgPSBleHBvcnRzQXNzaWdubWVudHNCeU5hbWUuZ2V0KGV4cG9ydE5hbWUpIHx8IHtcbiAgICAgICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICAgICAgc2NvcGVzOiBuZXcgU2V0KClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZXhwb3J0c0Fzc2lnbm1lbnRzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIGV4cG9ydHNBc3NpZ25tZW50cy5zY29wZXMuYWRkKHNjb3BlKTtcbiAgICAgICAgICAgICAgZXhwb3J0c0FjY2Vzc1Njb3Blcy5hZGQoc2NvcGUpO1xuICAgICAgICAgICAgICBleHBvcnRzQXNzaWdubWVudHNCeU5hbWUuc2V0KGV4cG9ydE5hbWUsIGV4cG9ydHNBc3NpZ25tZW50cyk7XG4gICAgICAgICAgICAgIGlmIChwcm9ncmFtRGVwdGggPD0gMykge1xuICAgICAgICAgICAgICAgIHRvcExldmVsQXNzaWdubWVudHMuYWRkKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNraXBwZWROb2Rlcy5hZGQobm9kZS5sZWZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGV4dHJhY3RBc3NpZ25lZE5hbWVzKG5vZGUubGVmdCkpIHtcbiAgICAgICAgICAgICAgcmVhc3NpZ25lZE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6IHtcbiAgICAgICAgICBpZiAoaXNEZWZpbmVDb21waWxlZEVzbShub2RlKSkge1xuICAgICAgICAgICAgaWYgKHByb2dyYW1EZXB0aCA9PT0gMyAmJiBwYXJlbnQudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgc3BlY2lhbCBoYW5kbGluZyBmb3IgW21vZHVsZS5dZXhwb3J0cyB1bnRpbCB3ZSBrbm93IHdlIHJlbmRlciB0aGlzXG4gICAgICAgICAgICAgIHNraXBwZWROb2Rlcy5hZGQobm9kZS5hcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgICB0b3BMZXZlbERlZmluZUNvbXBpbGVkRXNtRXhwcmVzc2lvbnMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNob3VsZFdyYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUuY2FsbGVlLm9iamVjdCAmJlxuICAgICAgICAgICAgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdyZXF1aXJlJyAmJlxuICAgICAgICAgICAgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ3Jlc29sdmUnICYmXG4gICAgICAgICAgICBoYXNEeW5hbWljTW9kdWxlRm9yUGF0aChpZCwgJy8nLCBkeW5hbWljUmVxdWlyZU1vZHVsZVNldClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVOb2RlID0gbm9kZS5jYWxsZWUub2JqZWN0O1xuICAgICAgICAgICAgbWFnaWNTdHJpbmcuYXBwZW5kTGVmdChcbiAgICAgICAgICAgICAgbm9kZS5lbmQgLSAxLFxuICAgICAgICAgICAgICBgLCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgZGlybmFtZShpZCkgPT09ICcuJyA/IG51bGwgLyogZGVmYXVsdCBiZWhhdmlvciAqLyA6IHZpcnR1YWxEeW5hbWljUmVxdWlyZVBhdGhcbiAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFnaWNTdHJpbmcub3ZlcndyaXRlKFxuICAgICAgICAgICAgICByZXF1aXJlTm9kZS5zdGFydCxcbiAgICAgICAgICAgICAgcmVxdWlyZU5vZGUuZW5kLFxuICAgICAgICAgICAgICBgJHtIRUxQRVJTX05BTUV9LmNvbW1vbmpzUmVxdWlyZWAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzU3RhdGljUmVxdWlyZVN0YXRlbWVudChub2RlLCBzY29wZSkpIHJldHVybjtcbiAgICAgICAgICBpZiAoIWlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCkge1xuICAgICAgICAgICAgc2tpcHBlZE5vZGVzLmFkZChub2RlLmNhbGxlZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNJZ25vcmVkUmVxdWlyZVN0YXRlbWVudChub2RlLCBpZ25vcmVSZXF1aXJlKSkge1xuICAgICAgICAgICAgc2tpcHBlZE5vZGVzLmFkZChub2RlLmNhbGxlZSk7XG4gICAgICAgICAgICBjb25zdCB1c2VzUmV0dXJuVmFsdWUgPSBwYXJlbnQudHlwZSAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnO1xuXG4gICAgICAgICAgICBsZXQgY2FuQ29udmVydFJlcXVpcmUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHNob3VsZFJlbW92ZVJlcXVpcmVTdGF0ZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcnlCbG9ja0VuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAoe1xuICAgICAgICAgICAgICAgIGNhbkNvbnZlcnRSZXF1aXJlLFxuICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZVJlcXVpcmVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgfSA9IGdldElnbm9yZVRyeUNhdGNoUmVxdWlyZVN0YXRlbWVudE1vZGUobm9kZS5hcmd1bWVudHNbMF0udmFsdWUpKTtcblxuICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlUmVxdWlyZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGhhc1JlbW92ZWRSZXF1aXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc291cmNlSWQgPSBnZXRSZXF1aXJlU3RyaW5nQXJnKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgaXNEeW5hbWljUmVnaXN0ZXIgPSBpc1dyYXBwZWRJZChzb3VyY2VJZCwgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVgpO1xuICAgICAgICAgICAgaWYgKGlzRHluYW1pY1JlZ2lzdGVyKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUlkID0gdW53cmFwSWQoc291cmNlSWQsIERZTkFNSUNfUkVHSVNURVJfU1VGRklYKTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZUlkLmVuZHNXaXRoKCcuanNvbicpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSWQgPSBEWU5BTUlDX0pTT05fUFJFRklYICsgc291cmNlSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdGVyU291cmNlcy5hZGQod3JhcElkKHNvdXJjZUlkLCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFzb3VyY2VJZC5lbmRzV2l0aCgnLmpzb24nKSAmJlxuICAgICAgICAgICAgICAgIGhhc0R5bmFtaWNNb2R1bGVGb3JQYXRoKHNvdXJjZUlkLCBpZCwgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVSZXF1aXJlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUobm9kZS5zdGFydCwgbm9kZS5lbmQsIGB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbkNvbnZlcnRSZXF1aXJlKSB7XG4gICAgICAgICAgICAgICAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW5kLFxuICAgICAgICAgICAgICAgICAgICBgJHtIRUxQRVJTX05BTUV9LmNvbW1vbmpzUmVxdWlyZSgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFZpcnR1YWxQYXRoRm9yRHluYW1pY1JlcXVpcmVQYXRoKHNvdXJjZUlkLCBjb21tb25EaXIpXG4gICAgICAgICAgICAgICAgICAgICl9LCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgIGRpcm5hbWUoaWQpID09PSAnLicgPyBudWxsIC8qIGRlZmF1bHQgYmVoYXZpb3IgKi8gOiB2aXJ0dWFsRHluYW1pY1JlcXVpcmVQYXRoXG4gICAgICAgICAgICAgICAgICAgICl9KWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB1c2VzRHluYW1pY1JlcXVpcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY2FuQ29udmVydFJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICBhZGRSZXF1aXJlU3RhdGVtZW50KHNvdXJjZUlkLCBub2RlLCBzY29wZSwgdXNlc1JldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXNlc1JldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVSZXF1aXJlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcub3ZlcndyaXRlKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyAmJlxuICAgICAgICAgICAgICAgICFzY29wZS5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuaWQudHlwZSA9PT0gJ0lkZW50aWZpZXInXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBhbGxvdyB1cyB0byByZXVzZSB0aGlzIHZhcmlhYmxlIG5hbWUgYXMgdGhlIGltcG9ydGVkIHZhcmlhYmxlIGlmIGl0IGlzIG5vdCByZWFzc2lnbmVkXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRvZXMgbm90IGNvbmZsaWN0IHdpdGggdmFyaWFibGVzIGluIG90aGVyIHBsYWNlcyB3aGVyZSB0aGlzIGlzIGltcG9ydGVkXG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSZXF1aXJlRGVjbGFyYXRvcnMuYWRkKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBiYXJlIGltcG9ydCwgZS5nLiBgcmVxdWlyZSgnZm9vJyk7YFxuXG4gICAgICAgICAgICAgIGlmICghY2FuQ29udmVydFJlcXVpcmUgJiYgIXNob3VsZFJlbW92ZVJlcXVpcmVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtYWdpY1N0cmluZy5yZW1vdmUocGFyZW50LnN0YXJ0LCBwYXJlbnQuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAvLyBza2lwIGRlYWQgYnJhbmNoZXNcbiAgICAgICAgICBpZiAoaXNGYWxzeShub2RlLnRlc3QpKSB7XG4gICAgICAgICAgICBza2lwcGVkTm9kZXMuYWRkKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmFsdGVybmF0ZSAmJiBpc1RydXRoeShub2RlLnRlc3QpKSB7XG4gICAgICAgICAgICBza2lwcGVkTm9kZXMuYWRkKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzoge1xuICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gbm9kZTtcbiAgICAgICAgICBpZiAoIShpc1JlZmVyZW5jZShub2RlLCBwYXJlbnQpICYmICFzY29wZS5jb250YWlucyhuYW1lKSkpIHJldHVybjtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlcXVpcmUnOlxuICAgICAgICAgICAgICBpZiAoaXNOb2RlUmVxdWlyZVByb3BlcnR5QWNjZXNzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY01vZHVsZUZvclBhdGgoaWQsICcvJywgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnByb3BlcnR5Lm5hbWUgPT09ICdjYWNoZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcub3ZlcndyaXRlKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBgJHtIRUxQRVJTX05BTUV9LmNvbW1vbmpzUmVxdWlyZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCAmJiBpc1JlcXVpcmVTdGF0ZW1lbnQocGFyZW50LCBzY29wZSkpIHtcbiAgICAgICAgICAgICAgICBtYWdpY1N0cmluZy5hcHBlbmRMZWZ0KFxuICAgICAgICAgICAgICAgICAgcGFyZW50LmVuZCAtIDEsXG4gICAgICAgICAgICAgICAgICBgLCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIGRpcm5hbWUoaWQpID09PSAnLicgPyBudWxsIC8qIGRlZmF1bHQgYmVoYXZpb3IgKi8gOiB2aXJ0dWFsRHluYW1pY1JlcXVpcmVQYXRoXG4gICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaWdub3JlRHluYW1pY1JlcXVpcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2hvcnRoYW5kUHJvcGVydHkocGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcuYXBwZW5kUmlnaHQobm9kZS5lbmQsIGA6ICR7SEVMUEVSU19OQU1FfS5jb21tb25qc1JlcXVpcmVgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcub3ZlcndyaXRlKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBgJHtIRUxQRVJTX05BTUV9LmNvbW1vbmpzUmVxdWlyZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXNlc0R5bmFtaWNSZXF1aXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnbW9kdWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cG9ydHMnOlxuICAgICAgICAgICAgICBzaG91bGRXcmFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdXNlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2dsb2JhbCc6XG4gICAgICAgICAgICAgIHVzZXMuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCFpZ25vcmVHbG9iYWwpIHtcbiAgICAgICAgICAgICAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUobm9kZS5zdGFydCwgbm9kZS5lbmQsIGAke0hFTFBFUlNfTkFNRX0uY29tbW9uanNHbG9iYWxgLCB7XG4gICAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdkZWZpbmUnOlxuICAgICAgICAgICAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUobm9kZS5zdGFydCwgbm9kZS5lbmQsICd1bmRlZmluZWQnLCB7XG4gICAgICAgICAgICAgICAgc3RvcmVOYW1lOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBnbG9iYWxzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICBpZiAoIWlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCAmJiBpc01vZHVsZVJlcXVpcmUobm9kZSwgc2NvcGUpKSB7XG4gICAgICAgICAgICBtYWdpY1N0cmluZy5vdmVyd3JpdGUobm9kZS5zdGFydCwgbm9kZS5lbmQsIGAke0hFTFBFUlNfTkFNRX0uY29tbW9uanNSZXF1aXJlYCwge1xuICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2tpcHBlZE5vZGVzLmFkZChub2RlLm9iamVjdCk7XG4gICAgICAgICAgICBza2lwcGVkTm9kZXMuYWRkKG5vZGUucHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgLy8gaWYgdG9wLWxldmVsIHJldHVybiwgd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgICAgICAgaWYgKGxleGljYWxEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2hvdWxkV3JhcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgIC8vIHJld3JpdGUgdG9wLWxldmVsIGB0aGlzYCBhcyBgY29tbW9uanNIZWxwZXJzLmNvbW1vbmpzR2xvYmFsYFxuICAgICAgICAgIGlmIChsZXhpY2FsRGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHVzZXMuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaWdub3JlR2xvYmFsKSB7XG4gICAgICAgICAgICAgIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZShub2RlLnN0YXJ0LCBub2RlLmVuZCwgYCR7SEVMUEVSU19OQU1FfS5jb21tb25qc0dsb2JhbGAsIHtcbiAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAvLyByZXdyaXRlIGB0eXBlb2YgbW9kdWxlYCwgYHR5cGVvZiBtb2R1bGUuZXhwb3J0c2AgYW5kIGB0eXBlb2YgZXhwb3J0c2AgKGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwLXBsdWdpbi1jb21tb25qcy9pc3N1ZXMvMTUxKVxuICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAndHlwZW9mJykge1xuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkID0gZ2V0S2V5cGF0aChub2RlLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGlmICghZmxhdHRlbmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChzY29wZS5jb250YWlucyhmbGF0dGVuZWQubmFtZSkpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmbGF0dGVuZWQua2V5cGF0aCA9PT0gJ21vZHVsZS5leHBvcnRzJyB8fFxuICAgICAgICAgICAgICBmbGF0dGVuZWQua2V5cGF0aCA9PT0gJ21vZHVsZScgfHxcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLmtleXBhdGggPT09ICdleHBvcnRzJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZShub2RlLnN0YXJ0LCBub2RlLmVuZCwgYCdvYmplY3QnYCwge1xuICAgICAgICAgICAgICAgIHN0b3JlTmFtZTogZmFsc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgICAgaWYgKCFzY29wZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRvcExldmVsRGVjbGFyYXRpb25zLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsZWF2ZShub2RlKSB7XG4gICAgICBwcm9ncmFtRGVwdGggLT0gMTtcbiAgICAgIGlmIChub2RlLnNjb3BlKSBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICAgIGlmIChmdW5jdGlvblR5cGUudGVzdChub2RlLnR5cGUpKSBsZXhpY2FsRGVwdGggLT0gMTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IG5hbWVCYXNlID0gZ2V0TmFtZShpZCk7XG4gIGNvbnN0IGV4cG9ydHNOYW1lID0gZGVjb25mbGljdChbLi4uZXhwb3J0c0FjY2Vzc1Njb3Blc10sIGdsb2JhbHMsIG5hbWVCYXNlKTtcbiAgY29uc3QgbW9kdWxlTmFtZSA9IGRlY29uZmxpY3QoWy4uLm1vZHVsZUFjY2Vzc1Njb3Blc10sIGdsb2JhbHMsIGAke25hbWVCYXNlfU1vZHVsZWApO1xuICBjb25zdCBkZWNvbmZsaWN0ZWRFeHBvcnROYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2V4cG9ydE5hbWUsIHsgc2NvcGVzIH1dIG9mIGV4cG9ydHNBc3NpZ25tZW50c0J5TmFtZSkge1xuICAgIGRlY29uZmxpY3RlZEV4cG9ydE5hbWVzW2V4cG9ydE5hbWVdID0gZGVjb25mbGljdChbLi4uc2NvcGVzXSwgZ2xvYmFscywgZXhwb3J0TmFtZSk7XG4gIH1cblxuICAvLyBXZSBjYW5ub3Qgd3JhcCBFUy9taXhlZCBtb2R1bGVzXG4gIHNob3VsZFdyYXAgPVxuICAgICFpc0VzTW9kdWxlICYmXG4gICAgIWRpc2FibGVXcmFwICYmXG4gICAgKHNob3VsZFdyYXAgfHwgKHVzZXMuZXhwb3J0cyAmJiBtb2R1bGVFeHBvcnRzQXNzaWdubWVudHMubGVuZ3RoID4gMCkpO1xuICBjb25zdCBkZXRlY3RXcmFwcGVkRGVmYXVsdCA9XG4gICAgc2hvdWxkV3JhcCAmJlxuICAgICh0b3BMZXZlbERlZmluZUNvbXBpbGVkRXNtRXhwcmVzc2lvbnMubGVuZ3RoID4gMCB8fCBjb2RlLmluZGV4T2YoJ19fZXNNb2R1bGUnKSA+PSAwKTtcblxuICBpZiAoXG4gICAgIShcbiAgICAgIHJlcXVpcmVkU291cmNlcy5sZW5ndGggfHxcbiAgICAgIGR5bmFtaWNSZWdpc3RlclNvdXJjZXMuc2l6ZSB8fFxuICAgICAgdXNlcy5tb2R1bGUgfHxcbiAgICAgIHVzZXMuZXhwb3J0cyB8fFxuICAgICAgdXNlcy5yZXF1aXJlIHx8XG4gICAgICB1c2VzRHluYW1pY1JlcXVpcmUgfHxcbiAgICAgIGhhc1JlbW92ZWRSZXF1aXJlIHx8XG4gICAgICB0b3BMZXZlbERlZmluZUNvbXBpbGVkRXNtRXhwcmVzc2lvbnMubGVuZ3RoID4gMFxuICAgICkgJiZcbiAgICAoaWdub3JlR2xvYmFsIHx8ICF1c2VzLmdsb2JhbClcbiAgKSB7XG4gICAgcmV0dXJuIHsgbWV0YTogeyBjb21tb25qczogeyBpc0NvbW1vbkpTOiBmYWxzZSB9IH0gfTtcbiAgfVxuXG4gIGxldCBsZWFkaW5nQ29tbWVudCA9ICcnO1xuICBpZiAoY29kZS5zdGFydHNXaXRoKCcvKicpKSB7XG4gICAgY29uc3QgY29tbWVudEVuZCA9IGNvZGUuaW5kZXhPZignKi8nLCAyKSArIDI7XG4gICAgbGVhZGluZ0NvbW1lbnQgPSBgJHtjb2RlLnNsaWNlKDAsIGNvbW1lbnRFbmQpfVxcbmA7XG4gICAgbWFnaWNTdHJpbmcucmVtb3ZlKDAsIGNvbW1lbnRFbmQpLnRyaW0oKTtcbiAgfVxuXG4gIGNvbnN0IGV4cG9ydE1vZGUgPSBzaG91bGRXcmFwXG4gICAgPyB1c2VzLm1vZHVsZVxuICAgICAgPyAnbW9kdWxlJ1xuICAgICAgOiAnZXhwb3J0cydcbiAgICA6IGZpcnN0VG9wTGV2ZWxNb2R1bGVFeHBvcnRzQXNzaWdubWVudFxuICAgID8gZXhwb3J0c0Fzc2lnbm1lbnRzQnlOYW1lLnNpemUgPT09IDAgJiYgdG9wTGV2ZWxEZWZpbmVDb21waWxlZEVzbUV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMFxuICAgICAgPyAncmVwbGFjZSdcbiAgICAgIDogJ21vZHVsZSdcbiAgICA6IG1vZHVsZUV4cG9ydHNBc3NpZ25tZW50cy5sZW5ndGggPT09IDBcbiAgICA/ICdleHBvcnRzJ1xuICAgIDogJ21vZHVsZSc7XG5cbiAgY29uc3QgaW1wb3J0QmxvY2sgPSByZXdyaXRlUmVxdWlyZUV4cHJlc3Npb25zQW5kR2V0SW1wb3J0QmxvY2soXG4gICAgbWFnaWNTdHJpbmcsXG4gICAgdG9wTGV2ZWxEZWNsYXJhdGlvbnMsXG4gICAgdG9wTGV2ZWxSZXF1aXJlRGVjbGFyYXRvcnMsXG4gICAgcmVhc3NpZ25lZE5hbWVzLFxuICAgIEhFTFBFUlNfTkFNRSxcbiAgICBkeW5hbWljUmVnaXN0ZXJTb3VyY2VzLFxuICAgIG1vZHVsZU5hbWUsXG4gICAgZXhwb3J0c05hbWUsXG4gICAgaWQsXG4gICAgZXhwb3J0TW9kZVxuICApO1xuXG4gIGNvbnN0IGV4cG9ydEJsb2NrID0gaXNFc01vZHVsZVxuICAgID8gJydcbiAgICA6IHJld3JpdGVFeHBvcnRzQW5kR2V0RXhwb3J0c0Jsb2NrKFxuICAgICAgICBtYWdpY1N0cmluZyxcbiAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgZXhwb3J0c05hbWUsXG4gICAgICAgIHNob3VsZFdyYXAsXG4gICAgICAgIG1vZHVsZUV4cG9ydHNBc3NpZ25tZW50cyxcbiAgICAgICAgZmlyc3RUb3BMZXZlbE1vZHVsZUV4cG9ydHNBc3NpZ25tZW50LFxuICAgICAgICBleHBvcnRzQXNzaWdubWVudHNCeU5hbWUsXG4gICAgICAgIHRvcExldmVsQXNzaWdubWVudHMsXG4gICAgICAgIHRvcExldmVsRGVmaW5lQ29tcGlsZWRFc21FeHByZXNzaW9ucyxcbiAgICAgICAgZGVjb25mbGljdGVkRXhwb3J0TmFtZXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIEhFTFBFUlNfTkFNRSxcbiAgICAgICAgZXhwb3J0TW9kZSxcbiAgICAgICAgZGV0ZWN0V3JhcHBlZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRJc01vZHVsZUV4cG9ydHNcbiAgICAgICk7XG5cbiAgaWYgKHNob3VsZFdyYXApIHtcbiAgICB3cmFwQ29kZShtYWdpY1N0cmluZywgdXNlcywgbW9kdWxlTmFtZSwgZXhwb3J0c05hbWUpO1xuICB9XG5cbiAgbWFnaWNTdHJpbmdcbiAgICAudHJpbSgpXG4gICAgLnByZXBlbmQobGVhZGluZ0NvbW1lbnQgKyBpbXBvcnRCbG9jaylcbiAgICAuYXBwZW5kKGV4cG9ydEJsb2NrKTtcblxuICByZXR1cm4ge1xuICAgIGNvZGU6IG1hZ2ljU3RyaW5nLnRvU3RyaW5nKCksXG4gICAgbWFwOiBzb3VyY2VNYXAgPyBtYWdpY1N0cmluZy5nZW5lcmF0ZU1hcCgpIDogbnVsbCxcbiAgICBzeW50aGV0aWNOYW1lZEV4cG9ydHM6IGlzRXNNb2R1bGUgPyBmYWxzZSA6ICdfX21vZHVsZUV4cG9ydHMnLFxuICAgIG1ldGE6IHsgY29tbW9uanM6IHsgaXNDb21tb25KUzogIWlzRXNNb2R1bGUgfSB9XG4gIH07XG59XG4iLCAiaW1wb3J0IHsgZGlybmFtZSwgZXh0bmFtZSB9IGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBjcmVhdGVGaWx0ZXIgfSBmcm9tICdAcm9sbHVwL3BsdWdpbnV0aWxzJztcbmltcG9ydCBnZXRDb21tb25EaXIgZnJvbSAnY29tbW9uZGlyJztcblxuaW1wb3J0IHsgcGVlckRlcGVuZGVuY2llcyB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmltcG9ydCBhbmFseXplVG9wTGV2ZWxTdGF0ZW1lbnRzIGZyb20gJy4vYW5hbHl6ZS10b3AtbGV2ZWwtc3RhdGVtZW50cyc7XG5cbmltcG9ydCB7XG4gIGdldER5bmFtaWNQYWNrYWdlc0VudHJ5SW50cm8sXG4gIGdldER5bmFtaWNQYWNrYWdlc01vZHVsZSxcbiAgaXNEeW5hbWljTW9kdWxlSW1wb3J0XG59IGZyb20gJy4vZHluYW1pYy1wYWNrYWdlcy1tYW5hZ2VyJztcbmltcG9ydCBnZXREeW5hbWljUmVxdWlyZVBhdGhzIGZyb20gJy4vZHluYW1pYy1yZXF1aXJlLXBhdGhzJztcbmltcG9ydCB7XG4gIERZTkFNSUNfSlNPTl9QUkVGSVgsXG4gIERZTkFNSUNfUEFDS0FHRVNfSUQsXG4gIERZTkFNSUNfUkVHSVNURVJfU1VGRklYLFxuICBFWFBPUlRTX1NVRkZJWCxcbiAgRVhURVJOQUxfU1VGRklYLFxuICBnZXRIZWxwZXJzTW9kdWxlLFxuICBIRUxQRVJTX0lELFxuICBpc1dyYXBwZWRJZCxcbiAgTU9EVUxFX1NVRkZJWCxcbiAgUFJPWFlfU1VGRklYLFxuICB1bndyYXBJZFxufSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgc2V0Q29tbW9uSlNNZXRhUHJvbWlzZSB9IGZyb20gJy4vaXMtY2pzJztcbmltcG9ydCB7IGhhc0Nqc0tleXdvcmRzIH0gZnJvbSAnLi9wYXJzZSc7XG5pbXBvcnQge1xuICBnZXREeW5hbWljSnNvblByb3h5LFxuICBnZXREeW5hbWljUmVxdWlyZVByb3h5LFxuICBnZXRTcGVjaWZpY0hlbHBlclByb3h5LFxuICBnZXRTdGF0aWNSZXF1aXJlUHJveHksXG4gIGdldFVua25vd25SZXF1aXJlUHJveHlcbn0gZnJvbSAnLi9wcm94aWVzJztcbmltcG9ydCBnZXRSZXNvbHZlSWQgZnJvbSAnLi9yZXNvbHZlLWlkJztcbmltcG9ydCB2YWxpZGF0ZVJvbGx1cFZlcnNpb24gZnJvbSAnLi9yb2xsdXAtdmVyc2lvbic7XG5pbXBvcnQgdHJhbnNmb3JtQ29tbW9uanMgZnJvbSAnLi90cmFuc2Zvcm0tY29tbW9uanMnO1xuaW1wb3J0IHsgZ2V0TmFtZSwgZ2V0VmlydHVhbFBhdGhGb3JEeW5hbWljUmVxdWlyZVBhdGgsIG5vcm1hbGl6ZVBhdGhTbGFzaGVzIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbW1vbmpzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBleHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IFsnLmpzJ107XG4gIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUZpbHRlcihvcHRpb25zLmluY2x1ZGUsIG9wdGlvbnMuZXhjbHVkZSk7XG4gIGNvbnN0IHtcbiAgICBpZ25vcmVHbG9iYWwsXG4gICAgaWdub3JlRHluYW1pY1JlcXVpcmVzLFxuICAgIHJlcXVpcmVSZXR1cm5zRGVmYXVsdDogcmVxdWlyZVJldHVybnNEZWZhdWx0T3B0aW9uLFxuICAgIGVzbUV4dGVybmFsc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ2V0UmVxdWlyZVJldHVybnNEZWZhdWx0ID1cbiAgICB0eXBlb2YgcmVxdWlyZVJldHVybnNEZWZhdWx0T3B0aW9uID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHJlcXVpcmVSZXR1cm5zRGVmYXVsdE9wdGlvblxuICAgICAgOiAoKSA9PiByZXF1aXJlUmV0dXJuc0RlZmF1bHRPcHRpb247XG4gIGxldCBlc21FeHRlcm5hbElkcztcbiAgY29uc3QgaXNFc21FeHRlcm5hbCA9XG4gICAgdHlwZW9mIGVzbUV4dGVybmFscyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBlc21FeHRlcm5hbHNcbiAgICAgIDogQXJyYXkuaXNBcnJheShlc21FeHRlcm5hbHMpXG4gICAgICA/ICgoZXNtRXh0ZXJuYWxJZHMgPSBuZXcgU2V0KGVzbUV4dGVybmFscykpLCAoaWQpID0+IGVzbUV4dGVybmFsSWRzLmhhcyhpZCkpXG4gICAgICA6ICgpID0+IGVzbUV4dGVybmFscztcbiAgY29uc3QgZGVmYXVsdElzTW9kdWxlRXhwb3J0cyA9XG4gICAgdHlwZW9mIG9wdGlvbnMuZGVmYXVsdElzTW9kdWxlRXhwb3J0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5kZWZhdWx0SXNNb2R1bGVFeHBvcnRzIDogJ2F1dG8nO1xuXG4gIGNvbnN0IHsgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQsIGR5bmFtaWNSZXF1aXJlTW9kdWxlRGlyUGF0aHMgfSA9IGdldER5bmFtaWNSZXF1aXJlUGF0aHMoXG4gICAgb3B0aW9ucy5keW5hbWljUmVxdWlyZVRhcmdldHNcbiAgKTtcbiAgY29uc3QgaXNEeW5hbWljUmVxdWlyZU1vZHVsZXNFbmFibGVkID0gZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQuc2l6ZSA+IDA7XG4gIGNvbnN0IGNvbW1vbkRpciA9IGlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZFxuICAgID8gZ2V0Q29tbW9uRGlyKG51bGwsIEFycmF5LmZyb20oZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQpLmNvbmNhdChwcm9jZXNzLmN3ZCgpKSlcbiAgICA6IG51bGw7XG5cbiAgY29uc3QgZXNNb2R1bGVzV2l0aERlZmF1bHRFeHBvcnQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVzTW9kdWxlc1dpdGhOYW1lZEV4cG9ydHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGNvbW1vbkpzTWV0YVByb21pc2VzID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IGlnbm9yZVJlcXVpcmUgPVxuICAgIHR5cGVvZiBvcHRpb25zLmlnbm9yZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvcHRpb25zLmlnbm9yZVxuICAgICAgOiBBcnJheS5pc0FycmF5KG9wdGlvbnMuaWdub3JlKVxuICAgICAgPyAoaWQpID0+IG9wdGlvbnMuaWdub3JlLmluY2x1ZGVzKGlkKVxuICAgICAgOiAoKSA9PiBmYWxzZTtcblxuICBjb25zdCBnZXRJZ25vcmVUcnlDYXRjaFJlcXVpcmVTdGF0ZW1lbnRNb2RlID0gKGlkKSA9PiB7XG4gICAgY29uc3QgbW9kZSA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVUcnlDYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuaWdub3JlVHJ5Q2F0Y2goaWQpXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShvcHRpb25zLmlnbm9yZVRyeUNhdGNoKVxuICAgICAgICA/IG9wdGlvbnMuaWdub3JlVHJ5Q2F0Y2guaW5jbHVkZXMoaWQpXG4gICAgICAgIDogdHlwZW9mIG9wdGlvbnMuaWdub3JlVHJ5Q2F0Y2ggIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gb3B0aW9ucy5pZ25vcmVUcnlDYXRjaFxuICAgICAgICA6IHRydWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FuQ29udmVydFJlcXVpcmU6IG1vZGUgIT09ICdyZW1vdmUnICYmIG1vZGUgIT09IHRydWUsXG4gICAgICBzaG91bGRSZW1vdmVSZXF1aXJlU3RhdGVtZW50OiBtb2RlID09PSAncmVtb3ZlJ1xuICAgIH07XG4gIH07XG5cbiAgY29uc3QgcmVzb2x2ZUlkID0gZ2V0UmVzb2x2ZUlkKGV4dGVuc2lvbnMpO1xuXG4gIGNvbnN0IHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwICE9PSBmYWxzZTtcblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1BbmRDaGVja0V4cG9ydHMoY29kZSwgaWQpIHtcbiAgICBpZiAoaXNEeW5hbWljUmVxdWlyZU1vZHVsZXNFbmFibGVkICYmIHRoaXMuZ2V0TW9kdWxlSW5mbyhpZCkuaXNFbnRyeSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBjb2RlID1cbiAgICAgICAgZ2V0RHluYW1pY1BhY2thZ2VzRW50cnlJbnRybyhkeW5hbWljUmVxdWlyZU1vZHVsZURpclBhdGhzLCBkeW5hbWljUmVxdWlyZU1vZHVsZVNldCkgKyBjb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaXNFc01vZHVsZSwgaGFzRGVmYXVsdEV4cG9ydCwgaGFzTmFtZWRFeHBvcnRzLCBhc3QgfSA9IGFuYWx5emVUb3BMZXZlbFN0YXRlbWVudHMoXG4gICAgICB0aGlzLnBhcnNlLFxuICAgICAgY29kZSxcbiAgICAgIGlkXG4gICAgKTtcbiAgICBpZiAoaGFzRGVmYXVsdEV4cG9ydCkge1xuICAgICAgZXNNb2R1bGVzV2l0aERlZmF1bHRFeHBvcnQuYWRkKGlkKTtcbiAgICB9XG4gICAgaWYgKGhhc05hbWVkRXhwb3J0cykge1xuICAgICAgZXNNb2R1bGVzV2l0aE5hbWVkRXhwb3J0cy5hZGQoaWQpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFkeW5hbWljUmVxdWlyZU1vZHVsZVNldC5oYXMobm9ybWFsaXplUGF0aFNsYXNoZXMoaWQpKSAmJlxuICAgICAgKCFoYXNDanNLZXl3b3Jkcyhjb2RlLCBpZ25vcmVHbG9iYWwpIHx8IChpc0VzTW9kdWxlICYmICFvcHRpb25zLnRyYW5zZm9ybU1peGVkRXNNb2R1bGVzKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB7IG1ldGE6IHsgY29tbW9uanM6IHsgaXNDb21tb25KUzogZmFsc2UgfSB9IH07XG4gICAgfVxuXG4gICAgLy8gYXZvaWQgd3JhcHBpbmcgYXMgdGhpcyBpcyBhIGNvbW1vbmpzUmVnaXN0ZXIgY2FsbFxuICAgIGNvbnN0IGRpc2FibGVXcmFwID0gaXNXcmFwcGVkSWQoaWQsIERZTkFNSUNfUkVHSVNURVJfU1VGRklYKTtcbiAgICBpZiAoZGlzYWJsZVdyYXApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgaWQgPSB1bndyYXBJZChpZCwgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm1Db21tb25qcyhcbiAgICAgIHRoaXMucGFyc2UsXG4gICAgICBjb2RlLFxuICAgICAgaWQsXG4gICAgICBpc0VzTW9kdWxlLFxuICAgICAgaWdub3JlR2xvYmFsIHx8IGlzRXNNb2R1bGUsXG4gICAgICBpZ25vcmVSZXF1aXJlLFxuICAgICAgaWdub3JlRHluYW1pY1JlcXVpcmVzICYmICFpc0R5bmFtaWNSZXF1aXJlTW9kdWxlc0VuYWJsZWQsXG4gICAgICBnZXRJZ25vcmVUcnlDYXRjaFJlcXVpcmVTdGF0ZW1lbnRNb2RlLFxuICAgICAgc291cmNlTWFwLFxuICAgICAgaXNEeW5hbWljUmVxdWlyZU1vZHVsZXNFbmFibGVkLFxuICAgICAgZHluYW1pY1JlcXVpcmVNb2R1bGVTZXQsXG4gICAgICBkaXNhYmxlV3JhcCxcbiAgICAgIGNvbW1vbkRpcixcbiAgICAgIGFzdCxcbiAgICAgIGRlZmF1bHRJc01vZHVsZUV4cG9ydHNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnY29tbW9uanMnLFxuXG4gICAgYnVpbGRTdGFydCgpIHtcbiAgICAgIHZhbGlkYXRlUm9sbHVwVmVyc2lvbih0aGlzLm1ldGEucm9sbHVwVmVyc2lvbiwgcGVlckRlcGVuZGVuY2llcy5yb2xsdXApO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZWRFeHBvcnRzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgICdUaGUgbmFtZWRFeHBvcnRzIG9wdGlvbiBmcm9tIFwiQHJvbGx1cC9wbHVnaW4tY29tbW9uanNcIiBpcyBkZXByZWNhdGVkLiBOYW1lZCBleHBvcnRzIGFyZSBub3cgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzb2x2ZUlkLFxuXG4gICAgbG9hZChpZCkge1xuICAgICAgaWYgKGlkID09PSBIRUxQRVJTX0lEKSB7XG4gICAgICAgIHJldHVybiBnZXRIZWxwZXJzTW9kdWxlKGlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCwgaWdub3JlRHluYW1pY1JlcXVpcmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoSEVMUEVSU19JRCkpIHtcbiAgICAgICAgcmV0dXJuIGdldFNwZWNpZmljSGVscGVyUHJveHkoaWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNXcmFwcGVkSWQoaWQsIE1PRFVMRV9TVUZGSVgpKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElkID0gdW53cmFwSWQoaWQsIE1PRFVMRV9TVUZGSVgpO1xuICAgICAgICBsZXQgbmFtZSA9IGdldE5hbWUoYWN0dWFsSWQpO1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgaWYgKGlzRHluYW1pY1JlcXVpcmVNb2R1bGVzRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChbJ21vZHVsZVBhdGgnLCAnY29tbW9uanNSZXF1aXJlJywgJ2NyZWF0ZU1vZHVsZSddLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gYCR7bmFtZX1fYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZSA9XG4gICAgICAgICAgICBgaW1wb3J0IHtjb21tb25qc1JlcXVpcmUsIGNyZWF0ZU1vZHVsZX0gZnJvbSBcIiR7SEVMUEVSU19JRH1cIjtcXG5gICtcbiAgICAgICAgICAgIGB2YXIgJHtuYW1lfSA9IGNyZWF0ZU1vZHVsZSgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBnZXRWaXJ0dWFsUGF0aEZvckR5bmFtaWNSZXF1aXJlUGF0aChkaXJuYW1lKGFjdHVhbElkKSwgY29tbW9uRGlyKVxuICAgICAgICAgICAgKX0pO1xcbmAgK1xuICAgICAgICAgICAgYGV4cG9ydCB7JHtuYW1lfSBhcyBfX21vZHVsZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSBgdmFyICR7bmFtZX0gPSB7ZXhwb3J0czoge319OyBleHBvcnQgeyR7bmFtZX0gYXMgX19tb2R1bGV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgc3ludGhldGljTmFtZWRFeHBvcnRzOiAnX19tb2R1bGUnLFxuICAgICAgICAgIG1ldGE6IHsgY29tbW9uanM6IHsgaXNDb21tb25KUzogZmFsc2UgfSB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1dyYXBwZWRJZChpZCwgRVhQT1JUU19TVUZGSVgpKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElkID0gdW53cmFwSWQoaWQsIEVYUE9SVFNfU1VGRklYKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldE5hbWUoYWN0dWFsSWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvZGU6IGB2YXIgJHtuYW1lfSA9IHt9OyBleHBvcnQgeyR7bmFtZX0gYXMgX19leHBvcnRzfWAsXG4gICAgICAgICAgbWV0YTogeyBjb21tb25qczogeyBpc0NvbW1vbkpTOiBmYWxzZSB9IH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzV3JhcHBlZElkKGlkLCBFWFRFUk5BTF9TVUZGSVgpKSB7XG4gICAgICAgIGNvbnN0IGFjdHVhbElkID0gdW53cmFwSWQoaWQsIEVYVEVSTkFMX1NVRkZJWCk7XG4gICAgICAgIHJldHVybiBnZXRVbmtub3duUmVxdWlyZVByb3h5KFxuICAgICAgICAgIGFjdHVhbElkLFxuICAgICAgICAgIGlzRXNtRXh0ZXJuYWwoYWN0dWFsSWQpID8gZ2V0UmVxdWlyZVJldHVybnNEZWZhdWx0KGFjdHVhbElkKSA6IHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkID09PSBEWU5BTUlDX1BBQ0tBR0VTX0lEKSB7XG4gICAgICAgIHJldHVybiBnZXREeW5hbWljUGFja2FnZXNNb2R1bGUoZHluYW1pY1JlcXVpcmVNb2R1bGVEaXJQYXRocywgY29tbW9uRGlyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoRFlOQU1JQ19KU09OX1BSRUZJWCkpIHtcbiAgICAgICAgcmV0dXJuIGdldER5bmFtaWNKc29uUHJveHkoaWQsIGNvbW1vbkRpcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0R5bmFtaWNNb2R1bGVJbXBvcnQoaWQsIGR5bmFtaWNSZXF1aXJlTW9kdWxlU2V0KSkge1xuICAgICAgICByZXR1cm4gYGV4cG9ydCBkZWZhdWx0IHJlcXVpcmUoJHtKU09OLnN0cmluZ2lmeShub3JtYWxpemVQYXRoU2xhc2hlcyhpZCkpfSk7YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzV3JhcHBlZElkKGlkLCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCkpIHtcbiAgICAgICAgcmV0dXJuIGdldER5bmFtaWNSZXF1aXJlUHJveHkoXG4gICAgICAgICAgbm9ybWFsaXplUGF0aFNsYXNoZXModW53cmFwSWQoaWQsIERZTkFNSUNfUkVHSVNURVJfU1VGRklYKSksXG4gICAgICAgICAgY29tbW9uRGlyXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1dyYXBwZWRJZChpZCwgUFJPWFlfU1VGRklYKSkge1xuICAgICAgICBjb25zdCBhY3R1YWxJZCA9IHVud3JhcElkKGlkLCBQUk9YWV9TVUZGSVgpO1xuICAgICAgICByZXR1cm4gZ2V0U3RhdGljUmVxdWlyZVByb3h5KFxuICAgICAgICAgIGFjdHVhbElkLFxuICAgICAgICAgIGdldFJlcXVpcmVSZXR1cm5zRGVmYXVsdChhY3R1YWxJZCksXG4gICAgICAgICAgZXNNb2R1bGVzV2l0aERlZmF1bHRFeHBvcnQsXG4gICAgICAgICAgZXNNb2R1bGVzV2l0aE5hbWVkRXhwb3J0cyxcbiAgICAgICAgICBjb21tb25Kc01ldGFQcm9taXNlc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtKGNvZGUsIHJhd0lkKSB7XG4gICAgICBsZXQgaWQgPSByYXdJZDtcblxuICAgICAgaWYgKGlzV3JhcHBlZElkKGlkLCBEWU5BTUlDX1JFR0lTVEVSX1NVRkZJWCkpIHtcbiAgICAgICAgaWQgPSB1bndyYXBJZChpZCwgRFlOQU1JQ19SRUdJU1RFUl9TVUZGSVgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHROYW1lID0gZXh0bmFtZShpZCk7XG4gICAgICBpZiAoXG4gICAgICAgIGV4dE5hbWUgIT09ICcuY2pzJyAmJlxuICAgICAgICBpZCAhPT0gRFlOQU1JQ19QQUNLQUdFU19JRCAmJlxuICAgICAgICAhaWQuc3RhcnRzV2l0aChEWU5BTUlDX0pTT05fUFJFRklYKSAmJlxuICAgICAgICAoIWZpbHRlcihpZCkgfHwgIWV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0TmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1BbmRDaGVja0V4cG9ydHMuY2FsbCh0aGlzLCBjb2RlLCByYXdJZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoZXJyLCBlcnIubG9jKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kdWxlUGFyc2VkKHsgaWQsIG1ldGE6IHsgY29tbW9uanM6IGNvbW1vbmpzTWV0YSB9IH0pIHtcbiAgICAgIGlmIChjb21tb25qc01ldGEgJiYgY29tbW9uanNNZXRhLmlzQ29tbW9uSlMgIT0gbnVsbCkge1xuICAgICAgICBzZXRDb21tb25KU01ldGFQcm9taXNlKGNvbW1vbkpzTWV0YVByb21pc2VzLCBpZCwgY29tbW9uanNNZXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0Q29tbW9uSlNNZXRhUHJvbWlzZShjb21tb25Kc01ldGFQcm9taXNlcywgaWQsIG51bGwpO1xuICAgIH1cbiAgfTtcbn1cbiIsICIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZvcm1hdFxuICovXG5cbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRyb2xsZWRQcm9taXNlLFxuICBGbGlwcGVyU2VydmVyRm9yU2VydmVyQWRkT24sXG4gIFNlcnZlckFkZE9uLFxufSBmcm9tICdmbGlwcGVyLXBsdWdpbic7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7V2ViU29ja2V0U2VydmVyLCBXZWJTb2NrZXR9IGZyb20gJ3dzJztcbmltcG9ydCB7cm9sbHVwfSBmcm9tICdyb2xsdXAnO1xuaW1wb3J0IHJlc29sdmUgZnJvbSAnQHJvbGx1cC9wbHVnaW4tbm9kZS1yZXNvbHZlJztcbmltcG9ydCBjb21tb25qcyBmcm9tICdAcm9sbHVwL3BsdWdpbi1jb21tb25qcyc7XG5pbXBvcnQge0V2ZW50cywgTWV0aG9kc30gZnJvbSAnLi9jb250cmFjdCc7XG5cbmNvbnN0IERFVl9UT09MU19QT1JUID0gODA5NzsgLy8gaGFyZGNvZGVkIGluIFJOXG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRHbG9iYWxEZXZUb29scyhcbiAgZmxpcHBlclNlcnZlcjogRmxpcHBlclNlcnZlckZvclNlcnZlckFkZE9uLFxuKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0OiBiYXNlUGF0aH0gPSBhd2FpdCBmbGlwcGVyU2VydmVyLmV4ZWMoXG4gICAgICAnbm9kZS1hcGktZXhlYycsXG4gICAgICAnbnBtIHJvb3QgLWcnLFxuICAgICk7XG4gICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5maW5kR2xvYmFsRGV2VG9vbHMgLT4gbnBtIHJvb3QnLFxuICAgICAgYmFzZVBhdGgsXG4gICAgKTtcbiAgICBjb25zdCBkZXZUb29sc1BhdGggPSBwYXRoLmpvaW4oXG4gICAgICBiYXNlUGF0aC50cmltKCksXG4gICAgICAncmVhY3QtZGV2dG9vbHMtaW5saW5lJyxcbiAgICAgICdmcm9udGVuZC5qcycsXG4gICAgKTtcbiAgICBhd2FpdCBmbGlwcGVyU2VydmVyLmV4ZWMoJ25vZGUtYXBpLWZzLXN0YXQnLCBkZXZUb29sc1BhdGgpO1xuICAgIHJldHVybiBkZXZUb29sc1BhdGg7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZmluZCBnbG9iYWxseSBpbnN0YWxsZWQgUmVhY3QgRGV2VG9vbHM6ICR7ZXJyb3J9YCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5jb25zdCBzZXJ2ZXJBZGRPbjogU2VydmVyQWRkT248RXZlbnRzLCBNZXRob2RzPiA9IGFzeW5jIChcbiAgY29ubmVjdGlvbixcbiAge2ZsaXBwZXJTZXJ2ZXJ9LFxuKSA9PiB7XG4gIGNvbnNvbGUuZGVidWcoJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IHN0YXJ0aW5nJyk7XG5cbiAgY29uc3Qgc3RhcnRTZXJ2ZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5kZWJ1ZygnZmxpcHBlci1wbHVnaW4tcmVhY3QtZGV2dG9vbHMuc2VydmVyQWRkT24gLT4gc3RhcnRTZXJ2ZXInKTtcblxuICAgIGNvbnN0IHdzcyA9IG5ldyBXZWJTb2NrZXRTZXJ2ZXIoe3BvcnQ6IERFVl9UT09MU19QT1JUfSk7XG5cbiAgICBjb25zdCBzdGFydGVkUHJvbWlzZSA9IGNyZWF0ZUNvbnRyb2xsZWRQcm9taXNlPHZvaWQ+KCk7XG4gICAgd3NzLm9uKCdsaXN0ZW5pbmcnLCAoKSA9PiBzdGFydGVkUHJvbWlzZS5yZXNvbHZlKCkpO1xuICAgIHdzcy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoc3RhcnRlZFByb21pc2Uuc3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICBzdGFydGVkUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKCdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBzdGFydGVkUHJvbWlzZS5wcm9taXNlO1xuXG4gICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBzdGFydGVkIHNlcnZlcicsXG4gICAgKTtcblxuICAgIHdzcy5vbignY29ubmVjdGlvbicsICh3cykgPT4ge1xuICAgICAgY29ubmVjdGlvbi5zZW5kKCdjb25uZWN0ZWQnKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBjb25uZWN0ZWQgYSBjbGllbnQnLFxuICAgICAgKTtcblxuICAgICAgd3Mub24oJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ21lc3NhZ2UnLCBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSkpO1xuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBjbGllbnQgc2VudCBhIG1lc3NhZ2UnLFxuICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICB3cy5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IGNsaWVudCBlcnJvcicsXG4gICAgICAgICAgZXJyLFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAnZmxpcHBlci1wbHVnaW4tcmVhY3QtZGV2dG9vbHMuc2VydmVyQWRkT24gLT4gY2xpZW50IGxlZnQnLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25uZWN0aW9uLnJlY2VpdmUoJ21lc3NhZ2UnLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IGRlc2t0b3Agc2VudCBhIG1lc3NhZ2UnLFxuICAgICAgICBkYXRhLFxuICAgICAgKTtcbiAgICAgIC8vIFRPRE86IEZpeCB0aGlzIHRoZSBuZXh0IHRpbWUgdGhlIGZpbGUgaXMgZWRpdGVkLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHdzcyEuY2xpZW50cy5mb3JFYWNoKCh3cykgPT4ge1xuICAgICAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd3NzO1xuICB9O1xuXG4gIGNvbnN0IHdzcyA9IGF3YWl0IHN0YXJ0U2VydmVyKCk7XG5cbiAgY29ubmVjdGlvbi5yZWNlaXZlKCdnbG9iYWxEZXZUb29scycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBnbG9iYWxEZXZUb29sc1BhdGggPSBhd2FpdCBmaW5kR2xvYmFsRGV2VG9vbHMoZmxpcHBlclNlcnZlcik7XG4gICAgaWYgKCFnbG9iYWxEZXZUb29sc1BhdGgpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IG5vdCBmb3VuZCBnbG9iYWwgUmVhY3QgRGV2VG9vbHMnLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5pbmZvKFxuICAgICAgJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IGZvdW5kIGdsb2JhbCBSZWFjdCBEZXZUb29sczogJyxcbiAgICAgIGdsb2JhbERldlRvb2xzUGF0aCxcbiAgICApO1xuXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgcm9sbHVwKHtcbiAgICAgIGlucHV0OiBnbG9iYWxEZXZUb29sc1BhdGgsXG4gICAgICBwbHVnaW5zOiBbcmVzb2x2ZSgpLCBjb21tb25qcygpXSxcbiAgICAgIGV4dGVybmFsOiBbJ3JlYWN0JywgJ3JlYWN0LWlzJywgJ3JlYWN0LWRvbS9jbGllbnQnLCAncmVhY3QtZG9tJ10sXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qge291dHB1dH0gPSBhd2FpdCBidW5kbGUuZ2VuZXJhdGUoe1xuICAgICAgICBmb3JtYXQ6ICdpaWZlJyxcbiAgICAgICAgZ2xvYmFsczoge1xuICAgICAgICAgIHJlYWN0OiAnZ2xvYmFsLlJlYWN0JyxcbiAgICAgICAgICAncmVhY3QtaXMnOiAnZ2xvYmFsLlJlYWN0SXMnLFxuICAgICAgICAgICdyZWFjdC1kb20vY2xpZW50JzogJ2dsb2JhbC5SZWFjdERPTUNsaWVudCcsXG4gICAgICAgICAgJ3JlYWN0LWRvbSc6ICdnbG9iYWwuUmVhY3RET00nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3V0cHV0WzBdLmNvZGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGJ1bmRsZS5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmRlYnVnKCdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBzdG9wcGluZycpO1xuICAgIGlmICh3c3MpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICdmbGlwcGVyLXBsdWdpbi1yZWFjdC1kZXZ0b29scy5zZXJ2ZXJBZGRPbiAtPiBzdG9wcGluZyB3c3MnLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIC8vIFRPRE86IEZpeCB0aGlzIHRoZSBuZXh0IHRpbWUgdGhlIGZpbGUgaXMgZWRpdGVkLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB3c3MhLmNsb3NlKChlcnIpID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSkpLFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoJ2ZsaXBwZXItcGx1Z2luLXJlYWN0LWRldnRvb2xzLnNlcnZlckFkZE9uIC0+IHN0b3BwZWQgd3NzJyk7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2VydmVyQWRkT247XG4iLCAiaW1wb3J0IGNyZWF0ZVdlYlNvY2tldFN0cmVhbSBmcm9tICcuL2xpYi9zdHJlYW0uanMnO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gJy4vbGliL3JlY2VpdmVyLmpzJztcbmltcG9ydCBTZW5kZXIgZnJvbSAnLi9saWIvc2VuZGVyLmpzJztcbmltcG9ydCBXZWJTb2NrZXQgZnJvbSAnLi9saWIvd2Vic29ja2V0LmpzJztcbmltcG9ydCBXZWJTb2NrZXRTZXJ2ZXIgZnJvbSAnLi9saWIvd2Vic29ja2V0LXNlcnZlci5qcyc7XG5cbmV4cG9ydCB7IGNyZWF0ZVdlYlNvY2tldFN0cmVhbSwgUmVjZWl2ZXIsIFNlbmRlciwgV2ViU29ja2V0LCBXZWJTb2NrZXRTZXJ2ZXIgfTtcbmV4cG9ydCBkZWZhdWx0IFdlYlNvY2tldDtcbiIsICIvKlxuICBAbGljZW5zZVxuXHRSb2xsdXAuanMgdjIuNzAuMVxuXHRNb24sIDE0IE1hciAyMDIyIDA1OjUwOjA4IEdNVCAtIGNvbW1pdCBiODMxNWUwM2Y5NzkwZDYxMGE0MTMzMTZmYmY2ZDU2NWY5MzQwY2FiXG5cblx0aHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXBcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuZXhwb3J0IHsgdmVyc2lvbiBhcyBWRVJTSU9OLCBkZWZpbmVDb25maWcsIHJvbGx1cCwgd2F0Y2ggfSBmcm9tICcuL3NoYXJlZC9yb2xsdXAuanMnO1xuaW1wb3J0ICdwYXRoJztcbmltcG9ydCAncHJvY2Vzcyc7XG5pbXBvcnQgJ3BlcmZfaG9va3MnO1xuaW1wb3J0ICdjcnlwdG8nO1xuaW1wb3J0ICdmcyc7XG5pbXBvcnQgJ2V2ZW50cyc7XG4iLCAiaW1wb3J0IHBhdGgsIHsgZGlybmFtZSwgcmVzb2x2ZSwgZXh0bmFtZSwgbm9ybWFsaXplLCBzZXAgfSBmcm9tICdwYXRoJztcbmltcG9ydCBidWlsdGluTGlzdCBmcm9tICdidWlsdGluLW1vZHVsZXMnO1xuaW1wb3J0IGRlZXBNZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IGlzTW9kdWxlIGZyb20gJ2lzLW1vZHVsZSc7XG5pbXBvcnQgZnMsIHsgcmVhbHBhdGhTeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBwYXRoVG9GaWxlVVJMLCBmaWxlVVJMVG9QYXRoIH0gZnJvbSAndXJsJztcbmltcG9ydCByZXNvbHZlJDEgZnJvbSAncmVzb2x2ZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWx0ZXIgfSBmcm9tICdAcm9sbHVwL3BsdWdpbnV0aWxzJztcblxudmFyIHZlcnNpb24gPSBcIjEzLjEuM1wiO1xuXG5wcm9taXNpZnkoZnMuYWNjZXNzKTtcbmNvbnN0IHJlYWRGaWxlJDEgPSBwcm9taXNpZnkoZnMucmVhZEZpbGUpO1xuY29uc3QgcmVhbHBhdGggPSBwcm9taXNpZnkoZnMucmVhbHBhdGgpO1xuY29uc3Qgc3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcblxuYXN5bmMgZnVuY3Rpb24gZmlsZUV4aXN0cyhmaWxlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN0YXQoZmlsZVBhdGgpO1xuICAgIHJldHVybiByZXMuaXNGaWxlKCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlU3ltbGluayhwYXRoKSB7XG4gIHJldHVybiAoYXdhaXQgZmlsZUV4aXN0cyhwYXRoKSkgPyByZWFscGF0aChwYXRoKSA6IHBhdGg7XG59XG5cbmNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRocm93IGVycm9yO1xufTtcblxuY29uc3QgbWFrZUNhY2hlID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCB3cmFwcGVkID0gYXN5bmMgKHBhcmFtLCBkb25lKSA9PiB7XG4gICAgaWYgKGNhY2hlLmhhcyhwYXJhbSkgPT09IGZhbHNlKSB7XG4gICAgICBjYWNoZS5zZXQoXG4gICAgICAgIHBhcmFtLFxuICAgICAgICBmbihwYXJhbSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGNhY2hlLmRlbGV0ZShwYXJhbSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FjaGUuZ2V0KHBhcmFtKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIGRvbmUobnVsbCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHdyYXBwZWQuY2xlYXIgPSAoKSA9PiBjYWNoZS5jbGVhcigpO1xuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcblxuY29uc3QgaXNEaXJDYWNoZWQgPSBtYWtlQ2FjaGUoYXN5bmMgKGZpbGUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHN0YXQoZmlsZSk7XG4gICAgcmV0dXJuIHN0YXRzLmlzRGlyZWN0b3J5KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuICB9XG59KTtcblxuY29uc3QgaXNGaWxlQ2FjaGVkID0gbWFrZUNhY2hlKGFzeW5jIChmaWxlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0KGZpbGUpO1xuICAgIHJldHVybiBzdGF0cy5pc0ZpbGUoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gb25FcnJvcihlcnJvcik7XG4gIH1cbn0pO1xuXG5jb25zdCByZWFkQ2FjaGVkRmlsZSA9IG1ha2VDYWNoZShyZWFkRmlsZSQxKTtcblxuZnVuY3Rpb24gaGFuZGxlRGVwcmVjYXRlZE9wdGlvbnMob3B0cykge1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuXG4gIGlmIChvcHRzLmN1c3RvbVJlc29sdmVPcHRpb25zKSB7XG4gICAgY29uc3QgeyBjdXN0b21SZXNvbHZlT3B0aW9ucyB9ID0gb3B0cztcbiAgICBpZiAoY3VzdG9tUmVzb2x2ZU9wdGlvbnMubW9kdWxlRGlyZWN0b3J5KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG9wdHMubW9kdWxlRGlyZWN0b3JpZXMgPSBBcnJheS5pc0FycmF5KGN1c3RvbVJlc29sdmVPcHRpb25zLm1vZHVsZURpcmVjdG9yeSlcbiAgICAgICAgPyBjdXN0b21SZXNvbHZlT3B0aW9ucy5tb2R1bGVEaXJlY3RvcnlcbiAgICAgICAgOiBbY3VzdG9tUmVzb2x2ZU9wdGlvbnMubW9kdWxlRGlyZWN0b3J5XTtcblxuICAgICAgd2FybmluZ3MucHVzaChcbiAgICAgICAgJ25vZGUtcmVzb2x2ZTogVGhlIGBjdXN0b21SZXNvbHZlT3B0aW9ucy5tb2R1bGVEaXJlY3RvcnlgIG9wdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgYG1vZHVsZURpcmVjdG9yaWVzYCwgd2hpY2ggbXVzdCBiZSBhbiBhcnJheS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjdXN0b21SZXNvbHZlT3B0aW9ucy5wcmVzZXJ2ZVN5bWxpbmtzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdub2RlLXJlc29sdmU6IGBjdXN0b21SZXNvbHZlT3B0aW9ucy5wcmVzZXJ2ZVN5bWxpbmtzYCBpcyBubyBsb25nZXIgYW4gb3B0aW9uLiBXZSBub3cgYWx3YXlzIHVzZSB0aGUgcm9sbHVwIGBwcmVzZXJ2ZVN5bWxpbmtzYCBvcHRpb24uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBbXG4gICAgICAnYmFzZWRpcicsXG4gICAgICAncGFja2FnZScsXG4gICAgICAnZXh0ZW5zaW9ucycsXG4gICAgICAnaW5jbHVkZUNvcmVNb2R1bGVzJyxcbiAgICAgICdyZWFkRmlsZScsXG4gICAgICAnaXNGaWxlJyxcbiAgICAgICdpc0RpcmVjdG9yeScsXG4gICAgICAncmVhbHBhdGgnLFxuICAgICAgJ3BhY2thZ2VGaWx0ZXInLFxuICAgICAgJ3BhdGhGaWx0ZXInLFxuICAgICAgJ3BhdGhzJyxcbiAgICAgICdwYWNrYWdlSXRlcmF0b3InXG4gICAgXS5mb3JFYWNoKChyZXNvbHZlT3B0aW9uKSA9PiB7XG4gICAgICBpZiAoY3VzdG9tUmVzb2x2ZU9wdGlvbnNbcmVzb2x2ZU9wdGlvbl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBub2RlLXJlc29sdmU6IFxcYGN1c3RvbVJlc29sdmVPcHRpb25zLiR7cmVzb2x2ZU9wdGlvbn1cXGAgaXMgbm8gbG9uZ2VyIGFuIG9wdGlvbi4gSWYgeW91IG5lZWQgdGhpcywgcGxlYXNlIG9wZW4gYW4gaXNzdWUuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHsgd2FybmluZ3MgfTtcbn1cblxuLy8gcmV0dXJucyB0aGUgaW1wb3J0ZWQgcGFja2FnZSBuYW1lIGZvciBiYXJlIG1vZHVsZSBpbXBvcnRzXG5mdW5jdGlvbiBnZXRQYWNrYWdlTmFtZShpZCkge1xuICBpZiAoaWQuc3RhcnRzV2l0aCgnLicpIHx8IGlkLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgc3BsaXQgPSBpZC5zcGxpdCgnLycpO1xuXG4gIC8vIEBteS1zY29wZS9teS1wYWNrYWdlL2Zvby5qcyAtPiBAbXktc2NvcGUvbXktcGFja2FnZVxuICAvLyBAbXktc2NvcGUvbXktcGFja2FnZSAtPiBAbXktc2NvcGUvbXktcGFja2FnZVxuICBpZiAoc3BsaXRbMF1bMF0gPT09ICdAJykge1xuICAgIHJldHVybiBgJHtzcGxpdFswXX0vJHtzcGxpdFsxXX1gO1xuICB9XG5cbiAgLy8gbXktcGFja2FnZS9mb28uanMgLT4gbXktcGFja2FnZVxuICAvLyBteS1wYWNrYWdlIC0+IG15LXBhY2thZ2VcbiAgcmV0dXJuIHNwbGl0WzBdO1xufVxuXG5mdW5jdGlvbiBnZXRNYWluRmllbGRzKG9wdGlvbnMpIHtcbiAgbGV0IG1haW5GaWVsZHM7XG4gIGlmIChvcHRpb25zLm1haW5GaWVsZHMpIHtcbiAgICAoeyBtYWluRmllbGRzIH0gPSBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBtYWluRmllbGRzID0gWydtb2R1bGUnLCAnbWFpbiddO1xuICB9XG4gIGlmIChvcHRpb25zLmJyb3dzZXIgJiYgbWFpbkZpZWxkcy5pbmRleE9mKCdicm93c2VyJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIFsnYnJvd3NlciddLmNvbmNhdChtYWluRmllbGRzKTtcbiAgfVxuICBpZiAoIW1haW5GaWVsZHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgZW5zdXJlIGF0IGxlYXN0IG9uZSBgbWFpbkZpZWxkc2AgdmFsdWUgaXMgc3BlY2lmaWVkJyk7XG4gIH1cbiAgcmV0dXJuIG1haW5GaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGdldFBhY2thZ2VJbmZvKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGNhY2hlLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgcGtnLFxuICAgIG1haW5GaWVsZHMsXG4gICAgcHJlc2VydmVTeW1saW5rcyxcbiAgICB1c2VCcm93c2VyT3ZlcnJpZGVzLFxuICAgIHJvb3REaXIsXG4gICAgaWdub3JlU2lkZUVmZmVjdHNGb3JSb290XG4gIH0gPSBvcHRpb25zO1xuICBsZXQgeyBwa2dQYXRoIH0gPSBvcHRpb25zO1xuXG4gIGlmIChjYWNoZS5oYXMocGtnUGF0aCkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KHBrZ1BhdGgpO1xuICB9XG5cbiAgLy8gYnJvd3NlcmlmeS9yZXNvbHZlIGRvZXNuJ3QgcmVhbHBhdGggcGF0aHMgcmV0dXJuZWQgaW4gaXRzIHBhY2thZ2VGaWx0ZXIgY2FsbGJhY2tcbiAgaWYgKCFwcmVzZXJ2ZVN5bWxpbmtzKSB7XG4gICAgcGtnUGF0aCA9IHJlYWxwYXRoU3luYyhwa2dQYXRoKTtcbiAgfVxuXG4gIGNvbnN0IHBrZ1Jvb3QgPSBkaXJuYW1lKHBrZ1BhdGgpO1xuXG4gIGNvbnN0IHBhY2thZ2VJbmZvID0ge1xuICAgIC8vIGNvcHkgYXMgd2UgYXJlIGFib3V0IHRvIG11bmdlIHRoZSBgbWFpbmAgZmllbGQgb2YgYHBrZ2AuXG4gICAgcGFja2FnZUpzb246IHsgLi4ucGtnIH0sXG5cbiAgICAvLyBwYXRoIHRvIHBhY2thZ2UuanNvbiBmaWxlXG4gICAgcGFja2FnZUpzb25QYXRoOiBwa2dQYXRoLFxuXG4gICAgLy8gZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIHBhY2thZ2UuanNvblxuICAgIHJvb3Q6IHBrZ1Jvb3QsXG5cbiAgICAvLyB3aGljaCBtYWluIGZpZWxkIHdhcyB1c2VkIGR1cmluZyByZXNvbHV0aW9uIG9mIHRoaXMgbW9kdWxlIChtYWluLCBtb2R1bGUsIG9yIGJyb3dzZXIpXG4gICAgcmVzb2x2ZWRNYWluRmllbGQ6ICdtYWluJyxcblxuICAgIC8vIHdoZXRoZXIgdGhlIGJyb3dzZXIgbWFwIHdhcyB1c2VkIHRvIHJlc29sdmUgdGhlIGVudHJ5IHBvaW50IHRvIHRoaXMgbW9kdWxlXG4gICAgYnJvd3Nlck1hcHBlZE1haW46IGZhbHNlLFxuXG4gICAgLy8gdGhlIGVudHJ5IHBvaW50IG9mIHRoZSBtb2R1bGUgd2l0aCByZXNwZWN0IHRvIHRoZSBzZWxlY3RlZCBtYWluIGZpZWxkIGFuZCBhbnlcbiAgICAvLyByZWxldmFudCBicm93c2VyIG1hcHBpbmdzLlxuICAgIHJlc29sdmVkRW50cnlQb2ludDogJydcbiAgfTtcblxuICBsZXQgb3ZlcnJpZGRlbk1haW4gPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYWluRmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmllbGQgPSBtYWluRmllbGRzW2ldO1xuICAgIGlmICh0eXBlb2YgcGtnW2ZpZWxkXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBrZy5tYWluID0gcGtnW2ZpZWxkXTtcbiAgICAgIHBhY2thZ2VJbmZvLnJlc29sdmVkTWFpbkZpZWxkID0gZmllbGQ7XG4gICAgICBvdmVycmlkZGVuTWFpbiA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbnRlcm5hbFBhY2thZ2VJbmZvID0ge1xuICAgIGNhY2hlZFBrZzogcGtnLFxuICAgIGhhc01vZHVsZVNpZGVFZmZlY3RzOiAoKSA9PiBudWxsLFxuICAgIGhhc1BhY2thZ2VFbnRyeTogb3ZlcnJpZGRlbk1haW4gIT09IGZhbHNlIHx8IG1haW5GaWVsZHMuaW5kZXhPZignbWFpbicpICE9PSAtMSxcbiAgICBwYWNrYWdlQnJvd3NlckZpZWxkOlxuICAgICAgdXNlQnJvd3Nlck92ZXJyaWRlcyAmJlxuICAgICAgdHlwZW9mIHBrZy5icm93c2VyID09PSAnb2JqZWN0JyAmJlxuICAgICAgT2JqZWN0LmtleXMocGtnLmJyb3dzZXIpLnJlZHVjZSgoYnJvd3Nlciwga2V5KSA9PiB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHBrZy5icm93c2VyW2tleV07XG4gICAgICAgIGlmIChyZXNvbHZlZCAmJiByZXNvbHZlZFswXSA9PT0gJy4nKSB7XG4gICAgICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlKHBrZ1Jvb3QsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICBicm93c2VyW2tleV0gPSByZXNvbHZlZDtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJy4nKSB7XG4gICAgICAgICAgY29uc3QgYWJzb2x1dGVLZXkgPSByZXNvbHZlKHBrZ1Jvb3QsIGtleSk7XG4gICAgICAgICAgYnJvd3NlclthYnNvbHV0ZUtleV0gPSByZXNvbHZlZDtcbiAgICAgICAgICBpZiAoIWV4dG5hbWUoa2V5KSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZWR1Y2UoKHN1YkJyb3dzZXIsIGV4dCkgPT4ge1xuICAgICAgICAgICAgICBzdWJCcm93c2VyW2Fic29sdXRlS2V5ICsgZXh0XSA9IHN1YkJyb3dzZXJba2V5XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN1YkJyb3dzZXI7XG4gICAgICAgICAgICB9LCBicm93c2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgICB9LCB7fSksXG4gICAgcGFja2FnZUluZm9cbiAgfTtcblxuICBjb25zdCBicm93c2VyTWFwID0gaW50ZXJuYWxQYWNrYWdlSW5mby5wYWNrYWdlQnJvd3NlckZpZWxkO1xuICBpZiAoXG4gICAgdXNlQnJvd3Nlck92ZXJyaWRlcyAmJlxuICAgIHR5cGVvZiBwa2cuYnJvd3NlciA9PT0gJ29iamVjdCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgYnJvd3Nlck1hcC5oYXNPd25Qcm9wZXJ0eShwa2cubWFpbilcbiAgKSB7XG4gICAgcGFja2FnZUluZm8ucmVzb2x2ZWRFbnRyeVBvaW50ID0gYnJvd3Nlck1hcFtwa2cubWFpbl07XG4gICAgcGFja2FnZUluZm8uYnJvd3Nlck1hcHBlZE1haW4gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGluZGV4Lm5vZGUgaXMgdGVjaG5pY2FsbHkgYSB2YWxpZCBkZWZhdWx0IGVudHJ5cG9pbnQgYXMgd2VsbC4uLlxuICAgIHBhY2thZ2VJbmZvLnJlc29sdmVkRW50cnlQb2ludCA9IHJlc29sdmUocGtnUm9vdCwgcGtnLm1haW4gfHwgJ2luZGV4LmpzJyk7XG4gICAgcGFja2FnZUluZm8uYnJvd3Nlck1hcHBlZE1haW4gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghaWdub3JlU2lkZUVmZmVjdHNGb3JSb290IHx8IHJvb3REaXIgIT09IHBrZ1Jvb3QpIHtcbiAgICBjb25zdCBwYWNrYWdlU2lkZUVmZmVjdHMgPSBwa2cuc2lkZUVmZmVjdHM7XG4gICAgaWYgKHR5cGVvZiBwYWNrYWdlU2lkZUVmZmVjdHMgPT09ICdib29sZWFuJykge1xuICAgICAgaW50ZXJuYWxQYWNrYWdlSW5mby5oYXNNb2R1bGVTaWRlRWZmZWN0cyA9ICgpID0+IHBhY2thZ2VTaWRlRWZmZWN0cztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFja2FnZVNpZGVFZmZlY3RzKSkge1xuICAgICAgaW50ZXJuYWxQYWNrYWdlSW5mby5oYXNNb2R1bGVTaWRlRWZmZWN0cyA9IGNyZWF0ZUZpbHRlcihwYWNrYWdlU2lkZUVmZmVjdHMsIG51bGwsIHtcbiAgICAgICAgcmVzb2x2ZTogcGtnUm9vdFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUuc2V0KHBrZ1BhdGgsIGludGVybmFsUGFja2FnZUluZm8pO1xuICByZXR1cm4gaW50ZXJuYWxQYWNrYWdlSW5mbztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSW5wdXQoaW5wdXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnB1dCk7XG4gIH1cblxuICAvLyBvdGhlcndpc2UgaXQncyBhIHN0cmluZ1xuICByZXR1cm4gW2lucHV0XTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYXdhaXQtaW4tbG9vcCAqL1xuXG5mdW5jdGlvbiBpc01vZHVsZURpcihjdXJyZW50LCBtb2R1bGVEaXJzKSB7XG4gIHJldHVybiBtb2R1bGVEaXJzLnNvbWUoKGRpcikgPT4gY3VycmVudC5lbmRzV2l0aChkaXIpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZFBhY2thZ2VKc29uKGJhc2UsIG1vZHVsZURpcnMpIHtcbiAgY29uc3QgeyByb290IH0gPSBwYXRoLnBhcnNlKGJhc2UpO1xuICBsZXQgY3VycmVudCA9IGJhc2U7XG5cbiAgd2hpbGUgKGN1cnJlbnQgIT09IHJvb3QgJiYgIWlzTW9kdWxlRGlyKGN1cnJlbnQsIG1vZHVsZURpcnMpKSB7XG4gICAgY29uc3QgcGtnSnNvblBhdGggPSBwYXRoLmpvaW4oY3VycmVudCwgJ3BhY2thZ2UuanNvbicpO1xuICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKHBrZ0pzb25QYXRoKSkge1xuICAgICAgY29uc3QgcGtnSnNvblN0cmluZyA9IGZzLnJlYWRGaWxlU3luYyhwa2dKc29uUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICByZXR1cm4geyBwa2dKc29uOiBKU09OLnBhcnNlKHBrZ0pzb25TdHJpbmcpLCBwa2dQYXRoOiBjdXJyZW50LCBwa2dKc29uUGF0aCB9O1xuICAgIH1cbiAgICBjdXJyZW50ID0gcGF0aC5yZXNvbHZlKGN1cnJlbnQsICcuLicpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VybChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFuZXcgVVJMKHN0cik7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb25kaXRpb25zKGV4cG9ydHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhleHBvcnRzKS5ldmVyeSgoaykgPT4gIWsuc3RhcnRzV2l0aCgnLicpKTtcbn1cblxuZnVuY3Rpb24gaXNNYXBwaW5ncyhleHBvcnRzKSB7XG4gIHJldHVybiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgIWlzQ29uZGl0aW9ucyhleHBvcnRzKTtcbn1cblxuZnVuY3Rpb24gaXNNaXhlZEV4cG9ydHMoZXhwb3J0cykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cyk7XG4gIHJldHVybiBrZXlzLnNvbWUoKGspID0+IGsuc3RhcnRzV2l0aCgnLicpKSAmJiBrZXlzLnNvbWUoKGspID0+ICFrLnN0YXJ0c1dpdGgoJy4nKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFcnJvck1zZyhpbXBvcnRTcGVjaWZpZXIsIGltcG9ydGVyKSB7XG4gIHJldHVybiBgQ291bGQgbm90IHJlc29sdmUgaW1wb3J0IFwiJHtpbXBvcnRTcGVjaWZpZXJ9XCIgaW4gJHtpbXBvcnRlcn1gO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJvck1zZyhjb250ZXh0LCByZWFzb24sIGludGVybmFsKSB7XG4gIGNvbnN0IHsgaW1wb3J0U3BlY2lmaWVyLCBpbXBvcnRlciwgcGtnSnNvblBhdGggfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGJhc2UgPSBjcmVhdGVCYXNlRXJyb3JNc2coaW1wb3J0U3BlY2lmaWVyLCBpbXBvcnRlcik7XG4gIGNvbnN0IGZpZWxkID0gaW50ZXJuYWwgPyAnaW1wb3J0cycgOiAnZXhwb3J0cyc7XG4gIHJldHVybiBgJHtiYXNlfSB1c2luZyAke2ZpZWxkfSBkZWZpbmVkIGluICR7cGtnSnNvblBhdGh9LiR7cmVhc29uID8gYCAke3JlYXNvbn1gIDogJyd9YDtcbn1cblxuY2xhc3MgUmVzb2x2ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIFJlc29sdmVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlYXNvbikge1xuICAgIHN1cGVyKGNyZWF0ZUVycm9yTXNnKGNvbnRleHQsIGBJbnZhbGlkIFwiZXhwb3J0c1wiIGZpZWxkLiAke3JlYXNvbn1gKSk7XG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZE1vZHVsZVNwZWNpZmllckVycm9yIGV4dGVuZHMgUmVzb2x2ZUVycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgaW50ZXJuYWwsIHJlYXNvbikge1xuICAgIHN1cGVyKGNyZWF0ZUVycm9yTXNnKGNvbnRleHQsIHJlYXNvbiwgaW50ZXJuYWwpKTtcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkUGFja2FnZVRhcmdldEVycm9yIGV4dGVuZHMgUmVzb2x2ZUVycm9yIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgcmVhc29uKSB7XG4gICAgc3VwZXIoY3JlYXRlRXJyb3JNc2coY29udGV4dCwgcmVhc29uKSk7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYXdhaXQtaW4tbG9vcCwgbm8tdW5kZWZpbmVkICovXG5cbmZ1bmN0aW9uIGluY2x1ZGVzSW52YWxpZFNlZ21lbnRzKHBhdGhTZWdtZW50cywgbW9kdWxlRGlycykge1xuICByZXR1cm4gcGF0aFNlZ21lbnRzXG4gICAgLnNwbGl0KCcvJylcbiAgICAuc2xpY2UoMSlcbiAgICAuc29tZSgodCkgPT4gWycuJywgJy4uJywgLi4ubW9kdWxlRGlyc10uaW5jbHVkZXModCkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUGFja2FnZVRhcmdldChjb250ZXh0LCB7IHRhcmdldCwgc3VicGF0aCwgcGF0dGVybiwgaW50ZXJuYWwgfSkge1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXBhdHRlcm4gJiYgc3VicGF0aC5sZW5ndGggPiAwICYmICF0YXJnZXQuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNb2R1bGVTcGVjaWZpZXJFcnJvcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICBpZiAoaW50ZXJuYWwgJiYgIVsnLycsICcuLi8nXS5zb21lKChwKSA9PiB0YXJnZXQuc3RhcnRzV2l0aChwKSkgJiYgIWlzVXJsKHRhcmdldCkpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIGJhcmUgcGFja2FnZSBpbXBvcnQsIHJlbWFwIGl0IGFuZCByZXNvbHZlIGl0IHVzaW5nIHJlZ3VsYXIgbm9kZSByZXNvbHZlXG4gICAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udGV4dC5yZXNvbHZlSWQoXG4gICAgICAgICAgICB0YXJnZXQucmVwbGFjZSgvXFwqL2csIHN1YnBhdGgpLFxuICAgICAgICAgICAgY29udGV4dC5wa2dVUkwuaHJlZlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHBhdGhUb0ZpbGVVUkwocmVzdWx0LmxvY2F0aW9uKS5ocmVmIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRleHQucmVzb2x2ZUlkKGAke3RhcmdldH0ke3N1YnBhdGh9YCwgY29udGV4dC5wa2dVUkwuaHJlZik7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyBwYXRoVG9GaWxlVVJMKHJlc3VsdC5sb2NhdGlvbikuaHJlZiA6IG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhY2thZ2VUYXJnZXRFcnJvcihjb250ZXh0LCBgSW52YWxpZCBtYXBwaW5nOiBcIiR7dGFyZ2V0fVwiLmApO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlc0ludmFsaWRTZWdtZW50cyh0YXJnZXQsIGNvbnRleHQubW9kdWxlRGlycykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFja2FnZVRhcmdldEVycm9yKGNvbnRleHQsIGBJbnZhbGlkIG1hcHBpbmc6IFwiJHt0YXJnZXR9XCIuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSBuZXcgVVJMKHRhcmdldCwgY29udGV4dC5wa2dVUkwpO1xuICAgIGlmICghcmVzb2x2ZWRUYXJnZXQuaHJlZi5zdGFydHNXaXRoKGNvbnRleHQucGtnVVJMLmhyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhY2thZ2VUYXJnZXRFcnJvcihcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYFJlc29sdmVkIHRvICR7cmVzb2x2ZWRUYXJnZXQuaHJlZn0gd2hpY2ggaXMgb3V0c2lkZSBwYWNrYWdlICR7Y29udGV4dC5wa2dVUkwuaHJlZn1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlc0ludmFsaWRTZWdtZW50cyhzdWJwYXRoLCBjb250ZXh0Lm1vZHVsZURpcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1vZHVsZVNwZWNpZmllckVycm9yKGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRUYXJnZXQuaHJlZi5yZXBsYWNlKC9cXCovZywgc3VicGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVVJMKHN1YnBhdGgsIHJlc29sdmVkVGFyZ2V0KS5ocmVmO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGxldCBsYXN0RXJyb3I7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRhcmdldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCByZXNvbHZlUGFja2FnZVRhcmdldChjb250ZXh0LCB7XG4gICAgICAgICAgdGFyZ2V0OiBpdGVtLFxuICAgICAgICAgIHN1YnBhdGgsXG4gICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXR1cm4gaWYgZGVmaW5lZCBvciBudWxsLCBidXQgbm90IHVuZGVmaW5lZFxuICAgICAgICBpZiAocmVzb2x2ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkUGFja2FnZVRhcmdldEVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0YXJnZXQpKSB7XG4gICAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcgfHwgY29udGV4dC5jb25kaXRpb25zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCByZXNvbHZlUGFja2FnZVRhcmdldChjb250ZXh0LCB7XG4gICAgICAgICAgdGFyZ2V0OiB2YWx1ZSxcbiAgICAgICAgICBzdWJwYXRoLFxuICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGlmIGRlZmluZWQgb3IgbnVsbCwgYnV0IG5vdCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHJlc29sdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkUGFja2FnZVRhcmdldEVycm9yKGNvbnRleHQsIGBJbnZhbGlkIGV4cG9ydHMgZmllbGQuYCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVBhY2thZ2VJbXBvcnRzRXhwb3J0cyhjb250ZXh0LCB7IG1hdGNoS2V5LCBtYXRjaE9iaiwgaW50ZXJuYWwgfSkge1xuICBpZiAoIW1hdGNoS2V5LmVuZHNXaXRoKCcqJykgJiYgbWF0Y2hLZXkgaW4gbWF0Y2hPYmopIHtcbiAgICBjb25zdCB0YXJnZXQgPSBtYXRjaE9ialttYXRjaEtleV07XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCByZXNvbHZlUGFja2FnZVRhcmdldChjb250ZXh0LCB7IHRhcmdldCwgc3VicGF0aDogJycsIGludGVybmFsIH0pO1xuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIGNvbnN0IGV4cGFuc2lvbktleXMgPSBPYmplY3Qua2V5cyhtYXRjaE9iailcbiAgICAuZmlsdGVyKChrKSA9PiBrLmVuZHNXaXRoKCcvJykgfHwgay5lbmRzV2l0aCgnKicpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcblxuICBmb3IgKGNvbnN0IGV4cGFuc2lvbktleSBvZiBleHBhbnNpb25LZXlzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZXhwYW5zaW9uS2V5LnN1YnN0cmluZygwLCBleHBhbnNpb25LZXkubGVuZ3RoIC0gMSk7XG5cbiAgICBpZiAoZXhwYW5zaW9uS2V5LmVuZHNXaXRoKCcqJykgJiYgbWF0Y2hLZXkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBtYXRjaE9ialtleHBhbnNpb25LZXldO1xuICAgICAgY29uc3Qgc3VicGF0aCA9IG1hdGNoS2V5LnN1YnN0cmluZyhleHBhbnNpb25LZXkubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmVQYWNrYWdlVGFyZ2V0KGNvbnRleHQsIHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBzdWJwYXRoLFxuICAgICAgICBwYXR0ZXJuOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoS2V5LnN0YXJ0c1dpdGgoZXhwYW5zaW9uS2V5KSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hPYmpbZXhwYW5zaW9uS2V5XTtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBtYXRjaEtleS5zdWJzdHJpbmcoZXhwYW5zaW9uS2V5Lmxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgcmVzb2x2ZVBhY2thZ2VUYXJnZXQoY29udGV4dCwgeyB0YXJnZXQsIHN1YnBhdGgsIGludGVybmFsIH0pO1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyRXJyb3IoY29udGV4dCwgaW50ZXJuYWwpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUGFja2FnZUV4cG9ydHMoY29udGV4dCwgc3VicGF0aCwgZXhwb3J0cykge1xuICBpZiAoaXNNaXhlZEV4cG9ydHMoZXhwb3J0cykpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcihcbiAgICAgIGNvbnRleHQsXG4gICAgICAnQWxsIGtleXMgbXVzdCBlaXRoZXIgc3RhcnQgd2l0aCAuLywgb3Igd2l0aG91dCBvbmUuJ1xuICAgICk7XG4gIH1cblxuICBpZiAoc3VicGF0aCA9PT0gJy4nKSB7XG4gICAgbGV0IG1haW5FeHBvcnQ7XG4gICAgLy8gSWYgZXhwb3J0cyBpcyBhIFN0cmluZyBvciBBcnJheSwgb3IgYW4gT2JqZWN0IGNvbnRhaW5pbmcgbm8ga2V5cyBzdGFydGluZyB3aXRoIFwiLlwiLCB0aGVuXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGV4cG9ydHMpIHx8IGlzQ29uZGl0aW9ucyhleHBvcnRzKSkge1xuICAgICAgbWFpbkV4cG9ydCA9IGV4cG9ydHM7XG4gICAgfSBlbHNlIGlmIChpc01hcHBpbmdzKGV4cG9ydHMpKSB7XG4gICAgICBtYWluRXhwb3J0ID0gZXhwb3J0c1snLiddO1xuICAgIH1cblxuICAgIGlmIChtYWluRXhwb3J0KSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmVQYWNrYWdlVGFyZ2V0KGNvbnRleHQsIHsgdGFyZ2V0OiBtYWluRXhwb3J0LCBzdWJwYXRoOiAnJyB9KTtcbiAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTWFwcGluZ3MoZXhwb3J0cykpIHtcbiAgICBjb25zdCByZXNvbHZlZE1hdGNoID0gYXdhaXQgcmVzb2x2ZVBhY2thZ2VJbXBvcnRzRXhwb3J0cyhjb250ZXh0LCB7XG4gICAgICBtYXRjaEtleTogc3VicGF0aCxcbiAgICAgIG1hdGNoT2JqOiBleHBvcnRzXG4gICAgfSk7XG5cbiAgICBpZiAocmVzb2x2ZWRNYXRjaCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkTWF0Y2g7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEludmFsaWRNb2R1bGVTcGVjaWZpZXJFcnJvcihjb250ZXh0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVBhY2thZ2VJbXBvcnRzKHtcbiAgaW1wb3J0U3BlY2lmaWVyLFxuICBpbXBvcnRlcixcbiAgbW9kdWxlRGlycyxcbiAgY29uZGl0aW9ucyxcbiAgcmVzb2x2ZUlkXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbmRQYWNrYWdlSnNvbihpbXBvcnRlciwgbW9kdWxlRGlycyk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGNyZWF0ZUJhc2VFcnJvck1zZygnLiBDb3VsZCBub3QgZmluZCBhIHBhcmVudCBwYWNrYWdlLmpzb24uJykpO1xuICB9XG5cbiAgY29uc3QgeyBwa2dQYXRoLCBwa2dKc29uUGF0aCwgcGtnSnNvbiB9ID0gcmVzdWx0O1xuICBjb25zdCBwa2dVUkwgPSBwYXRoVG9GaWxlVVJMKGAke3BrZ1BhdGh9L2ApO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGltcG9ydGVyLFxuICAgIGltcG9ydFNwZWNpZmllcixcbiAgICBtb2R1bGVEaXJzLFxuICAgIHBrZ1VSTCxcbiAgICBwa2dKc29uUGF0aCxcbiAgICBjb25kaXRpb25zLFxuICAgIHJlc29sdmVJZFxuICB9O1xuXG4gIGNvbnN0IHsgaW1wb3J0cyB9ID0gcGtnSnNvbjtcbiAgaWYgKCFpbXBvcnRzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRNb2R1bGVTcGVjaWZpZXJFcnJvcihjb250ZXh0LCB0cnVlKTtcbiAgfVxuXG4gIGlmIChpbXBvcnRTcGVjaWZpZXIgPT09ICcjJyB8fCBpbXBvcnRTcGVjaWZpZXIuc3RhcnRzV2l0aCgnIy8nKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyRXJyb3IoY29udGV4dCwgdHJ1ZSwgJ0ludmFsaWQgaW1wb3J0IHNwZWNpZmllci4nKTtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlUGFja2FnZUltcG9ydHNFeHBvcnRzKGNvbnRleHQsIHtcbiAgICBtYXRjaEtleTogaW1wb3J0U3BlY2lmaWVyLFxuICAgIG1hdGNoT2JqOiBpbXBvcnRzLFxuICAgIGludGVybmFsOiB0cnVlXG4gIH0pO1xufVxuXG5jb25zdCByZXNvbHZlSW1wb3J0UGF0aCA9IHByb21pc2lmeShyZXNvbHZlJDEpO1xuY29uc3QgcmVhZEZpbGUgPSBwcm9taXNpZnkoZnMucmVhZEZpbGUpO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRQYWNrYWdlSnNvbihpbXBvcnRlciwgcGtnTmFtZSwgcmVzb2x2ZU9wdGlvbnMsIG1vZHVsZURpcmVjdG9yaWVzKSB7XG4gIGlmIChpbXBvcnRlcikge1xuICAgIGNvbnN0IHNlbGZQYWNrYWdlSnNvblJlc3VsdCA9IGF3YWl0IGZpbmRQYWNrYWdlSnNvbihpbXBvcnRlciwgbW9kdWxlRGlyZWN0b3JpZXMpO1xuICAgIGlmIChzZWxmUGFja2FnZUpzb25SZXN1bHQgJiYgc2VsZlBhY2thZ2VKc29uUmVzdWx0LnBrZ0pzb24ubmFtZSA9PT0gcGtnTmFtZSkge1xuICAgICAgLy8gdGhlIHJlZmVyZW5jZWQgcGFja2FnZSBuYW1lIGlzIHRoZSBjdXJyZW50IHBhY2thZ2VcbiAgICAgIHJldHVybiBzZWxmUGFja2FnZUpzb25SZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwa2dKc29uUGF0aCA9IGF3YWl0IHJlc29sdmVJbXBvcnRQYXRoKGAke3BrZ05hbWV9L3BhY2thZ2UuanNvbmAsIHJlc29sdmVPcHRpb25zKTtcbiAgICBjb25zdCBwa2dKc29uID0gSlNPTi5wYXJzZShhd2FpdCByZWFkRmlsZShwa2dKc29uUGF0aCwgJ3V0Zi04JykpO1xuICAgIHJldHVybiB7IHBrZ0pzb25QYXRoLCBwa2dKc29uLCBwa2dQYXRoOiBkaXJuYW1lKHBrZ0pzb25QYXRoKSB9O1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUlkQ2xhc3NpYyh7XG4gIGltcG9ydFNwZWNpZmllcixcbiAgcGFja2FnZUluZm9DYWNoZSxcbiAgZXh0ZW5zaW9ucyxcbiAgbWFpbkZpZWxkcyxcbiAgcHJlc2VydmVTeW1saW5rcyxcbiAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgYmFzZURpcixcbiAgbW9kdWxlRGlyZWN0b3JpZXMsXG4gIHJvb3REaXIsXG4gIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdFxufSkge1xuICBsZXQgaGFzTW9kdWxlU2lkZUVmZmVjdHMgPSAoKSA9PiBudWxsO1xuICBsZXQgaGFzUGFja2FnZUVudHJ5ID0gdHJ1ZTtcbiAgbGV0IHBhY2thZ2VCcm93c2VyRmllbGQgPSBmYWxzZTtcbiAgbGV0IHBhY2thZ2VJbmZvO1xuXG4gIGNvbnN0IGZpbHRlciA9IChwa2csIHBrZ1BhdGgpID0+IHtcbiAgICBjb25zdCBpbmZvID0gZ2V0UGFja2FnZUluZm8oe1xuICAgICAgY2FjaGU6IHBhY2thZ2VJbmZvQ2FjaGUsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgcGtnLFxuICAgICAgcGtnUGF0aCxcbiAgICAgIG1haW5GaWVsZHMsXG4gICAgICBwcmVzZXJ2ZVN5bWxpbmtzLFxuICAgICAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgICAgIHJvb3REaXIsXG4gICAgICBpZ25vcmVTaWRlRWZmZWN0c0ZvclJvb3RcbiAgICB9KTtcblxuICAgICh7IHBhY2thZ2VJbmZvLCBoYXNNb2R1bGVTaWRlRWZmZWN0cywgaGFzUGFja2FnZUVudHJ5LCBwYWNrYWdlQnJvd3NlckZpZWxkIH0gPSBpbmZvKTtcblxuICAgIHJldHVybiBpbmZvLmNhY2hlZFBrZztcbiAgfTtcblxuICBjb25zdCByZXNvbHZlT3B0aW9ucyA9IHtcbiAgICBiYXNlZGlyOiBiYXNlRGlyLFxuICAgIHJlYWRGaWxlOiByZWFkQ2FjaGVkRmlsZSxcbiAgICBpc0ZpbGU6IGlzRmlsZUNhY2hlZCxcbiAgICBpc0RpcmVjdG9yeTogaXNEaXJDYWNoZWQsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBpbmNsdWRlQ29yZU1vZHVsZXM6IGZhbHNlLFxuICAgIG1vZHVsZURpcmVjdG9yeTogbW9kdWxlRGlyZWN0b3JpZXMsXG4gICAgcHJlc2VydmVTeW1saW5rcyxcbiAgICBwYWNrYWdlRmlsdGVyOiBmaWx0ZXJcbiAgfTtcblxuICBsZXQgbG9jYXRpb247XG4gIHRyeSB7XG4gICAgbG9jYXRpb24gPSBhd2FpdCByZXNvbHZlSW1wb3J0UGF0aChpbXBvcnRTcGVjaWZpZXIsIHJlc29sdmVPcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uOiBwcmVzZXJ2ZVN5bWxpbmtzID8gbG9jYXRpb24gOiBhd2FpdCByZXNvbHZlU3ltbGluayhsb2NhdGlvbiksXG4gICAgaGFzTW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgaGFzUGFja2FnZUVudHJ5LFxuICAgIHBhY2thZ2VCcm93c2VyRmllbGQsXG4gICAgcGFja2FnZUluZm9cbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVdpdGhFeHBvcnRNYXAoe1xuICBpbXBvcnRlcixcbiAgaW1wb3J0U3BlY2lmaWVyLFxuICBleHBvcnRDb25kaXRpb25zLFxuICBwYWNrYWdlSW5mb0NhY2hlLFxuICBleHRlbnNpb25zLFxuICBtYWluRmllbGRzLFxuICBwcmVzZXJ2ZVN5bWxpbmtzLFxuICB1c2VCcm93c2VyT3ZlcnJpZGVzLFxuICBiYXNlRGlyLFxuICBtb2R1bGVEaXJlY3RvcmllcyxcbiAgcm9vdERpcixcbiAgaWdub3JlU2lkZUVmZmVjdHNGb3JSb290XG59KSB7XG4gIGlmIChpbXBvcnRTcGVjaWZpZXIuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgLy8gdGhpcyBpcyBhIHBhY2thZ2UgaW50ZXJuYWwgaW1wb3J0LCByZXNvbHZlIHVzaW5nIHBhY2thZ2UgaW1wb3J0cyBmaWVsZFxuICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSBhd2FpdCByZXNvbHZlUGFja2FnZUltcG9ydHMoe1xuICAgICAgaW1wb3J0U3BlY2lmaWVyLFxuICAgICAgaW1wb3J0ZXIsXG4gICAgICBtb2R1bGVEaXJzOiBtb2R1bGVEaXJlY3RvcmllcyxcbiAgICAgIGNvbmRpdGlvbnM6IGV4cG9ydENvbmRpdGlvbnMsXG4gICAgICByZXNvbHZlSWQoaWQgLyogLCBwYXJlbnQqLykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUlkQ2xhc3NpYyh7XG4gICAgICAgICAgaW1wb3J0U3BlY2lmaWVyOiBpZCxcbiAgICAgICAgICBwYWNrYWdlSW5mb0NhY2hlLFxuICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgbWFpbkZpZWxkcyxcbiAgICAgICAgICBwcmVzZXJ2ZVN5bWxpbmtzLFxuICAgICAgICAgIHVzZUJyb3dzZXJPdmVycmlkZXMsXG4gICAgICAgICAgYmFzZURpcixcbiAgICAgICAgICBtb2R1bGVEaXJlY3Rvcmllc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gZmlsZVVSTFRvUGF0aChyZXNvbHZlUmVzdWx0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHByZXNlcnZlU3ltbGlua3MgPyBsb2NhdGlvbiA6IGF3YWl0IHJlc29sdmVTeW1saW5rKGxvY2F0aW9uKSxcbiAgICAgIGhhc01vZHVsZVNpZGVFZmZlY3RzOiAoKSA9PiBudWxsLFxuICAgICAgaGFzUGFja2FnZUVudHJ5OiB0cnVlLFxuICAgICAgcGFja2FnZUJyb3dzZXJGaWVsZDogZmFsc2UsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gICAgICBwYWNrYWdlSW5mbzogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBrZ05hbWUgPSBnZXRQYWNrYWdlTmFtZShpbXBvcnRTcGVjaWZpZXIpO1xuICBpZiAocGtnTmFtZSkge1xuICAgIC8vIGl0J3MgYSBiYXJlIGltcG9ydCwgZmluZCB0aGUgcGFja2FnZS5qc29uIGFuZCByZXNvbHZlIHVzaW5nIHBhY2thZ2UgZXhwb3J0cyBpZiBhdmFpbGFibGVcbiAgICBsZXQgaGFzTW9kdWxlU2lkZUVmZmVjdHMgPSAoKSA9PiBudWxsO1xuICAgIGxldCBoYXNQYWNrYWdlRW50cnkgPSB0cnVlO1xuICAgIGxldCBwYWNrYWdlQnJvd3NlckZpZWxkID0gZmFsc2U7XG4gICAgbGV0IHBhY2thZ2VJbmZvO1xuXG4gICAgY29uc3QgZmlsdGVyID0gKHBrZywgcGtnUGF0aCkgPT4ge1xuICAgICAgY29uc3QgaW5mbyA9IGdldFBhY2thZ2VJbmZvKHtcbiAgICAgICAgY2FjaGU6IHBhY2thZ2VJbmZvQ2FjaGUsXG4gICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgIHBrZyxcbiAgICAgICAgcGtnUGF0aCxcbiAgICAgICAgbWFpbkZpZWxkcyxcbiAgICAgICAgcHJlc2VydmVTeW1saW5rcyxcbiAgICAgICAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgICAgICAgcm9vdERpcixcbiAgICAgICAgaWdub3JlU2lkZUVmZmVjdHNGb3JSb290XG4gICAgICB9KTtcblxuICAgICAgKHsgcGFja2FnZUluZm8sIGhhc01vZHVsZVNpZGVFZmZlY3RzLCBoYXNQYWNrYWdlRW50cnksIHBhY2thZ2VCcm93c2VyRmllbGQgfSA9IGluZm8pO1xuXG4gICAgICByZXR1cm4gaW5mby5jYWNoZWRQa2c7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc29sdmVPcHRpb25zID0ge1xuICAgICAgYmFzZWRpcjogYmFzZURpcixcbiAgICAgIHJlYWRGaWxlOiByZWFkQ2FjaGVkRmlsZSxcbiAgICAgIGlzRmlsZTogaXNGaWxlQ2FjaGVkLFxuICAgICAgaXNEaXJlY3Rvcnk6IGlzRGlyQ2FjaGVkLFxuICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgIGluY2x1ZGVDb3JlTW9kdWxlczogZmFsc2UsXG4gICAgICBtb2R1bGVEaXJlY3Rvcnk6IG1vZHVsZURpcmVjdG9yaWVzLFxuICAgICAgcHJlc2VydmVTeW1saW5rcyxcbiAgICAgIHBhY2thZ2VGaWx0ZXI6IGZpbHRlclxuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRQYWNrYWdlSnNvbihpbXBvcnRlciwgcGtnTmFtZSwgcmVzb2x2ZU9wdGlvbnMsIG1vZHVsZURpcmVjdG9yaWVzKTtcblxuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnBrZ0pzb24uZXhwb3J0cykge1xuICAgICAgY29uc3QgeyBwa2dKc29uLCBwa2dKc29uUGF0aCB9ID0gcmVzdWx0O1xuICAgICAgY29uc3Qgc3VicGF0aCA9XG4gICAgICAgIHBrZ05hbWUgPT09IGltcG9ydFNwZWNpZmllciA/ICcuJyA6IGAuJHtpbXBvcnRTcGVjaWZpZXIuc3Vic3RyaW5nKHBrZ05hbWUubGVuZ3RoKX1gO1xuICAgICAgY29uc3QgcGtnRHIgPSBwa2dKc29uUGF0aC5yZXBsYWNlKCdwYWNrYWdlLmpzb24nLCAnJyk7XG4gICAgICBjb25zdCBwa2dVUkwgPSBwYXRoVG9GaWxlVVJMKHBrZ0RyKTtcblxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgaW1wb3J0ZXIsXG4gICAgICAgIGltcG9ydFNwZWNpZmllcixcbiAgICAgICAgbW9kdWxlRGlyczogbW9kdWxlRGlyZWN0b3JpZXMsXG4gICAgICAgIHBrZ1VSTCxcbiAgICAgICAgcGtnSnNvblBhdGgsXG4gICAgICAgIGNvbmRpdGlvbnM6IGV4cG9ydENvbmRpdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCByZXNvbHZlZFBhY2thZ2VFeHBvcnQgPSBhd2FpdCByZXNvbHZlUGFja2FnZUV4cG9ydHMoY29udGV4dCwgc3VicGF0aCwgcGtnSnNvbi5leHBvcnRzKTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZmlsZVVSTFRvUGF0aChyZXNvbHZlZFBhY2thZ2VFeHBvcnQpO1xuICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9jYXRpb246IHByZXNlcnZlU3ltbGlua3MgPyBsb2NhdGlvbiA6IGF3YWl0IHJlc29sdmVTeW1saW5rKGxvY2F0aW9uKSxcbiAgICAgICAgICBoYXNNb2R1bGVTaWRlRWZmZWN0cyxcbiAgICAgICAgICBoYXNQYWNrYWdlRW50cnksXG4gICAgICAgICAgcGFja2FnZUJyb3dzZXJGaWVsZCxcbiAgICAgICAgICBwYWNrYWdlSW5mb1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlV2l0aENsYXNzaWMoe1xuICBpbXBvcnRlcixcbiAgaW1wb3J0U3BlY2lmaWVyTGlzdCxcbiAgZXhwb3J0Q29uZGl0aW9ucyxcbiAgd2FybixcbiAgcGFja2FnZUluZm9DYWNoZSxcbiAgZXh0ZW5zaW9ucyxcbiAgbWFpbkZpZWxkcyxcbiAgcHJlc2VydmVTeW1saW5rcyxcbiAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgYmFzZURpcixcbiAgbW9kdWxlRGlyZWN0b3JpZXMsXG4gIHJvb3REaXIsXG4gIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdFxufSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGltcG9ydFNwZWNpZmllckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmVJZENsYXNzaWMoe1xuICAgICAgaW1wb3J0ZXIsXG4gICAgICBpbXBvcnRTcGVjaWZpZXI6IGltcG9ydFNwZWNpZmllckxpc3RbaV0sXG4gICAgICBleHBvcnRDb25kaXRpb25zLFxuICAgICAgd2FybixcbiAgICAgIHBhY2thZ2VJbmZvQ2FjaGUsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgbWFpbkZpZWxkcyxcbiAgICAgIHByZXNlcnZlU3ltbGlua3MsXG4gICAgICB1c2VCcm93c2VyT3ZlcnJpZGVzLFxuICAgICAgYmFzZURpcixcbiAgICAgIG1vZHVsZURpcmVjdG9yaWVzLFxuICAgICAgcm9vdERpcixcbiAgICAgIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gUmVzb2x2ZXMgdG8gdGhlIG1vZHVsZSBpZiBmb3VuZCBvciBgbnVsbGAuXG4vLyBUaGUgZmlyc3QgaW1wb3J0IHNwZWNpZmljZXIgd2lsbCBmaXJzdCBiZSBhdHRlbXB0ZWQgd2l0aCB0aGUgZXhwb3J0cyBhbGdvcml0aG0uXG4vLyBJZiB0aGlzIGlzIHVuc3VjY2VzZnVsIGJlY2F1c2UgZXhwb3J0IG1hcHMgYXJlIG5vdCBiZWluZyB1c2VkLCB0aGVuIGFsbCBvZiBgaW1wb3J0U3BlY2lmaWVyTGlzdGBcbi8vIHdpbGwgYmUgdHJpZWQgd2l0aCB0aGUgY2xhc3NpYyByZXNvbHV0aW9uIGFsZ29yaXRobVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUltcG9ydFNwZWNpZmllcnMoe1xuICBpbXBvcnRlcixcbiAgaW1wb3J0U3BlY2lmaWVyTGlzdCxcbiAgZXhwb3J0Q29uZGl0aW9ucyxcbiAgd2FybixcbiAgcGFja2FnZUluZm9DYWNoZSxcbiAgZXh0ZW5zaW9ucyxcbiAgbWFpbkZpZWxkcyxcbiAgcHJlc2VydmVTeW1saW5rcyxcbiAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgYmFzZURpcixcbiAgbW9kdWxlRGlyZWN0b3JpZXMsXG4gIHJvb3REaXIsXG4gIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdFxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IGV4cG9ydE1hcFJlcyA9IGF3YWl0IHJlc29sdmVXaXRoRXhwb3J0TWFwKHtcbiAgICAgIGltcG9ydGVyLFxuICAgICAgaW1wb3J0U3BlY2lmaWVyOiBpbXBvcnRTcGVjaWZpZXJMaXN0WzBdLFxuICAgICAgZXhwb3J0Q29uZGl0aW9ucyxcbiAgICAgIHBhY2thZ2VJbmZvQ2FjaGUsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgbWFpbkZpZWxkcyxcbiAgICAgIHByZXNlcnZlU3ltbGlua3MsXG4gICAgICB1c2VCcm93c2VyT3ZlcnJpZGVzLFxuICAgICAgYmFzZURpcixcbiAgICAgIG1vZHVsZURpcmVjdG9yaWVzLFxuICAgICAgcm9vdERpcixcbiAgICAgIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdFxuICAgIH0pO1xuICAgIGlmIChleHBvcnRNYXBSZXMpIHJldHVybiBleHBvcnRNYXBSZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVzb2x2ZUVycm9yKSB7XG4gICAgICB3YXJuKGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHBhY2thZ2UgaGFzIG5vIGltcG9ydHMgb3IgZXhwb3J0cywgdXNlIGNsYXNzaWMgbm9kZSByZXNvbHZlXG4gIHJldHVybiByZXNvbHZlV2l0aENsYXNzaWMoe1xuICAgIGltcG9ydGVyLFxuICAgIGltcG9ydFNwZWNpZmllckxpc3QsXG4gICAgZXhwb3J0Q29uZGl0aW9ucyxcbiAgICB3YXJuLFxuICAgIHBhY2thZ2VJbmZvQ2FjaGUsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBtYWluRmllbGRzLFxuICAgIHByZXNlcnZlU3ltbGlua3MsXG4gICAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgICBiYXNlRGlyLFxuICAgIG1vZHVsZURpcmVjdG9yaWVzLFxuICAgIHJvb3REaXIsXG4gICAgaWdub3JlU2lkZUVmZmVjdHNGb3JSb290XG4gIH0pO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tc2hhZG93LCBuby11bmRlZmluZWQgKi9cblxuY29uc3QgYnVpbHRpbnMgPSBuZXcgU2V0KGJ1aWx0aW5MaXN0KTtcbmNvbnN0IEVTNl9CUk9XU0VSX0VNUFRZID0gJ1xcMG5vZGUtcmVzb2x2ZTplbXB0eS5qcyc7XG5jb25zdCBkZWVwRnJlZXplID0gKG9iamVjdCkgPT4ge1xuICBPYmplY3QuZnJlZXplKG9iamVjdCk7XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKG9iamVjdCkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhT2JqZWN0LmlzRnJvemVuKHZhbHVlKSkge1xuICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IGJhc2VDb25kaXRpb25zID0gWydkZWZhdWx0JywgJ21vZHVsZSddO1xuY29uc3QgYmFzZUNvbmRpdGlvbnNFc20gPSBbLi4uYmFzZUNvbmRpdGlvbnMsICdpbXBvcnQnXTtcbmNvbnN0IGJhc2VDb25kaXRpb25zQ2pzID0gWy4uLmJhc2VDb25kaXRpb25zLCAncmVxdWlyZSddO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGRlZHVwZTogW10sXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgLm1qcyBpcyBsaXN0ZWQgYmVmb3JlIC5qcyBzbyB0aGF0IFJvbGx1cCB3aWxsIGludGVycHJldCBucG0gbW9kdWxlc1xuICAvLyB3aGljaCBkZXBsb3kgYm90aCBFU00gLm1qcyBhbmQgQ29tbW9uSlMgLmpzIGZpbGVzIGFzIEVTTS5cbiAgZXh0ZW5zaW9uczogWycubWpzJywgJy5qcycsICcuanNvbicsICcubm9kZSddLFxuICByZXNvbHZlT25seTogW10sXG4gIG1vZHVsZURpcmVjdG9yaWVzOiBbJ25vZGVfbW9kdWxlcyddLFxuICBpZ25vcmVTaWRlRWZmZWN0c0ZvclJvb3Q6IGZhbHNlXG59O1xuY29uc3QgREVGQVVMVFMgPSBkZWVwRnJlZXplKGRlZXBNZXJnZSh7fSwgZGVmYXVsdHMpKTtcblxuZnVuY3Rpb24gbm9kZVJlc29sdmUob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgd2FybmluZ3MgfSA9IGhhbmRsZURlcHJlY2F0ZWRPcHRpb25zKG9wdHMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gIGNvbnN0IHsgZXh0ZW5zaW9ucywgamFpbCwgbW9kdWxlRGlyZWN0b3JpZXMsIGlnbm9yZVNpZGVFZmZlY3RzRm9yUm9vdCB9ID0gb3B0aW9ucztcbiAgY29uc3QgY29uZGl0aW9uc0VzbSA9IFsuLi5iYXNlQ29uZGl0aW9uc0VzbSwgLi4uKG9wdGlvbnMuZXhwb3J0Q29uZGl0aW9ucyB8fCBbXSldO1xuICBjb25zdCBjb25kaXRpb25zQ2pzID0gWy4uLmJhc2VDb25kaXRpb25zQ2pzLCAuLi4ob3B0aW9ucy5leHBvcnRDb25kaXRpb25zIHx8IFtdKV07XG4gIGNvbnN0IHBhY2thZ2VJbmZvQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGlkVG9QYWNrYWdlSW5mbyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWFpbkZpZWxkcyA9IGdldE1haW5GaWVsZHMob3B0aW9ucyk7XG4gIGNvbnN0IHVzZUJyb3dzZXJPdmVycmlkZXMgPSBtYWluRmllbGRzLmluZGV4T2YoJ2Jyb3dzZXInKSAhPT0gLTE7XG4gIGNvbnN0IGlzUHJlZmVyQnVpbHRpbnNTZXQgPSBvcHRpb25zLnByZWZlckJ1aWx0aW5zID09PSB0cnVlIHx8IG9wdGlvbnMucHJlZmVyQnVpbHRpbnMgPT09IGZhbHNlO1xuICBjb25zdCBwcmVmZXJCdWlsdGlucyA9IGlzUHJlZmVyQnVpbHRpbnNTZXQgPyBvcHRpb25zLnByZWZlckJ1aWx0aW5zIDogdHJ1ZTtcbiAgY29uc3Qgcm9vdERpciA9IHJlc29sdmUob3B0aW9ucy5yb290RGlyIHx8IHByb2Nlc3MuY3dkKCkpO1xuICBsZXQgeyBkZWR1cGUgfSA9IG9wdGlvbnM7XG4gIGxldCByb2xsdXBPcHRpb25zO1xuXG4gIGlmICh0eXBlb2YgZGVkdXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVkdXBlID0gKGltcG9ydGVlKSA9PlxuICAgICAgb3B0aW9ucy5kZWR1cGUuaW5jbHVkZXMoaW1wb3J0ZWUpIHx8IG9wdGlvbnMuZGVkdXBlLmluY2x1ZGVzKGdldFBhY2thZ2VOYW1lKGltcG9ydGVlKSk7XG4gIH1cblxuICBjb25zdCByZXNvbHZlT25seSA9IG9wdGlvbnMucmVzb2x2ZU9ubHkubWFwKChwYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkID0gcGF0dGVybi5yZXBsYWNlKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtub3JtYWxpemVkfSRgKTtcbiAgfSk7XG5cbiAgY29uc3QgYnJvd3Nlck1hcENhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgcHJlc2VydmVTeW1saW5rcztcblxuICBjb25zdCBkb1Jlc29sdmVJZCA9IGFzeW5jIChjb250ZXh0LCBpbXBvcnRlZSwgaW1wb3J0ZXIsIGN1c3RvbSkgPT4ge1xuICAgIC8vIHN0cmlwIHF1ZXJ5IHBhcmFtcyBmcm9tIGltcG9ydFxuICAgIGNvbnN0IFtpbXBvcnRQYXRoLCBwYXJhbXNdID0gaW1wb3J0ZWUuc3BsaXQoJz8nKTtcbiAgICBjb25zdCBpbXBvcnRTdWZmaXggPSBgJHtwYXJhbXMgPyBgPyR7cGFyYW1zfWAgOiAnJ31gO1xuICAgIGltcG9ydGVlID0gaW1wb3J0UGF0aDtcblxuICAgIGNvbnN0IGJhc2VEaXIgPSAhaW1wb3J0ZXIgfHwgZGVkdXBlKGltcG9ydGVlKSA/IHJvb3REaXIgOiBkaXJuYW1lKGltcG9ydGVyKTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL3BhY2thZ2UtYnJvd3Nlci1maWVsZC1zcGVjXG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJNYXBDYWNoZS5nZXQoaW1wb3J0ZXIpO1xuICAgIGlmICh1c2VCcm93c2VyT3ZlcnJpZGVzICYmIGJyb3dzZXIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0ZWUgPSByZXNvbHZlKGJhc2VEaXIsIGltcG9ydGVlKTtcbiAgICAgIGlmIChicm93c2VyW2ltcG9ydGVlXSA9PT0gZmFsc2UgfHwgYnJvd3NlcltyZXNvbHZlZEltcG9ydGVlXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgaWQ6IEVTNl9CUk9XU0VSX0VNUFRZIH07XG4gICAgICB9XG4gICAgICBjb25zdCBicm93c2VySW1wb3J0ZWUgPVxuICAgICAgICAoaW1wb3J0ZWVbMF0gIT09ICcuJyAmJiBicm93c2VyW2ltcG9ydGVlXSkgfHxcbiAgICAgICAgYnJvd3NlcltyZXNvbHZlZEltcG9ydGVlXSB8fFxuICAgICAgICBicm93c2VyW2Ake3Jlc29sdmVkSW1wb3J0ZWV9LmpzYF0gfHxcbiAgICAgICAgYnJvd3NlcltgJHtyZXNvbHZlZEltcG9ydGVlfS5qc29uYF07XG4gICAgICBpZiAoYnJvd3NlckltcG9ydGVlKSB7XG4gICAgICAgIGltcG9ydGVlID0gYnJvd3NlckltcG9ydGVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhcnRzID0gaW1wb3J0ZWUuc3BsaXQoL1svXFxcXF0vKTtcbiAgICBsZXQgaWQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGxldCBpc1JlbGF0aXZlSW1wb3J0ID0gZmFsc2U7XG5cbiAgICBpZiAoaWRbMF0gPT09ICdAJyAmJiBwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBzY29wZWQgcGFja2FnZXNcbiAgICAgIGlkICs9IGAvJHtwYXJ0cy5zaGlmdCgpfWA7XG4gICAgfSBlbHNlIGlmIChpZFswXSA9PT0gJy4nKSB7XG4gICAgICAvLyBhbiBpbXBvcnQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBkaXIgb2YgdGhlIGltcG9ydGVyXG4gICAgICBpZCA9IHJlc29sdmUoYmFzZURpciwgaW1wb3J0ZWUpO1xuICAgICAgaXNSZWxhdGl2ZUltcG9ydCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzUmVsYXRpdmVJbXBvcnQgJiZcbiAgICAgIHJlc29sdmVPbmx5Lmxlbmd0aCAmJlxuICAgICAgIXJlc29sdmVPbmx5LnNvbWUoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChpZCkpXG4gICAgKSB7XG4gICAgICBpZiAobm9ybWFsaXplSW5wdXQocm9sbHVwT3B0aW9ucy5pbnB1dCkuaW5jbHVkZXMoaW1wb3J0ZWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGltcG9ydFNwZWNpZmllckxpc3QgPSBbaW1wb3J0ZWVdO1xuXG4gICAgaWYgKGltcG9ydGVyID09PSB1bmRlZmluZWQgJiYgIWltcG9ydGVlWzBdLm1hdGNoKC9eXFwuP1xcLj9cXC8vKSkge1xuICAgICAgLy8gRm9yIG1vZHVsZSBncmFwaCByb290cyAoaS5lLiB3aGVuIGltcG9ydGVyIGlzIHVuZGVmaW5lZCksIHdlXG4gICAgICAvLyBuZWVkIHRvIGhhbmRsZSAncGF0aCBmcmFnbWVudHNgIGxpa2UgYGZvby9iYXJgIHRoYXQgYXJlIGNvbW1vbmx5XG4gICAgICAvLyBmb3VuZCBpbiByb2xsdXAgY29uZmlnIGZpbGVzLiBJZiBpbXBvcnRlZSBkb2Vzbid0IGxvb2sgbGlrZSBhXG4gICAgICAvLyByZWxhdGl2ZSBvciBhYnNvbHV0ZSBwYXRoLCB3ZSBtYWtlIGl0IHJlbGF0aXZlIGFuZCBhdHRlbXB0IHRvXG4gICAgICAvLyByZXNvbHZlIGl0LlxuICAgICAgaW1wb3J0U3BlY2lmaWVyTGlzdC5wdXNoKGAuLyR7aW1wb3J0ZWV9YCk7XG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCBmaWxlcyBtYXkgaW1wb3J0ICcuanMnIHRvIHJlZmVyIHRvIGVpdGhlciAnLnRzJyBvciAnLnRzeCdcbiAgICBpZiAoaW1wb3J0ZXIgJiYgaW1wb3J0ZWUuZW5kc1dpdGgoJy5qcycpKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4dCBvZiBbJy50cycsICcudHN4J10pIHtcbiAgICAgICAgaWYgKGltcG9ydGVyLmVuZHNXaXRoKGV4dCkgJiYgZXh0ZW5zaW9ucy5pbmNsdWRlcyhleHQpKSB7XG4gICAgICAgICAgaW1wb3J0U3BlY2lmaWVyTGlzdC5wdXNoKGltcG9ydGVlLnJlcGxhY2UoLy5qcyQvLCBleHQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4gY29udGV4dC53YXJuKC4uLmFyZ3MpO1xuICAgIGNvbnN0IGlzUmVxdWlyZSA9IGN1c3RvbSAmJiBjdXN0b21bJ25vZGUtcmVzb2x2ZSddICYmIGN1c3RvbVsnbm9kZS1yZXNvbHZlJ10uaXNSZXF1aXJlO1xuICAgIGNvbnN0IGV4cG9ydENvbmRpdGlvbnMgPSBpc1JlcXVpcmUgPyBjb25kaXRpb25zQ2pzIDogY29uZGl0aW9uc0VzbTtcblxuICAgIGlmICh1c2VCcm93c2VyT3ZlcnJpZGVzICYmICFleHBvcnRDb25kaXRpb25zLmluY2x1ZGVzKCdicm93c2VyJykpXG4gICAgICBleHBvcnRDb25kaXRpb25zLnB1c2goJ2Jyb3dzZXInKTtcblxuICAgIGNvbnN0IHJlc29sdmVkV2l0aG91dEJ1aWx0aW5zID0gYXdhaXQgcmVzb2x2ZUltcG9ydFNwZWNpZmllcnMoe1xuICAgICAgaW1wb3J0ZXIsXG4gICAgICBpbXBvcnRTcGVjaWZpZXJMaXN0LFxuICAgICAgZXhwb3J0Q29uZGl0aW9ucyxcbiAgICAgIHdhcm4sXG4gICAgICBwYWNrYWdlSW5mb0NhY2hlLFxuICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgIG1haW5GaWVsZHMsXG4gICAgICBwcmVzZXJ2ZVN5bWxpbmtzLFxuICAgICAgdXNlQnJvd3Nlck92ZXJyaWRlcyxcbiAgICAgIGJhc2VEaXIsXG4gICAgICBtb2R1bGVEaXJlY3RvcmllcyxcbiAgICAgIHJvb3REaXIsXG4gICAgICBpZ25vcmVTaWRlRWZmZWN0c0ZvclJvb3RcbiAgICB9KTtcblxuICAgIGNvbnN0IGltcG9ydGVlSXNCdWlsdGluID0gYnVpbHRpbnMuaGFzKGltcG9ydGVlKTtcbiAgICBjb25zdCByZXNvbHZlZCA9XG4gICAgICBpbXBvcnRlZUlzQnVpbHRpbiAmJiBwcmVmZXJCdWlsdGluc1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIHBhY2thZ2VJbmZvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoYXNNb2R1bGVTaWRlRWZmZWN0czogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIGhhc1BhY2thZ2VFbnRyeTogdHJ1ZSxcbiAgICAgICAgICAgIHBhY2thZ2VCcm93c2VyRmllbGQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICA6IHJlc29sdmVkV2l0aG91dEJ1aWx0aW5zO1xuICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcGFja2FnZUluZm8sIGhhc01vZHVsZVNpZGVFZmZlY3RzLCBoYXNQYWNrYWdlRW50cnksIHBhY2thZ2VCcm93c2VyRmllbGQgfSA9IHJlc29sdmVkO1xuICAgIGxldCB7IGxvY2F0aW9uIH0gPSByZXNvbHZlZDtcbiAgICBpZiAocGFja2FnZUJyb3dzZXJGaWVsZCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYWNrYWdlQnJvd3NlckZpZWxkLCBsb2NhdGlvbikpIHtcbiAgICAgICAgaWYgKCFwYWNrYWdlQnJvd3NlckZpZWxkW2xvY2F0aW9uXSkge1xuICAgICAgICAgIGJyb3dzZXJNYXBDYWNoZS5zZXQobG9jYXRpb24sIHBhY2thZ2VCcm93c2VyRmllbGQpO1xuICAgICAgICAgIHJldHVybiB7IGlkOiBFUzZfQlJPV1NFUl9FTVBUWSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvY2F0aW9uID0gcGFja2FnZUJyb3dzZXJGaWVsZFtsb2NhdGlvbl07XG4gICAgICB9XG4gICAgICBicm93c2VyTWFwQ2FjaGUuc2V0KGxvY2F0aW9uLCBwYWNrYWdlQnJvd3NlckZpZWxkKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGFja2FnZUVudHJ5ICYmICFwcmVzZXJ2ZVN5bWxpbmtzKSB7XG4gICAgICBjb25zdCBleGlzdHMgPSBhd2FpdCBmaWxlRXhpc3RzKGxvY2F0aW9uKTtcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgbG9jYXRpb24gPSBhd2FpdCByZWFscGF0aChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWRUb1BhY2thZ2VJbmZvLnNldChsb2NhdGlvbiwgcGFja2FnZUluZm8pO1xuXG4gICAgaWYgKGhhc1BhY2thZ2VFbnRyeSkge1xuICAgICAgaWYgKGltcG9ydGVlSXNCdWlsdGluICYmIHByZWZlckJ1aWx0aW5zKSB7XG4gICAgICAgIGlmICghaXNQcmVmZXJCdWlsdGluc1NldCAmJiByZXNvbHZlZFdpdGhvdXRCdWlsdGlucyAmJiByZXNvbHZlZCAhPT0gaW1wb3J0ZWUpIHtcbiAgICAgICAgICBjb250ZXh0Lndhcm4oXG4gICAgICAgICAgICBgcHJlZmVycmluZyBidWlsdC1pbiBtb2R1bGUgJyR7aW1wb3J0ZWV9JyBvdmVyIGxvY2FsIGFsdGVybmF0aXZlIGF0ICcke3Jlc29sdmVkV2l0aG91dEJ1aWx0aW5zLmxvY2F0aW9ufScsIHBhc3MgJ3ByZWZlckJ1aWx0aW5zOiBmYWxzZScgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yIG9yICdwcmVmZXJCdWlsdGluczogdHJ1ZScgdG8gZGlzYWJsZSB0aGlzIHdhcm5pbmdgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGphaWwgJiYgbG9jYXRpb24uaW5kZXhPZihub3JtYWxpemUoamFpbC50cmltKHNlcCkpKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tb2R1bGVzT25seSAmJiAoYXdhaXQgZmlsZUV4aXN0cyhsb2NhdGlvbikpKSB7XG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVhZEZpbGUkMShsb2NhdGlvbiwgJ3V0Zi04Jyk7XG4gICAgICBpZiAoaXNNb2R1bGUoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogYCR7bG9jYXRpb259JHtpbXBvcnRTdWZmaXh9YCxcbiAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogaGFzTW9kdWxlU2lkZUVmZmVjdHMobG9jYXRpb24pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgJHtsb2NhdGlvbn0ke2ltcG9ydFN1ZmZpeH1gLFxuICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6IGhhc01vZHVsZVNpZGVFZmZlY3RzKGxvY2F0aW9uKVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnbm9kZS1yZXNvbHZlJyxcblxuICAgIHZlcnNpb24sXG5cbiAgICBidWlsZFN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgIHJvbGx1cE9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygd2FybmluZ3MpIHtcbiAgICAgICAgdGhpcy53YXJuKHdhcm5pbmcpO1xuICAgICAgfVxuXG4gICAgICAoeyBwcmVzZXJ2ZVN5bWxpbmtzIH0gPSBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVCdW5kbGUoKSB7XG4gICAgICByZWFkQ2FjaGVkRmlsZS5jbGVhcigpO1xuICAgICAgaXNGaWxlQ2FjaGVkLmNsZWFyKCk7XG4gICAgICBpc0RpckNhY2hlZC5jbGVhcigpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXNvbHZlSWQoaW1wb3J0ZWUsIGltcG9ydGVyLCByZXNvbHZlT3B0aW9ucykge1xuICAgICAgaWYgKGltcG9ydGVlID09PSBFUzZfQlJPV1NFUl9FTVBUWSkge1xuICAgICAgICByZXR1cm4gaW1wb3J0ZWU7XG4gICAgICB9XG4gICAgICAvLyBpZ25vcmUgSURzIHdpdGggbnVsbCBjaGFyYWN0ZXIsIHRoZXNlIGJlbG9uZyB0byBvdGhlciBwbHVnaW5zXG4gICAgICBpZiAoL1xcMC8udGVzdChpbXBvcnRlZSkpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoL1xcMC8udGVzdChpbXBvcnRlcikpIHtcbiAgICAgICAgaW1wb3J0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgZG9SZXNvbHZlSWQodGhpcywgaW1wb3J0ZWUsIGltcG9ydGVyLCByZXNvbHZlT3B0aW9ucy5jdXN0b20pO1xuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUmVzb2x2ZWQgPSBhd2FpdCB0aGlzLnJlc29sdmUoXG4gICAgICAgICAgcmVzb2x2ZWQuaWQsXG4gICAgICAgICAgaW1wb3J0ZXIsXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7IHNraXBTZWxmOiB0cnVlIH0sIHJlc29sdmVPcHRpb25zKVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVzb2x2ZWRSZXNvbHZlZCkge1xuICAgICAgICAgIC8vIEhhbmRsZSBwbHVnaW5zIHRoYXQgbWFudWFsbHkgbWFrZSB0aGUgcmVzdWx0IGV4dGVybmFsXG4gICAgICAgICAgaWYgKHJlc29sdmVkUmVzb2x2ZWQuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGFzcyBvbiBtZXRhIGluZm9ybWF0aW9uIGFkZGVkIGJ5IG90aGVyIHBsdWdpbnNcbiAgICAgICAgICByZXR1cm4geyAuLi5yZXNvbHZlZCwgbWV0YTogcmVzb2x2ZWRSZXNvbHZlZC5tZXRhIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9LFxuXG4gICAgbG9hZChpbXBvcnRlZSkge1xuICAgICAgaWYgKGltcG9ydGVlID09PSBFUzZfQlJPV1NFUl9FTVBUWSkge1xuICAgICAgICByZXR1cm4gJ2V4cG9ydCBkZWZhdWx0IHt9Oyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0UGFja2FnZUluZm9Gb3JJZChpZCkge1xuICAgICAgcmV0dXJuIGlkVG9QYWNrYWdlSW5mby5nZXQoaWQpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgREVGQVVMVFMsIG5vZGVSZXNvbHZlIGFzIGRlZmF1bHQsIG5vZGVSZXNvbHZlIH07XG4iLCAiaW1wb3J0IHsgZXh0bmFtZSwgc2VwLCByZXNvbHZlLCBwb3NpeCB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHBtIGZyb20gJ3BpY29tYXRjaCc7XG5cbmNvbnN0IGFkZEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihmaWxlbmFtZSwgZXh0ID0gJy5qcycpIHtcbiAgICBsZXQgcmVzdWx0ID0gYCR7ZmlsZW5hbWV9YDtcbiAgICBpZiAoIWV4dG5hbWUoZmlsZW5hbWUpKVxuICAgICAgICByZXN1bHQgKz0gZXh0O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB3YWxrKGFzdCwgeyBlbnRlciwgbGVhdmUgfSkge1xuXHRyZXR1cm4gdmlzaXQoYXN0LCBudWxsLCBlbnRlciwgbGVhdmUpO1xufVxuXG5sZXQgc2hvdWxkX3NraXAgPSBmYWxzZTtcbmxldCBzaG91bGRfcmVtb3ZlID0gZmFsc2U7XG5sZXQgcmVwbGFjZW1lbnQgPSBudWxsO1xuY29uc3QgY29udGV4dCA9IHtcblx0c2tpcDogKCkgPT4gc2hvdWxkX3NraXAgPSB0cnVlLFxuXHRyZW1vdmU6ICgpID0+IHNob3VsZF9yZW1vdmUgPSB0cnVlLFxuXHRyZXBsYWNlOiAobm9kZSkgPT4gcmVwbGFjZW1lbnQgPSBub2RlXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpIHtcblx0aWYgKHBhcmVudCkge1xuXHRcdGlmIChpbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0cGFyZW50W3Byb3BdW2luZGV4XSA9IG5vZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmVudFtwcm9wXSA9IG5vZGU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShwYXJlbnQsIHByb3AsIGluZGV4KSB7XG5cdGlmIChwYXJlbnQpIHtcblx0XHRpZiAoaW5kZXggIT09IG51bGwpIHtcblx0XHRcdHBhcmVudFtwcm9wXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgcGFyZW50W3Byb3BdO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiB2aXNpdChcblx0bm9kZSxcblx0cGFyZW50LFxuXHRlbnRlcixcblx0bGVhdmUsXG5cdHByb3AsXG5cdGluZGV4XG4pIHtcblx0aWYgKG5vZGUpIHtcblx0XHRpZiAoZW50ZXIpIHtcblx0XHRcdGNvbnN0IF9zaG91bGRfc2tpcCA9IHNob3VsZF9za2lwO1xuXHRcdFx0Y29uc3QgX3Nob3VsZF9yZW1vdmUgPSBzaG91bGRfcmVtb3ZlO1xuXHRcdFx0Y29uc3QgX3JlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRzaG91bGRfc2tpcCA9IGZhbHNlO1xuXHRcdFx0c2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXHRcdFx0cmVwbGFjZW1lbnQgPSBudWxsO1xuXG5cdFx0XHRlbnRlci5jYWxsKGNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXG5cdFx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0bm9kZSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRyZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRyZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNraXBwZWQgPSBzaG91bGRfc2tpcDtcblx0XHRcdGNvbnN0IHJlbW92ZWQgPSBzaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRzaG91bGRfc2tpcCA9IF9zaG91bGRfc2tpcDtcblx0XHRcdHNob3VsZF9yZW1vdmUgPSBfc2hvdWxkX3JlbW92ZTtcblx0XHRcdHJlcGxhY2VtZW50ID0gX3JlcGxhY2VtZW50O1xuXG5cdFx0XHRpZiAoc2tpcHBlZCkgcmV0dXJuIG5vZGU7XG5cdFx0XHRpZiAocmVtb3ZlZCkgcmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSAobm9kZSApW2tleV07XG5cblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgayA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGogKz0gMSwgayArPSAxKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlW2pdICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZVtqXS50eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0aWYgKCF2aXNpdCh2YWx1ZVtqXSwgbm9kZSwgZW50ZXIsIGxlYXZlLCBrZXksIGspKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZWRcblx0XHRcdFx0XHRcdFx0ai0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmlzaXQodmFsdWUsIG5vZGUsIGVudGVyLCBsZWF2ZSwga2V5LCBudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGVhdmUpIHtcblx0XHRcdGNvbnN0IF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50O1xuXHRcdFx0Y29uc3QgX3Nob3VsZF9yZW1vdmUgPSBzaG91bGRfcmVtb3ZlO1xuXHRcdFx0cmVwbGFjZW1lbnQgPSBudWxsO1xuXHRcdFx0c2hvdWxkX3JlbW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRsZWF2ZS5jYWxsKGNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXgpO1xuXG5cdFx0XHRpZiAocmVwbGFjZW1lbnQpIHtcblx0XHRcdFx0bm9kZSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRyZXBsYWNlKHBhcmVudCwgcHJvcCwgaW5kZXgsIG5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2hvdWxkX3JlbW92ZSkge1xuXHRcdFx0XHRyZW1vdmUocGFyZW50LCBwcm9wLCBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlbW92ZWQgPSBzaG91bGRfcmVtb3ZlO1xuXG5cdFx0XHRyZXBsYWNlbWVudCA9IF9yZXBsYWNlbWVudDtcblx0XHRcdHNob3VsZF9yZW1vdmUgPSBfc2hvdWxkX3JlbW92ZTtcblxuXHRcdFx0aWYgKHJlbW92ZWQpIHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBub2RlO1xufVxuXG5jb25zdCBleHRyYWN0b3JzID0ge1xuICAgIEFycmF5UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcmFtLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICBleHRyYWN0b3JzW2VsZW1lbnQudHlwZV0obmFtZXMsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBc3NpZ25tZW50UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZXh0cmFjdG9yc1twYXJhbS5sZWZ0LnR5cGVdKG5hbWVzLCBwYXJhbS5sZWZ0KTtcbiAgICB9LFxuICAgIElkZW50aWZpZXIobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIG5hbWVzLnB1c2gocGFyYW0ubmFtZSk7XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uKCkgeyB9LFxuICAgIE9iamVjdFBhdHRlcm4obmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFR5cGVzY3JpcHQgcmVwb3J0cyB0aGF0IHRoaXMgaXMgbm90IGEgdmFsaWQgdHlwZVxuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RvcnMuUmVzdEVsZW1lbnQobmFtZXMsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdG9yc1twcm9wLnZhbHVlLnR5cGVdKG5hbWVzLCBwcm9wLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgUmVzdEVsZW1lbnQobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGV4dHJhY3RvcnNbcGFyYW0uYXJndW1lbnQudHlwZV0obmFtZXMsIHBhcmFtLmFyZ3VtZW50KTtcbiAgICB9XG59O1xuY29uc3QgZXh0cmFjdEFzc2lnbmVkTmFtZXMgPSBmdW5jdGlvbiBleHRyYWN0QXNzaWduZWROYW1lcyhwYXJhbSkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgZXh0cmFjdG9yc1twYXJhbS50eXBlXShuYW1lcywgcGFyYW0pO1xuICAgIHJldHVybiBuYW1lcztcbn07XG5cbmNvbnN0IGJsb2NrRGVjbGFyYXRpb25zID0ge1xuICAgIGNvbnN0OiB0cnVlLFxuICAgIGxldDogdHJ1ZVxufTtcbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrU2NvcGUgPSAhIW9wdGlvbnMuYmxvY2s7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RBc3NpZ25lZE5hbWVzKHBhcmFtKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKG5vZGUsIGlzQmxvY2tEZWNsYXJhdGlvbiwgaXNWYXIpIHtcbiAgICAgICAgaWYgKCFpc0Jsb2NrRGVjbGFyYXRpb24gJiYgdGhpcy5pc0Jsb2NrU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgYSBgdmFyYCBvciBmdW5jdGlvbiBub2RlLCBhbmQgdGhpc1xuICAgICAgICAgICAgLy8gaXMgYSBibG9jayBzY29wZSwgc28gd2UgbmVlZCB0byBnbyB1cFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYWRkRGVjbGFyYXRpb24obm9kZSwgaXNCbG9ja0RlY2xhcmF0aW9uLCBpc1Zhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5pZCkge1xuICAgICAgICAgICAgZXh0cmFjdEFzc2lnbmVkTmFtZXMobm9kZS5pZCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5zKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb25zW25hbWVdIHx8ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNvbnRhaW5zKG5hbWUpIDogZmFsc2UpO1xuICAgIH1cbn1cbmNvbnN0IGF0dGFjaFNjb3BlcyA9IGZ1bmN0aW9uIGF0dGFjaFNjb3Blcyhhc3QsIHByb3BlcnR5TmFtZSA9ICdzY29wZScpIHtcbiAgICBsZXQgc2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICB3YWxrKGFzdCwge1xuICAgICAgICBlbnRlcihuLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuO1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24gZm9vICgpIHsuLi59XG4gICAgICAgICAgICAvLyBjbGFzcyBGb28gey4uLn1cbiAgICAgICAgICAgIGlmICgvKEZ1bmN0aW9ufENsYXNzKURlY2xhcmF0aW9uLy50ZXN0KG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5hZGREZWNsYXJhdGlvbihub2RlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIGZvbyA9IDFcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2luZCB9ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Jsb2NrRGVjbGFyYXRpb24gPSBibG9ja0RlY2xhcmF0aW9uc1traW5kXTtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhZGQgY29uc3QvbGV0IGRlY2xhcmF0aW9ucyBpbiB0aGUgYm9keSBvZiBhIGZvciBsb29wICMxMTNcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50ID8gcGFyZW50LnR5cGUgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoIShpc0Jsb2NrRGVjbGFyYXRpb24gJiYgL0Zvck9mU3RhdGVtZW50Ly50ZXN0KHBhcmVudFR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWRkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIGlzQmxvY2tEZWNsYXJhdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTY29wZTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZnVuY3Rpb24gc2NvcGVcbiAgICAgICAgICAgIGlmICgvRnVuY3Rpb24vLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gbmV3IFNjb3BlKHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGZ1bmMucGFyYW1zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbmFtZWQgZnVuY3Rpb24gZXhwcmVzc2lvbnMgLSB0aGUgbmFtZSBpcyBjb25zaWRlcmVkXG4gICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgZnVuY3Rpb24ncyBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChmdW5jLnR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nICYmIGZ1bmMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUuYWRkRGVjbGFyYXRpb24oZnVuYywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGJsb2NrIHNjb3BlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnICYmICEvRnVuY3Rpb24vLnRlc3QocGFyZW50LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2F0Y2ggY2xhdXNlIGhhcyBpdHMgb3duIGJsb2NrIHNjb3BlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQ2F0Y2hDbGF1c2UnKSB7XG4gICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IG5vZGUucGFyYW0gPyBbbm9kZS5wYXJhbV0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTY29wZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1Njb3BlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZShuKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbjtcbiAgICAgICAgICAgIGlmIChub2RlW3Byb3BlcnR5TmFtZV0pXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2NvcGU7XG59O1xuXG4vLyBIZWxwZXIgc2luY2UgVHlwZXNjcmlwdCBjYW4ndCBkZXRlY3QgcmVhZG9ubHkgYXJyYXlzIHdpdGggQXJyYXkuaXNBcnJheVxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xufVxuZnVuY3Rpb24gZW5zdXJlQXJyYXkodGhpbmcpIHtcbiAgICBpZiAoaXNBcnJheSh0aGluZykpXG4gICAgICAgIHJldHVybiB0aGluZztcbiAgICBpZiAodGhpbmcgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbdGhpbmddO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVyU3RyaW5nKGlkLCByZXNvbHV0aW9uQmFzZSkge1xuICAgIGlmIChyZXNvbHV0aW9uQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvLyByZXNvbHZlKCcnKSBpcyB2YWxpZCBhbmQgd2lsbCBkZWZhdWx0IHRvIHByb2Nlc3MuY3dkKClcbiAgICBjb25zdCBiYXNlUGF0aCA9IHJlc29sdmUocmVzb2x1dGlvbkJhc2UgfHwgJycpXG4gICAgICAgIC5zcGxpdChzZXApXG4gICAgICAgIC5qb2luKCcvJylcbiAgICAgICAgLy8gZXNjYXBlIGFsbCBwb3NzaWJsZSAocG9zaXggKyB3aW4pIHBhdGggY2hhcmFjdGVycyB0aGF0IG1pZ2h0IGludGVyZmVyZSB3aXRoIHJlZ2V4XG4gICAgICAgIC5yZXBsYWNlKC9bLV4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSB1c2UgcG9zaXguam9pbiBiZWNhdXNlOlxuICAgIC8vIDEuIHRoZSBiYXNlUGF0aCBoYXMgYmVlbiBub3JtYWxpemVkIHRvIHVzZSAvXG4gICAgLy8gMi4gdGhlIGluY29taW5nIGdsb2IgKGlkKSBtYXRjaGVyLCBhbHNvIHVzZXMgL1xuICAgIC8vIG90aGVyd2lzZSBOb2RlIHdpbGwgZm9yY2UgYmFja3NsYXNoIChcXCkgb24gd2luZG93c1xuICAgIHJldHVybiBwb3NpeC5qb2luKGJhc2VQYXRoLCBpZCk7XG59XG5jb25zdCBjcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoaW5jbHVkZSwgZXhjbHVkZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc29sdXRpb25CYXNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc29sdmU7XG4gICAgY29uc3QgZ2V0TWF0Y2hlciA9IChpZCkgPT4gaWQgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgPyBpZFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHRlc3Q6ICh3aGF0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyByZWZhY3RvciBpcyBhIHRhZCBvdmVybHkgdmVyYm9zZSBidXQgbWFrZXMgZm9yIGVhc3kgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGdldE1hdGNoZXJTdHJpbmcoaWQsIHJlc29sdXRpb25CYXNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHBtKHBhdHRlcm4sIHsgZG90OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHdoYXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgY29uc3QgaW5jbHVkZU1hdGNoZXJzID0gZW5zdXJlQXJyYXkoaW5jbHVkZSkubWFwKGdldE1hdGNoZXIpO1xuICAgIGNvbnN0IGV4Y2x1ZGVNYXRjaGVycyA9IGVuc3VyZUFycmF5KGV4Y2x1ZGUpLm1hcChnZXRNYXRjaGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVzdWx0KGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoL1xcMC8udGVzdChpZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhdGhJZCA9IGlkLnNwbGl0KHNlcCkuam9pbignLycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVNYXRjaGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IGV4Y2x1ZGVNYXRjaGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyLnRlc3QocGF0aElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNsdWRlTWF0Y2hlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXIgPSBpbmNsdWRlTWF0Y2hlcnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KHBhdGhJZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFpbmNsdWRlTWF0Y2hlcnMubGVuZ3RoO1xuICAgIH07XG59O1xuXG5jb25zdCByZXNlcnZlZFdvcmRzID0gJ2JyZWFrIGNhc2UgY2xhc3MgY2F0Y2ggY29uc3QgY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkZWxldGUgZG8gZWxzZSBleHBvcnQgZXh0ZW5kcyBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbXBvcnQgaW4gaW5zdGFuY2VvZiBsZXQgbmV3IHJldHVybiBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGggeWllbGQgZW51bSBhd2FpdCBpbXBsZW1lbnRzIHBhY2thZ2UgcHJvdGVjdGVkIHN0YXRpYyBpbnRlcmZhY2UgcHJpdmF0ZSBwdWJsaWMnO1xuY29uc3QgYnVpbHRpbnMgPSAnYXJndW1lbnRzIEluZmluaXR5IE5hTiB1bmRlZmluZWQgbnVsbCB0cnVlIGZhbHNlIGV2YWwgdW5ldmFsIGlzRmluaXRlIGlzTmFOIHBhcnNlRmxvYXQgcGFyc2VJbnQgZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBlbmNvZGVVUkkgZW5jb2RlVVJJQ29tcG9uZW50IGVzY2FwZSB1bmVzY2FwZSBPYmplY3QgRnVuY3Rpb24gQm9vbGVhbiBTeW1ib2wgRXJyb3IgRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTeW50YXhFcnJvciBUeXBlRXJyb3IgVVJJRXJyb3IgTnVtYmVyIE1hdGggRGF0ZSBTdHJpbmcgUmVnRXhwIEFycmF5IEludDhBcnJheSBVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IEludDE2QXJyYXkgVWludDE2QXJyYXkgSW50MzJBcnJheSBVaW50MzJBcnJheSBGbG9hdDMyQXJyYXkgRmxvYXQ2NEFycmF5IE1hcCBTZXQgV2Vha01hcCBXZWFrU2V0IFNJTUQgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBQcm9taXNlIEdlbmVyYXRvciBHZW5lcmF0b3JGdW5jdGlvbiBSZWZsZWN0IFByb3h5IEludGwnO1xuY29uc3QgZm9yYmlkZGVuSWRlbnRpZmllcnMgPSBuZXcgU2V0KGAke3Jlc2VydmVkV29yZHN9ICR7YnVpbHRpbnN9YC5zcGxpdCgnICcpKTtcbmZvcmJpZGRlbklkZW50aWZpZXJzLmFkZCgnJyk7XG5jb25zdCBtYWtlTGVnYWxJZGVudGlmaWVyID0gZnVuY3Rpb24gbWFrZUxlZ2FsSWRlbnRpZmllcihzdHIpIHtcbiAgICBsZXQgaWRlbnRpZmllciA9IHN0clxuICAgICAgICAucmVwbGFjZSgvLShcXHcpL2csIChfLCBsZXR0ZXIpID0+IGxldHRlci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZSgvW14kX2EtekEtWjAtOV0vZywgJ18nKTtcbiAgICBpZiAoL1xcZC8udGVzdChpZGVudGlmaWVyWzBdKSB8fCBmb3JiaWRkZW5JZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgICAgaWRlbnRpZmllciA9IGBfJHtpZGVudGlmaWVyfWA7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyIHx8ICdfJztcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgICByZXR1cm4gKEpTT04uc3RyaW5naWZ5KG9iaikgfHwgJ3VuZGVmaW5lZCcpLnJlcGxhY2UoL1tcXHUyMDI4XFx1MjAyOV0vZywgKGNoYXIpID0+IGBcXFxcdSR7YDAwMCR7Y2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC00KX1gKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KGFyciwgaW5kZW50LCBiYXNlSW5kZW50KSB7XG4gICAgbGV0IG91dHB1dCA9ICdbJztcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBpbmRlbnQgPyBgXFxuJHtiYXNlSW5kZW50fSR7aW5kZW50fWAgOiAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBhcnJbaV07XG4gICAgICAgIG91dHB1dCArPSBgJHtpID4gMCA/ICcsJyA6ICcnfSR7c2VwYXJhdG9yfSR7c2VyaWFsaXplKGtleSwgaW5kZW50LCBiYXNlSW5kZW50ICsgaW5kZW50KX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7b3V0cHV0fSR7aW5kZW50ID8gYFxcbiR7YmFzZUluZGVudH1gIDogJyd9XWA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqLCBpbmRlbnQsIGJhc2VJbmRlbnQpIHtcbiAgICBsZXQgb3V0cHV0ID0gJ3snO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IGluZGVudCA/IGBcXG4ke2Jhc2VJbmRlbnR9JHtpbmRlbnR9YCA6ICcnO1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhvYmopO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyaWVzW2ldO1xuICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBtYWtlTGVnYWxJZGVudGlmaWVyKGtleSkgPT09IGtleSA/IGtleSA6IHN0cmluZ2lmeShrZXkpO1xuICAgICAgICBvdXRwdXQgKz0gYCR7aSA+IDAgPyAnLCcgOiAnJ30ke3NlcGFyYXRvcn0ke3N0cmluZ0tleX06JHtpbmRlbnQgPyAnICcgOiAnJ30ke3NlcmlhbGl6ZSh2YWx1ZSwgaW5kZW50LCBiYXNlSW5kZW50ICsgaW5kZW50KX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7b3V0cHV0fSR7aW5kZW50ID8gYFxcbiR7YmFzZUluZGVudH1gIDogJyd9fWA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqLCBpbmRlbnQsIGJhc2VJbmRlbnQpIHtcbiAgICBpZiAob2JqID09PSBJbmZpbml0eSlcbiAgICAgICAgcmV0dXJuICdJbmZpbml0eSc7XG4gICAgaWYgKG9iaiA9PT0gLUluZmluaXR5KVxuICAgICAgICByZXR1cm4gJy1JbmZpbml0eSc7XG4gICAgaWYgKG9iaiA9PT0gMCAmJiAxIC8gb2JqID09PSAtSW5maW5pdHkpXG4gICAgICAgIHJldHVybiAnLTAnO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4gYG5ldyBEYXRlKCR7b2JqLmdldFRpbWUoKX0pYDtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgaWYgKG9iaiAhPT0gb2JqKVxuICAgICAgICByZXR1cm4gJ05hTic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFycmF5KG9iaiwgaW5kZW50LCBiYXNlSW5kZW50KTtcbiAgICBpZiAob2JqID09PSBudWxsKVxuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChvYmosIGluZGVudCwgYmFzZUluZGVudCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xufVxuY29uc3QgZGF0YVRvRXNtID0gZnVuY3Rpb24gZGF0YVRvRXNtKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHQgPSBvcHRpb25zLmNvbXBhY3QgPyAnJyA6ICdpbmRlbnQnIGluIG9wdGlvbnMgPyBvcHRpb25zLmluZGVudCA6ICdcXHQnO1xuICAgIGNvbnN0IF8gPSBvcHRpb25zLmNvbXBhY3QgPyAnJyA6ICcgJztcbiAgICBjb25zdCBuID0gb3B0aW9ucy5jb21wYWN0ID8gJycgOiAnXFxuJztcbiAgICBjb25zdCBkZWNsYXJhdGlvblR5cGUgPSBvcHRpb25zLnByZWZlckNvbnN0ID8gJ2NvbnN0JyA6ICd2YXInO1xuICAgIGlmIChvcHRpb25zLm5hbWVkRXhwb3J0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgZGF0YSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgZGF0YSBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzZXJpYWxpemUoZGF0YSwgb3B0aW9ucy5jb21wYWN0ID8gbnVsbCA6IHQsICcnKTtcbiAgICAgICAgY29uc3QgbWFnaWMgPSBfIHx8ICgvXlt7W1xcLVxcL10vLnRlc3QoY29kZSkgPyAnJyA6ICcgJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgICAgcmV0dXJuIGBleHBvcnQgZGVmYXVsdCR7bWFnaWN9JHtjb2RlfTtgO1xuICAgIH1cbiAgICBsZXQgbmFtZWRFeHBvcnRDb2RlID0gJyc7XG4gICAgY29uc3QgZGVmYXVsdEV4cG9ydFJvd3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBtYWtlTGVnYWxJZGVudGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9iamVjdFNob3J0aGFuZClcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXhwb3J0Um93cy5wdXNoKGtleSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVmYXVsdEV4cG9ydFJvd3MucHVzaChgJHtrZXl9OiR7X30ke2tleX1gKTtcbiAgICAgICAgICAgIG5hbWVkRXhwb3J0Q29kZSArPSBgZXhwb3J0ICR7ZGVjbGFyYXRpb25UeXBlfSAke2tleX0ke199PSR7X30ke3NlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucy5jb21wYWN0ID8gbnVsbCA6IHQsICcnKX07JHtufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0RXhwb3J0Um93cy5wdXNoKGAke3N0cmluZ2lmeShrZXkpfToke199JHtzZXJpYWxpemUodmFsdWUsIG9wdGlvbnMuY29tcGFjdCA/IG51bGwgOiB0LCAnJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWVkRXhwb3J0Q29kZX1leHBvcnQgZGVmYXVsdCR7X317JHtufSR7dH0ke2RlZmF1bHRFeHBvcnRSb3dzLmpvaW4oYCwke259JHt0fWApfSR7bn19OyR7bn1gO1xufTtcblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gbmV4dCBtYWpvclxudmFyIGluZGV4ID0ge1xuICAgIGFkZEV4dGVuc2lvbixcbiAgICBhdHRhY2hTY29wZXMsXG4gICAgY3JlYXRlRmlsdGVyLFxuICAgIGRhdGFUb0VzbSxcbiAgICBleHRyYWN0QXNzaWduZWROYW1lcyxcbiAgICBtYWtlTGVnYWxJZGVudGlmaWVyXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IGFkZEV4dGVuc2lvbiwgYXR0YWNoU2NvcGVzLCBjcmVhdGVGaWx0ZXIsIGRhdGFUb0VzbSwgZXh0cmFjdEFzc2lnbmVkTmFtZXMs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QUFBQSxNQUFHO0FBQUEsTUFDN0M7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUM3QztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFDN0M7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUM3QztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFB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O0FBQUEsTUFDcEIsK0JBQStCO0FBQUEsTUFDL0IsZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZTtBQUFBLE1BQ2YsMEJBQTBCO0FBQUEsTUFDMUIsbUJBQW1CO0FBQUEsTUFDbkIscUJBQXFCO0FBQUEsTUFDckIsZUFBZTtBQUFBLE1BQ2YsbUJBQW1CO0FBQUEsTUFDbkIsZ0JBQWdCO0FBQUEsTUFDaEIsT0FBTztBQUFBLE1BQ1AsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osU0FBUztBQUFBLE1BQ1Qsa0JBQWtCO0FBQUEsTUFDbEIsU0FBUztBQUFBLE1BQ1Qsb0JBQW9CO0FBQUEsTUFDcEIsZUFBZTtBQUFBLE1BQ2Ysc0JBQXNCO0FBQUEsTUFDdEIsbUJBQW1CO0FBQUEsTUFDbkIsWUFBWTtBQUFBLE1BQ1osc0JBQXNCO0FBQUEsTUFDdEIsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsV0FBVztBQUFBLE1BQ1gsS0FBSztBQUFBLE1BQ0wsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsaUJBQWlCO0FBQUEsTUFDakIsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsYUFBYTtBQUFBLE1BQ2IsU0FBUztBQUFBLE1BQ1QsYUFBYTtBQUFBLE1BQ2IscUJBQXFCO0FBQUEsTUFDckIsY0FBYztBQUFBLE1BQ2QsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsTUFDakIsdUJBQXVCO0FBQUEsTUFDdkIsZ0JBQWdCO0FBQUEsTUFDaEIsYUFBYTtBQUFBLE1BQ2IsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsc0JBQXNCO0FBQUEsTUFDdEIsZUFBZTtBQUFBLE1BQ2YsZUFBZTtBQUFBLE1BQ2YsV0FBVztBQUFBLE1BQ1gsbUJBQW1CO0FBQUEsTUFDbkIsd0JBQXdCO0FBQUEsTUFDeEIsa0JBQWtCO0FBQUEsTUFDbEIsZUFBZTtBQUFBLE1BQ2YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1Ysa0JBQWtCO0FBQUEsTUFDbEIsY0FBYztBQUFBLE1BQ2QsVUFBVTtBQUFBLE1BQ1YsY0FBYztBQUFBLE1BQ2QsbUJBQW1CO0FBQUEsTUFDbkIsV0FBVztBQUFBLE1BQ1gsbUJBQW1CO0FBQUEsTUFDbkIsV0FBVztBQUFBLE1BQ1gsVUFBVTtBQUFBLE1BQ1Ysa0JBQWtCO0FBQUEsTUFDbEIsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsaUJBQWlCO0FBQUEsTUFDakIsZUFBZTtBQUFBLE1BQ2YsY0FBYztBQUFBLE1BQ2QsY0FBYztBQUFBLE1BQ2QsV0FBVztBQUFBLE1BQ1gsd0JBQXdCO0FBQUEsTUFDeEIsU0FBUztBQUFBLE1BQ1QsWUFBWTtBQUFBLE1BQ1osT0FBTztBQUFBLE1BQ1AsYUFBYTtBQUFBLE1BQ2IsYUFBYTtBQUFBLE1BQ2IsVUFBVTtBQUFBLE1BQ1YsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLE1BQ04sVUFBVTtBQUFBLE1BQ1YsWUFBWTtBQUFBLE1BQ1osTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLE1BQ1Ysc0JBQXNCO0FBQUEsTUFDdEIsVUFBVTtBQUFBLE1BQ1YsUUFBUTtBQUFBLE1BQ1IsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsZUFBZTtBQUFBLE1BQ2YsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsY0FBYztBQUFBLE1BQ2QsaUJBQWlCO0FBQUEsTUFDakIsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsaUJBQWlCO0FBQUEsTUFDakIsZUFBZTtBQUFBLE1BQ2YsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsZ0JBQWdCO0FBQUEsTUFDaEIsb0JBQW9CO0FBQUEsTUFDcEIsaUJBQWlCO0FBQUEsTUFDakIscUJBQXFCO0FBQUEsTUFDckIsb0JBQW9CO0FBQUEsTUFDcEIsbUJBQW1CO0FBQUEsTUFDbkIsc0JBQXNCO0FBQUEsTUFDdEIsZ0JBQWdCO0FBQUEsTUFDaEIsa0JBQWtCO0FBQUEsTUFDbEIsY0FBYztBQUFBLE1BQ2QsYUFBYTtBQUFBLE1BQ2Isa0JBQWtCO0FBQUEsTUFDbEIscUJBQXFCO0FBQUEsTUFDckIsaUJBQWlCO0FBQUEsTUFDakIsNEJBQTRCO0FBQUEsTUFDNUIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIscUJBQXFCO0FBQUEsTUFDckIsaUJBQWlCO0FBQUEsTUFDakIsb0JBQW9CO0FBQUEsTUFDcEIsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsTUFDakIsbUJBQW1CO0FBQUEsTUFDbkIsa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsbUJBQW1CO0FBQUEsTUFDbkIsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsTUFDakIsZ0JBQWdCO0FBQUEsTUFDaEIsb0JBQW9CO0FBQUEsTUFDcEIsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIsZ0JBQWdCO0FBQUEsTUFDaEIsbUJBQW1CO0FBQUEsTUFDbkIsa0JBQWtCO0FBQUEsTUFDbEIscUJBQXFCO0FBQUEsTUFDckIsbUJBQW1CO0FBQUEsTUFDbkIsdUJBQXVCO0FBQUEsTUFDdkIsbUJBQW1CO0FBQUEsTUFDbkIsc0JBQXNCO0FBQUEsTUFDdEIsa0JBQWtCO0FBQUEsTUFDbEIsb0JBQW9CO0FBQUEsTUFDcEIsZ0JBQWdCO0FBQUEsTUFDaEIscUJBQXFCO0FBQUEsTUFDckIsa0JBQWtCO0FBQUEsTUFDbEIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsaUJBQWlCO0FBQUEsTUFDakIsbUJBQW1CO0FBQUEsTUFDbkIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIseUJBQXlCO0FBQUEsTUFDekIsc0JBQXNCO0FBQUEsTUFDdEIscUJBQXFCO0FBQUEsTUFDckIsa0JBQWtCO0FBQUEsTUFDbEIscUJBQXFCO0FBQUEsTUFDckIseUJBQXlCO0FBQUEsTUFDekIscUJBQXFCO0FBQUEsTUFDckIscUJBQXFCO0FBQUEsTUFDckIsaUJBQWlCO0FBQUEsTUFDakIsa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsb0JBQW9CO0FBQUEsTUFDcEIsa0JBQWtCO0FBQUEsTUFDbEIsV0FBVztBQUFBLE1BQ1gsb0JBQW9CO0FBQUEsTUFDcEIsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLE1BQ2IsZ0JBQWdCO0FBQUEsTUFDaEIsa0JBQWtCO0FBQUEsTUFDbEIsWUFBWTtBQUFBLE1BQ1osZ0JBQWdCO0FBQUEsTUFDaEIsdUJBQXVCO0FBQUEsTUFDdkIsY0FBYztBQUFBLE1BQ2QsZUFBZTtBQUFBLE1BQ2YsT0FBTztBQUFBLE1BQ1AsYUFBYTtBQUFBLE1BQ2IsNkJBQTZCO0FBQUEsTUFDN0IsY0FBYztBQUFBLE1BQ2QsV0FBVztBQUFBLE1BQ1gsV0FBVztBQUFBLE1BQ1gsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osWUFBWTtBQUFBLE1BQ1osc0JBQXNCO0FBQUEsTUFDdEIsMkJBQTJCO0FBQUEsTUFDM0IsaUJBQWlCO0FBQUEsTUFDakIsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsY0FBYztBQUFBLE1BQ2QsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osaUJBQWlCO0FBQUEsTUFDakIsY0FBYztBQUFBLE1BQ2QsNkJBQTZCO0FBQUEsTUFDN0IscUJBQXFCO0FBQUEsTUFDckIsWUFBWTtBQUFBLE1BQ1osc0JBQXNCO0FBQUEsTUFDdEIsaUJBQWlCO0FBQUEsTUFDakIsbUJBQW1CO0FBQUEsTUFDbkIsc0JBQXNCO0FBQUEsTUFDdEIsV0FBVztBQUFBLE1BQ1gsZ0JBQWdCO0FBQUEsTUFDaEIscUJBQXFCO0FBQUEsTUFDckIsZUFBZTtBQUFBLE1BQ2Ysb0JBQW9CO0FBQUEsTUFDcEIsYUFBYTtBQUFBLE1BQ2IsYUFBYTtBQUFBLE1BQ2IsaUNBQWlDO0FBQUEsTUFDakMsNEJBQTRCO0FBQUEsTUFDNUIsa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsdUJBQXVCO0FBQUEsTUFDdkIsU0FBUztBQUFBLE1BQ1QsZ0JBQWdCO0FBQUEsTUFDaEIsY0FBYztBQUFBLE1BQ2QsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1oscUJBQXFCO0FBQUEsTUFDckIsV0FBVztBQUFBLE1BQ1gsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsWUFBWTtBQUFBLE1BQ1osZUFBZTtBQUFBLE1BQ2YsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsZUFBZTtBQUFBLE1BQ2YsWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsZUFBZTtBQUFBLE1BQ2Ysa0JBQWtCO0FBQUEsTUFDbEIsZ0JBQWdCO0FBQUEsTUFDaEIsTUFBTTtBQUFBLE1BQ04sY0FBYztBQUFBLE1BQ2QsMEJBQTBCO0FBQUEsTUFDMUIsV0FBVztBQUFBLE1BQ1gsV0FBVztBQUFBLE1BQ1gsb0JBQW9CO0FBQUEsTUFDcEIsTUFBTTtBQUFBLE1BQ04sWUFBWTtBQUFBLE1BQ1osY0FBYztBQUFBLE1BQ2QsVUFBVTtBQUFBLE1BQ1YsY0FBYztBQUFBLE1BQ2QsNkJBQTZCO0FBQUEsTUFDN0IscUJBQXFCO0FBQUEsTUFDckIsb0JBQW9CO0FBQUEsTUFDcEIsaUJBQWlCO0FBQUEsTUFDakIsTUFBTTtBQUFBLE1BQ04sY0FBYztBQUFBLE1BQ2QsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsZ0JBQWdCO0FBQUEsTUFDaEIsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1oscUJBQXFCO0FBQUEsTUFDckIsYUFBYTtBQUFBLE1BQ2IsYUFBYTtBQUFBLE1BQ2IsWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsZ0JBQWdCO0FBQUEsTUFDaEIsZ0JBQWdCO0FBQUEsTUFDaEIsMkJBQTJCO0FBQUEsTUFDM0IsaUJBQWlCO0FBQUEsTUFDakIsYUFBYTtBQUFBLE1BQ2IsYUFBYTtBQUFBLE1BQ2Isa0JBQWtCO0FBQUEsTUFDbEIsMkJBQTJCO0FBQUEsTUFDM0IsaUJBQWlCO0FBQUEsTUFDakIsb0JBQW9CO0FBQUEsTUFDcEIsdUJBQXVCO0FBQUEsTUFDdkIsNkJBQTZCO0FBQUEsTUFDN0IscUJBQXFCO0FBQUEsTUFDckIsOEJBQThCO0FBQUEsTUFDOUIsd0JBQXdCO0FBQUEsTUFDeEIsMkJBQTJCO0FBQUEsTUFDM0IsbUJBQW1CO0FBQUEsTUFDbkIsY0FBYztBQUFBLE1BQ2QsYUFBYTtBQUFBLE1BQ2Isa0JBQWtCO0FBQUEsTUFDbEIsYUFBYTtBQUFBLE1BQ2IsbUJBQW1CO0FBQUEsTUFDbkIsUUFBUTtBQUFBLE1BQ1IsYUFBYTtBQUFBLE1BQ2IsY0FBYztBQUFBLE1BQ2QsZUFBZTtBQUFBLE1BQ2YsYUFBYTtBQUFBLE1BQ2IsY0FBYztBQUFBLE1BQ2QsMEJBQTBCO0FBQUEsTUFDMUIsd0JBQXdCO0FBQUEsTUFDeEIsc0NBQXNDO0FBQUEsTUFDdEMsa0NBQWtDO0FBQUEsTUFDbEMsNEJBQTRCO0FBQUEsTUFDNUIsc0JBQXNCO0FBQUEsTUFDdEIscUJBQXFCO0FBQUEsTUFDckIsT0FBTztBQUFBLE1BQ1AsdUJBQXVCO0FBQUEsTUFDdkIsZUFBZTtBQUFBLE1BQ2YsdUJBQXVCO0FBQUEsTUFDdkIsUUFBUTtBQUFBLE1BQ1IsYUFBYTtBQUFBLE1BQ2Isa0JBQWtCO0FBQUEsTUFDbEIseUJBQXlCO0FBQUEsTUFDekIsZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZTtBQUFBLE1BQ2YsT0FBTztBQUFBLE1BQ1AsZ0JBQWdCO0FBQUEsTUFDaEIsZ0JBQWdCO0FBQUEsTUFDaEIscUJBQXFCO0FBQUEsTUFDckIsU0FBUztBQUFBLE1BQ1QsdUJBQXVCO0FBQUEsTUFDdkIscUJBQXFCO0FBQUEsTUFDckIsVUFBVTtBQUFBLE1BQ1YsZ0JBQWdCO0FBQUEsTUFDaEIscUJBQXFCO0FBQUEsTUFDckIsVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsZ0JBQWdCO0FBQUEsTUFDaEIsZ0JBQWdCO0FBQUEsTUFDaEIscUJBQXFCO0FBQUEsTUFDckIsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsaUJBQWlCO0FBQUEsTUFDakIsbUJBQW1CO0FBQUEsTUFDbkIsMkJBQTJCO0FBQUEsTUFDM0IsZ0JBQWdCO0FBQUEsTUFDaEIsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsdUJBQXVCO0FBQUEsTUFDdkIsZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZTtBQUFBLE1BQ2YsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osbUJBQW1CO0FBQUEsTUFDbkIsV0FBVztBQUFBLE1BQ1gsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QscUJBQXFCO0FBQUEsTUFDckIsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLE1BQ1YsVUFBVTtBQUFBLE1BQ1YsU0FBUztBQUFBLE1BQ1QsU0FBUztBQUFBLE1BQ1QsOEJBQThCO0FBQUEsTUFDOUIsV0FBVztBQUFBLE1BQ1gsZUFBZTtBQUFBLE1BQ2Ysd0JBQXdCO0FBQUEsTUFDeEIsMkJBQTJCO0FBQUEsTUFDM0IsZ0JBQWdCO0FBQUEsTUFDaEIsWUFBWTtBQUFBLE1BQ1osY0FBYztBQUFBLE1BQ2QsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsc0JBQXNCO0FBQUEsTUFDdEIsMEJBQTBCO0FBQUEsTUFDMUIsYUFBYTtBQUFBLE1BQ2IsUUFBUTtBQUFBLE1BQ1IsV0FBVztBQUFBLE1BQ1gsa0JBQWtCO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLE1BQ1QsY0FBYztBQUFBLE1BQ2QsZ0JBQWdCO0FBQUEsTUFDaEIsWUFBWTtBQUFBLE1BQ1osWUFBWTtBQUFBLE1BQ1osZ0JBQWdCO0FBQUEsTUFDaEIsY0FBYztBQUFBLE1BQ2QsYUFBYTtBQUFBLE1BQ2IsVUFBVTtBQUFBLE1BQ1Ysa0JBQWtCO0FBQUEsTUFDbEIsb0JBQW9CO0FBQUEsTUFDcEIsd0JBQXdCO0FBQUEsTUFDeEIsb0JBQW9CO0FBQUEsTUFDcEIsbUJBQW1CO0FBQUEsTUFDbkIsdUJBQXVCO0FBQUEsTUFDdkIsbUJBQW1CO0FBQUEsTUFDbkIsdUJBQXVCO0FBQUEsTUFDdkIsZ0NBQWdDO0FBQUEsTUFDaEMsaUJBQWlCO0FBQUEsTUFDakIsbUJBQW1CO0FBQUEsTUFDbkIsMEJBQTBCO0FBQUEsTUFDMUIsbUJBQW1CO0FBQUEsTUFDbkIseUJBQXlCO0FBQUEsTUFDekIsNEJBQTRCO0FBQUEsTUFDNUIscUJBQXFCO0FBQUEsTUFDckIsa0JBQWtCO0FBQUEsTUFDbEIsb0JBQW9CO0FBQUEsTUFDcEIscUNBQXFDO0FBQUEsTUFDckMsZ0JBQWdCO0FBQUEsTUFDaEIsZ0JBQWdCO0FBQUEsTUFDaEIsbUJBQW1CO0FBQUEsTUFDbkIsWUFBWTtBQUFBLE1BQ1osbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIseUJBQXlCO0FBQUEsTUFDekIsK0JBQStCO0FBQUEsTUFDL0IsdUJBQXVCO0FBQUEsTUFDdkIsNEJBQTRCO0FBQUEsTUFDNUIsNkJBQTZCO0FBQUEsTUFDN0IsNkJBQTZCO0FBQUEsTUFDN0IsMEJBQTBCO0FBQUEsTUFDMUIsd0JBQXdCO0FBQUEsTUFDeEIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsMEJBQTBCO0FBQUEsTUFDMUIsbUJBQW1CO0FBQUEsTUFDbkIsbUJBQW1CO0FBQUEsTUFDbkIsdUJBQXVCO0FBQUEsTUFDdkIsd0JBQXdCO0FBQUEsTUFDeEIsb0JBQW9CO0FBQUEsTUFDcEIsd0JBQXdCO0FBQUEsTUFDeEIsOEJBQThCO0FBQUEsTUFDOUIsdUJBQXVCO0FBQUEsTUFDdkIsa0JBQWtCO0FBQUEsTUFDbEIsd0JBQXdCO0FBQUEsTUFDeEIsa0JBQWtCO0FBQUEsTUFDbEIseUJBQXlCO0FBQUEsTUFDekIsYUFBYTtBQUFBLE1BQ2Isb0JBQW9CO0FBQUEsTUFDcEIsb0JBQW9CO0FBQUEsTUFDcEIsb0JBQW9CO0FBQUEsTUFDcEIsaUJBQWlCO0FBQUEsTUFDakIsV0FBVztBQUFBLE1BQ1gsZUFBZTtBQUFBLE1BQ2YsMEJBQTBCO0FBQUEsTUFDMUIsZ0JBQWdCO0FBQUEsTUFDaEIsa0JBQWtCO0FBQUEsTUFDbEIsZ0JBQWdCO0FBQUEsTUFDaEIsV0FBVztBQUFBLE1BQ1gsb0JBQW9CO0FBQUEsTUFDcEIsaUJBQWlCO0FBQUEsTUFDakIsV0FBVztBQUFBLE1BQ1gsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsbUJBQW1CO0FBQUEsTUFDbkIsVUFBVTtBQUFBLE1BQ1YsY0FBYztBQUFBLE1BQ2QsbUJBQW1CO0FBQUEsTUFDbkIsb0JBQW9CO0FBQUEsTUFDcEIsd0JBQXdCO0FBQUEsTUFDeEIsMEJBQTBCO0FBQUEsTUFDMUIsU0FBUztBQUFBLE1BQ1QsZ0JBQWdCO0FBQUEsTUFDaEIsa0JBQWtCO0FBQUEsTUFDbEIsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsTUFDakIsZUFBZTtBQUFBLE1BQ2Ysa0JBQWtCO0FBQUEsTUFDbEIsa0JBQWtCO0FBQUEsTUFDbEIsdUJBQXVCO0FBQUEsTUFDdkIsZ0JBQWdCO0FBQUEsTUFDaEIsb0JBQW9CO0FBQUEsTUFDcEIsMkJBQTJCO0FBQUEsTUFDM0IsaUJBQWlCO0FBQUEsTUFDakIsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsaUJBQWlCO0FBQUEsTUFDakIsY0FBYztBQUFBLE1BQ2QsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsdUJBQXVCO0FBQUEsTUFDdkIsTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsYUFBYTtBQUFBLE1BQ2IsV0FBVztBQUFBLE1BQ1gsY0FBYztBQUFBLE1BQ2Qsa0JBQWtCO0FBQUEsTUFDbEIsZUFBZTtBQUFBLE1BQ2YsWUFBWTtBQUFBLE1BQ1osU0FBUztBQUFBLE1BQ1QsS0FBSztBQUFBLE1BQ0wsT0FBTztBQUFBLE1BQ1AsWUFBWTtBQUFBLE1BQ1osV0FBVztBQUFBLE1BQ1gsWUFBWTtBQUFBLE1BQ1osaUJBQWlCO0FBQUEsTUFDakIsWUFBWTtBQUFBLE1BQ1osU0FBUztBQUFBLE1BQ1QsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsZ0JBQWdCO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsZ0JBQWdCO0FBQUEsTUFDaEIsYUFBYTtBQUFBLE1BQ2Isd0JBQXdCO0FBQUEsTUFDeEIsaUJBQWlCO0FBQUEsTUFDakIsYUFBYTtBQUFBLE1BQ2IsbUJBQW1CO0FBQUEsTUFDbkIsa0JBQWtCO0FBQUEsTUFDbEIsY0FBYztBQUFBLE1BQ2QsWUFBWTtBQUFBLE1BQ1osbUJBQW1CO0FBQUEsTUFDbkIsdUJBQXVCO0FBQUEsTUFDdkIsY0FBYztBQUFBLE1BQ2QsYUFBYTtBQUFBLE1BQ2IsNEJBQTRCO0FBQUEsTUFDNUIsV0FBVztBQUFBLE1BQ1gsY0FBYztBQUFBLE1BQ2Qsd0JBQXdCO0FBQUEsTUFDeEIsc0JBQXNCO0FBQUEsTUFDdEIsd0JBQXdCO0FBQUEsTUFDeEIsV0FBVztBQUFBLE1BQ1gsWUFBWTtBQUFBLE1BQ1osUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsZ0JBQWdCO0FBQUEsTUFDaEIsYUFBYTtBQUFBLE1BQ2IsZ0JBQWdCO0FBQUEsTUFDaEIsMkJBQTJCO0FBQUEsTUFDM0Isc0JBQXNCO0FBQUEsTUFDdEIsZUFBZTtBQUFBLE1BQ2YsZ0JBQWdCO0FBQUEsTUFDaEIsaUJBQWlCO0FBQUEsTUFDakIsYUFBYTtBQUFBLE1BQ2IsZUFBZTtBQUFBLElBQ25CO0FBQ0EsZUFBVyxVQUFVLENBQUMsVUFBVSxVQUFVLFFBQVEsWUFBWSxHQUFHO0FBQzdELG1CQUFhLFVBQVU7QUFBQSxJQUMzQjtBQXlCQSxJQUFNLGlCQUFOLGNBQTZCLFNBQVM7QUFBQSxNQUNsQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxlQUFlO0FBQUEsTUFDeEI7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixlQUFPLENBQUMsZUFBZSxDQUFDLEtBQUssTUFBTSxHQUFHQSxLQUFJLENBQUM7QUFBQSxNQUMvQztBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNO0FBQzdCLGVBQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxNQUFNLEdBQUdBLEtBQUksQ0FBQztBQUFBLE1BQzdDO0FBQUEsSUFDSjtBQUVBLElBQU0sbUJBQW1CO0FBQUEsTUFDckIsV0FBVztBQUFBLE1BQ1gsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLElBQ1Q7QUFDQSxJQUFNLGFBQU4sY0FBeUIsU0FBUztBQUFBLE1BQzlCLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLFdBQVc7QUFDaEIsYUFBSyxjQUFjO0FBQ25CLGFBQUssY0FBYztBQUFBLE1BQ3ZCO0FBQUEsTUFDQSxxQkFBcUIsV0FBVyx1QkFBdUI7QUFDbkQsWUFBSSxLQUFLLGFBQWEsUUFBUSxzQkFBc0IsSUFBSSxLQUFLLFFBQVEsR0FBRztBQUNwRSxvQkFBVSxLQUFLLEtBQUssUUFBUTtBQUFBLFFBQ2hDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTztBQUNILFlBQUksS0FBSyxhQUFhLFFBQVEsYUFBYSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELGVBQUssV0FBVyxLQUFLLE1BQU0sYUFBYSxLQUFLLElBQUk7QUFDakQsZUFBSyxTQUFTLGFBQWEsSUFBSTtBQUFBLFFBQ25DO0FBQUEsTUFDSjtBQUFBLE1BQ0EsUUFBUSxNQUFNLE1BQU07QUFDaEIsWUFBSTtBQUNKLGNBQU0sRUFBRSxVQUFVLElBQUksS0FBSyxRQUFRO0FBQ25DLGdCQUFRLE1BQU07QUFBQSxVQUNWLEtBQUs7QUFDRCx1QkFBVyxLQUFLLE1BQU0sZUFBZSxNQUFNLEtBQUssU0FBUyxNQUFNLElBQUk7QUFDbkUsZ0JBQUksYUFBYSxVQUFVLGtDQUFrQztBQUV6RCx1QkFBUyxrQ0FBa0M7QUFBQSxZQUMvQztBQUNBO0FBQUEsVUFDSixLQUFLO0FBRUQsdUJBQVcsS0FBSyxNQUFNLGVBQWUsTUFBTSxLQUFLLFNBQVMsTUFBTSxLQUFLO0FBQ3BFO0FBQUEsVUFDSixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQ0QsdUJBQVcsS0FBSyxNQUFNLGVBQWUsTUFBTSxLQUFLLFNBQVMsTUFBTSxLQUFLO0FBQ3BFO0FBQUEsVUFDSixLQUFLO0FBQ0QsdUJBQVcsS0FBSyxNQUFNLHdCQUF3QixJQUFJO0FBQ2xEO0FBQUEsVUFFSjtBQUVJLGtCQUFNLElBQUksTUFBTSw4Q0FBOEMsT0FBTztBQUFBLFFBQzdFO0FBQ0EsaUJBQVMsT0FBTztBQUNoQixlQUFPLENBQUUsS0FBSyxXQUFXLFFBQVM7QUFBQSxNQUN0QztBQUFBLE1BQ0EsZUFBZUEsT0FBTTtBQUNqQixZQUFJQSxNQUFLLFdBQVcsS0FBSyxDQUFDLEtBQUssTUFBTSxTQUFTLEtBQUssSUFBSSxHQUFHO0FBQ3RELGVBQUssMkJBQTJCO0FBQUEsUUFDcEM7QUFDQSxhQUFLLFNBQVMsZUFBZUEsS0FBSTtBQUFBLE1BQ3JDO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxhQUFLLFNBQVMsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxnQkFBZ0I7QUFBQSxNQUMxRjtBQUFBLE1BQ0Esc0JBQXNCQSxPQUFNLGtCQUFrQixRQUFRO0FBQ2xELGVBQU8sS0FBSyx5QkFBeUIsRUFBRSxzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxNQUMvRjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsZUFBTyxLQUFLLHlCQUF5QixFQUFFLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixNQUFNO0FBQUEsTUFDMUg7QUFBQSxNQUNBLGFBQWE7QUFDVCxZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLFlBQUksS0FBSyxjQUFjLEtBQUssS0FBSyxTQUFTLFNBQVMsT0FBTztBQUN0RCxpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFRLEtBQUssUUFBUSxRQUFRLFVBQVUsNEJBQ25DLEtBQUssb0JBQW9CLGtCQUN6QixLQUFLLFNBQVMsNkJBQTZCLFVBQVU7QUFBQSxNQUM3RDtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsZUFBUSxLQUFLLGFBQWEsUUFDdEIsS0FBSyx5QkFBeUIsRUFBRSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQ2xGO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFRLENBQUMsS0FBSyxhQUNUQSxNQUFLLFNBQVMsSUFDVCxLQUFLLHlCQUF5QixJQUM5QixLQUFLLFVBQVUsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxNQUN2RTtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxlQUFRLENBQUMsS0FBSyxZQUNWLEtBQUsseUJBQXlCLEVBQUUsMkJBQTJCQSxPQUFNLGFBQWEsT0FBTztBQUFBLE1BQzdGO0FBQUEsTUFDQSxVQUFVO0FBQ04sWUFBSSxDQUFDLEtBQUs7QUFDTixlQUFLLHFCQUFxQjtBQUM5QixZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGVBQUssV0FBVztBQUNoQixjQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLGlCQUFLLFFBQVEsd0JBQXdCLEtBQUssUUFBUTtBQUFBLFVBQ3REO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHFCQUFxQixTQUFTLE1BQU07QUFDaEMsYUFBSyx5QkFBeUIsRUFBRSxxQkFBcUIsU0FBUyxJQUFJO0FBQUEsTUFDdEU7QUFBQSxNQUNBLGdCQUFnQjtBQUVaLFlBQUksS0FBSyxnQkFBZ0I7QUFDckIsaUJBQU8sS0FBSztBQUNoQixZQUFJLEVBQUUsS0FBSyxvQkFBb0Isa0JBQzNCLENBQUMsS0FBSyxTQUFTLFFBQ2YsRUFBRSxLQUFLLFNBQVMsUUFBUSxtQkFBbUI7QUFDM0MsaUJBQVEsS0FBSyxjQUFjO0FBQUEsUUFDL0I7QUFDQSxZQUFJO0FBQ0osWUFBSSxLQUFLLFNBQVMsZ0JBQ2QsS0FBSyxTQUFTLGFBQWEsV0FBVyxNQUNyQyxVQUFVLEtBQUssU0FBUyxhQUFhLE9BQ3RDLEtBQUssUUFBUSxRQUFRLFNBQ3JCLCtCQUErQixJQUFJLE1BQU0sK0JBQStCLE9BQU8sR0FBRztBQUdsRixpQkFBUSxLQUFLLGNBQWM7QUFBQSxRQUMvQjtBQUNBLFlBQUksQ0FBQyxLQUFLLFNBQVMsYUFBYTtBQUc1QixpQkFBUSxLQUFLLGNBQWM7QUFBQSxRQUMvQjtBQUNBLGVBQVEsS0FBSyxjQUFjO0FBQUEsTUFDL0I7QUFBQSxNQUNBLHlCQUF5QjtBQUNyQixhQUFLLFNBQVMsY0FBYztBQUFBLE1BQ2hDO0FBQUEsTUFDQSxPQUFPLE1BQU0sRUFBRSxVQUFVLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLG9CQUFvQiwwQkFBMEIsb0JBQW9CLElBQUksT0FBTztBQUM3SCxZQUFJLEtBQUssVUFBVTtBQUNmLGdCQUFNLE9BQU8sS0FBSyxTQUFTLFFBQVEsaUJBQWlCO0FBQ3BELGNBQUksU0FBUyxLQUFLLE1BQU07QUFDcEIsaUJBQUssVUFBVSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU07QUFBQSxjQUN2QyxhQUFhO0FBQUEsY0FDYixXQUFXO0FBQUEsWUFDZixDQUFDO0FBQ0QsZ0JBQUkscUJBQXFCO0FBQ3JCLG1CQUFLLGFBQWEsS0FBSyxPQUFPLEdBQUcsS0FBSyxRQUFRO0FBQUEsWUFDbEQ7QUFBQSxVQUNKO0FBRUEsY0FBSSxTQUFTLFVBQ1QsdUJBQXVCLG9CQUN2QiwwQkFBMEI7QUFDMUIsaUJBQUssWUFBWSxLQUFLLE9BQU8sS0FBSztBQUFBLFVBQ3RDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsWUFBSSxLQUFLLGFBQWEsUUFBUSxLQUFLLG9CQUFvQixlQUFlO0FBQ2xFLGVBQUssU0FBUyx3QkFBd0I7QUFDdEMsZUFBSyxRQUFRLHVCQUF1QjtBQUFBLFFBQ3hDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsNkJBQTZCO0FBQ3pCLGVBQU8sS0FBSyxRQUFRLE1BQU07QUFBQSxVQUN0QixNQUFNO0FBQUEsVUFDTixTQUFTLG1DQUFtQyxLQUFLO0FBQUEsUUFDckQsR0FBRyxLQUFLLEtBQUs7QUFBQSxNQUNqQjtBQUFBLE1BQ0EsMkJBQTJCO0FBQ3ZCLFlBQUksS0FBSyxjQUFjLEdBQUc7QUFDdEIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxJQUNKO0FBU0EsSUFBTSxjQUFOLGNBQTBCLFNBQVM7QUFBQSxNQUMvQixjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQ25CLGFBQUssa0JBQWtCO0FBQUEsTUFDM0I7QUFBQSxNQUNBLHFCQUFxQixXQUFXLHVCQUF1QjtBQUNuRCxhQUFLLFNBQVMscUJBQXFCLFdBQVcscUJBQXFCO0FBQUEsTUFDdkU7QUFBQSxNQUNBLFFBQVEsTUFBTSxNQUFNO0FBQ2hCLGFBQUssa0JBQWtCO0FBQ3ZCLGVBQU8sS0FBSyxTQUFTLFFBQVEsTUFBTSxrQkFBa0I7QUFBQSxNQUN6RDtBQUFBLE1BQ0EsZUFBZUEsT0FBTTtBQUNqQixRQUFBQSxNQUFLLFdBQVcsS0FBSyxLQUFLLFNBQVMsZUFBZSxVQUFVO0FBQUEsTUFDaEU7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQU9BLE1BQUssU0FBUyxLQUFLLEtBQUssU0FBUyw2QkFBNkIsWUFBWSxPQUFPO0FBQUEsTUFDNUY7QUFBQSxNQUNBLHlCQUF5QjtBQUNyQixhQUFLLFNBQVMsdUJBQXVCO0FBQUEsTUFDekM7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsWUFBSSxLQUFLLG9CQUFvQixNQUFNO0FBQy9CLGVBQUssZ0JBQWdCLGVBQWUsQ0FBQyxZQUFZLFVBQVUsQ0FBQztBQUM1RCxlQUFLLFFBQVEsdUJBQXVCO0FBQUEsUUFDeEM7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sMEJBQU4sY0FBc0MsU0FBUztBQUFBLE1BQzNDLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLG9CQUFvQjtBQUFBLE1BQzdCO0FBQUEsTUFDQSxZQUFZLGFBQWE7QUFDckIsYUFBSyxRQUFRLElBQUksaUJBQWlCLGFBQWEsS0FBSyxPQUFPO0FBQUEsTUFDL0Q7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFHakIsWUFBSUEsTUFBSyxXQUFXLEtBQUtBLE1BQUssT0FBTyxZQUFZO0FBQzdDLGVBQUssTUFBTSxvQkFBb0IsRUFBRSxlQUFlLFlBQVk7QUFBQSxRQUNoRTtBQUFBLE1BQ0o7QUFBQSxNQUVBLDhCQUE4QjtBQUFBLE1BQUU7QUFBQSxNQUNoQyxvQ0FBb0NBLE9BQU07QUFDdEMsWUFBSUEsTUFBSyxXQUFXLEdBQUc7QUFDbkIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsWUFBSSxLQUFLLE9BQU87QUFDWixjQUFJLENBQUMsS0FBSyxtQkFBbUI7QUFDekIsaUJBQUssb0JBQW9CO0FBQ3pCLGlCQUFLLE1BQU0sb0JBQW9CLEVBQUUsZUFBZSxZQUFZO0FBQzVELGlCQUFLLFFBQVEsdUJBQXVCO0FBQUEsVUFDeEM7QUFDQSxpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPLEtBQUssTUFBTSxvQkFBb0I7QUFBQSxNQUMxQztBQUFBLE1BQ0EsYUFBYTtBQUNULGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU07QUFDL0IsZUFBT0EsTUFBSyxTQUFTO0FBQUEsTUFDekI7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixlQUFPQSxNQUFLLFNBQVM7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGNBQWMsU0FBUztBQUNwRCxZQUFJQSxNQUFLLFNBQVM7QUFDZCxpQkFBTztBQUNYLFlBQUksS0FBSyxPQUFPO0FBQ1osZ0JBQU0sRUFBRSx3QkFBd0IsSUFBSSxLQUFLLFFBQVEsUUFDNUM7QUFDTCxnQkFBTSxtQkFBbUIsS0FBSyxNQUFNLG9CQUFvQjtBQUN4RCxjQUFJLGlCQUFpQiwyQkFBMkIsQ0FBQyxNQUFNLEdBQUcsRUFBRSxNQUFNLFNBQVMsV0FBVyxNQUFNLFNBQVMsTUFBTSxHQUFHLE9BQU8sS0FDaEgsNEJBQ0ksNEJBQTRCLFlBQ3pCLGlCQUFpQiw2QkFBNkIsQ0FBQyxNQUFNLEdBQUcsT0FBTyxJQUFLO0FBQzVFLG1CQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFDQSxtQkFBVyxTQUFTLEtBQUssUUFBUTtBQUM3QixjQUFJLE1BQU0sV0FBVyxPQUFPO0FBQ3hCLG1CQUFPO0FBQUEsUUFDZjtBQUNBLGNBQU0sRUFBRSxRQUFBc0UsU0FBUSxXQUFXLElBQUk7QUFDL0IsZ0JBQVEsU0FBUztBQUFBLFVBQ2IsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsUUFBUSxvQkFBSSxJQUFJO0FBQUEsVUFDaEIsYUFBYTtBQUFBLFFBQ2pCO0FBQ0EsWUFBSSxLQUFLLEtBQUssV0FBVyxPQUFPO0FBQzVCLGlCQUFPO0FBQ1gsZ0JBQVEsU0FBU0E7QUFDakIsZ0JBQVEsYUFBYTtBQUNyQixlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsbUJBQVcsU0FBUyxLQUFLLFFBQVE7QUFDN0IsY0FBSSxFQUFFLGlCQUFpQixhQUFhO0FBQ2hDLGtCQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxVQUNyRDtBQUFBLFFBQ0o7QUFDQSxjQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLGdCQUFRLGFBQWE7QUFDckIsYUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsZ0JBQVEsYUFBYTtBQUFBLE1BQ3pCO0FBQUEsTUFDQSxxQkFBcUIsU0FBUyxNQUFNO0FBQ2hDLGFBQUssTUFBTSxxQkFBcUIsU0FBUyxJQUFJO0FBQUEsTUFDakQ7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLE1BQU0sc0JBQXNCLEtBQUssT0FBTyxJQUFJLFdBQVMsTUFBTSxRQUFRLGFBQWEsa0JBQWtCLENBQUMsR0FBRyxLQUFLLE9BQU8sS0FBSyxPQUFPLFNBQVMsY0FBYyxXQUFXO0FBQ3JLLFlBQUksS0FBSyxnQkFBZ0IsZ0JBQWdCO0FBQ3JDLGVBQUssS0FBSyxtQ0FBbUM7QUFBQSxRQUNqRCxPQUNLO0FBQ0QsZUFBSyxNQUFNLG9CQUFvQixLQUFLLElBQUk7QUFBQSxRQUM1QztBQUFBLE1BQ0o7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixZQUFJLFdBQVcsS0FBSyxTQUFTLGtCQUFrQjtBQUMzQyxlQUFLLE9BQU8sSUFBSSxlQUFlLFdBQVcsTUFBTSxNQUFNLEtBQUssTUFBTSxtQkFBbUI7QUFBQSxRQUN4RjtBQUNBLGNBQU0sVUFBVSxVQUFVO0FBQUEsTUFDOUI7QUFBQSxJQUNKO0FBQ0EsNEJBQXdCLFVBQVUseUJBQXlCO0FBNEMzRCxJQUFNLGdCQUFOLGNBQTRCLFNBQVM7QUFBQSxNQUNqQyxxQkFBcUIsV0FBVyx1QkFBdUI7QUFDbkQsbUJBQVcsWUFBWSxLQUFLLFlBQVk7QUFDcEMsY0FBSSxTQUFTLFNBQVMsWUFBWTtBQUM5QixxQkFBUyxNQUFNLHFCQUFxQixXQUFXLHFCQUFxQjtBQUFBLFVBQ3hFLE9BQ0s7QUFDRCxxQkFBUyxTQUFTLHFCQUFxQixXQUFXLHFCQUFxQjtBQUFBLFVBQzNFO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLFFBQVEsTUFBTSxNQUFNO0FBQ2hCLGNBQU0sWUFBWSxDQUFDO0FBQ25CLG1CQUFXLFlBQVksS0FBSyxZQUFZO0FBQ3BDLG9CQUFVLEtBQUssR0FBRyxTQUFTLFFBQVEsTUFBTSxJQUFJLENBQUM7QUFBQSxRQUNsRDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxlQUFldEUsT0FBTTtBQUNqQixZQUFJQSxNQUFLLFdBQVcsR0FBRztBQUNuQixxQkFBVyxZQUFZLEtBQUssWUFBWTtBQUNwQyxxQkFBUyxlQUFlQSxLQUFJO0FBQUEsVUFDaEM7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsWUFBSUEsTUFBSyxTQUFTO0FBQ2QsaUJBQU87QUFDWCxtQkFBVyxZQUFZLEtBQUssWUFBWTtBQUNwQyxjQUFJLFNBQVMsNkJBQTZCLFlBQVksT0FBTztBQUN6RCxtQkFBTztBQUFBLFFBQ2Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EseUJBQXlCO0FBQ3JCLG1CQUFXLFlBQVksS0FBSyxZQUFZO0FBQ3BDLG1CQUFTLHVCQUF1QjtBQUFBLFFBQ3BDO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFNLHVCQUFOLGNBQW1DLFNBQVM7QUFBQSxNQUN4QyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLGVBQVEsS0FBSyxNQUFNLFdBQVcsT0FBTyxLQUNqQyxLQUFLLEtBQUssV0FBVyxPQUFPLEtBQzVCLEtBQUssS0FBSyw2QkFBNkIsWUFBWSxPQUFPO0FBQUEsTUFDbEU7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQU9BLE1BQUssU0FBUyxLQUFLLEtBQUssTUFBTSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQ25GO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsYUFBSyxXQUFXO0FBQ2hCLFlBQUk7QUFDSixZQUFJLDhCQUNBLEtBQUssYUFBYSxPQUNsQixLQUFLLEtBQUssYUFDUixvQkFBb0Isd0JBQXdCLEdBQzFDLEtBQUssS0FBSyxXQUFXLGlCQUFpQixLQUNsQyxLQUFLLEtBQUssNkJBQTZCLFlBQVksaUJBQWlCLElBQUk7QUFDaEYsZUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxRQUN6RDtBQUNBLGFBQUssTUFBTSxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsTUFDMUQ7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTLEVBQUUsWUFBWSxvQkFBb0IsMkJBQTJCLElBQUksT0FBTztBQUMxRixZQUFJLEtBQUssS0FBSyxVQUFVO0FBQ3BCLGVBQUssS0FBSyxPQUFPLE1BQU0sT0FBTztBQUM5QixlQUFLLE1BQU0sT0FBTyxNQUFNLE9BQU87QUFBQSxRQUNuQyxPQUNLO0FBQ0QsZ0JBQU0saUJBQWlCLGtCQUFrQixLQUFLLFVBQVUsa0NBQWtDLEtBQUssVUFBVSxLQUFLLEtBQUssS0FBSyxHQUFHLElBQUksQ0FBQztBQUNoSSxlQUFLLE9BQU8sS0FBSyxPQUFPLGNBQWM7QUFDdEMsY0FBSSxZQUFZO0FBQ1osNkJBQWlCLE1BQU0sZ0JBQWdCLEtBQUssTUFBTSxLQUFLO0FBQUEsVUFDM0Q7QUFDQSxlQUFLLE1BQU0sT0FBTyxNQUFNLFNBQVM7QUFBQSxZQUM3QixvQkFBb0Isc0JBQXNCLEtBQUssT0FBTztBQUFBLFlBQ3RELDRCQUE0Qiw4QkFBOEIsS0FBSyxPQUFPO0FBQUEsVUFDMUUsQ0FBQztBQUFBLFFBQ0w7QUFDQSxZQUFJLFFBQVEsV0FBVyxVQUFVO0FBQzdCLGNBQUksS0FBSyxnQkFBZ0IsWUFBWTtBQUNqQyxrQkFBTSxXQUFXLEtBQUssS0FBSztBQUMzQixrQkFBTSxjQUFjLFFBQVEsc0JBQXNCLElBQUksUUFBUTtBQUM5RCxnQkFBSSxhQUFhO0FBQ2Isa0JBQUksWUFBWSxXQUFXLEdBQUc7QUFDMUIsNkNBQTZCLFVBQVUsS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU87QUFBQSxjQUM5RSxPQUNLO0FBQ0QsMERBQTBDLFVBQVUsS0FBSyxPQUFPLEtBQUssS0FBSyxLQUFLLE9BQU8sU0FBUyx1QkFBdUIsTUFBTSxPQUFPO0FBQUEsY0FDdkk7QUFDQTtBQUFBLFlBQ0o7QUFBQSxVQUNKLE9BQ0s7QUFDRCxrQkFBTSx1QkFBdUIsQ0FBQztBQUM5QixpQkFBSyxLQUFLLHFCQUFxQixzQkFBc0IsUUFBUSxxQkFBcUI7QUFDbEYsZ0JBQUkscUJBQXFCLFNBQVMsR0FBRztBQUNqQyx5Q0FBMkIsc0JBQXNCLEtBQUssT0FBTyxLQUFLLEtBQUssK0JBQStCLHVCQUF1QixNQUFNLE9BQU87QUFDMUk7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxZQUFJLEtBQUssS0FBSyxZQUNWLEtBQUssZ0JBQWdCLGtCQUNwQiwrQkFBK0IseUJBQzVCLCtCQUErQiw0QkFBNEI7QUFDL0QsZUFBSyxZQUFZLEtBQUssT0FBTyxHQUFHO0FBQ2hDLGVBQUssWUFBWSxLQUFLLEtBQUssR0FBRztBQUFBLFFBQ2xDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsdUJBQXVCO0FBQ25CLGFBQUssY0FBYztBQUNuQixhQUFLLEtBQUssZUFBZSxVQUFVO0FBQ25DLGFBQUssTUFBTSxlQUFlLFlBQVk7QUFDdEMsYUFBSyxRQUFRLHVCQUF1QjtBQUFBLE1BQ3hDO0FBQUEsSUFDSjtBQUVBLElBQU0sb0JBQU4sY0FBZ0MsU0FBUztBQUFBLE1BQ3JDLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLGNBQWM7QUFBQSxNQUN2QjtBQUFBLE1BQ0EscUJBQXFCLFdBQVcsdUJBQXVCO0FBQ25ELGFBQUssS0FBSyxxQkFBcUIsV0FBVyxxQkFBcUI7QUFBQSxNQUNuRTtBQUFBLE1BQ0EsUUFBUSxNQUFNLE1BQU07QUFDaEIsZUFBTyxLQUFLLEtBQUssUUFBUSxNQUFNLElBQUk7QUFBQSxNQUN2QztBQUFBLE1BQ0EsZUFBZUEsT0FBTTtBQUNqQixRQUFBQSxNQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssZUFBZUEsS0FBSTtBQUFBLE1BQ3REO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPQSxNQUFLLFNBQVMsS0FBSyxLQUFLLEtBQUssNkJBQTZCLFlBQVksT0FBTztBQUFBLE1BQ3hGO0FBQUEsTUFDQSx5QkFBeUI7QUFDckIsYUFBSyxLQUFLLHVCQUF1QjtBQUFBLE1BQ3JDO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUyxFQUFFLG9CQUFvQixJQUFJLE9BQU87QUFDbkQsYUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLEVBQUUsb0JBQW9CLENBQUM7QUFDdkQsYUFBSyxNQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDbkM7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxLQUFLLGVBQWUsVUFBVTtBQUNuQyxhQUFLLE1BQU0sZUFBZSxZQUFZO0FBQ3RDLGFBQUssUUFBUSx1QkFBdUI7QUFBQSxNQUN4QztBQUFBLElBQ0o7QUFFQSxJQUFNLG9CQUFOLGNBQWdDLGNBQWM7QUFBQSxNQUMxQyxZQUFZLFNBQVM7QUFDakIsY0FBTSxhQUFhLE1BQU0sb0JBQW9CLE9BQU87QUFBQSxNQUN4RDtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNO0FBQy9CLGVBQU9BLE1BQUssU0FBUztBQUFBLE1BQ3pCO0FBQUEsTUFDQSwrQkFBK0I7QUFDM0IsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDZCQUE2QjtBQUN6QixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFFQSxJQUFNLGVBQU4sY0FBMkIsY0FBYztBQUFBLE1BQ3JDLFlBQVksU0FBUztBQUNqQixjQUFNLFFBQVEsTUFBTSxNQUFNLE9BQU87QUFDakMsYUFBSyxtQkFBbUIsQ0FBQztBQUN6QixhQUFLLDBCQUEwQixvQkFBSSxJQUFJO0FBQ3ZDLGFBQUsseUJBQXlCLENBQUM7QUFDL0IsYUFBSyxzQkFBc0IsSUFBSSx5QkFBeUI7QUFBQSxNQUM1RDtBQUFBLE1BQ0EseUJBQXlCLFFBQVE7QUFDN0IsbUJBQVdBLFNBQVEsS0FBSyxrQkFBa0I7QUFDdEMsaUJBQU8sZUFBZUEsS0FBSTtBQUFBLFFBQzlCO0FBQ0EsbUJBQVcsc0JBQXNCLEtBQUssd0JBQXdCO0FBQzFELGVBQUssNkJBQTZCLFFBQVEsa0JBQWtCO0FBQUEsUUFDaEU7QUFDQSxhQUFLLHdCQUF3QixJQUFJLE1BQU07QUFBQSxNQUMzQztBQUFBLE1BQ0EsZUFBZUEsT0FBTTtBQUNqQixZQUFJQSxNQUFLLFdBQVcsS0FDaEIsS0FBSyxzQkFBc0IsaUNBQWlDQSxPQUFNLElBQUksR0FBRztBQUN6RTtBQUFBLFFBQ0o7QUFDQSxhQUFLLGlCQUFpQixLQUFLQSxLQUFJO0FBQy9CLG1CQUFXLFVBQVUsS0FBSyx5QkFBeUI7QUFDL0MsaUJBQU8sZUFBZUEsS0FBSTtBQUFBLFFBQzlCO0FBQUEsTUFDSjtBQUFBLE1BQ0EsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZTtBQUNwRCxjQUFNLHFCQUFxQjtBQUFBLFVBQ3ZCO0FBQUEsVUFDQSxNQUFBQTtBQUFBLFVBQ0E7QUFBQSxRQUNKO0FBQ0EsWUFBSSxDQUFDLEtBQUssb0JBQW9CLGlDQUFpQ0EsT0FBTSxPQUFPLGFBQWEsR0FBRztBQUN4RixxQkFBVyxVQUFVLEtBQUsseUJBQXlCO0FBQy9DLGlCQUFLLDZCQUE2QixRQUFRLGtCQUFrQjtBQUFBLFVBQ2hFO0FBQ0EsZUFBSyx1QkFBdUIsS0FBSyxrQkFBa0I7QUFBQSxRQUN2RDtBQUFBLE1BQ0o7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQVEsS0FBSyxRQUFRLE9BQU8sRUFBRSw2QkFBNkJBLE9BQU0sT0FBTyxLQUNwRSxNQUFNLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDeEQ7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQVEsS0FBSyxRQUFRLE9BQU8sRUFBRSw2QkFBNkJBLE9BQU0sT0FBTyxLQUNwRSxNQUFNLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDeEQ7QUFBQSxNQUNBLDZCQUE2QixRQUFRLEVBQUUsT0FBTyxNQUFBQSxPQUFNLGNBQWMsR0FBRztBQUNqRSxlQUFPLDRCQUE0QixPQUFPQSxPQUFNLGtCQUFrQixPQUFPLFNBQVMsZUFBZSx3QkFBd0I7QUFBQSxNQUM3SDtBQUFBLE1BQ0EsUUFBUSxTQUFTO0FBQ2IsZUFBTyxRQUFRLHNCQUFzQixJQUFJLElBQUksS0FBSztBQUFBLE1BQ3REO0FBQUEsSUFDSjtBQUVBLElBQU0sZ0JBQU4sY0FBNEIsaUJBQWlCO0FBQUEsTUFDekMsWUFBWSxRQUFRLFNBQVM7QUFDekIsY0FBTSxRQUFRLE9BQU87QUFDckIsYUFBSyxVQUFVLElBQUksYUFBYyxLQUFLLG9CQUFvQixJQUFJLGtCQUFrQixPQUFPLENBQUU7QUFDekYsYUFBSyxVQUFVLElBQUksUUFBUyxLQUFLLGVBQWUsSUFBSSxhQUFhLE9BQU8sQ0FBRTtBQUFBLE1BQzlFO0FBQUEsTUFDQSxzQkFBc0I7QUFDbEIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLHFCQUFxQixTQUFTLE1BQU07QUFDaEMsY0FBTSxxQkFBcUIsU0FBUyxJQUFJO0FBQ3hDLFlBQUksS0FBSyxrQkFBa0IsVUFBVTtBQUNqQyxxQkFBVyxPQUFPLE1BQU07QUFDcEIsZ0JBQUksQ0FBQyxJQUFJLFVBQVU7QUFDZixrQkFBSSxRQUFRLFNBQVMsS0FBSztBQUFBLFlBQzlCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sZUFBTixjQUEyQixTQUFTO0FBQUEsTUFDaEMsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssb0JBQW9CO0FBQ3pCLGFBQUsseUJBQXlCO0FBQUEsTUFDbEM7QUFBQSxNQUNBLFlBQVksYUFBYTtBQUNyQixhQUFLLFFBQVEsSUFBSSxjQUFjLGFBQWEsS0FBSyxPQUFPO0FBQUEsTUFDNUQ7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsWUFBSUEsTUFBSyxXQUFXLEdBQUc7QUFDbkIsY0FBSUEsTUFBSyxPQUFPLGFBQWE7QUFDekIsaUJBQUsseUJBQXlCO0FBQUEsVUFDbEMsV0FDU0EsTUFBSyxPQUFPLFlBQVk7QUFDN0IsaUJBQUsseUJBQXlCO0FBRzlCLGlCQUFLLE1BQU0sb0JBQW9CLEVBQUUsZUFBZSxZQUFZO0FBQUEsVUFDaEU7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BRUEsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZTtBQUNwRCxZQUFJLFVBQVUsY0FBYztBQUN4QixjQUFJQSxNQUFLLFNBQVMsR0FBRztBQUNqQiwwQkFBYyxlQUFlLFlBQVk7QUFBQSxVQUM3QyxPQUNLO0FBQ0QsaUJBQUssTUFBTSxhQUFhLHlCQUF5QixhQUFhO0FBQUEsVUFDbEU7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNO0FBQ3RDLFlBQUlBLE1BQUssV0FBVyxHQUFHO0FBQ25CLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUksS0FBSyxPQUFPO0FBQ1osY0FBSSxDQUFDLEtBQUssbUJBQW1CO0FBQ3pCLGlCQUFLLG9CQUFvQjtBQUN6QixpQkFBSyxNQUFNLG9CQUFvQixFQUFFLGVBQWUsWUFBWTtBQUM1RCxpQkFBSyxRQUFRLHVCQUF1QjtBQUFBLFVBQ3hDO0FBQ0EsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZUFBTyxLQUFLLE1BQU0sb0JBQW9CO0FBQUEsTUFDMUM7QUFBQSxNQUNBLGFBQWE7QUFDVCxlQUFPLEtBQUssT0FBTyxRQUFRLEtBQUssR0FBRyxXQUFXO0FBQUEsTUFDbEQ7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixZQUFJQSxNQUFLLFVBQVU7QUFDZixpQkFBTztBQUNYLGVBQU9BLE1BQUssU0FBUyxLQUFLQSxNQUFLLE9BQU8sZUFBZSxLQUFLO0FBQUEsTUFDOUQ7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixZQUFJQSxNQUFLLFVBQVUsR0FBRztBQUNsQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPQSxNQUFLLFNBQVMsS0FBS0EsTUFBSyxPQUFPLGVBQWUsS0FBSztBQUFBLE1BQzlEO0FBQUEsTUFDQSwyQkFBMkJBLE9BQU0sYUFBYSxTQUFTO0FBQ25ELFlBQUlBLE1BQUssU0FBUztBQUNkLGlCQUFPO0FBQ1gsWUFBSSxLQUFLLE9BQU87QUFDWixnQkFBTSxFQUFFLHdCQUF3QixJQUFJLEtBQUssUUFBUSxRQUM1QztBQUNMLGdCQUFNLG1CQUFtQixLQUFLLE1BQU0sb0JBQW9CO0FBQ3hELGNBQUksaUJBQWlCLDJCQUEyQixDQUFDLE1BQU0sR0FBRyxFQUFFLE1BQU0sU0FBUyxXQUFXLE1BQU0sU0FBUyxNQUFNLEdBQUcsT0FBTyxLQUNoSCw0QkFDSSw0QkFBNEIsWUFDekIsaUJBQWlCLDZCQUE2QixDQUFDLE1BQU0sR0FBRyxPQUFPLElBQUs7QUFDNUUsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUNBLG1CQUFXLFNBQVMsS0FBSyxRQUFRO0FBQzdCLGNBQUksTUFBTSxXQUFXLE9BQU87QUFDeEIsbUJBQU87QUFBQSxRQUNmO0FBQ0EsY0FBTSxXQUFXLFFBQVEsc0JBQXNCLElBQUksS0FBSyxNQUFNLFlBQVk7QUFDMUUsZ0JBQVEsc0JBQXNCLElBQUksS0FBSyxNQUFNLGNBQWMsWUFBWSxVQUNqRSxJQUFJLGFBQWEsdUJBQU8sT0FBTyxJQUFJLEdBQUcsZ0JBQWdCLElBQ3RELGtCQUFrQjtBQUN4QixjQUFNLEVBQUUsWUFBWSxRQUFBc0UsUUFBTyxJQUFJO0FBQy9CLGdCQUFRLFNBQVM7QUFBQSxVQUNiLFFBQVE7QUFBQSxVQUNSLFdBQVc7QUFBQSxVQUNYLFFBQVEsb0JBQUksSUFBSTtBQUFBLFVBQ2hCLGFBQWE7QUFBQSxRQUNqQjtBQUNBLFlBQUksS0FBSyxLQUFLLFdBQVcsT0FBTztBQUM1QixpQkFBTztBQUNYLGdCQUFRLGFBQWE7QUFDckIsWUFBSSxVQUFVO0FBQ1Ysa0JBQVEsc0JBQXNCLElBQUksS0FBSyxNQUFNLGNBQWMsUUFBUTtBQUFBLFFBQ3ZFLE9BQ0s7QUFDRCxrQkFBUSxzQkFBc0IsT0FBTyxLQUFLLE1BQU0sWUFBWTtBQUFBLFFBQ2hFO0FBQ0EsZ0JBQVEsU0FBU0E7QUFDakIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLFlBQUksS0FBSztBQUNMLGVBQUssR0FBRyxRQUFRO0FBQ3BCLGNBQU0sZUFBZSxLQUFLLE1BQU0sa0JBQWtCO0FBQ2xELG1CQUFXLFNBQVMsS0FBSyxRQUFRO0FBQzdCLGNBQUksRUFBRSxpQkFBaUIsZUFBZSxjQUFjO0FBQ2hELGtCQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxVQUNyRDtBQUFBLFFBQ0o7QUFDQSxjQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLGdCQUFRLGFBQWE7QUFDckIsYUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsZ0JBQVEsYUFBYTtBQUFBLE1BQ3pCO0FBQUEsTUFDQSxxQkFBcUIsU0FBUyxNQUFNO0FBQ2hDLGFBQUssTUFBTSxxQkFBcUIsU0FBUyxJQUFJO0FBQUEsTUFDakQ7QUFBQSxNQUNBLGFBQWE7QUFDVCxZQUFJLEtBQUssT0FBTyxNQUFNO0FBQ2xCLGVBQUssR0FBRyxRQUFRLFlBQVksSUFBSTtBQUFBLFFBQ3BDO0FBQ0EsYUFBSyxNQUFNLHNCQUFzQixLQUFLLE9BQU8sSUFBSSxXQUFTLE1BQU0sUUFBUSxhQUFhLGtCQUFrQixDQUFDLEdBQUcsS0FBSyxPQUFPLEtBQUssT0FBTyxTQUFTLGNBQWMsV0FBVztBQUNySyxhQUFLLEtBQUssbUNBQW1DO0FBQUEsTUFDakQ7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixhQUFLLE9BQU8sSUFBSSxlQUFlLFdBQVcsTUFBTSxNQUFNLEtBQUssTUFBTSxtQkFBbUI7QUFDcEYsY0FBTSxVQUFVLFVBQVU7QUFBQSxNQUM5QjtBQUFBLElBQ0o7QUFDQSxpQkFBYSxVQUFVLHlCQUF5QjtBQUVoRCxJQUFNLGtCQUFOLGNBQThCLFNBQVM7QUFBQSxNQUNuQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLGFBQWE7QUFDVCxZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsWUFBSSxDQUFDLEtBQUssVUFBVTtBQUNoQixlQUFLLFdBQVc7QUFDaEI7QUFBb0IsZ0JBQUksQ0FBQyxLQUFLLFFBQVEsbUJBQW1CO0FBQ3JELGtCQUFJLFNBQVMsS0FBSztBQUNsQixpQkFBRztBQUNDLG9CQUFJLGtCQUFrQixnQkFBZ0Isa0JBQWtCO0FBQ3BELHdCQUFNO0FBQUEsY0FDZCxTQUFVLFNBQVMsT0FBTztBQUMxQixtQkFBSyxRQUFRLG9CQUFvQjtBQUFBLFlBQ3JDO0FBQUEsUUFDSjtBQUNBLGFBQUssU0FBUyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsTUFDN0Q7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxTQUFTLGVBQWUsWUFBWTtBQUN6QyxhQUFLLFFBQVEsdUJBQXVCO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBRUEsSUFBTSxrQkFBa0I7QUFBQSxNQUNwQixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixPQUFPLENBQUMsTUFBTSxVQUFVLFNBQVM7QUFBQSxNQUNqQyxLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUU3QixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixPQUFPLENBQUMsTUFBTSxVQUFVLFNBQVM7QUFBQSxNQUNqQyxLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixNQUFNLENBQUMsTUFBTSxVQUFVLFFBQVE7QUFBQSxNQUMvQixPQUFPLENBQUMsTUFBTSxVQUFVLFNBQVM7QUFBQSxNQUNqQyxLQUFLLENBQUMsTUFBTSxVQUFVLE9BQU87QUFBQSxNQUM3QixJQUFJLE1BQU07QUFBQSxNQUNWLFlBQVksTUFBTTtBQUFBLE1BQ2xCLEtBQUssQ0FBQyxNQUFNLFVBQVUsT0FBTztBQUFBLElBQ2pDO0FBQ0EsSUFBTSxtQkFBTixjQUErQixTQUFTO0FBQUEsTUFDcEMsa0JBQWtCO0FBQUEsTUFBRTtBQUFBLE1BQ3BCLHNCQUFzQnRFLE9BQU0sa0JBQWtCLFFBQVE7QUFDbEQsWUFBSUEsTUFBSyxTQUFTO0FBQ2QsaUJBQU87QUFDWCxjQUFNLFlBQVksS0FBSyxLQUFLLHNCQUFzQixZQUFZLGtCQUFrQixNQUFNO0FBQ3RGLFlBQUksY0FBYztBQUNkLGlCQUFPO0FBQ1gsY0FBTSxhQUFhLEtBQUssTUFBTSxzQkFBc0IsWUFBWSxrQkFBa0IsTUFBTTtBQUN4RixZQUFJLGVBQWU7QUFDZixpQkFBTztBQUNYLGNBQU0sYUFBYSxnQkFBZ0IsS0FBSztBQUN4QyxZQUFJLENBQUM7QUFDRCxpQkFBTztBQUNYLGVBQU8sV0FBVyxXQUFXLFVBQVU7QUFBQSxNQUMzQztBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBRWhCLFlBQUksS0FBSyxhQUFhLE9BQ2xCLEtBQUssa0JBQWtCLHVCQUN2QixLQUFLLEtBQUssc0JBQXNCLFlBQVksMEJBQTBCLElBQUksTUFBTTtBQUNoRixpQkFBTztBQUNYLGVBQU8sTUFBTSxXQUFXLE9BQU87QUFBQSxNQUNuQztBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNO0FBQy9CLGVBQU9BLE1BQUssU0FBUztBQUFBLE1BQ3pCO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUyxFQUFFLDJCQUEyQixJQUFJLE9BQU87QUFDMUQsYUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLEVBQUUsMkJBQTJCLENBQUM7QUFDOUQsYUFBSyxNQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDbkM7QUFBQSxJQUNKO0FBRUEsSUFBTSxpQkFBTixjQUE2QixTQUFTO0FBQUEsTUFDbEMsV0FBVyxTQUFTO0FBQ2hCLFlBQUksS0FBSyxPQUFPO0FBQ1osY0FBSSxDQUFDLFFBQVEsT0FBTyxPQUFPLElBQUksS0FBSyxNQUFNLElBQUk7QUFDMUMsbUJBQU87QUFDWCxrQkFBUSxlQUFlLElBQUksS0FBSyxNQUFNLElBQUk7QUFDMUMsa0JBQVEsYUFBYTtBQUFBLFFBQ3pCLE9BQ0s7QUFDRCxjQUFJLENBQUMsUUFBUSxPQUFPO0FBQ2hCLG1CQUFPO0FBQ1gsa0JBQVEsYUFBYTtBQUFBLFFBQ3pCO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUztBQUNiLGFBQUssV0FBVztBQUNoQixZQUFJLEtBQUssT0FBTztBQUNaLGVBQUssTUFBTSxRQUFRO0FBQ25CLGtCQUFRLGVBQWUsSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUFBLFFBQzlDO0FBQ0EsZ0JBQVEsYUFBYSxLQUFLLFFBQVEsaUNBQWlDO0FBQUEsTUFDdkU7QUFBQSxJQUNKO0FBRUEsSUFBTSxVQUFOLGNBQXNCLFNBQVM7QUFBQSxNQUMzQiw4QkFBOEI7QUFBQSxNQUFFO0FBQUEsTUFDaEMsc0JBQXNCQSxPQUFNO0FBQ3hCLFlBQUlBLE1BQUssU0FBUyxLQUViLEtBQUssVUFBVSxRQUFRLEtBQUssUUFBUSxLQUFLLFdBQVcsS0FBSyxLQUFLLE1BQU0sT0FDckUsT0FBTyxLQUFLLFVBQVUsWUFFdEIsS0FBSyxRQUFRLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxJQUFJO0FBQ2pELGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxvQ0FBb0NBLE9BQU07QUFDdEMsWUFBSUEsTUFBSyxXQUFXO0FBQ2hCLGlCQUFPO0FBQ1gsZUFBTyxvQ0FBb0MsS0FBSyxTQUFTQSxNQUFLLEVBQUU7QUFBQSxNQUNwRTtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNO0FBQy9CLFlBQUksS0FBSyxVQUFVLE1BQU07QUFDckIsaUJBQU9BLE1BQUssU0FBUztBQUFBLFFBQ3pCO0FBQ0EsZUFBT0EsTUFBSyxTQUFTO0FBQUEsTUFDekI7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixlQUFPQSxNQUFLLFNBQVM7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxZQUFJQSxNQUFLLFdBQVcsR0FBRztBQUNuQixpQkFBTywwQkFBMEIsS0FBSyxTQUFTQSxNQUFLLElBQUksYUFBYSxPQUFPO0FBQUEsUUFDaEY7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsYUFBYTtBQUNULGFBQUssVUFBVSwwQkFBMEIsS0FBSyxLQUFLO0FBQUEsTUFDdkQ7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixhQUFLLFFBQVEsV0FBVztBQUN4QixhQUFLLFFBQVEsV0FBVztBQUN4QixjQUFNLFVBQVUsVUFBVTtBQUFBLE1BQzlCO0FBQUEsTUFDQSxPQUFPLE1BQU07QUFDVCxZQUFJLE9BQU8sS0FBSyxVQUFVLFVBQVU7QUFDaEMsZUFBSyxzQkFBc0IsS0FBSyxDQUFDLEtBQUssUUFBUSxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUM7QUFBQSxRQUNsRTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBR0EsSUFBTSxpQkFBaUI7QUFvQ3ZCLElBQU0sbUJBQU4sY0FBK0IsU0FBUztBQUFBLE1BQ3BDLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLFdBQVc7QUFDaEIsYUFBSyxjQUFjO0FBQ25CLGFBQUssUUFBUTtBQUNiLGFBQUssNkJBQTZCLENBQUM7QUFDbkMsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLE9BQU87QUFDSCxhQUFLLFFBQVE7QUFDYixjQUFNQSxRQUFPLHFCQUFxQixJQUFJO0FBQ3RDLGNBQU0sZUFBZUEsU0FBUSxLQUFLLE1BQU0sYUFBYUEsTUFBSyxHQUFHLEdBQUc7QUFDaEUsWUFBSSxnQkFBZ0IsYUFBYSxhQUFhO0FBQzFDLGdCQUFNLG1CQUFtQixLQUFLLDBCQUEwQixjQUFjQSxNQUFLLE1BQU0sQ0FBQyxDQUFDO0FBQ25GLGNBQUksQ0FBQyxrQkFBa0I7QUFDbkIsa0JBQU0sS0FBSztBQUFBLFVBQ2YsV0FDUyxPQUFPLHFCQUFxQixVQUFVO0FBQzNDLGlCQUFLLGNBQWM7QUFBQSxVQUN2QixPQUNLO0FBQ0QsaUJBQUssV0FBVztBQUNoQixpQkFBSyxNQUFNLHlCQUF5QixrQkFBa0JBLEtBQUksR0FBRyxnQkFBZ0I7QUFBQSxVQUNqRjtBQUFBLFFBQ0osT0FDSztBQUNELGdCQUFNLEtBQUs7QUFBQSxRQUNmO0FBQUEsTUFDSjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsY0FBTSw2QkFBNkIsS0FBSztBQUN4QyxhQUFLLDZCQUE2QixDQUFDO0FBQ25DLGFBQUssY0FBYztBQUNuQixhQUFLLE9BQU8sZUFBZSxZQUFZO0FBQ3ZDLG1CQUFXLGNBQWMsNEJBQTRCO0FBQ2pELHFCQUFXLGdCQUFnQjtBQUFBLFFBQy9CO0FBQUEsTUFDSjtBQUFBLE1BQ0EsZUFBZUEsT0FBTTtBQUNqQixZQUFJQSxNQUFLLFdBQVc7QUFDaEIsZUFBSyw4QkFBOEI7QUFDdkMsWUFBSSxLQUFLLFVBQVU7QUFDZixlQUFLLFNBQVMsZUFBZUEsS0FBSTtBQUFBLFFBQ3JDLFdBQ1MsQ0FBQyxLQUFLLGFBQWE7QUFDeEIsY0FBSUEsTUFBSyxTQUFTLGdCQUFnQjtBQUM5QixpQkFBSyxPQUFPLGVBQWUsQ0FBQyxLQUFLLGVBQWUsR0FBRyxHQUFHQSxLQUFJLENBQUM7QUFBQSxVQUMvRDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxZQUFJLEtBQUssVUFBVTtBQUNmLGVBQUssU0FBUyw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGdCQUFnQjtBQUFBLFFBQzFGLFdBQ1MsQ0FBQyxLQUFLLGFBQWE7QUFDeEIsY0FBSUEsTUFBSyxTQUFTLGdCQUFnQjtBQUM5QixpQkFBSyxPQUFPLDRCQUE0QixPQUFPLENBQUMsS0FBSyxlQUFlLEdBQUcsR0FBR0EsS0FBSSxHQUFHLGVBQWUsZ0JBQWdCO0FBQUEsVUFDcEgsT0FDSztBQUNELDBCQUFjLGVBQWUsWUFBWTtBQUFBLFVBQzdDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHNCQUFzQkEsT0FBTSxrQkFBa0IsUUFBUTtBQUNsRCxZQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLGlCQUFPLEtBQUssU0FBUyxzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxRQUM3RTtBQUNBLFlBQUksS0FBSyxhQUFhO0FBQ2xCLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGFBQUssMkJBQTJCLEtBQUssTUFBTTtBQUMzQyxZQUFJQSxNQUFLLFNBQVMsZ0JBQWdCO0FBQzlCLGlCQUFPLEtBQUssT0FBTyxzQkFBc0IsQ0FBQyxLQUFLLGVBQWUsR0FBRyxHQUFHQSxLQUFJLEdBQUcsa0JBQWtCLE1BQU07QUFBQSxRQUN2RztBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsUUFBUTtBQUM3RSxZQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLGlCQUFPLEtBQUssU0FBUyxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLFFBQ3hHO0FBQ0EsWUFBSSxLQUFLLGFBQWE7QUFDbEIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsYUFBSywyQkFBMkIsS0FBSyxNQUFNO0FBQzNDLFlBQUlBLE1BQUssU0FBUyxnQkFBZ0I7QUFDOUIsaUJBQU8sS0FBSyxPQUFPLG9DQUFvQyxDQUFDLEtBQUssZUFBZSxHQUFHLEdBQUdBLEtBQUksR0FBRyxhQUFhLGtCQUFrQixNQUFNO0FBQUEsUUFDbEk7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsY0FBTSxFQUFFLHdCQUF3QixJQUFJLEtBQUssUUFBUSxRQUM1QztBQUNMLGVBQVEsS0FBSyxTQUFTLFdBQVcsT0FBTyxLQUNwQyxLQUFLLE9BQU8sV0FBVyxPQUFPLEtBRTdCLEVBQUUsS0FBSyxZQUNKLEtBQUssZUFDSixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxPQUFPLGFBQWEsUUFDekUsNEJBQ0MsNEJBQTRCLFlBQ3pCLEtBQUssT0FBTyw2QkFBNkIsQ0FBQyxLQUFLLGVBQWUsQ0FBQyxHQUFHLE9BQU87QUFBQSxNQUN6RjtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsWUFBSSxLQUFLLGFBQWEsTUFBTTtBQUN4QixpQkFBTyxLQUFLLFNBQVMsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxRQUNuRTtBQUNBLFlBQUksS0FBSyxhQUFhO0FBQ2xCLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUlBLE1BQUssU0FBUyxnQkFBZ0I7QUFDOUIsaUJBQU8sS0FBSyxPQUFPLDZCQUE2QixDQUFDLEtBQUssZUFBZSxHQUFHLEdBQUdBLEtBQUksR0FBRyxPQUFPO0FBQUEsUUFDN0Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsWUFBSSxLQUFLLGFBQWEsTUFBTTtBQUN4QixpQkFBTyxLQUFLLFNBQVMsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxRQUNuRTtBQUNBLFlBQUksS0FBSyxhQUFhO0FBQ2xCLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUlBLE1BQUssU0FBUyxnQkFBZ0I7QUFDOUIsaUJBQU8sS0FBSyxPQUFPLDZCQUE2QixDQUFDLEtBQUssZUFBZSxHQUFHLEdBQUdBLEtBQUksR0FBRyxPQUFPO0FBQUEsUUFDN0Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxZQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLGlCQUFPLEtBQUssU0FBUywyQkFBMkJBLE9BQU0sYUFBYSxPQUFPO0FBQUEsUUFDOUU7QUFDQSxZQUFJLEtBQUssYUFBYTtBQUNsQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJQSxNQUFLLFNBQVMsZ0JBQWdCO0FBQzlCLGlCQUFPLEtBQUssT0FBTywyQkFBMkIsQ0FBQyxLQUFLLGVBQWUsR0FBRyxHQUFHQSxLQUFJLEdBQUcsYUFBYSxPQUFPO0FBQUEsUUFDeEc7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLFlBQUksQ0FBQyxLQUFLLFVBQVU7QUFDaEIsZUFBSyxXQUFXO0FBQ2hCLGNBQUksS0FBSyxhQUFhLE1BQU07QUFDeEIsaUJBQUssUUFBUSx3QkFBd0IsS0FBSyxRQUFRO0FBQUEsVUFDdEQ7QUFBQSxRQUNKO0FBQ0EsYUFBSyxPQUFPLFFBQVEsU0FBUywwQkFBMEI7QUFDdkQsYUFBSyxTQUFTLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxNQUM3RDtBQUFBLE1BQ0EscUJBQXFCLFNBQVMsTUFBTTtBQUNoQyxZQUFJLEtBQUssVUFBVTtBQUNmLGVBQUssU0FBUyxxQkFBcUIsU0FBUyxJQUFJO0FBQUEsUUFDcEQsT0FDSztBQUNELGdCQUFNLHFCQUFxQixTQUFTLElBQUk7QUFBQSxRQUM1QztBQUFBLE1BQ0o7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLGNBQWMseUJBQXlCLElBQUk7QUFBQSxNQUNwRDtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsRUFBRSxvQkFBb0IsMEJBQTBCLDJCQUEyQixJQUFJLE9BQU87QUFDeEcsWUFBSSxLQUFLLFlBQVksS0FBSyxhQUFhO0FBQ25DLGdCQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLElBQUk7QUFDNUMsY0FBSSxjQUFjLEtBQUssV0FBVyxLQUFLLFNBQVMsUUFBUSxpQkFBaUIsSUFBSSxLQUFLO0FBQ2xGLGNBQUksc0JBQXNCO0FBQ3RCLDBCQUFjLFFBQVE7QUFDMUIsZUFBSyxVQUFVLEtBQUssT0FBTyxLQUFLLEtBQUssYUFBYTtBQUFBLFlBQzlDLGFBQWE7QUFBQSxZQUNiLFdBQVc7QUFBQSxVQUNmLENBQUM7QUFBQSxRQUNMLE9BQ0s7QUFDRCxjQUFJLHNCQUFzQiwwQkFBMEI7QUFDaEQsaUJBQUssWUFBWSxLQUFLLE9BQU8sS0FBSztBQUFBLFVBQ3RDO0FBQ0EsZUFBSyxPQUFPLE9BQU8sTUFBTSxTQUFTLEVBQUUsMkJBQTJCLENBQUM7QUFDaEUsZUFBSyxTQUFTLE9BQU8sTUFBTSxPQUFPO0FBQUEsUUFDdEM7QUFBQSxNQUNKO0FBQUEsTUFDQSx1QkFBdUI7QUFDbkIsYUFBSyxjQUFjO0FBQ25CLGNBQU0sRUFBRSx3QkFBd0IsSUFBSSxLQUFLLFFBQVEsUUFDNUM7QUFDTCxZQUVBLEtBQUssU0FDRCwyQkFDQSxFQUFFLEtBQUssWUFBWSxLQUFLLGNBQWM7QUFFdEMsY0FBSSxFQUFFLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLE9BQU8sYUFBYSxNQUFNO0FBQ2hGLGlCQUFLLE9BQU8sNEJBQTRCLGdCQUFnQixDQUFDLEtBQUssV0FBVyxHQUFHLEtBQUssUUFBUSx3QkFBd0I7QUFBQSxVQUNySDtBQUNBLGNBQUksS0FBSyxrQkFBa0Isc0JBQXNCO0FBQzdDLGlCQUFLLE9BQU8sNEJBQTRCLGdCQUFnQixDQUFDLEtBQUssV0FBVyxHQUFHLEtBQUssUUFBUSx3QkFBd0I7QUFBQSxVQUNySDtBQUNBLGVBQUssUUFBUSx1QkFBdUI7QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFBQSxNQUNBLGdDQUFnQztBQUM1QixZQUFJLEtBQUssa0JBQWtCLFlBQVk7QUFDbkMsZ0JBQU0sV0FBVyxLQUFLLE1BQU0sYUFBYSxLQUFLLE9BQU8sSUFBSTtBQUN6RCxjQUFJLFNBQVMsYUFBYTtBQUN0QixnQkFBSSxLQUFLLFVBQVU7QUFDZixtQkFBSyxRQUFRLHdCQUF3QixLQUFLLFFBQVE7QUFBQSxZQUN0RDtBQUNBLGlCQUFLLFFBQVEsS0FBSztBQUFBLGNBQ2QsTUFBTTtBQUFBLGNBQ04sU0FBUyxtQ0FBbUMsS0FBSyxPQUFPO0FBQUEsWUFDNUQsR0FBRyxLQUFLLEtBQUs7QUFBQSxVQUNqQjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSxpQkFBaUI7QUFDYixZQUFJLEtBQUssZ0JBQWdCLE1BQU07QUFDM0IsZUFBSyxjQUFjO0FBQ25CLGdCQUFNLFFBQVEsS0FBSyxTQUFTLHNCQUFzQixZQUFZLDBCQUEwQixJQUFJO0FBQzVGLGlCQUFRLEtBQUssY0FBYyxVQUFVLGVBQWUsYUFBYSxPQUFPLEtBQUs7QUFBQSxRQUNqRjtBQUNBLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSwwQkFBMEIsY0FBY0EsT0FBTTtBQUMxQyxZQUFJQSxNQUFLLFdBQVc7QUFDaEIsaUJBQU87QUFDWCxZQUFJLENBQUMsYUFBYSxlQUFlLHdCQUF3QjtBQUNyRCxpQkFBTztBQUNYLGNBQU0sYUFBYUEsTUFBSyxHQUFHO0FBQzNCLGNBQU0sV0FBVyxhQUFhLFFBQVEsWUFBWSxVQUFVO0FBQzVELFlBQUksQ0FBQyxVQUFVO0FBQ1gsZ0JBQU0sV0FBVyxhQUFhLFFBQVE7QUFDdEMsZUFBSyxRQUFRLEtBQUs7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLFVBQVUsV0FBVyxRQUFRO0FBQUEsWUFDN0IsVUFBVSxXQUFXLEtBQUssUUFBUSxRQUFRO0FBQUEsWUFDMUMsU0FBUyxJQUFJLG1DQUFtQyxXQUFXLFFBQVE7QUFBQSxZQUNuRSxTQUFTO0FBQUEsWUFDVCxLQUFLO0FBQUEsVUFDVCxHQUFHQSxNQUFLLEdBQUcsR0FBRztBQUNkLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8sS0FBSywwQkFBMEIsVUFBVUEsTUFBSyxNQUFNLENBQUMsQ0FBQztBQUFBLE1BQ2pFO0FBQUEsSUFDSjtBQUVBLElBQU0saUJBQU4sY0FBNkIsU0FBUztBQUFBLE1BQ2xDLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxvQ0FBb0MsQ0FBQztBQUMxQyxhQUFLLDZCQUE2QixvQkFBSSxJQUFJO0FBQzFDLGFBQUssbUJBQW1CO0FBQUEsTUFDNUI7QUFBQSxNQUNBLE9BQU87QUFDSCxjQUFNLEtBQUs7QUFDWCxZQUFJLEtBQUssa0JBQWtCLFlBQVk7QUFDbkMsZ0JBQU0sV0FBVyxLQUFLLE1BQU0sYUFBYSxLQUFLLE9BQU8sSUFBSTtBQUN6RCxjQUFJLFNBQVMsYUFBYTtBQUN0QixpQkFBSyxRQUFRLEtBQUs7QUFBQSxjQUNkLE1BQU07QUFBQSxjQUNOLFNBQVMsNkJBQTZCLEtBQUssT0FBTztBQUFBLFlBQ3RELEdBQUcsS0FBSyxLQUFLO0FBQUEsVUFDakI7QUFDQSxjQUFJLEtBQUssT0FBTyxTQUFTLFFBQVE7QUFDN0IsaUJBQUssUUFBUSxLQUFLO0FBQUEsY0FDZCxNQUFNO0FBQUEsY0FDTixTQUFTO0FBQUEsY0FDVCxLQUFLO0FBQUEsWUFDVCxHQUFHLEtBQUssS0FBSztBQUFBLFVBQ2pCO0FBQUEsUUFDSjtBQUNBLGFBQUssY0FBYztBQUFBLFVBQ2YsTUFBTSxLQUFLO0FBQUEsVUFDWCxXQUFXLEtBQUssa0JBQWtCLG9CQUFvQixDQUFDLEtBQUssT0FBTyxXQUM3RCxLQUFLLE9BQU8sU0FDWjtBQUFBLFVBQ04sU0FBUztBQUFBLFFBQ2I7QUFBQSxNQUNKO0FBQUEsTUFDQSxrQkFBa0I7QUFDZCxZQUFJLEtBQUsscUJBQXFCLG9CQUFvQjtBQUM5QyxlQUFLLG1CQUFtQjtBQUN4QixxQkFBVyxjQUFjLEtBQUssbUNBQW1DO0FBQzdELHVCQUFXLGdCQUFnQjtBQUFBLFVBQy9CO0FBQ0EscUJBQVcsY0FBYyxLQUFLLDRCQUE0QjtBQUN0RCx1QkFBVyxlQUFlLFlBQVk7QUFBQSxVQUMxQztBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSxlQUFlQSxPQUFNO0FBQ2pCLFlBQUlBLE1BQUssV0FBVyxLQUNoQixLQUFLLFFBQVEsc0JBQXNCLGlDQUFpQ0EsT0FBTSxJQUFJLEdBQUc7QUFDakY7QUFBQSxRQUNKO0FBQ0EsY0FBTSxtQkFBbUIsS0FBSyxvQkFBb0I7QUFDbEQsWUFBSSxxQkFBcUIsb0JBQW9CO0FBQ3pDLDJCQUFpQixlQUFlQSxLQUFJO0FBQUEsUUFDeEM7QUFBQSxNQUNKO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxjQUFNLG1CQUFtQixLQUFLLG9CQUFvQixnQkFBZ0I7QUFDbEUsWUFBSSxxQkFBcUIsb0JBQW9CO0FBQ3pDLHdCQUFjLGVBQWUsWUFBWTtBQUFBLFFBQzdDLE9BQ0s7QUFDRCwyQkFBaUIsd0JBQXdCQSxPQUFNLGtCQUFrQixNQUFNO0FBQ25FLGlCQUFLLDJCQUEyQixJQUFJLGFBQWE7QUFDakQsNkJBQWlCLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQUEsVUFDN0YsR0FBRyxNQUFTO0FBQUEsUUFDaEI7QUFBQSxNQUNKO0FBQUEsTUFDQSxzQkFBc0JBLE9BQU0sa0JBQWtCLFFBQVE7QUFDbEQsY0FBTSxtQkFBbUIsS0FBSyxvQkFBb0IsZ0JBQWdCO0FBQ2xFLFlBQUkscUJBQXFCLG9CQUFvQjtBQUN6QyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPLGlCQUFpQix3QkFBd0JBLE9BQU0sa0JBQWtCLE1BQU07QUFDMUUsZUFBSyxrQ0FBa0MsS0FBSyxNQUFNO0FBQ2xELGlCQUFPLGlCQUFpQixzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxRQUNoRixHQUFHLFlBQVk7QUFBQSxNQUNuQjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsY0FBTSxtQkFBbUIsS0FBSyxvQkFBb0IsZ0JBQWdCO0FBQ2xFLFlBQUksS0FBSyxxQkFBcUIsb0JBQW9CO0FBQzlDLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8saUJBQWlCLHdCQUF3QkEsT0FBTSxrQkFBa0IsTUFBTTtBQUMxRSxlQUFLLGtDQUFrQyxLQUFLLE1BQU07QUFDbEQsaUJBQU8saUJBQWlCLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixNQUFNO0FBQUEsUUFDM0csR0FBRyxrQkFBa0I7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLFlBQUk7QUFDQSxxQkFBVyxZQUFZLEtBQUssV0FBVztBQUNuQyxnQkFBSSxTQUFTLFdBQVcsT0FBTztBQUMzQixxQkFBTztBQUFBLFVBQ2Y7QUFDQSxjQUFJLEtBQUssUUFBUSxRQUFRLFVBQVUsZUFDL0IsS0FBSztBQUNMLG1CQUFPO0FBQ1gsaUJBQVEsS0FBSyxPQUFPLFdBQVcsT0FBTyxLQUNsQyxLQUFLLE9BQU8sMkJBQTJCLFlBQVksS0FBSyxhQUFhLE9BQU87QUFBQSxRQUNwRixVQUNBO0FBQ0ksY0FBSSxDQUFDLEtBQUs7QUFDTixpQkFBSyxxQkFBcUI7QUFBQSxRQUNsQztBQUFBLE1BQ0o7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQVEsQ0FBQyxRQUFRLFNBQVMsaUNBQWlDQSxPQUFNLElBQUksS0FDakUsS0FBSyxvQkFBb0IsRUFBRSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQzdFO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFRLENBQUMsUUFBUSxTQUFTLGlDQUFpQ0EsT0FBTSxJQUFJLEtBQ2pFLEtBQUssb0JBQW9CLEVBQUUsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxNQUM3RTtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxlQUFRLEVBQUUsWUFBWSxVQUFVLFFBQVEsZUFBZSxRQUFRLFFBQVEsaUNBQWlDQSxPQUFNLGFBQWEsSUFBSSxLQUMzSCxLQUFLLG9CQUFvQixFQUFFLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUN4RjtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLFlBQUksNEJBQTRCO0FBQzVCLGdCQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFDakQsY0FBSSwrQkFBK0Isc0JBQy9CLEtBQUssa0JBQWtCLGNBQ3ZCLEtBQUssT0FBTyxVQUFVO0FBQ3RCLGlCQUFLLE9BQU8sU0FBUywyQkFBMkI7QUFBQSxVQUNwRDtBQUFBLFFBQ0osT0FDSztBQUNELGVBQUssV0FBVztBQUNoQixlQUFLLE9BQU8sUUFBUSxTQUFTLEtBQUs7QUFBQSxRQUN0QztBQUNBLGFBQUssT0FBTyxxQkFBcUIsU0FBUyxLQUFLLFNBQVM7QUFDeEQsY0FBTSxtQkFBbUIsS0FBSyxvQkFBb0I7QUFDbEQsWUFBSSxDQUFDLGlCQUFpQixVQUFVO0FBQzVCLDJCQUFpQixRQUFRLFNBQVMsS0FBSztBQUFBLFFBQzNDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsRUFBRSwyQkFBMkIsSUFBSSxPQUFPO0FBQzFELGFBQUssT0FBTyxPQUFPLE1BQU0sU0FBUztBQUFBLFVBQzlCLDBCQUEwQjtBQUFBLFVBQzFCO0FBQUEsUUFDSixDQUFDO0FBQ0QsWUFBSSxLQUFLLFVBQVUsU0FBUyxHQUFHO0FBQzNCLGNBQUksS0FBSyxVQUFVLEtBQUssVUFBVSxTQUFTLEdBQUcsVUFBVTtBQUNwRCx1QkFBVyxPQUFPLEtBQUssV0FBVztBQUM5QixrQkFBSSxPQUFPLE1BQU0sT0FBTztBQUFBLFlBQzVCO0FBQUEsVUFDSixPQUNLO0FBQ0QsZ0JBQUksb0JBQW9CLEtBQUssVUFBVSxTQUFTO0FBQ2hELG1CQUFPLHFCQUFxQixLQUFLLENBQUMsS0FBSyxVQUFVLG1CQUFtQixVQUFVO0FBQzFFO0FBQUEsWUFDSjtBQUNBLGdCQUFJLHFCQUFxQixHQUFHO0FBQ3hCLHVCQUFTLFFBQVEsR0FBRyxTQUFTLG1CQUFtQixTQUFTO0FBQ3JELHFCQUFLLFVBQVUsT0FBTyxPQUFPLE1BQU0sT0FBTztBQUFBLGNBQzlDO0FBQ0EsbUJBQUssT0FBTyxrQ0FBa0MsS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLG1CQUFtQixHQUFHLEdBQUcsS0FBSyxNQUFNLENBQUM7QUFBQSxZQUMxSCxPQUNLO0FBQ0QsbUJBQUssT0FBTyxrQ0FBa0MsS0FBSyxVQUFVLEtBQUssS0FBSyxPQUFPLEdBQUcsSUFBSSxHQUFHLEtBQUssTUFBTSxDQUFDO0FBQUEsWUFDeEc7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsY0FBTSxFQUFFLFVBQVUsSUFBSSxLQUFLO0FBQzNCLFlBQUksV0FBVztBQUNYLGVBQUssT0FBTyw0QkFBNEIsY0FBYyxZQUFZLFdBQVcsd0JBQXdCO0FBQUEsUUFDekc7QUFDQSxtQkFBVyxZQUFZLEtBQUssV0FBVztBQUVuQyxtQkFBUyxlQUFlLFlBQVk7QUFBQSxRQUN4QztBQUNBLGFBQUssUUFBUSx1QkFBdUI7QUFBQSxNQUN4QztBQUFBLE1BQ0Esb0JBQW9CLG1CQUFtQiwwQkFBMEI7QUFDN0QsWUFBSSxLQUFLLHFCQUFxQixNQUFNO0FBQ2hDLGVBQUssbUJBQW1CO0FBQ3hCLGlCQUFRLEtBQUssbUJBQW1CLEtBQUssT0FBTyxvQ0FBb0MsWUFBWSxLQUFLLGFBQWEsa0JBQWtCLElBQUk7QUFBQSxRQUN4STtBQUNBLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsSUFDSjtBQUVBLElBQU0sYUFBTixjQUF5QixlQUFlO0FBQUEsTUFDcEMsZUFBZSxZQUFZLFNBQVMsTUFBTSxXQUFXO0FBQ2pELGNBQU0sb0JBQW9CLEtBQUssVUFBVSxJQUFJLFdBQVcsSUFBSTtBQUM1RCxZQUFJLG1CQUFtQjtBQUluQixlQUFLLE9BQU8sZUFBZSxZQUFZLFNBQVMsc0JBQXNCLFNBQVM7QUFDL0UsNEJBQWtCLGVBQWUsWUFBWSxJQUFJO0FBQ2pELGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8sS0FBSyxPQUFPLGVBQWUsWUFBWSxTQUFTLE1BQU0sU0FBUztBQUFBLE1BQzFFO0FBQUEsSUFDSjtBQUVBLElBQU0sY0FBTixjQUEwQixTQUFTO0FBQUEsTUFDL0IsWUFBWSxhQUFhO0FBQ3JCLGFBQUssUUFBUSxJQUFJLFdBQVcsYUFBYSxLQUFLLE9BQU87QUFBQSxNQUN6RDtBQUFBLE1BQ0EsVUFBVSxZQUFZO0FBSWxCLGNBQU0sRUFBRSxNQUFNLElBQUk7QUFDbEIsWUFBSSxPQUFPO0FBQ1AsZUFBSyxRQUFRLEtBQUssS0FBSyxRQUFRLG1CQUFtQixNQUFNLElBQUksR0FBRyxPQUFPLE1BQU0sS0FBSyxLQUFLO0FBQ3RGLGVBQUssTUFBTSxRQUFRLGFBQWEsa0JBQWtCO0FBQUEsUUFDdEQ7QUFDQSxjQUFNLFVBQVUsVUFBVTtBQUFBLE1BQzlCO0FBQUEsSUFDSjtBQUVBLElBQU0sa0JBQU4sY0FBOEIsU0FBUztBQUFBLElBQ3ZDO0FBRUEsSUFBTSxpQkFBTixjQUE2QixXQUFXO0FBQUEsTUFDcEMsWUFBWSxRQUFRLFdBQVcsU0FBUztBQUNwQyxjQUFNLE1BQU07QUFDWixhQUFLLFVBQVUsSUFBSSxRQUFTLEtBQUssZUFBZSxJQUFJLGNBQWMsUUFBUSxNQUFNLFdBQVcsT0FBTyxDQUFFO0FBQ3BHLGFBQUssZ0JBQWdCLElBQUksV0FBVyxJQUFJO0FBQ3hDLGFBQUssY0FBYyxVQUFVLElBQUksUUFBUSxJQUFJLGFBQWEsT0FBTyxDQUFDO0FBQUEsTUFDdEU7QUFBQSxNQUNBLHNCQUFzQjtBQUNsQixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFFQSxJQUFNLFlBQU4sY0FBd0IsU0FBUztBQUFBLE1BQzdCLFlBQVksYUFBYTtBQUNyQixhQUFLLFFBQVEsSUFBSSxlQUFlLGFBQWEsS0FBSyxRQUFRLEtBQUssT0FBTztBQUFBLE1BQzFFO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixhQUFLLFFBQVEsd0JBQXdCLEtBQUssTUFBTSxZQUFZO0FBQzVELG1CQUFXLGNBQWMsS0FBSyxNQUFNO0FBQ2hDLHFCQUFXLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxRQUMxRDtBQUFBLE1BQ0o7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixjQUFNLE9BQVEsS0FBSyxPQUFPLENBQUM7QUFDM0IsbUJBQVcsY0FBYyxXQUFXLE1BQU07QUFDdEMsZUFBSyxLQUFLLEtBQUssS0FBSyxRQUFRLG1CQUFtQixXQUFXLElBQUksR0FBRyxZQUFZLE1BQU0sV0FBVyxTQUFTLEtBQUssUUFBUSxLQUFLLE1BQU0sYUFBYSxDQUFDO0FBQUEsUUFDako7QUFDQSxjQUFNLFVBQVUsVUFBVTtBQUFBLE1BQzlCO0FBQUEsSUFDSjtBQUVBLElBQU0sYUFBTixjQUF5QixTQUFTO0FBQUEsTUFDOUIsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssZ0JBQWdCO0FBQ3JCLGFBQUssc0JBQXNCO0FBQUEsVUFDdkIsTUFBTTtBQUFBLFVBQ04sV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFFBQ2I7QUFBQSxNQUNKO0FBQUEsTUFHQSxrQkFBa0I7QUFBQSxNQUFFO0FBQUEsTUFDcEIsZUFBZUEsT0FBTTtBQUNqQixhQUFLLGlCQUFpQixFQUFFLGVBQWVBLEtBQUk7QUFBQSxNQUMvQztBQUFBLE1BQ0EsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxrQkFBa0I7QUFDdEUsWUFBSSxVQUFVLGtCQUFrQixLQUFLLFNBQVMsU0FBU0EsTUFBSyxXQUFXLEdBQUc7QUFDdEUsaUJBQU8sS0FBSyxNQUFNLDRCQUE0QixjQUFjLFlBQVksZUFBZSxnQkFBZ0I7QUFBQSxRQUMzRztBQUNBLFlBQUksVUFBVSxrQkFBa0IsS0FBSyxTQUFTLFNBQVNBLE1BQUssV0FBVyxHQUFHO0FBQ3RFLGlCQUFPLEtBQUssTUFBTSw0QkFBNEIsY0FBYyxZQUFZLGVBQWUsZ0JBQWdCO0FBQUEsUUFDM0c7QUFDQSxhQUFLLGlCQUFpQixFQUFFLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQUEsTUFDcEc7QUFBQSxNQUNBLHNCQUFzQkEsT0FBTSxrQkFBa0IsUUFBUTtBQUNsRCxlQUFPLEtBQUssaUJBQWlCLEVBQUUsc0JBQXNCQSxPQUFNLGtCQUFrQixNQUFNO0FBQUEsTUFDdkY7QUFBQSxNQUNBLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixRQUFRO0FBQzdFLGVBQU8sS0FBSyxpQkFBaUIsRUFBRSxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLE1BQ2xIO0FBQUEsTUFDQSxXQUFXLFNBQVM7QUFDaEIsZUFBTyxLQUFLLElBQUksV0FBVyxPQUFPO0FBQUEsTUFDdEM7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLFlBQUksS0FBSyxTQUFTLFNBQVNBLE1BQUssV0FBVyxHQUFHO0FBQzFDLGlCQUFPLEtBQUssTUFBTSwyQkFBMkIsWUFBWSxLQUFLLHFCQUFxQixPQUFPO0FBQUEsUUFDOUY7QUFDQSxlQUFPLEtBQUssaUJBQWlCLEVBQUUsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxNQUM3RTtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsWUFBSSxLQUFLLFNBQVMsT0FBTztBQUNyQixpQkFBTyxLQUFLLE1BQU0sMkJBQTJCLFlBQVksS0FBSyxxQkFBcUIsT0FBTztBQUFBLFFBQzlGO0FBQ0EsZUFBTyxLQUFLLGlCQUFpQixFQUFFLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDN0U7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsZUFBTyxLQUFLLGlCQUFpQixFQUFFLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUN4RjtBQUFBLE1BQ0EsbUJBQW1CO0FBQ2YsWUFBSSxLQUFLLGtCQUFrQixNQUFNO0FBQzdCLGNBQUksS0FBSyxTQUFTLE9BQU87QUFDckIsaUJBQUssZ0JBQWdCO0FBQ3JCLG1CQUFRLEtBQUssZ0JBQWdCLEtBQUssTUFBTSxvQ0FBb0MsWUFBWSxLQUFLLHFCQUFxQiwwQkFBMEIsSUFBSTtBQUFBLFVBQ3BKLE9BQ0s7QUFDRCxtQkFBUSxLQUFLLGdCQUFnQixLQUFLO0FBQUEsVUFDdEM7QUFBQSxRQUNKO0FBQ0EsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxJQUNKO0FBRUEsSUFBTSxtQkFBTixjQUErQixXQUFXO0FBQUEsSUFDMUM7QUFFQSxJQUFNLGVBQU4sY0FBMkIsaUJBQWlCO0FBQUEsTUFDeEMsWUFBWSxRQUFRLEtBQUs7QUFDckIsY0FBTTtBQUNOLGFBQUssU0FBUztBQUNkLGFBQUssTUFBTTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsYUFBSyxPQUFPLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBR0EsS0FBSSxDQUFDO0FBQUEsTUFDbEQ7QUFBQSxNQUNBLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsa0JBQWtCO0FBQ3RFLGFBQUssT0FBTyw0QkFBNEIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHQSxLQUFJLEdBQUcsZUFBZSxnQkFBZ0I7QUFBQSxNQUN2RztBQUFBLE1BQ0Esc0JBQXNCQSxPQUFNLGtCQUFrQixRQUFRO0FBQ2xELGVBQU8sS0FBSyxPQUFPLHNCQUFzQixDQUFDLEtBQUssS0FBSyxHQUFHQSxLQUFJLEdBQUcsa0JBQWtCLE1BQU07QUFBQSxNQUMxRjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsZUFBTyxLQUFLLE9BQU8sb0NBQW9DLENBQUMsS0FBSyxLQUFLLEdBQUdBLEtBQUksR0FBRyxhQUFhLGtCQUFrQixNQUFNO0FBQUEsTUFDckg7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLFlBQUlBLE1BQUssV0FBVztBQUNoQixpQkFBTztBQUNYLGVBQU8sS0FBSyxPQUFPLDZCQUE2QixDQUFDLEtBQUssS0FBSyxHQUFHQSxLQUFJLEdBQUcsT0FBTztBQUFBLE1BQ2hGO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLEtBQUssT0FBTyw2QkFBNkIsQ0FBQyxLQUFLLEtBQUssR0FBR0EsS0FBSSxHQUFHLE9BQU87QUFBQSxNQUNoRjtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxlQUFPLEtBQUssT0FBTywyQkFBMkIsQ0FBQyxLQUFLLEtBQUssR0FBR0EsS0FBSSxHQUFHLGFBQWEsT0FBTztBQUFBLE1BQzNGO0FBQUEsSUFDSjtBQUVBLElBQU0sWUFBTixjQUF3QixTQUFTO0FBQUEsTUFDN0IsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssZUFBZTtBQUFBLE1BQ3hCO0FBQUEsTUFDQSxZQUFZLGFBQWE7QUFDckIsYUFBSyxRQUFRLElBQUksV0FBVyxXQUFXO0FBQUEsTUFDM0M7QUFBQSxNQUNBLGtCQUFrQjtBQUNkLGFBQUssZ0JBQWdCLEVBQUUsd0JBQXdCO0FBQUEsTUFDbkQ7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsYUFBSyxnQkFBZ0IsRUFBRSxlQUFlQSxLQUFJO0FBQUEsTUFDOUM7QUFBQSxNQUNBLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsa0JBQWtCO0FBQ3RFLGFBQUssZ0JBQWdCLEVBQUUsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxnQkFBZ0I7QUFBQSxNQUNuRztBQUFBLE1BQ0Esc0JBQXNCQSxPQUFNLGtCQUFrQixRQUFRO0FBQ2xELGVBQU8sS0FBSyxnQkFBZ0IsRUFBRSxzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxNQUN0RjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsZUFBTyxLQUFLLGdCQUFnQixFQUFFLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixNQUFNO0FBQUEsTUFDakg7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLElBQUk7QUFDUixjQUFNLGVBQWUsS0FBSyxLQUFLLGdCQUFnQixRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsV0FBVyxPQUFPLE1BQU0sS0FBSyxLQUFLLFdBQVcsT0FBTztBQUN2SSxTQUFDLEtBQUssS0FBSyxRQUFRLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyx1QkFBdUI7QUFDOUUsZUFBTyxjQUFjLE1BQU0sV0FBVyxPQUFPO0FBQUEsTUFDakQ7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQU8sS0FBSyxnQkFBZ0IsRUFBRSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQzVFO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLEtBQUssZ0JBQWdCLEVBQUUsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxNQUM1RTtBQUFBLE1BQ0EsMkJBQTJCQSxPQUFNLGFBQWEsU0FBUztBQUNuRCxZQUFJQSxNQUFLLFdBQVcsR0FBRztBQUNuQixpQkFBUSxDQUFDLFlBQVksWUFDaEIsS0FBSyxxQkFBcUIsT0FDckIsS0FBSyxpQkFBaUIsMkJBQTJCLFlBQVksYUFBYSxPQUFPLElBQ2pGLEtBQUssZUFBZSxRQUNsQixLQUFLLFdBQVcsMkJBQTJCQSxPQUFNLGFBQWEsT0FBTztBQUFBLFFBQ3JGLE9BQ0s7QUFDRCxpQkFBTyxLQUFLLGdCQUFnQixFQUFFLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxRQUN2RjtBQUFBLE1BQ0o7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsWUFBSTtBQUNKLGFBQUssV0FBVztBQUNoQixTQUFDLEtBQUssS0FBSyxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFFBQVEsU0FBUywwQkFBMEI7QUFDMUcsYUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsWUFBSSxLQUFLLElBQUk7QUFDVCxlQUFLLEdBQUcsdUJBQXVCO0FBQy9CLGVBQUssR0FBRyxRQUFRO0FBQUEsUUFDcEI7QUFBQSxNQUNKO0FBQUEsTUFDQSxhQUFhO0FBQ1QsWUFBSTtBQUNKLFNBQUMsS0FBSyxLQUFLLFFBQVEsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFFBQVEsU0FBUyxJQUFJO0FBQzVFLG1CQUFXLFVBQVUsS0FBSyxLQUFLLE1BQU07QUFDakMsY0FBSSxrQkFBa0Isb0JBQW9CLE9BQU8sU0FBUyxlQUFlO0FBQ3JFLGlCQUFLLG1CQUFtQjtBQUN4QjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsYUFBSyxtQkFBbUI7QUFBQSxNQUM1QjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsWUFBSSxLQUFLLGlCQUFpQixNQUFNO0FBQzVCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLGNBQU0sbUJBQW1CLENBQUM7QUFDMUIsY0FBTSxpQkFBaUIsQ0FBQztBQUN4QixtQkFBVyxjQUFjLEtBQUssS0FBSyxNQUFNO0FBQ3JDLGdCQUFNLGFBQWEsV0FBVyxTQUFTLG1CQUFtQjtBQUMxRCxnQkFBTSxpQkFBaUIsV0FBVztBQUVsQyxjQUFJLGVBQWUsa0JBQWtCLENBQUM7QUFDbEM7QUFDSixnQkFBTSxPQUFPLG1CQUFtQixTQUFTLG1CQUFtQixRQUFRLGlCQUFpQjtBQUNyRixjQUFJO0FBQ0osY0FBSSxXQUFXLFVBQVU7QUFDckIsa0JBQU0sV0FBVyxXQUFXLElBQUksc0JBQXNCLFlBQVksMEJBQTBCLElBQUk7QUFDaEcsZ0JBQUksYUFBYSxjQUFjO0FBQzNCLHlCQUFXLEtBQUssRUFBRSxLQUFLLFlBQVksTUFBTSxVQUFVLFdBQVcsQ0FBQztBQUMvRDtBQUFBLFlBQ0osT0FDSztBQUNELG9CQUFNLE9BQU8sUUFBUTtBQUFBLFlBQ3pCO0FBQUEsVUFDSixPQUNLO0FBQ0Qsa0JBQ0ksV0FBVyxlQUFlLGFBQ3BCLFdBQVcsSUFBSSxPQUNmLE9BQU8sV0FBVyxJQUFJLEtBQUs7QUFBQSxVQUN6QztBQUNBLHFCQUFXLEtBQUssRUFBRSxLQUFLLE1BQU0sVUFBVSxXQUFXLENBQUM7QUFBQSxRQUN2RDtBQUNBLHlCQUFpQixRQUFRO0FBQUEsVUFDckIsS0FBSztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sVUFBVSxJQUFJLGFBQWEsZ0JBQWdCLEtBQUssYUFBYSxJQUFJLGFBQWEsS0FBSyxZQUFZLFdBQVcsSUFBSSxnQkFBZ0I7QUFBQSxRQUNsSSxDQUFDO0FBQ0QsZUFBUSxLQUFLLGVBQWUsSUFBSSxhQUFhLGtCQUFrQixLQUFLLGNBQWMsZ0JBQWdCO0FBQUEsTUFDdEc7QUFBQSxJQUNKO0FBRUEsSUFBTSxtQkFBTixjQUErQixVQUFVO0FBQUEsTUFDckMsYUFBYTtBQUNULGNBQU0sV0FBVztBQUNqQixZQUFJLEtBQUssT0FBTyxNQUFNO0FBQ2xCLGVBQUssR0FBRyxTQUFTLE9BQU87QUFBQSxRQUM1QjtBQUFBLE1BQ0o7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixZQUFJLFdBQVcsT0FBTyxNQUFNO0FBQ3hCLGVBQUssS0FBSyxJQUFJLFdBQVcsV0FBVyxJQUFJLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFBQSxRQUNuRTtBQUNBLGNBQU0sVUFBVSxVQUFVO0FBQUEsTUFDOUI7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTO0FBQ2xCLGNBQU0sRUFBRSx1QkFBdUIsUUFBUSxVQUFVLEVBQUUsRUFBRSxFQUFFLElBQUk7QUFDM0QsWUFBSSxXQUFXLFlBQVksS0FBSyxNQUFNLHNCQUFzQixJQUFJLEtBQUssR0FBRyxRQUFRLEdBQUc7QUFDL0UsZUFBSyxXQUFXLEtBQUssS0FBSyxHQUFHLElBQUkseUJBQXlCLENBQUMsS0FBSyxHQUFHLFFBQVEsR0FBRyxPQUFPLElBQUk7QUFBQSxRQUM3RjtBQUNBLGNBQU0sT0FBTyxNQUFNLE9BQU87QUFBQSxNQUM5QjtBQUFBLElBQ0o7QUFFQSxJQUFNLGtCQUFOLGNBQThCLFVBQVU7QUFBQSxNQUNwQyxPQUFPLE1BQU0sU0FBUyxFQUFFLDJCQUEyQixJQUFJLE9BQU87QUFDMUQsY0FBTSxPQUFPLE1BQU0sT0FBTztBQUMxQixZQUFJLCtCQUErQix1QkFBdUI7QUFDdEQsZUFBSyxZQUFZLEtBQUssT0FBTyxHQUFHO0FBQ2hDLGVBQUssWUFBWSxLQUFLLEtBQUssR0FBRztBQUFBLFFBQ2xDO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFNLGtCQUFOLGNBQThCLGlCQUFpQjtBQUFBLE1BQzNDLFlBQVksYUFBYTtBQUNyQixjQUFNO0FBQ04sYUFBSyxjQUFjO0FBQ25CLGFBQUssV0FBVztBQUFBLE1BQ3BCO0FBQUEsTUFDQSxlQUFlQSxPQUFNO0FBQ2pCLG1CQUFXLGNBQWMsS0FBSyxhQUFhO0FBQ3ZDLHFCQUFXLGVBQWVBLEtBQUk7QUFBQSxRQUNsQztBQUFBLE1BQ0o7QUFBQSxNQUNBLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixRQUFRO0FBQzdFLGVBQU8sSUFBSSxnQkFBZ0IsS0FBSyxZQUFZLElBQUksZ0JBQWMsV0FBVyxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTSxDQUFDLENBQUM7QUFBQSxNQUM5SjtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsbUJBQVcsY0FBYyxLQUFLLGFBQWE7QUFDdkMsY0FBSSxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPO0FBQ3JELG1CQUFPO0FBQUEsUUFDZjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxtQkFBVyxjQUFjLEtBQUssYUFBYTtBQUN2QyxjQUFJLFdBQVcsNkJBQTZCQSxPQUFNLE9BQU87QUFDckQsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsbUJBQVcsY0FBYyxLQUFLLGFBQWE7QUFDdkMsY0FBSSxXQUFXLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFDaEUsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFHekMsbUJBQVcsY0FBYyxLQUFLLGFBQWE7QUFDdkMsY0FBSSxDQUFDLFdBQVcsVUFBVTtBQUN0Qix1QkFBVyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsVUFDMUQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFNLHdCQUFOLGNBQW9DLFNBQVM7QUFBQSxNQUN6QyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyw2QkFBNkIsQ0FBQztBQUNuQyxhQUFLLDZCQUE2QjtBQUNsQyxhQUFLLGFBQWE7QUFBQSxNQUN0QjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsWUFBSSxLQUFLLGVBQWUsTUFBTTtBQUMxQixnQkFBTSxlQUFlLEtBQUssZUFBZSxLQUFLLGFBQWEsS0FBSyxZQUFZLEtBQUs7QUFDakYsZUFBSyxhQUFhO0FBQ2xCLHVCQUFhLGVBQWUsWUFBWTtBQUN4QyxxQkFBVyxjQUFjLEtBQUssNEJBQTRCO0FBQ3RELHVCQUFXLGdCQUFnQjtBQUFBLFVBQy9CO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLGVBQWUsTUFBTTtBQUNyQixlQUFLLFdBQVcsZUFBZUEsS0FBSTtBQUNuQyxlQUFLLFVBQVUsZUFBZUEsS0FBSTtBQUFBLFFBQ3RDLE9BQ0s7QUFDRCxxQkFBVyxlQUFlQSxLQUFJO0FBQUEsUUFDbEM7QUFBQSxNQUNKO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxhQUFLLFdBQVcsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxnQkFBZ0I7QUFDeEYsYUFBSyxVQUFVLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQUEsTUFDM0Y7QUFBQSxNQUNBLHNCQUFzQkEsT0FBTSxrQkFBa0IsUUFBUTtBQUNsRCxjQUFNLGFBQWEsS0FBSyxjQUFjO0FBQ3RDLFlBQUksZUFBZTtBQUNmLGlCQUFPO0FBQ1gsYUFBSywyQkFBMkIsS0FBSyxNQUFNO0FBQzNDLGVBQU8sV0FBVyxzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxNQUMxRTtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLGVBQWU7QUFDZixpQkFBTyxJQUFJLGdCQUFnQjtBQUFBLFlBQ3ZCLEtBQUssV0FBVyxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLFlBQy9GLEtBQUssVUFBVSxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLFVBQ2xHLENBQUM7QUFDTCxhQUFLLDJCQUEyQixLQUFLLE1BQU07QUFDM0MsZUFBTyxXQUFXLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixNQUFNO0FBQUEsTUFDckc7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLEtBQUssS0FBSyxXQUFXLE9BQU87QUFDNUIsaUJBQU87QUFDWCxjQUFNLGFBQWEsS0FBSyxjQUFjO0FBQ3RDLFlBQUksZUFBZSxNQUFNO0FBQ3JCLGlCQUFPLEtBQUssV0FBVyxXQUFXLE9BQU8sS0FBSyxLQUFLLFVBQVUsV0FBVyxPQUFPO0FBQUEsUUFDbkY7QUFDQSxlQUFPLFdBQVcsV0FBVyxPQUFPO0FBQUEsTUFDeEM7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLE1BQU07QUFDckIsaUJBQVEsS0FBSyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPLEtBQzlELEtBQUssVUFBVSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLFFBQ2pFO0FBQ0EsZUFBTyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDaEU7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLE1BQU07QUFDckIsaUJBQVEsS0FBSyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPLEtBQzlELEtBQUssVUFBVSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLFFBQ2pFO0FBQ0EsZUFBTyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDaEU7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLGVBQWUsTUFBTTtBQUNyQixpQkFBUSxLQUFLLFdBQVcsMkJBQTJCQSxPQUFNLGFBQWEsT0FBTyxLQUN6RSxLQUFLLFVBQVUsMkJBQTJCQSxPQUFNLGFBQWEsT0FBTztBQUFBLFFBQzVFO0FBQ0EsZUFBTyxXQUFXLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUMzRTtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLDhCQUE4QixLQUFLLEtBQUssaUJBQWlCLE9BQU8sS0FBSyxlQUFlLE1BQU07QUFDMUYsZUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsZUFBSyxXQUFXLFFBQVEsU0FBUywwQkFBMEI7QUFDM0QsZUFBSyxVQUFVLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxRQUM5RCxPQUNLO0FBQ0QscUJBQVcsUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQzFEO0FBQUEsTUFDSjtBQUFBLE1BQ0EscUJBQXFCLFNBQVMsTUFBTTtBQUNoQyxjQUFNLGFBQWEsS0FBSyxjQUFjO0FBQ3RDLFlBQUksZUFBZSxNQUFNO0FBQ3JCLGVBQUssV0FBVyxxQkFBcUIsU0FBUyxJQUFJO0FBQ2xELGVBQUssVUFBVSxxQkFBcUIsU0FBUyxJQUFJO0FBQUEsUUFDckQsT0FDSztBQUNELHFCQUFXLHFCQUFxQixTQUFTLElBQUk7QUFBQSxRQUNqRDtBQUFBLE1BQ0o7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTLEVBQUUsMEJBQTBCLFlBQVksb0JBQW9CLDJCQUEyQixJQUFJLE9BQU87QUFDcEgsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLENBQUMsS0FBSyxLQUFLLFVBQVU7QUFDckIsZ0JBQU0sV0FBVyxrQ0FBa0MsS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEdBQUc7QUFDMUYsZ0JBQU0saUJBQWlCLGtCQUFrQixLQUFLLFdBQVcsS0FBSyxXQUFXLFdBQ25FLGtDQUFrQyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssR0FBRyxJQUNuRSxZQUFZLENBQUM7QUFDbkIsY0FBSSxZQUFZO0FBQ1osNkJBQWlCLE1BQU0sZ0JBQWdCLFdBQVcsS0FBSztBQUFBLFVBQzNEO0FBQ0EsZUFBSyxPQUFPLEtBQUssT0FBTyxjQUFjO0FBQ3RDLGNBQUksS0FBSyxXQUFXLFVBQVU7QUFDMUIsaUJBQUssT0FBTyxVQUFVLEtBQUssR0FBRztBQUFBLFVBQ2xDO0FBQ0EsNEJBQWtCLE1BQU0sSUFBSTtBQUM1QixxQkFBVyxPQUFPLE1BQU0sU0FBUztBQUFBLFlBQzdCO0FBQUEsWUFDQSxZQUFZO0FBQUEsWUFDWixvQkFBb0Isc0JBQXNCLEtBQUssT0FBTztBQUFBLFlBQ3RELDRCQUE0Qiw4QkFBOEIsS0FBSyxPQUFPO0FBQUEsVUFDMUUsQ0FBQztBQUFBLFFBQ0wsT0FDSztBQUNELGVBQUssS0FBSyxPQUFPLE1BQU0sU0FBUyxFQUFFLDJCQUEyQixDQUFDO0FBQzlELGVBQUssV0FBVyxPQUFPLE1BQU0sT0FBTztBQUNwQyxlQUFLLFVBQVUsT0FBTyxNQUFNLE9BQU87QUFBQSxRQUN2QztBQUFBLE1BQ0o7QUFBQSxNQUNBLGdCQUFnQjtBQUNaLFlBQUksS0FBSyw0QkFBNEI7QUFDakMsaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBQ0EsYUFBSyw2QkFBNkI7QUFDbEMsY0FBTSxZQUFZLEtBQUssS0FBSyxzQkFBc0IsWUFBWSwwQkFBMEIsSUFBSTtBQUM1RixlQUFPLGNBQWMsZUFDZixPQUNDLEtBQUssYUFBYSxZQUFZLEtBQUssYUFBYSxLQUFLO0FBQUEsTUFDaEU7QUFBQSxJQUNKO0FBRUEsSUFBTSxvQkFBTixjQUFnQyxTQUFTO0FBQUEsTUFDckMsV0FBVyxTQUFTO0FBQ2hCLFlBQUksS0FBSyxPQUFPO0FBQ1osY0FBSSxDQUFDLFFBQVEsT0FBTyxPQUFPLElBQUksS0FBSyxNQUFNLElBQUk7QUFDMUMsbUJBQU87QUFDWCxrQkFBUSxlQUFlLElBQUksS0FBSyxNQUFNLElBQUk7QUFDMUMsa0JBQVEsYUFBYTtBQUFBLFFBQ3pCLE9BQ0s7QUFDRCxjQUFJLENBQUMsUUFBUSxPQUFPO0FBQ2hCLG1CQUFPO0FBQ1gsa0JBQVEsYUFBYTtBQUFBLFFBQ3pCO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUztBQUNiLGFBQUssV0FBVztBQUNoQixZQUFJLEtBQUssT0FBTztBQUNaLGVBQUssTUFBTSxRQUFRO0FBQ25CLGtCQUFRLGVBQWUsSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUFBLFFBQzlDO0FBQ0EsZ0JBQVEsYUFBYSxLQUFLLFFBQVEsaUNBQWlDO0FBQUEsTUFDdkU7QUFBQSxJQUNKO0FBRUEsSUFBTSxtQkFBTixjQUErQixTQUFTO0FBQUEsTUFDcEMsV0FBVyxTQUFTO0FBQ2hCLFlBQUksS0FBSyxLQUFLLFdBQVcsT0FBTztBQUM1QixpQkFBTztBQUNYLGNBQU0sRUFBRSxZQUFZLFFBQVEsRUFBRSxRQUFRLFVBQVUsRUFBRSxJQUFJO0FBQ3RELGdCQUFRLE9BQU8sU0FBUztBQUN4QixnQkFBUSxPQUFPLFlBQVk7QUFDM0IsWUFBSSxLQUFLLEtBQUssV0FBVyxPQUFPO0FBQzVCLGlCQUFPO0FBQ1gsZ0JBQVEsT0FBTyxTQUFTO0FBQ3hCLGdCQUFRLE9BQU8sWUFBWTtBQUMzQixnQkFBUSxhQUFhO0FBQ3JCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixhQUFLLEtBQUssUUFBUSxTQUFTLDBCQUEwQjtBQUNyRCxjQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLGFBQUssS0FBSyx5QkFBeUIsU0FBUywwQkFBMEI7QUFDdEUsZ0JBQVEsYUFBYTtBQUFBLE1BQ3pCO0FBQUEsSUFDSjtBQUVBLElBQU0saUJBQU4sY0FBNkIsU0FBUztBQUFBLE1BQ2xDLGFBQWE7QUFDVCxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFFQSxJQUFNLHVCQUFOLGNBQW1DLFNBQVM7QUFBQSxNQUN4QyxhQUFhO0FBQ1QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLFFBQVEsVUFBVSxJQUFJO0FBQUEsTUFDL0I7QUFBQSxNQUNBLE9BQU8sTUFBTSxVQUFVLG1CQUFtQjtBQUN0QyxhQUFLLE9BQU8sa0JBQWtCLE9BQU8sa0JBQWtCLEdBQUc7QUFBQSxNQUM5RDtBQUFBLElBQ0o7QUFDQSx5QkFBcUIsVUFBVSxrQkFBa0I7QUFFakQsSUFBTSxzQkFBTixjQUFrQyxhQUFhO0FBQUEsTUFDM0MsYUFBYTtBQUNULGNBQU0sV0FBVztBQUNqQixZQUFJLEtBQUssT0FBTyxNQUFNO0FBQ2xCLGVBQUssR0FBRyxTQUFTLE9BQU87QUFBQSxRQUM1QjtBQUFBLE1BQ0o7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixZQUFJLFdBQVcsT0FBTyxNQUFNO0FBQ3hCLGVBQUssS0FBSyxJQUFJLFdBQVcsV0FBVyxJQUFJLE1BQU0sS0FBSyxNQUFNLE1BQU07QUFBQSxRQUNuRTtBQUNBLGNBQU0sVUFBVSxVQUFVO0FBQUEsTUFDOUI7QUFBQSxJQUNKO0FBZUEsSUFBTSwyQkFBTixjQUF1QyxTQUFTO0FBQUEsTUFDNUMsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxjQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFDakQsWUFBSSw0QkFBNEI7QUFDNUIsZUFBSyxRQUFRLHdCQUF3QixLQUFLLFFBQVE7QUFBQSxRQUN0RDtBQUFBLE1BQ0o7QUFBQSxNQUNBLGFBQWE7QUFDVCxjQUFNLGNBQWMsS0FBSztBQUN6QixhQUFLLGtCQUNBLFlBQVksTUFBTSxZQUFZLEdBQUcsUUFBUyxLQUFLLFlBQVk7QUFDaEUsYUFBSyxXQUFXLEtBQUssTUFBTSw0QkFBNEIsS0FBSyxtQkFBbUIsS0FBSyxRQUFRLGNBQWMsR0FBRyxNQUFNLEtBQUssT0FBTztBQUMvSCxhQUFLLFFBQVEsVUFBVSxJQUFJO0FBQUEsTUFDL0I7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTLG1CQUFtQjtBQUNyQyxjQUFNLEVBQUUsT0FBTyxJQUFJLElBQUk7QUFDdkIsY0FBTSxtQkFBbUIsb0JBQW9CLEtBQUssVUFBVSxLQUFLLEtBQUs7QUFDdEUsWUFBSSxLQUFLLHVCQUF1QixxQkFBcUI7QUFDakQsZUFBSyx1QkFBdUIsTUFBTSxrQkFBa0IsWUFBWSxLQUFLLEtBQUssWUFBWSxPQUFPLE1BQU0sT0FBTztBQUFBLFFBQzlHLFdBQ1MsS0FBSyx1QkFBdUIsa0JBQWtCO0FBQ25ELGVBQUssdUJBQXVCLE1BQU0sa0JBQWtCLFNBQVMsS0FBSyxLQUFLLFlBQVksT0FBTyxNQUFNLE9BQU87QUFBQSxRQUMzRyxXQUNTLEtBQUssU0FBUyxvQkFBb0IsTUFBTSxLQUFLLFVBQVU7QUFFNUQsd0JBQWMsTUFBTSxNQUFNLE9BQU8sR0FBRztBQUNwQztBQUFBLFFBQ0osV0FDUyxLQUFLLFNBQVMsVUFBVTtBQUM3QixlQUFLLDBCQUEwQixNQUFNLGtCQUFrQixPQUFPO0FBQUEsUUFDbEUsT0FDSztBQUNELGVBQUssT0FBTyxLQUFLLE9BQU8sZ0JBQWdCO0FBQ3hDLGVBQUssWUFBWSxPQUFPLE1BQU0sU0FBUztBQUFBLFlBQ25DLDRCQUE0QjtBQUFBLFVBQ2hDLENBQUM7QUFDRCxjQUFJLEtBQUssU0FBUyxLQUFLLE1BQU0sT0FBTyxLQUFLO0FBQ3JDLGlCQUFLLFdBQVcsS0FBSyxLQUFLLEdBQUc7QUFBQSxVQUNqQztBQUNBO0FBQUEsUUFDSjtBQUNBLGFBQUssWUFBWSxPQUFPLE1BQU0sT0FBTztBQUFBLE1BQ3pDO0FBQUEsTUFDQSx1QkFBdUIsTUFBTSxrQkFBa0Isb0JBQW9CLFdBQVcsU0FBUyxTQUFTO0FBQzVGLGNBQU0sRUFBRSx1QkFBdUIsUUFBUSxVQUFVLEVBQUUsa0JBQWtCLEVBQUUsSUFBSTtBQUMzRSxjQUFNLE9BQU8sS0FBSyxTQUFTLFFBQVEsaUJBQWlCO0FBRXBELGFBQUssT0FBTyxLQUFLLE9BQU8sZ0JBQWdCO0FBQ3hDLFlBQUksU0FBUztBQUNULGVBQUssV0FBVyxvQkFBb0IsS0FBSyxVQUFVLG9CQUFvQixXQUFXLGdCQUFnQixHQUFHLElBQUksTUFBTTtBQUFBLFFBQ25IO0FBQ0EsWUFBSSxXQUFXLFlBQ1gsS0FBSyx1QkFBdUIsb0JBQzVCLHNCQUFzQixJQUFJLEtBQUssUUFBUSxHQUFHO0FBQzFDLGVBQUssV0FBVyxLQUFLLEtBQUssSUFBSSx5QkFBeUIsQ0FBQyxLQUFLLFFBQVEsR0FBRyxPQUFPLElBQUk7QUFBQSxRQUN2RjtBQUFBLE1BQ0o7QUFBQSxNQUNBLDBCQUEwQixNQUFNLGtCQUFrQixFQUFFLFFBQVEsdUJBQXVCLFVBQVUsRUFBRSxNQUFNLGtCQUFrQixFQUFFLEdBQUc7QUFDeEgsY0FBTSx1QkFBdUIsS0FBSyxTQUFTLFdBQVcsS0FBSyxNQUFNLENBQUMsTUFBTTtBQUN4RSxjQUFNLG9CQUFvQixXQUFXLFlBQVksc0JBQXNCLElBQUksS0FBSyxRQUFRO0FBQ3hGLFlBQUksbUJBQW1CO0FBQ25CLGVBQUssVUFBVSxLQUFLLE9BQU8sa0JBQWtCLEdBQUcsUUFBUSxLQUFLLFNBQVMsUUFBUSxpQkFBaUIsZ0JBQWdCLGtCQUFrQixPQUFPO0FBQ3hJLGVBQUssWUFBWSx1QkFBdUIsS0FBSyxNQUFNLElBQUksS0FBSyxLQUFLLE9BQU8sdUJBQXVCLEtBQUssSUFBSTtBQUFBLFFBQzVHLE9BQ0s7QUFDRCxlQUFLLFVBQVUsS0FBSyxPQUFPLGtCQUFrQixHQUFHLFFBQVEsS0FBSyxTQUFTLFFBQVEsaUJBQWlCLE1BQU07QUFDckcsY0FBSSxDQUFDLHNCQUFzQjtBQUN2QixpQkFBSyxXQUFXLEtBQUssS0FBSyxHQUFHO0FBQUEsVUFDakM7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSw2QkFBeUIsVUFBVSxrQkFBa0I7QUFFckQsSUFBTSx5QkFBTixjQUFxQyxTQUFTO0FBQUEsTUFDMUMsT0FBTztBQUVILFlBQUksS0FBSyxnQkFBZ0I7QUFDckIsZUFBSyxZQUFZLEtBQUs7QUFBQSxNQUM5QjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLGVBQU8sS0FBSyxnQkFBZ0IsUUFBUSxLQUFLLFlBQVksV0FBVyxPQUFPO0FBQUEsTUFDM0U7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLFFBQVEsVUFBVSxJQUFJO0FBQUEsTUFDL0I7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTLG1CQUFtQjtBQUNyQyxjQUFNLEVBQUUsT0FBTyxJQUFJLElBQUk7QUFDdkIsWUFBSSxLQUFLLGdCQUFnQixNQUFNO0FBQzNCLGVBQUssT0FBTyxPQUFPLEdBQUc7QUFBQSxRQUMxQixPQUNLO0FBQ0QsZUFBSyxPQUFPLEtBQUssT0FBTyxLQUFLLFlBQVksS0FBSztBQUM5QyxlQUFLLFlBQVksT0FBTyxNQUFNLFNBQVMsRUFBRSxLQUFLLE1BQU0sQ0FBQztBQUFBLFFBQ3pEO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSwyQkFBdUIsVUFBVSxrQkFBa0I7QUFFbkQsSUFBTSxrQkFBTixjQUE4QixTQUFTO0FBQUEsSUFDdkM7QUFFQSxJQUFNLGlCQUFOLGNBQTZCLFNBQVM7QUFBQSxNQUNsQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLFlBQVksYUFBYTtBQUNyQixhQUFLLFFBQVEsSUFBSSxXQUFXLFdBQVc7QUFBQSxNQUMzQztBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsWUFBSyxLQUFLLFNBQ0wsS0FBSyxLQUFLLFdBQVcsT0FBTyxLQUN6QixLQUFLLEtBQUssNkJBQTZCLFlBQVksT0FBTyxNQUM3RCxLQUFLLFNBQVMsS0FBSyxNQUFNLFdBQVcsT0FBTztBQUM1QyxpQkFBTztBQUNYLGNBQU0sRUFBRSxZQUFZLFFBQVEsRUFBRSxRQUFRLFVBQVUsRUFBRSxJQUFJO0FBQ3RELGdCQUFRLE9BQU8sU0FBUztBQUN4QixnQkFBUSxPQUFPLFlBQVk7QUFDM0IsWUFBSSxLQUFLLEtBQUssV0FBVyxPQUFPO0FBQzVCLGlCQUFPO0FBQ1gsZ0JBQVEsT0FBTyxTQUFTO0FBQ3hCLGdCQUFRLE9BQU8sWUFBWTtBQUMzQixnQkFBUSxhQUFhO0FBQ3JCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssS0FBSyxRQUFRLFNBQVMsOEJBQThCLElBQUk7QUFDN0QsYUFBSyxNQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFDdEQsY0FBTSxFQUFFLFdBQVcsSUFBSTtBQUN2QixhQUFLLEtBQUsseUJBQXlCLFNBQVMsMEJBQTBCO0FBQ3RFLGdCQUFRLGFBQWE7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsYUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFDNUMsYUFBSyxNQUFNLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFFN0MsWUFBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQU0sUUFBUSxDQUFDLE1BQU0sS0FBYTtBQUNoRSxlQUFLLFlBQVksS0FBSyxNQUFNLE9BQU8sR0FBRztBQUFBLFFBQzFDO0FBQ0EsYUFBSyxLQUFLLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDbEM7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxLQUFLLGVBQWUsVUFBVTtBQUNuQyxhQUFLLFFBQVEsdUJBQXVCO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBRUEsSUFBTSxpQkFBTixjQUE2QixTQUFTO0FBQUEsTUFDbEMsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssY0FBYztBQUFBLE1BQ3ZCO0FBQUEsTUFDQSxZQUFZLGFBQWE7QUFDckIsYUFBSyxRQUFRLElBQUksV0FBVyxXQUFXO0FBQUEsTUFDM0M7QUFBQSxNQUNBLGFBQWE7QUFDVCxZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBRTlCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLFlBQUksQ0FBQyxLQUFLO0FBQ04sZUFBSyxxQkFBcUI7QUFDOUIsYUFBSyxXQUFXO0FBQ2hCLGFBQUssS0FBSyxRQUFRLFNBQVMsOEJBQThCLElBQUk7QUFDN0QsYUFBSyxNQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFDdEQsY0FBTSxFQUFFLFdBQVcsSUFBSTtBQUN2QixhQUFLLEtBQUsseUJBQXlCLFNBQVMsMEJBQTBCO0FBQ3RFLGdCQUFRLGFBQWE7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsYUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFDNUMsYUFBSyxNQUFNLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFFN0MsWUFBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQU0sUUFBUSxDQUFDLE1BQU0sS0FBYTtBQUNoRSxlQUFLLFlBQVksS0FBSyxNQUFNLE9BQU8sR0FBRztBQUFBLFFBQzFDO0FBQ0EsYUFBSyxLQUFLLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDbEM7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxLQUFLLGVBQWUsVUFBVTtBQUNuQyxhQUFLLFFBQVEsdUJBQXVCO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBRUEsSUFBTSxlQUFOLGNBQTJCLFNBQVM7QUFBQSxNQUNoQyxZQUFZLGFBQWE7QUFDckIsYUFBSyxRQUFRLElBQUksV0FBVyxXQUFXO0FBQUEsTUFDM0M7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFLLEtBQUssUUFBUSxLQUFLLEtBQUssV0FBVyxPQUFPLEtBQ3pDLEtBQUssUUFBUSxLQUFLLEtBQUssV0FBVyxPQUFPLEtBQ3pDLEtBQUssVUFBVSxLQUFLLE9BQU8sV0FBVyxPQUFPO0FBQzlDLGlCQUFPO0FBQ1gsY0FBTSxFQUFFLFlBQVksUUFBUSxFQUFFLFFBQVEsVUFBVSxFQUFFLElBQUk7QUFDdEQsZ0JBQVEsT0FBTyxTQUFTO0FBQ3hCLGdCQUFRLE9BQU8sWUFBWTtBQUMzQixZQUFJLEtBQUssS0FBSyxXQUFXLE9BQU87QUFDNUIsaUJBQU87QUFDWCxnQkFBUSxPQUFPLFNBQVM7QUFDeEIsZ0JBQVEsT0FBTyxZQUFZO0FBQzNCLGdCQUFRLGFBQWE7QUFDckIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLFlBQUksS0FBSztBQUNMLGVBQUssS0FBSyx5QkFBeUIsU0FBUywwQkFBMEI7QUFDMUUsWUFBSSxLQUFLO0FBQ0wsZUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDekQsY0FBTSxFQUFFLFdBQVcsSUFBSTtBQUN2QixZQUFJLEtBQUs7QUFDTCxlQUFLLE9BQU8sUUFBUSxTQUFTLDBCQUEwQjtBQUMzRCxhQUFLLEtBQUsseUJBQXlCLFNBQVMsMEJBQTBCO0FBQ3RFLGdCQUFRLGFBQWE7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsWUFBSSxLQUFLO0FBQ0wsZUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFDaEQsWUFBSSxLQUFLO0FBQ0wsZUFBSyxLQUFLLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFDaEQsWUFBSSxLQUFLO0FBQ0wsZUFBSyxPQUFPLE9BQU8sTUFBTSxTQUFTLFlBQVk7QUFDbEQsYUFBSyxLQUFLLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDbEM7QUFBQSxJQUNKO0FBRUEsSUFBTSxxQkFBTixjQUFpQyxhQUFhO0FBQUEsTUFDMUMsT0FBTyxNQUFNLFNBQVMsRUFBRSwyQkFBMkIsSUFBSSxPQUFPO0FBQzFELGNBQU0sT0FBTyxNQUFNLE9BQU87QUFDMUIsWUFBSSwrQkFBK0IsdUJBQXVCO0FBQ3RELGVBQUssWUFBWSxLQUFLLE9BQU8sR0FBRztBQUNoQyxlQUFLLFlBQVksS0FBSyxLQUFLLEdBQUc7QUFBQSxRQUNsQztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsSUFBTSxnQkFBTixjQUE0QixXQUFXO0FBQUEsTUFDbkMsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssc0JBQXNCLENBQUM7QUFBQSxNQUNoQztBQUFBLE1BQ0EsZUFBZSxZQUFZLFNBQVMsTUFBTSxXQUFXO0FBQ2pELGFBQUssb0JBQW9CLEtBQUssVUFBVTtBQUN4QyxlQUFPLE1BQU0sZUFBZSxZQUFZLFNBQVMsTUFBTSxTQUFTO0FBQUEsTUFDcEU7QUFBQSxJQUNKO0FBRUEsSUFBTSxRQUFRLE9BQU8sT0FBTztBQUM1QixJQUFNLGNBQU4sY0FBMEIsU0FBUztBQUFBLE1BQy9CLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLFlBQVk7QUFBQSxNQUNyQjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsYUFBSyxZQUFZO0FBQUEsTUFDckI7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLEtBQUssS0FBSyxXQUFXLE9BQU8sR0FBRztBQUMvQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxjQUFNLFlBQVksS0FBSyxhQUFhO0FBQ3BDLFlBQUksY0FBYyxjQUFjO0FBQzVCLGdCQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLGNBQUksS0FBSyxXQUFXLFdBQVcsT0FBTztBQUNsQyxtQkFBTztBQUNYLGdCQUFNLHVCQUF1QixRQUFRO0FBQ3JDLGtCQUFRLGFBQWE7QUFDckIsY0FBSSxLQUFLLGNBQWM7QUFDbkIsbUJBQU87QUFDWCxjQUFJLEtBQUssVUFBVSxXQUFXLE9BQU87QUFDakMsbUJBQU87QUFDWCxrQkFBUSxhQUNKLFFBQVEsYUFBYSx1QkFBdUIsUUFBUSxhQUFhO0FBQ3JFLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8sWUFDRCxLQUFLLFdBQVcsV0FBVyxPQUFPLElBQ2xDLEtBQUssY0FBYyxRQUFRLEtBQUssVUFBVSxXQUFXLE9BQU87QUFBQSxNQUN0RTtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsWUFBSSw0QkFBNEI7QUFDNUIsZUFBSyxtQkFBbUIsNEJBQTRCLE9BQU87QUFBQSxRQUMvRCxPQUNLO0FBQ0QsZ0JBQU0sWUFBWSxLQUFLLGFBQWE7QUFDcEMsY0FBSSxjQUFjLGNBQWM7QUFDNUIsaUJBQUssbUJBQW1CLE9BQU87QUFBQSxVQUNuQyxPQUNLO0FBQ0QsaUJBQUssaUJBQWlCLFNBQVMsU0FBUztBQUFBLFVBQzVDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixhQUFLLGtCQUFrQixJQUFJLGNBQWMsS0FBSyxLQUFLO0FBQ25ELGFBQUssYUFBYSxLQUFLLEtBQUssUUFBUSxtQkFBbUIsV0FBVyxXQUFXLElBQUksR0FBRyxXQUFXLFlBQVksTUFBTSxLQUFLLGVBQWU7QUFDckksWUFBSSxXQUFXLFdBQVc7QUFDdEIsZUFBSyxpQkFBaUIsSUFBSSxjQUFjLEtBQUssS0FBSztBQUNsRCxlQUFLLFlBQVksS0FBSyxLQUFLLFFBQVEsbUJBQW1CLFdBQVcsVUFBVSxJQUFJLEdBQUcsV0FBVyxXQUFXLE1BQU0sS0FBSyxjQUFjO0FBQUEsUUFDckk7QUFDQSxjQUFNLFVBQVUsVUFBVTtBQUFBLE1BQzlCO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixjQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLElBQUk7QUFFNUMsY0FBTSxZQUFZLEtBQUssYUFBYTtBQUNwQyxjQUFNLHNCQUFzQixDQUFDO0FBQzdCLGNBQU0saUJBQWlCLEtBQUssS0FBSztBQUNqQyxjQUFNLGNBQWMsQ0FBQyxLQUFLLFFBQVEsUUFBUTtBQUMxQyxZQUFJLGdCQUFnQjtBQUNoQixlQUFLLEtBQUssT0FBTyxNQUFNLE9BQU87QUFBQSxRQUNsQyxPQUNLO0FBQ0QsZUFBSyxPQUFPLEtBQUssT0FBTyxLQUFLLFdBQVcsS0FBSztBQUFBLFFBQ2pEO0FBQ0EsWUFBSSxLQUFLLFdBQVcsYUFBYSxlQUFlLGNBQWMsZ0JBQWdCLFlBQVk7QUFDdEYsZUFBSyxXQUFXLE9BQU8sTUFBTSxPQUFPO0FBQUEsUUFDeEMsT0FDSztBQUNELGVBQUssVUFBVSxLQUFLLFdBQVcsT0FBTyxLQUFLLFdBQVcsS0FBSyxpQkFBaUIsTUFBTSxFQUFFO0FBQ3BGLDhCQUFvQixLQUFLLEdBQUcsS0FBSyxnQkFBZ0IsbUJBQW1CO0FBQUEsUUFDeEU7QUFDQSxZQUFJLEtBQUssV0FBVztBQUNoQixjQUFJLEtBQUssVUFBVSxhQUFhLGVBQWUsY0FBYyxnQkFBZ0IsQ0FBQyxZQUFZO0FBQ3RGLGdCQUFJLGdCQUFnQjtBQUNoQixrQkFBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLFVBQVUsUUFBUSxDQUFDLE1BQU0sS0FBSztBQUM1RCxxQkFBSyxZQUFZLEtBQUssVUFBVSxPQUFPLEdBQUc7QUFBQSxjQUM5QztBQUFBLFlBQ0osT0FDSztBQUNELG1CQUFLLE9BQU8sS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUs7QUFBQSxZQUN6RDtBQUNBLGlCQUFLLFVBQVUsT0FBTyxNQUFNLE9BQU87QUFBQSxVQUN2QyxPQUNLO0FBQ0QsZ0JBQUksa0JBQWtCLEtBQUssMEJBQTBCLEdBQUc7QUFDcEQsbUJBQUssVUFBVSxLQUFLLFVBQVUsT0FBTyxLQUFLLEtBQUssR0FBRztBQUFBLFlBQ3RELE9BQ0s7QUFDRCxtQkFBSyxPQUFPLEtBQUssV0FBVyxLQUFLLEtBQUssR0FBRztBQUFBLFlBQzdDO0FBQ0EsZ0NBQW9CLEtBQUssR0FBRyxLQUFLLGVBQWUsbUJBQW1CO0FBQUEsVUFDdkU7QUFBQSxRQUNKO0FBQ0EsYUFBSywwQkFBMEIscUJBQXFCLE1BQU0saUJBQWlCO0FBQUEsTUFDL0U7QUFBQSxNQUNBLGVBQWU7QUFDWCxZQUFJLEtBQUssY0FBYyxPQUFPO0FBQzFCLGlCQUFRLEtBQUssWUFBWSxLQUFLLEtBQUssc0JBQXNCLFlBQVksMEJBQTBCLElBQUk7QUFBQSxRQUN2RztBQUNBLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxpQkFBaUIsU0FBUyxXQUFXO0FBQ2pDLFlBQUksS0FBSyxLQUFLLGlCQUFpQixPQUFPLEdBQUc7QUFDckMsZUFBSyxLQUFLLFFBQVEsU0FBUyxLQUFLO0FBQUEsUUFDcEM7QUFDQSxZQUFJLGFBQWEsS0FBSyxXQUFXLGlCQUFpQixPQUFPLEdBQUc7QUFDeEQsZUFBSyxXQUFXLHlCQUF5QixTQUFTLEtBQUs7QUFBQSxRQUMzRDtBQUNBLFlBQUksS0FBSyxjQUFjLFFBQVEsQ0FBQyxhQUFhLEtBQUssVUFBVSxpQkFBaUIsT0FBTyxHQUFHO0FBQ25GLGVBQUssVUFBVSx5QkFBeUIsU0FBUyxLQUFLO0FBQUEsUUFDMUQ7QUFBQSxNQUNKO0FBQUEsTUFDQSxtQkFBbUIsNEJBQTRCLFNBQVM7QUFDcEQsYUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsYUFBSyxXQUFXLFFBQVEsU0FBUywwQkFBMEI7QUFDM0QsWUFBSSxLQUFLLGNBQWMsTUFBTTtBQUN6QixlQUFLLFVBQVUsUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQzlEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsbUJBQW1CLFNBQVM7QUFDeEIsYUFBSyxLQUFLLFFBQVEsU0FBUyxLQUFLO0FBQ2hDLGNBQU0sRUFBRSxXQUFXLElBQUk7QUFDdkIsWUFBSSx1QkFBdUI7QUFDM0IsWUFBSSxLQUFLLFdBQVcsaUJBQWlCLE9BQU8sR0FBRztBQUMzQyxlQUFLLFdBQVcseUJBQXlCLFNBQVMsS0FBSztBQUN2RCxpQ0FBdUIsUUFBUTtBQUMvQixrQkFBUSxhQUFhO0FBQUEsUUFDekI7QUFDQSxZQUFJLEtBQUssY0FBYyxRQUFRLEtBQUssVUFBVSxpQkFBaUIsT0FBTyxHQUFHO0FBQ3JFLGVBQUssVUFBVSx5QkFBeUIsU0FBUyxLQUFLO0FBQ3RELGtCQUFRLGFBQ0osUUFBUSxhQUFhLHVCQUF1QixRQUFRLGFBQWE7QUFBQSxRQUN6RTtBQUFBLE1BQ0o7QUFBQSxNQUNBLDBCQUEwQixxQkFBcUIsTUFBTSxtQkFBbUI7QUFDcEUsY0FBTSxjQUFjO0FBQUEsVUFDaEIsR0FBRyxJQUFJLElBQUksb0JBQW9CLElBQUksZ0JBQWM7QUFDN0Msa0JBQU0sV0FBVyxXQUFXO0FBQzVCLG1CQUFPLFNBQVMsV0FBVyxTQUFTLFFBQVEsaUJBQWlCLElBQUk7QUFBQSxVQUNyRSxDQUFDLENBQUM7QUFBQSxRQUNOLEVBQ0ssT0FBTyxPQUFPLEVBQ2QsS0FBSyxJQUFJO0FBQ2QsWUFBSSxhQUFhO0FBQ2IsZ0JBQU0sYUFBYSxLQUFLLE9BQU87QUFDL0IsZ0JBQU0sY0FBYyxlQUFlLGFBQWEsZUFBZTtBQUMvRCxlQUFLLGFBQWEsS0FBSyxPQUFPLEdBQUcsY0FBYyxPQUFPLFNBQVMsZUFBZTtBQUM5RSxjQUFJLGFBQWE7QUFDYixpQkFBSyxXQUFXLEtBQUssS0FBSyxJQUFJO0FBQUEsVUFDbEM7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsNEJBQTRCO0FBQ3hCLFlBQUksZ0JBQWdCLEtBQUs7QUFDekIsV0FBRztBQUNDLGNBQUkseUJBQXlCLGVBQWUsY0FBYyxXQUFXO0FBQ2pFLG1CQUFPO0FBQUEsVUFDWDtBQUNBLGNBQUkseUJBQXlCLGdCQUFnQjtBQUN6QyxtQkFBTztBQUFBLFVBQ1g7QUFDQSwwQkFBZ0IsY0FBYztBQUFBLFFBQ2xDLFNBQVM7QUFDVCxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFFQSxJQUFNLG9CQUFOLGNBQWdDLFNBQVM7QUFBQSxNQUVyQyxPQUFPO0FBQUEsTUFBRTtBQUFBLE1BQ1QsYUFBYTtBQUNULGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxhQUFhO0FBQ1QsYUFBSyxRQUFRLFVBQVUsSUFBSTtBQUFBLE1BQy9CO0FBQUEsTUFDQSxPQUFPLE1BQU0sVUFBVSxtQkFBbUI7QUFDdEMsYUFBSyxPQUFPLGtCQUFrQixPQUFPLGtCQUFrQixHQUFHO0FBQUEsTUFDOUQ7QUFBQSxJQUNKO0FBQ0Esc0JBQWtCLFVBQVUsa0JBQWtCO0FBRTlDLElBQU0seUJBQU4sY0FBcUMsU0FBUztBQUFBLElBQzlDO0FBRUEsSUFBTSwyQkFBMkI7QUFDakMsSUFBTSxrQ0FBa0M7QUFDeEMsSUFBTSw2QkFBNkI7QUFDbkMsSUFBTSxxQ0FBcUM7QUFDM0MsSUFBTSwwQ0FBMEM7QUFDaEQsSUFBTSw0QkFBNEI7QUFDbEMsSUFBTSxxQ0FBcUM7QUFBQSxNQUN2QyxNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsTUFDVCxhQUFhO0FBQUEsTUFDYixVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsSUFDVjtBQUNBLElBQU0scUJBQXFCLENBQUMsYUFBYSx5QkFBeUIsZ0JBQWdCLGNBQzdFLHlCQUF5QixnQkFBZ0IsVUFBVSxnQkFBZ0I7QUFDeEUsSUFBTSx1Q0FBdUM7QUFBQSxNQUN6QyxNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsTUFDVCxhQUFhO0FBQUEsTUFDYixVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsSUFDVjtBQUNBLElBQU0saUNBQWlDLENBQUMsYUFBYSx5QkFBeUIsbUJBQW1CLGFBQWEsb0JBQW9CLEtBQzlILG1DQUFtQyxpQkFBaUI7QUFDeEQsSUFBTSxrQkFBa0IsQ0FBQyxtQkFBbUIsaUJBQWlCUSxTQUFRLFVBQVUsY0FBYyxRQUFRLHlCQUF5QjtBQUMxSCxZQUFNLGNBQWMsSUFBSSxJQUFJLGlCQUFpQjtBQUM3QyxpQkFBVyxZQUFZLGNBQWM7QUFDakMsWUFBSSxnQkFBZ0IsSUFBSSxRQUFRLEdBQUc7QUFDL0Isc0JBQVksSUFBSSxRQUFRO0FBQUEsUUFDNUI7QUFBQSxNQUNKO0FBQ0EsYUFBTyxhQUFhLElBQUksY0FBWSxZQUFZLElBQUksUUFBUSxJQUN0RCxrQkFBa0IsVUFBVUEsU0FBUSxVQUFVLGNBQWMsUUFBUSxzQkFBc0IsV0FBVyxJQUNyRyxFQUFFLEVBQUUsS0FBSyxFQUFFO0FBQUEsSUFDckI7QUFDQSxJQUFNLG9CQUFvQjtBQUFBLE1BQ3RCLENBQUMsaUNBQWlDLElBQUksVUFBVSxjQUFjO0FBQzFELGNBQU0sRUFBRSxHQUFHLHlCQUF5QixHQUFBRCxHQUFFLElBQUk7QUFDMUMsY0FBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLHdCQUF3QixDQUFDLEdBQUcsR0FBRztBQUFBLFVBQ2pELGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLE1BQU07QUFBQSxRQUNWLENBQUM7QUFDRCxlQUFRLEdBQUcsUUFBUSxNQUFNLFlBQVksT0FBTyxZQUFZLE1BQU0sYUFBYSxRQUFRLEtBQUssSUFDakYsZUFBZSxzQkFBc0IsUUFBUSxJQUFJLGlCQUFpQixRQUFRLElBQUksUUFBUUEsS0FBSUE7QUFBQSxNQUNyRztBQUFBLE1BQ0EsQ0FBQywwQkFBMEIsSUFBSSxVQUFVLGNBQWM7QUFDbkQsY0FBTSxFQUFFLEdBQUcseUJBQXlCLEdBQUFBLEdBQUUsSUFBSTtBQUMxQyxjQUFNLENBQUMsTUFBTSxLQUFLLElBQUksd0JBQXdCLENBQUMsR0FBRyxHQUFHO0FBQUEsVUFDakQsZ0JBQWdCO0FBQUEsVUFDaEIsaUJBQWlCO0FBQUEsVUFDakIsTUFBTTtBQUFBLFFBQ1YsQ0FBQztBQUNELGVBQVEsR0FBRyxRQUFRLE1BQU0sZ0JBQWdCLEtBQUssSUFDdkMsZUFBZSxzQkFBc0IsUUFBUSxJQUFJLGlCQUFpQixRQUFRLElBQUksUUFBUUEsS0FBSUE7QUFBQSxNQUNyRztBQUFBLE1BQ0EsQ0FBQyx5Q0FBeUMsSUFBSSxVQUFVLGVBQWUsUUFBUSxzQkFBc0I7QUFDakcsY0FBTSxFQUFFLHlCQUF5QixXQUFXLEdBQUFBLEdBQUUsSUFBSTtBQUNsRCxjQUFNLENBQUMsTUFBTSxLQUFLLElBQUksd0JBQXdCLENBQUMsR0FBRyxHQUFHO0FBQUEsVUFDakQsZ0JBQWdCO0FBQUEsVUFDaEIsaUJBQWlCO0FBQUEsVUFDakIsTUFBTTtBQUFBLFFBQ1YsQ0FBQztBQUNELGVBQU8sR0FBRyxPQUFPLFVBQVUsUUFBUSxtQkFBbUIsc0JBQXNCLFVBQVU7QUFBQSxVQUNsRixDQUFDLGFBQWEsTUFBTTtBQUFBLFVBQ3BCLENBQUMsV0FBVyxHQUFHO0FBQUEsUUFDbkIsR0FBRyxFQUFFLGlCQUFpQixLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxRQUFRQSxLQUFJQTtBQUFBLE1BQzVEO0FBQUEsTUFDQSxDQUFDLG9DQUFvQyxHQUFHLFVBQVUsY0FBYyxRQUFRLHNCQUFzQjtBQUMxRixjQUFNLEVBQUUsR0FBRyxHQUFBQSxHQUFFLElBQUk7QUFDakIsZUFBUSxZQUFZLHdDQUF3QyxLQUFLQSxPQUM3RCxzQkFBc0IsR0FBRyxHQUFHLFVBQVUsY0FBYyxRQUFRLG9CQUFvQixJQUNoRixJQUFJQSxLQUFJQTtBQUFBLE1BQ2hCO0FBQUEsTUFDQSxDQUFDLDRCQUE0QixHQUFHLFVBQVUsY0FBYyxRQUFRLHNCQUFzQixhQUFhO0FBQy9GLGNBQU0sRUFBRSxHQUFHLHlCQUF5QixHQUFBQSxHQUFFLElBQUk7QUFDMUMsWUFBSSxZQUFZLElBQUksa0NBQWtDLEdBQUc7QUFDckQsZ0JBQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSx3QkFBd0IsQ0FBQyxHQUFHLEdBQUc7QUFBQSxZQUNqRCxnQkFBZ0I7QUFBQSxZQUNoQixpQkFBaUI7QUFBQSxZQUNqQixNQUFNO0FBQUEsVUFDVixDQUFDO0FBQ0QsaUJBQU8sR0FBRyxRQUFRLE1BQU0sZ0JBQWdCLEtBQUssS0FBSyxLQUFLLElBQUksd0NBQXdDLFFBQVFBLEtBQUlBO0FBQUEsUUFDbkg7QUFDQSxlQUFRLFlBQVksZ0NBQWdDLEtBQUtBLEtBQ2xELE1BQU0sTUFBTSxNQUFNLGlCQUFpQixhQUFhQSxPQUNuRCxzQkFBc0IsR0FBRyxHQUFHLFVBQVUsY0FBYyxRQUFRLG9CQUFvQixJQUNoRixJQUFJQSxLQUFJQTtBQUFBLE1BQ2hCO0FBQUEsTUFDQSxDQUFDLDJCQUEyQixHQUFHLFVBQVUsY0FBYyxRQUFRLHNCQUFzQjtBQUNqRixjQUFNLEVBQUUsR0FBRyxNQUFNLEdBQUFBLEdBQUUsSUFBSTtBQUN2QixjQUFNLGFBQWEsU0FBUyxTQUFTO0FBQ3JDLGVBQVEsWUFBWSxrQ0FBa0MsS0FBS0EsS0FDcEQsSUFBSSxtQkFBbUIsSUFBSUEsS0FDdkIsSUFBSSxJQUFJLE1BQU0sTUFBTSxPQUFPLGFBQWEsTUFBTSxjQUFjLEtBQUtBLFFBQ25FLGVBQ0ssYUFDSSw2QkFDQSwwQkFDSixvQkFBb0IsR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLFFBQVEsSUFDcEQsR0FBRyxJQUFJLElBQUksS0FBS0EsS0FDYixJQUFJLE1BQU0sWUFBWSxHQUFHLFFBQVEsSUFBSUEsS0FDekMsV0FBVyxVQUFVLFFBQVEsbUJBQW1CLHNCQUFzQixLQUFLLFFBQVEsQ0FBQyxLQUFLQSxNQUN4RkEsS0FBSUE7QUFBQSxNQUNoQjtBQUFBLElBQ0o7QUFDQSxJQUFNLHdCQUF3QixDQUFDLEVBQUUsR0FBRyxVQUFVLE1BQU0sSUFBSSxLQUFLLElBQUksVUFBVSxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxFQUFFLGlCQUFpQixLQUFLLENBQUM7QUFDeEgsSUFBTSxtQkFBbUIsQ0FBQyxFQUFFLEdBQUcsa0JBQWtCLE1BQU0sSUFBSSxrQkFBa0IsU0FBUyxJQUFJLEtBQUs7QUFDL0YsSUFBTSx3QkFBd0IsQ0FBQyxHQUFHLEdBQUcsVUFBVSxjQUFjLFFBQVEseUJBQXlCO0FBQzFGLFlBQU0sRUFBRSxHQUFHLE1BQU0sV0FBVyxtQkFBbUIsR0FBQUEsSUFBRyxFQUFFLElBQUk7QUFDeEQsWUFBTSxlQUFlLElBQUlBLFFBQ3BCLGVBQWUsdUNBQXVDLG9CQUFvQixHQUFHLElBQUksSUFBSSxHQUFHLFFBQVEsSUFDakcsR0FBRyxJQUFJO0FBQ1gsYUFBUSxHQUFHLElBQUksU0FBUyxLQUFLLHNCQUFzQix1QkFDN0MsSUFBSSxLQUFLLHlCQUF5QixJQUFJLG9CQUFvQixTQUFTLElBQUksT0FDdkUsT0FBT0EsS0FDTixNQUFNLE9BQU8sS0FBS0EsS0FDbEIsSUFBSSxJQUFJLGFBQWEsY0FBYyxDQUFDLGNBQWMsUUFBUSxJQUFJQSxLQUM5RCxLQUFLQSxLQUNMLEtBQUssa0JBQWtCLFNBQVMsSUFBSSxLQUFLLE1BQU1BLEtBQy9DLFdBQVcsVUFBVSxRQUFRLEdBQUcsSUFBSSxJQUFJQTtBQUFBLElBQ25EO0FBQ0EsSUFBTSxlQUFlLENBQUMsTUFBTSxzQkFBc0IsRUFBRSxHQUFHLE1BQU0sa0JBQWtCLEVBQUUsTUFBTSxTQUFTLFNBQVMsdUJBQ25HLE1BQU0sS0FBSyxlQUFlLElBQUksU0FDOUIsMEJBQTBCLGlCQUFpQixDQUFDLEdBQUcsR0FBRztBQUFBLE1BQ2hELFNBQVM7QUFBQSxNQUNULE1BQU07QUFBQSxJQUNWLENBQUMsSUFBSSxRQUFRO0FBQ2pCLElBQU0scUJBQXFCLENBQUMsTUFBTSxZQUFZLEdBQUcsRUFBRSxHQUFHLE1BQU0seUJBQXlCLGtCQUFrQixHQUFBQSxHQUFFLE1BQU07QUFDM0csVUFBSSxZQUFZO0FBQ1osY0FBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLHdCQUF3QixDQUFDLEdBQUcsR0FBRztBQUFBLFVBQ2pELGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQixFQUFFLE1BQU0sR0FBRyxFQUFFO0FBQUEsVUFDOUIsTUFBTTtBQUFBLFFBQ1YsQ0FBQztBQUNELGVBQVEsYUFBYSxRQUNiLE1BQU0sWUFBWSxPQUFPLFlBQVksTUFBTSxxQkFBcUIsTUFBTSwyQkFBMkIsaUJBQWlCLENBQUMsR0FBRyxHQUFHO0FBQUEsVUFDekgsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFFBQ1YsQ0FBQyxJQUFJLFFBQVE7QUFBQSxNQUNyQjtBQUNBLGFBQVEsTUFBTSxVQUFVLEtBQUssTUFBTSxLQUFLLEtBQUssYUFBYSxRQUFRLEtBQUtBLEtBQ2hFLElBQUksSUFBSSxTQUFTLEtBQUssU0FBU0EsS0FDL0IsSUFBSSxNQUFNLGFBQWEsT0FBTyxZQUFZLE1BQU0sc0JBQXNCLEtBQUssT0FBTyxLQUFLLGVBQWUsSUFBSSxPQUFPLEtBQUtBLEtBQUk7QUFBQSxJQUNySTtBQUNBLElBQU0sdUNBQXVDLENBQUMsR0FBRyxHQUFHLGFBQWE7QUFDN0QsWUFBTSxFQUFFLEdBQUcsR0FBQUEsR0FBRSxJQUFJO0FBQ2pCLGFBQVEsR0FBRyxNQUFNLE1BQU0sT0FBTyxjQUFjLEtBQUtBLE9BQzdDLDJCQUEyQixHQUFHLElBQUksR0FBRyxRQUFRLElBQzdDLEdBQUcsS0FBS0E7QUFBQSxJQUNoQjtBQUNBLElBQU0sNkJBQTZCLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxNQUFNLHlCQUF5QixHQUFBQSxHQUFFLE1BQU07QUFDbEYsWUFBTSxDQUFDLE1BQU0sS0FBSyxJQUFJLHdCQUF3QixDQUFDLEdBQUc7QUFBQSxRQUM5QyxnQkFBZ0I7QUFBQSxRQUNoQixpQkFBaUI7QUFBQSxRQUNqQixNQUFNO0FBQUEsTUFDVixDQUFDO0FBQ0QsYUFBUSxHQUFHLElBQUksU0FBUyxLQUFLLHNDQUFzQyxPQUFPQSxLQUNuRSw0QkFBNEIsTUFBTSxTQUFTLEtBQUssS0FBSyxLQUFLLEtBQUtBLEtBQy9ELElBQUksZUFBZSxTQUFTQSxLQUM1QixJQUFJLFFBQVEsSUFBSSxXQUFXLFFBQVFBLEtBQ25DLE9BQU9BO0FBQUEsSUFDbEI7QUFDQSxJQUFNLDBCQUEwQixDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsTUFBTSx5QkFBeUIsR0FBQUEsR0FBRSxNQUFNO0FBQy9FLFlBQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSx3QkFBd0IsQ0FBQyxHQUFHO0FBQUEsUUFDOUMsZ0JBQWdCO0FBQUEsUUFDaEIsaUJBQWlCO0FBQUEsUUFDakIsTUFBTTtBQUFBLE1BQ1YsQ0FBQztBQUNELGFBQVEsR0FBRyxJQUFJLFNBQVMsS0FBSyxzQ0FBc0MsT0FBT0EsS0FDbkUsTUFBTSxPQUFPLEtBQUtBLEtBQ2xCLElBQUksNEJBQTRCLE1BQU0sU0FBUyxLQUFLLEtBQUssS0FBSyxLQUFLQSxLQUNuRSxJQUFJLElBQUksZUFBZSxTQUFTQSxLQUNoQyxJQUFJLElBQUksUUFBUSxJQUFJLFdBQVcsUUFBUUEsS0FDdkMsSUFBSSxPQUFPQSxLQUNYLEtBQUtBO0FBQUEsSUFDaEI7QUFDQSxJQUFNLHFCQUFxQixDQUFDLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBQUEsR0FBRSxNQUFNLEdBQUcsUUFBUSxLQUFLLFNBQVNBO0FBQ3pFLElBQU0sWUFBWSxDQUFDLFFBQVEsYUFBYSxTQUFTLGlCQUFpQixjQUFjO0FBQ2hGLElBQU0scUJBQXFCLENBQUMsc0JBQXNCLFVBQVUsRUFBRSxHQUFHLFVBQVUsTUFBTSx1QkFDM0UseUJBQXlCLFlBQVksdUJBQXVCLElBQUksb0JBQW9CLFNBQVMsT0FDN0Y7QUFDTixJQUFNLGVBQWUsT0FBTyxLQUFLLGlCQUFpQjtBQU9sRCxJQUFNLG1CQUFOLGNBQStCLFNBQVM7QUFBQSxNQUNwQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxrQkFBa0I7QUFDdkIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssYUFBYTtBQUFBLE1BQ3RCO0FBQUEsTUFDQSxhQUFhO0FBQ1QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsWUFBSSxDQUFDLEtBQUssVUFBVTtBQUNoQixlQUFLLFdBQVc7QUFDaEIsZUFBSyxRQUFRLHFCQUFxQixJQUFJO0FBQ3RDLGVBQUssTUFBTSx5QkFBeUIsSUFBSTtBQUFBLFFBQzVDO0FBQ0EsYUFBSyxPQUFPLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxNQUMzRDtBQUFBLE1BQ0EsYUFBYTtBQUNULGFBQUssUUFBUSxpQkFBaUIsSUFBSTtBQUFBLE1BQ3RDO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixZQUFJLEtBQUssaUJBQWlCO0FBQ3RCLGdCQUFNLEVBQUUsVUFBVSxFQUFFLHlCQUF5QixrQkFBa0IsRUFBRSxJQUFJO0FBQ3JFLGdCQUFNLENBQUMsTUFBTSxLQUFLLElBQUksd0JBQXdCLENBQUMsR0FBRztBQUFBLFlBQzlDLGdCQUFnQjtBQUFBLFlBQ2hCLGlCQUFpQjtBQUFBLFlBQ2pCLE1BQU07QUFBQSxVQUNWLENBQUM7QUFDRCxlQUFLLFVBQVUsS0FBSyxPQUFPLEtBQUssS0FBSywwQkFBMEIsT0FBTyxLQUFLLGdCQUFnQixRQUFRLGlCQUFpQixJQUFJLFVBQVUsRUFBRSxhQUFhLEtBQUssQ0FBQztBQUN2SjtBQUFBLFFBQ0o7QUFDQSxZQUFJLEtBQUssV0FBVztBQUNoQixlQUFLLFVBQVUsS0FBSyxPQUFPLGtDQUFrQyxLQUFLLFVBQVUsS0FBSyxLQUFLLFFBQVEsQ0FBQyxJQUFJLEdBQUcsS0FBSyxVQUFVLE1BQU0sRUFBRSxhQUFhLEtBQUssQ0FBQztBQUNoSixlQUFLLFVBQVUsS0FBSyxNQUFNLEdBQUcsS0FBSyxLQUFLLEtBQUssVUFBVSxPQUFPLEVBQUUsYUFBYSxLQUFLLENBQUM7QUFBQSxRQUN0RjtBQUNBLGFBQUssT0FBTyxPQUFPLE1BQU0sT0FBTztBQUFBLE1BQ3BDO0FBQUEsTUFDQSxzQkFBc0IsTUFBTSxZQUFZLHFCQUFxQixFQUFFLHdCQUF3QixHQUFHO0FBQ3RGLGFBQUssVUFBVSxLQUFLLE9BQU8sT0FBTyxLQUFLLE9BQU8sS0FBSyxVQUFVO0FBQzdELFlBQUkscUJBQXFCO0FBQ3JCLGdCQUFNLENBQUMsTUFBTSxLQUFLLElBQUksd0JBQXdCLENBQUMsR0FBRyxHQUFHO0FBQUEsWUFDakQsZ0JBQWdCO0FBQUEsWUFDaEIsaUJBQWlCO0FBQUEsWUFDakIsTUFBTTtBQUFBLFVBQ1YsQ0FBQztBQUNELGVBQUssWUFBWSxLQUFLLEtBQUssU0FBUyxTQUFTLHNCQUFzQixRQUFRO0FBQUEsUUFDL0U7QUFBQSxNQUNKO0FBQUEsTUFDQSxzQkFBc0IsWUFBWSxZQUFZLFNBQVMsVUFBVSxjQUFjLHdCQUF3QjtBQUNuRyxjQUFNLEVBQUUsT0FBTyxJQUFJO0FBQ25CLGFBQUssYUFBYTtBQUNsQixjQUFNLGtCQUFrQixDQUFDLEdBQUksc0JBQXNCLFdBQVcsQ0FBQyxDQUFFO0FBQ2pFLFlBQUk7QUFDSixTQUFDLEVBQUUsUUFBUSxXQUFXLEtBQUssVUFBVSxJQUFJLEtBQUssbUNBQW1DLFlBQVksWUFBWSxTQUFTLFVBQVUsWUFBWTtBQUN4SSxZQUFJLFFBQVE7QUFDUiwwQkFBZ0IsS0FBSyxNQUFNO0FBQUEsUUFDL0I7QUFDQSxZQUFJLGdCQUFnQixTQUFTLEdBQUc7QUFDNUIsZUFBSyxNQUFNLG1CQUFtQixpQkFBaUIsc0JBQXNCO0FBQUEsUUFDekU7QUFBQSxNQUNKO0FBQUEsTUFDQSxzQkFBc0IsaUJBQWlCO0FBQ25DLGFBQUssa0JBQWtCO0FBQUEsTUFDM0I7QUFBQSxNQUNBLG1DQUFtQyxZQUFZLFlBQVksRUFBRSxTQUFTLHVCQUF1QixRQUFRLGVBQWUsRUFBRSxlQUFlLEdBQUcsUUFBUSxHQUFHLEVBQUUsR0FBRyx5QkFBeUIsd0JBQXdCLEdBQUcsY0FBYztBQUN0TixjQUFNLFlBQVksYUFBYSxjQUFjLHVCQUF1QjtBQUFBLFVBQ2hFO0FBQUEsWUFDSSxrQkFBa0IsT0FBTyxLQUFLLGVBQWUsV0FBVyxLQUFLLGFBQWE7QUFBQSxZQUMxRTtBQUFBLFlBQ0EsVUFBVSxLQUFLLFFBQVEsT0FBTztBQUFBLFlBQzlCLGdCQUFnQixLQUFLLGNBQWMsT0FBTyxLQUFLLGVBQWUsV0FBVyxLQUFLLFdBQVcsS0FBSztBQUFBLFVBQ2xHO0FBQUEsUUFDSixDQUFDO0FBQ0QsWUFBSSxXQUFXO0FBQ1gsaUJBQU8sRUFBRSxRQUFRLE1BQU0sVUFBVTtBQUFBLFFBQ3JDO0FBQ0EsY0FBTSxtQkFBbUIsQ0FBQyxLQUFLLGNBQWMsT0FBTyxLQUFLLGVBQWU7QUFDeEUsZ0JBQVEsUUFBUTtBQUFBLFVBQ1osS0FBSyxPQUFPO0FBQ1Isa0JBQU0sU0FBUyxpQkFBaUIsWUFBWSxZQUFZLE9BQU87QUFDL0QsZ0JBQUksT0FBTztBQUNYLGdCQUFJLFFBQVE7QUFDWixnQkFBSSxRQUFRO0FBQ1IscUJBQU8sZ0JBQWdCLFVBQVU7QUFDakMsdUJBQVM7QUFBQSxZQUNiO0FBQ0Esa0JBQU0sQ0FBQyxjQUFjLGFBQWEsSUFBSSx3QkFBd0IsQ0FBQyxHQUFHO0FBQUEsY0FDOUQsZ0JBQWdCO0FBQUEsY0FDaEIsaUJBQWlCO0FBQUEsY0FDakIsTUFBTTtBQUFBLFlBQ1YsQ0FBQztBQUNELG1CQUFPLDBCQUEwQixlQUFlO0FBQ2hELHFCQUFTLEdBQUc7QUFDWixnQkFBSSxDQUFDLGtCQUFrQixrQkFBa0I7QUFDckMscUJBQU8sd0JBQXdCLENBQUMsR0FBRyxHQUFHLEdBQUcsUUFBUSxTQUFTO0FBQUEsZ0JBQ3RELHdCQUF3QjtBQUFBLGdCQUN4QixzQkFBc0I7QUFBQSxjQUMxQixDQUFDO0FBQ0Qsc0JBQVE7QUFBQSxZQUNaO0FBQ0EsbUJBQU87QUFBQSxjQUNIO0FBQUEsY0FDQSxXQUFXLEVBQUUsTUFBTSxNQUFNO0FBQUEsWUFDN0I7QUFBQSxVQUNKO0FBQUEsVUFDQSxLQUFLLE9BQU87QUFDUixrQkFBTWdFLFdBQVUsVUFBVSxNQUFNO0FBQ2hDLGtCQUFNLFNBQVMsVUFBVSxNQUFNO0FBQy9CLGtCQUFNLFNBQVMsaUJBQWlCLFlBQVksWUFBWSxPQUFPO0FBQy9ELGtCQUFNLENBQUMsYUFBYSxZQUFZLElBQUksd0JBQXdCLENBQUMsR0FBRyxHQUFHO0FBQUEsY0FDL0QsZ0JBQWdCO0FBQUEsY0FDaEIsaUJBQWlCO0FBQUEsY0FDakIsTUFBTTtBQUFBLFlBQ1YsQ0FBQztBQUNELGtCQUFNLG1CQUFtQixTQUNuQixHQUFHLGNBQWNBLHlCQUF3QixhQUFhLGlCQUN0REE7QUFDTixrQkFBTSxDQUFDLGFBQWEsWUFBWSxJQUFJLHdCQUF3QixDQUFDQSxVQUFTLE1BQU0sR0FBRztBQUFBLGNBQzNFLGdCQUFnQjtBQUFBLGNBQ2hCLGlCQUFpQjtBQUFBLGNBQ2pCLE1BQU07QUFBQSxZQUNWLENBQUM7QUFDRCxnQkFBSSxPQUFPLGVBQWU7QUFDMUIsZ0JBQUksUUFBUSxLQUFLLElBQUksb0JBQW9CLElBQUksVUFBVTtBQUN2RCxnQkFBSSxDQUFDLGtCQUFrQixrQkFBa0I7QUFDckMscUJBQU8sd0JBQXdCLENBQUMsR0FBRyxHQUFHLEdBQUcsUUFBUSxTQUFTO0FBQUEsZ0JBQ3RELHdCQUF3QjtBQUFBLGdCQUN4QixzQkFBc0I7QUFBQSxjQUMxQixDQUFDO0FBQ0Qsc0JBQVE7QUFBQSxZQUNaO0FBQ0EsbUJBQU87QUFBQSxjQUNIO0FBQUEsY0FDQSxXQUFXLEVBQUUsTUFBTSxNQUFNO0FBQUEsWUFDN0I7QUFBQSxVQUNKO0FBQUEsVUFDQSxLQUFLO0FBQ0QsbUJBQU87QUFBQSxjQUNILFFBQVE7QUFBQSxjQUNSLFdBQVc7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sT0FBTztBQUFBLGNBQ1g7QUFBQSxZQUNKO0FBQUEsVUFDSixLQUFLO0FBQ0QsZ0JBQUksdUJBQXVCO0FBQ3ZCLHFCQUFPO0FBQUEsZ0JBQ0gsUUFBUTtBQUFBLGdCQUNSLFdBQVc7QUFBQSxrQkFDUCxNQUFNLEdBQUc7QUFBQSxrQkFDVCxPQUFPO0FBQUEsZ0JBQ1g7QUFBQSxjQUNKO0FBQUEsWUFDSjtBQUFBLFFBQ1I7QUFDQSxlQUFPLEVBQUUsUUFBUSxNQUFNLFdBQVcsS0FBSztBQUFBLE1BQzNDO0FBQUEsSUFDSjtBQVFBLElBQU0sd0JBQXdCO0FBQUEsTUFDMUIsS0FBSyxDQUFDLFNBQVM7QUFBQSxNQUNmLEtBQUssQ0FBQyxTQUFTO0FBQUEsTUFDZixRQUFRLENBQUMsUUFBUTtBQUFBLElBQ3JCO0FBRUEsSUFBTSwyQkFBTixjQUF1QyxTQUFTO0FBQUEsSUFDaEQ7QUFFQSxJQUFNLGtCQUFOLGNBQThCLFNBQVM7QUFBQSxJQUN2QztBQUVBLElBQU0sbUJBQU4sY0FBK0IsU0FBUztBQUFBLE1BQ3BDLFdBQVcsU0FBUztBQUNoQixjQUFNLGFBQWEsUUFBUTtBQUMzQixnQkFBUSxPQUFPLE9BQU8sSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUN6QyxZQUFJLEtBQUssS0FBSyxXQUFXLE9BQU87QUFDNUIsaUJBQU87QUFDWCxnQkFBUSxPQUFPLE9BQU8sT0FBTyxLQUFLLE1BQU0sSUFBSTtBQUM1QyxZQUFJLFFBQVEsZUFBZSxJQUFJLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDN0Msa0JBQVEsZUFBZSxPQUFPLEtBQUssTUFBTSxJQUFJO0FBQzdDLGtCQUFRLGFBQWE7QUFBQSxRQUN6QjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixjQUFNLGFBQWEsUUFBUTtBQUMzQixhQUFLLEtBQUssUUFBUSxTQUFTLDBCQUEwQjtBQUNyRCxZQUFJLDhCQUE4QixRQUFRLGVBQWUsSUFBSSxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQzNFLGVBQUssTUFBTSxRQUFRO0FBQ25CLGtCQUFRLGVBQWUsT0FBTyxLQUFLLE1BQU0sSUFBSTtBQUM3QyxrQkFBUSxhQUFhO0FBQUEsUUFDekI7QUFBQSxNQUNKO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixZQUFJLEtBQUssTUFBTSxVQUFVO0FBQ3JCLGVBQUssTUFBTSxPQUFPLE1BQU0sT0FBTztBQUFBLFFBQ25DLE9BQ0s7QUFDRCxlQUFLLE9BQU8sS0FBSyxPQUFPLGtCQUFrQixLQUFLLFVBQVUsa0NBQWtDLEtBQUssVUFBVSxLQUFLLEtBQUssTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQUEsUUFDdkk7QUFDQSxhQUFLLEtBQUssT0FBTyxNQUFNLE9BQU87QUFBQSxNQUNsQztBQUFBLElBQ0o7QUFFQSxJQUFNLG9CQUFOLGNBQWdDLFNBQVM7QUFBQSxNQUNyQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFFbEIsYUFBSyw2QkFBNkIsQ0FBQztBQUNuQyxhQUFLLDZCQUE2QjtBQUNsQyxhQUFLLGFBQWE7QUFBQSxNQUN0QjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsWUFBSSxLQUFLLGVBQWUsTUFBTTtBQUMxQixnQkFBTSxlQUFlLEtBQUssZUFBZSxLQUFLLE9BQU8sS0FBSyxRQUFRLEtBQUs7QUFDdkUsZUFBSyxhQUFhO0FBQ2xCLHVCQUFhLGVBQWUsWUFBWTtBQUN4QyxxQkFBVyxjQUFjLEtBQUssNEJBQTRCO0FBQ3RELHVCQUFXLGdCQUFnQjtBQUFBLFVBQy9CO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLGVBQWV2RSxPQUFNO0FBQ2pCLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLE1BQU07QUFDckIsZUFBSyxLQUFLLGVBQWVBLEtBQUk7QUFDN0IsZUFBSyxNQUFNLGVBQWVBLEtBQUk7QUFBQSxRQUNsQyxPQUNLO0FBQ0QscUJBQVcsZUFBZUEsS0FBSTtBQUFBLFFBQ2xDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxrQkFBa0I7QUFDdEUsYUFBSyxLQUFLLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQ2xGLGFBQUssTUFBTSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGdCQUFnQjtBQUFBLE1BQ3ZGO0FBQUEsTUFDQSxzQkFBc0JBLE9BQU0sa0JBQWtCLFFBQVE7QUFDbEQsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLGVBQWU7QUFDZixpQkFBTztBQUNYLGFBQUssMkJBQTJCLEtBQUssTUFBTTtBQUMzQyxlQUFPLFdBQVcsc0JBQXNCQSxPQUFNLGtCQUFrQixNQUFNO0FBQUEsTUFDMUU7QUFBQSxNQUNBLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixRQUFRO0FBQzdFLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlO0FBQ2YsaUJBQU8sSUFBSSxnQkFBZ0I7QUFBQSxZQUN2QixLQUFLLEtBQUssb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLE1BQU07QUFBQSxZQUN6RixLQUFLLE1BQU0sb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLE1BQU07QUFBQSxVQUM5RixDQUFDO0FBQ0wsYUFBSywyQkFBMkIsS0FBSyxNQUFNO0FBQzNDLGVBQU8sV0FBVyxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLE1BQ3JHO0FBQUEsTUFDQSxXQUFXLFNBQVM7QUFDaEIsWUFBSSxLQUFLLEtBQUssV0FBVyxPQUFPLEdBQUc7QUFDL0IsaUJBQU87QUFBQSxRQUNYO0FBQ0EsWUFBSSxLQUFLLGNBQWMsTUFBTSxLQUFLLE1BQU07QUFDcEMsaUJBQU8sS0FBSyxNQUFNLFdBQVcsT0FBTztBQUFBLFFBQ3hDO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLE1BQU07QUFDckIsaUJBQVEsS0FBSyxLQUFLLDZCQUE2QkEsT0FBTSxPQUFPLEtBQ3hELEtBQUssTUFBTSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLFFBQzdEO0FBQ0EsZUFBTyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDaEU7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGNBQU0sYUFBYSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxlQUFlLE1BQU07QUFDckIsaUJBQVEsS0FBSyxLQUFLLDZCQUE2QkEsT0FBTSxPQUFPLEtBQ3hELEtBQUssTUFBTSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLFFBQzdEO0FBQ0EsZUFBTyxXQUFXLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDaEU7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLGVBQWUsTUFBTTtBQUNyQixpQkFBUSxLQUFLLEtBQUssMkJBQTJCQSxPQUFNLGFBQWEsT0FBTyxLQUNuRSxLQUFLLE1BQU0sMkJBQTJCQSxPQUFNLGFBQWEsT0FBTztBQUFBLFFBQ3hFO0FBQ0EsZUFBTyxXQUFXLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUMzRTtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsY0FBTSxhQUFhLEtBQUssY0FBYztBQUN0QyxZQUFJLDhCQUNDLGVBQWUsS0FBSyxTQUFTLEtBQUssS0FBSyxpQkFBaUIsT0FBTyxLQUNoRSxlQUFlLE1BQU07QUFDckIsZUFBSyxLQUFLLFFBQVEsU0FBUywwQkFBMEI7QUFDckQsZUFBSyxNQUFNLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxRQUMxRCxPQUNLO0FBQ0QscUJBQVcsUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQzFEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsRUFBRSwwQkFBMEIsWUFBWSxvQkFBb0IsMkJBQTJCLElBQUksT0FBTztBQUNwSCxZQUFJLENBQUMsS0FBSyxLQUFLLFlBQVksQ0FBQyxLQUFLLE1BQU0sVUFBVTtBQUM3QyxnQkFBTSxjQUFjLGtDQUFrQyxLQUFLLFVBQVUsS0FBSyxVQUFVLEtBQUssS0FBSyxHQUFHO0FBQ2pHLGNBQUksS0FBSyxNQUFNLFVBQVU7QUFDckIsa0JBQU0sWUFBWSxrQkFBa0IsS0FBSyxVQUFVLGNBQWMsQ0FBQztBQUNsRSxpQkFBSyxPQUFPLEtBQUssT0FBTyxTQUFTO0FBQ2pDLGdCQUFJLFlBQVk7QUFDWiwrQkFBaUIsTUFBTSxXQUFXLEtBQUssTUFBTSxLQUFLO0FBQUEsWUFDdEQ7QUFBQSxVQUNKLE9BQ0s7QUFDRCxpQkFBSyxPQUFPLGFBQWEsS0FBSyxHQUFHO0FBQUEsVUFDckM7QUFDQSw0QkFBa0IsTUFBTSxJQUFJO0FBQzVCLGVBQUssY0FBYyxFQUFFLE9BQU8sTUFBTSxTQUFTO0FBQUEsWUFDdkM7QUFBQSxZQUNBO0FBQUEsWUFDQSxvQkFBb0Isc0JBQXNCLEtBQUssT0FBTztBQUFBLFlBQ3RELDRCQUE0Qiw4QkFBOEIsS0FBSyxPQUFPO0FBQUEsVUFDMUUsQ0FBQztBQUFBLFFBQ0wsT0FDSztBQUNELGVBQUssS0FBSyxPQUFPLE1BQU0sU0FBUztBQUFBLFlBQzVCO0FBQUEsWUFDQTtBQUFBLFVBQ0osQ0FBQztBQUNELGVBQUssTUFBTSxPQUFPLE1BQU0sT0FBTztBQUFBLFFBQ25DO0FBQUEsTUFDSjtBQUFBLE1BQ0EsZ0JBQWdCO0FBQ1osWUFBSSxDQUFDLEtBQUssNEJBQTRCO0FBQ2xDLGVBQUssNkJBQTZCO0FBQ2xDLGdCQUFNLFlBQVksS0FBSyxLQUFLLHNCQUFzQixZQUFZLDBCQUEwQixJQUFJO0FBQzVGLGNBQUksY0FBYyxjQUFjO0FBQzVCLG1CQUFPO0FBQUEsVUFDWCxPQUNLO0FBQ0QsaUJBQUssYUFDQSxLQUFLLGFBQWEsUUFBUSxhQUN0QixLQUFLLGFBQWEsUUFBUSxDQUFDLGFBQzNCLEtBQUssYUFBYSxRQUFRLGFBQWEsT0FDdEMsS0FBSyxPQUNMLEtBQUs7QUFBQSxVQUNuQjtBQUFBLFFBQ0o7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUFBLElBQ0o7QUFFQSxJQUFNLGVBQWU7QUFDckIsSUFBTSxlQUFlO0FBQ3JCLElBQU0sY0FBYztBQUNwQixJQUFNLGVBQU4sY0FBMkIsU0FBUztBQUFBLE1BQ2hDLG1CQUFtQixRQUFRLHdCQUF3QjtBQUMvQyxjQUFNLGVBQWUsS0FBSztBQUMxQixjQUFNLG1CQUFtQixpQkFDcEIsYUFBYSxXQUFXLFdBQVcsS0FDaEMsYUFBYSxXQUFXLFlBQVksS0FDcEMsYUFBYSxXQUFXLFlBQVksS0FDdEMseUJBQ0Esd0JBQXdCO0FBQzlCLFlBQUksZ0JBQWdCLFNBQVMsR0FBRztBQUM1QixlQUFLLE1BQU0sbUJBQW1CLGlCQUFpQixzQkFBc0I7QUFBQSxRQUN6RTtBQUFBLE1BQ0o7QUFBQSxNQUNBLHNCQUFzQixvQkFBb0I7QUFDdEMsY0FBTSxlQUFlLEtBQUs7QUFDMUIsWUFBSSxnQkFBZ0IsYUFBYSxXQUFXLFdBQVcsR0FBRztBQUN0RCxpQkFBTyxtQkFBbUIsWUFBWSxhQUFhLFVBQVUsWUFBWSxNQUFNLENBQUM7QUFBQSxRQUNwRjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxhQUFhO0FBQ1QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTTtBQUMvQixlQUFPQSxNQUFLLFNBQVM7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsVUFBVTtBQUNOLFlBQUksQ0FBQyxLQUFLLFVBQVU7QUFDaEIsZUFBSyxXQUFXO0FBQ2hCLGNBQUksS0FBSyxLQUFLLFNBQVMsVUFBVTtBQUM3QixpQkFBSyxRQUFRLGNBQWMsSUFBSTtBQUMvQixrQkFBTSxTQUFTLEtBQUs7QUFDcEIsaUJBQUssZUFDRCxrQkFBa0Isb0JBQW9CLE9BQU8sT0FBTyxnQkFBZ0IsV0FDOUQsT0FBTyxjQUNQO0FBQUEsVUFDZDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSxxQkFBcUIsTUFBTSxTQUFTLFFBQVEsVUFBVSxvQkFBb0I7QUFDdEUsWUFBSTtBQUNKLGNBQU0sU0FBUyxLQUFLO0FBQ3BCLGNBQU0sZUFBZSxLQUFLO0FBQzFCLFlBQUksaUJBQ0MsYUFBYSxXQUFXLFdBQVcsS0FDaEMsYUFBYSxXQUFXLFlBQVksS0FDcEMsYUFBYSxXQUFXLFlBQVksSUFBSTtBQUM1QyxjQUFJLGNBQWM7QUFDbEIsY0FBSSxtQkFBbUI7QUFDdkIsY0FBSSxtQkFBbUI7QUFDdkIsY0FBSTtBQUNKLGNBQUksYUFBYSxXQUFXLFdBQVcsR0FBRztBQUN0QywwQkFBYyxhQUFhLFVBQVUsWUFBWSxNQUFNO0FBQ3ZELHVCQUFXLG1CQUFtQixZQUFZLFdBQVc7QUFBQSxVQUN6RCxXQUNTLGFBQWEsV0FBVyxZQUFZLEdBQUc7QUFDNUMsNEJBQWdCLGNBQWMsbUVBQW1FLGdDQUFnQyxNQUFNLEtBQUssUUFBUSxPQUFPO0FBQzNKLCtCQUFtQixhQUFhLFVBQVUsYUFBYSxNQUFNO0FBQzdELHVCQUFXLG1CQUFtQixZQUFZLGdCQUFnQjtBQUFBLFVBQzlELE9BQ0s7QUFDRCw0QkFBZ0IsY0FBYyxtRUFBbUUsZ0NBQWdDLE1BQU0sS0FBSyxRQUFRLE9BQU87QUFDM0osK0JBQW1CLGFBQWEsVUFBVSxhQUFhLE1BQU07QUFDN0QsdUJBQVcsbUJBQW1CLFlBQVksZ0JBQWdCO0FBQUEsVUFDOUQ7QUFDQSxnQkFBTSxlQUFlLGNBQVUsWUFBQWEsY0FBVyxxQkFBUSxPQUFPLEdBQUcsUUFBUSxDQUFDO0FBQ3JFLGNBQUkyRDtBQUNKLGNBQUkscUJBQXFCLE1BQU07QUFDM0IsWUFBQUEsZUFBYyxtQkFBbUIsY0FBYyxtQkFBbUI7QUFBQSxjQUM5RDtBQUFBLGdCQUNJLGVBQWU7QUFBQSxnQkFDZjtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0EsVUFBVSxLQUFLLFFBQVEsT0FBTztBQUFBLGdCQUM5QixtQkFBbUI7QUFBQSxjQUN2QjtBQUFBLFlBQ0osQ0FBQztBQUFBLFVBQ0w7QUFDQSxjQUFJLENBQUNBLGNBQWE7QUFDZCxZQUFBQSxlQUNJLG1CQUFtQixjQUFjLGtCQUFrQjtBQUFBLGNBQy9DO0FBQUEsZ0JBQ0k7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBLFVBQVUsS0FBSyxRQUFRLE9BQU87QUFBQSxnQkFDOUIsYUFBYSxlQUFlLG9CQUFvQjtBQUFBLGdCQUNoRDtBQUFBLGNBQ0o7QUFBQSxZQUNKLENBQUMsS0FBSyxzQkFBc0IsUUFBUSxZQUFZO0FBQUEsVUFDeEQ7QUFDQSxlQUFLLFVBQVUsT0FBTyxPQUFPLE9BQU8sS0FBS0EsY0FBYSxFQUFFLGFBQWEsS0FBSyxDQUFDO0FBQzNFO0FBQUEsUUFDSjtBQUNBLGNBQU0sY0FBYyxtQkFBbUIsY0FBYyxxQkFBcUI7QUFBQSxVQUN0RTtBQUFBLFVBQ0E7QUFBQSxZQUNJO0FBQUEsWUFDQTtBQUFBLFlBQ0EsVUFBVSxLQUFLLFFBQVEsT0FBTztBQUFBLFVBQ2xDO0FBQUEsUUFDSixDQUFDLE9BQU8sS0FBSyxxQkFBcUIsYUFBYSxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsS0FBSyxzQkFBc0IsY0FBYyxFQUFFLFNBQVMsU0FBUyxDQUFDO0FBQ2pKLFlBQUksT0FBTyxnQkFBZ0IsVUFBVTtBQUNqQyxjQUFJLGtCQUFrQixrQkFBa0I7QUFDcEMsaUJBQUssVUFBVSxPQUFPLE9BQU8sT0FBTyxLQUFLLGFBQWEsRUFBRSxhQUFhLEtBQUssQ0FBQztBQUFBLFVBQy9FLE9BQ0s7QUFDRCxpQkFBSyxVQUFVLEtBQUssT0FBTyxLQUFLLEtBQUssYUFBYSxFQUFFLGFBQWEsS0FBSyxDQUFDO0FBQUEsVUFDM0U7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSxJQUFNLHlCQUF5QjtBQUFBLE1BQzNCLEtBQUssQ0FBQyxZQUFZLFVBQVUsS0FBSztBQUFBLE1BQ2pDLEtBQUssQ0FBQyxZQUFZLFdBQVcsS0FBSztBQUFBLE1BQ2xDLElBQUksQ0FBQztBQUFBLE1BQ0wsTUFBTSxDQUFDLFlBQVksS0FBSztBQUFBLE1BQ3hCLFFBQVEsQ0FBQyxRQUFRO0FBQUEsTUFDakIsS0FBSyxDQUFDLFlBQVksV0FBVyxLQUFLO0FBQUEsSUFDdEM7QUFDQSxJQUFNLHlCQUF5QjtBQUFBLE1BQzNCLEtBQUssQ0FBQyxZQUFZLFdBQVcsS0FBSztBQUFBLE1BQ2xDLEtBQUssQ0FBQyxZQUFZLFdBQVcsS0FBSztBQUFBLE1BQ2xDLElBQUksQ0FBQztBQUFBLE1BQ0wsTUFBTSxDQUFDLFlBQVksS0FBSztBQUFBLE1BQ3hCLFFBQVEsQ0FBQyxVQUFVLEtBQUs7QUFBQSxNQUN4QixLQUFLLENBQUMsWUFBWSxXQUFXLEtBQUs7QUFBQSxJQUN0QztBQUNBLElBQU0sZ0JBQWdCLENBQUN4RSxPQUFNeUUsT0FBTSxVQUFVLE9BQU9BLFFBQU96RTtBQUMzRCxJQUFNLDZCQUE2QixDQUFDLGNBQWMwRSxPQUFNLFVBQVUsY0FBYyxJQUFJLGtCQUFrQkEsT0FBTSx1REFBdUQsNEVBQTRFO0FBQy9PLElBQU0sZ0NBQWdDLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxRQUFRLE1BQU07QUFDckUsWUFBTSxlQUFlLE9BQU8sT0FBTztBQUNuQyxhQUFPLFNBQVMsT0FDVixXQUFXLG9CQUNYLFNBQVMsUUFDTCxlQUNBO0FBQUEsSUFDZDtBQUNBLElBQU0scUJBQXFCLENBQUMsU0FBU0EsT0FBTSxVQUFVLEdBQUdBLE9BQU0sdURBQXVELHVFQUF1RTtBQUM1TCxJQUFNLHdCQUF3QjtBQUFBLE1BQzFCLEtBQUssa0JBQWdCO0FBQ2pCLFlBQUksYUFBYSxPQUFPO0FBQ3BCLHlCQUFlLE9BQU87QUFDMUIsZUFBTyxjQUFjLGtCQUFrQixrQ0FBa0M7QUFBQSxNQUM3RTtBQUFBLE1BQ0EsS0FBSyxrQkFBZ0Isc0NBQXNDLGNBQWMsMkJBQTJCLGlCQUFpQiwyQkFBMkIsT0FBTywyQkFBMkIsWUFBWTtBQUFBLE1BQzlMLElBQUksa0JBQWdCLGNBQWMsSUFBSSxnQ0FBZ0M7QUFBQSxNQUN0RSxNQUFNLGtCQUFnQiwyQkFBMkIsWUFBWTtBQUFBLE1BQzdELFFBQVEsa0JBQWdCLGNBQWMsSUFBSSxnQ0FBZ0M7QUFBQSxNQUMxRSxLQUFLLGtCQUFnQix5RUFBeUUsY0FBYywyQkFBMkIsaUJBQWlCLDJCQUEyQixPQUFPLDJCQUEyQixjQUFjLElBQUk7QUFBQSxJQUMzTztBQUNBLElBQU0sdUJBQXVCO0FBQUEsTUFDekIsS0FBSyw4QkFBOEIsTUFBTSxjQUFjLDhCQUE4QixDQUFDO0FBQUEsTUFDdEYsS0FBSyw4QkFBOEIsYUFBVyxzQ0FBc0MsY0FBYyx3QkFBd0IsMkJBQTJCLE9BQU8sbUJBQW1CLE9BQU8sSUFBSTtBQUFBLE1BQzFMLE1BQU0sOEJBQThCLGFBQVcsbUJBQW1CLE9BQU8sQ0FBQztBQUFBLE1BQzFFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLE1BQU0sU0FBUyxPQUFPLGdCQUFnQixjQUFjLGtCQUFrQixJQUFJO0FBQUEsTUFDM0gsS0FBSyw4QkFBOEIsYUFBVyx5RUFBeUUsY0FBYyx3QkFBd0IsMkJBQTJCLE9BQU8sbUJBQW1CLFNBQVMsSUFBSSxJQUFJO0FBQUEsSUFDdk87QUFFQSxJQUFNLGdCQUFOLGNBQTRCLFNBQVM7QUFBQSxNQUNqQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLG1CQUFXLFlBQVksS0FBSyxXQUFXO0FBQ25DLGNBQUksU0FBUyxXQUFXLE9BQU87QUFDM0IsbUJBQU87QUFBQSxRQUNmO0FBQ0EsWUFBSSxLQUFLLFFBQVEsUUFBUSxVQUFVLGVBQy9CLEtBQUs7QUFDTCxpQkFBTztBQUNYLGVBQVEsS0FBSyxPQUFPLFdBQVcsT0FBTyxLQUNsQyxLQUFLLE9BQU8sMkJBQTJCLFlBQVksS0FBSyxhQUFhLE9BQU87QUFBQSxNQUNwRjtBQUFBLE1BQ0EsNkJBQTZCMUUsT0FBTTtBQUMvQixlQUFPQSxNQUFLLFNBQVM7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsYUFBYTtBQUNULGFBQUssY0FBYztBQUFBLFVBQ2YsTUFBTSxLQUFLO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsUUFDYjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsbUJBQVcsWUFBWSxLQUFLLFdBQVc7QUFFbkMsbUJBQVMsZUFBZSxZQUFZO0FBQUEsUUFDeEM7QUFDQSxhQUFLLFFBQVEsdUJBQXVCO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBRUEsSUFBTSxtQkFBTixjQUErQixTQUFTO0FBQUEsTUFDcEMsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssZUFBZTtBQUFBLE1BQ3hCO0FBQUEsTUFDQSxrQkFBa0I7QUFDZCxhQUFLLGdCQUFnQixFQUFFLHdCQUF3QjtBQUFBLE1BQ25EO0FBQUEsTUFDQSxlQUFlQSxPQUFNO0FBQ2pCLGFBQUssZ0JBQWdCLEVBQUUsZUFBZUEsS0FBSTtBQUFBLE1BQzlDO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxhQUFLLGdCQUFnQixFQUFFLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQUEsTUFDbkc7QUFBQSxNQUNBLHNCQUFzQkEsT0FBTSxrQkFBa0IsUUFBUTtBQUNsRCxlQUFPLEtBQUssZ0JBQWdCLEVBQUUsc0JBQXNCQSxPQUFNLGtCQUFrQixNQUFNO0FBQUEsTUFDdEY7QUFBQSxNQUNBLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixRQUFRO0FBQzdFLGVBQU8sS0FBSyxnQkFBZ0IsRUFBRSxvQ0FBb0NBLE9BQU0sYUFBYSxrQkFBa0IsTUFBTTtBQUFBLE1BQ2pIO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLEtBQUssZ0JBQWdCLEVBQUUsNkJBQTZCQSxPQUFNLE9BQU87QUFBQSxNQUM1RTtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsZUFBTyxLQUFLLGdCQUFnQixFQUFFLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDNUU7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsZUFBTyxLQUFLLGdCQUFnQixFQUFFLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUN2RjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsRUFBRSwyQkFBMkIsSUFBSSxPQUFPO0FBQzFELGNBQU0sT0FBTyxNQUFNLE9BQU87QUFDMUIsWUFBSSwrQkFBK0IseUJBQy9CLCtCQUErQiwyQkFBMkI7QUFDMUQsZUFBSyxZQUFZLEtBQUssT0FBTyxHQUFHO0FBQ2hDLGVBQUssWUFBWSxLQUFLLEtBQUssR0FBRztBQUFBLFFBQ2xDO0FBQUEsTUFDSjtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsWUFBSSxLQUFLLGlCQUFpQixNQUFNO0FBQzVCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLFlBQUksWUFBWTtBQUNoQixjQUFNLGFBQWEsQ0FBQztBQUNwQixtQkFBVyxZQUFZLEtBQUssWUFBWTtBQUNwQyxjQUFJLG9CQUFvQixlQUFlO0FBQ25DLHVCQUFXLEtBQUssRUFBRSxLQUFLLFlBQVksTUFBTSxRQUFRLFNBQVMsQ0FBQztBQUMzRDtBQUFBLFVBQ0o7QUFDQSxjQUFJO0FBQ0osY0FBSSxTQUFTLFVBQVU7QUFDbkIsa0JBQU0sV0FBVyxTQUFTLElBQUksc0JBQXNCLFlBQVksMEJBQTBCLElBQUk7QUFDOUYsZ0JBQUksYUFBYSxjQUFjO0FBQzNCLHlCQUFXLEtBQUssRUFBRSxLQUFLLFlBQVksTUFBTSxTQUFTLE1BQU0sU0FBUyxDQUFDO0FBQ2xFO0FBQUEsWUFDSixPQUNLO0FBQ0Qsb0JBQU0sT0FBTyxRQUFRO0FBQUEsWUFDekI7QUFBQSxVQUNKLE9BQ0s7QUFDRCxrQkFDSSxTQUFTLGVBQWUsYUFDbEIsU0FBUyxJQUFJLE9BQ2IsT0FBTyxTQUFTLElBQUksS0FBSztBQUNuQyxnQkFBSSxRQUFRLGVBQWUsU0FBUyxTQUFTLFFBQVE7QUFDakQsMEJBQ0ksU0FBUyxpQkFBaUIsV0FBVyxTQUFTLE1BQU0sVUFBVSxPQUN4RCxPQUNBLFNBQVM7QUFDbkI7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUNBLHFCQUFXLEtBQUssRUFBRSxLQUFLLE1BQU0sU0FBUyxNQUFNLFNBQVMsQ0FBQztBQUFBLFFBQzFEO0FBQ0EsZUFBUSxLQUFLLGVBQWUsSUFBSSxhQUFhLFlBQVksU0FBUztBQUFBLE1BQ3RFO0FBQUEsSUFDSjtBQUVBLElBQU0sb0JBQU4sY0FBZ0MsU0FBUztBQUFBLElBQ3pDO0FBRUEsSUFBTSxVQUFOLGNBQXNCLFNBQVM7QUFBQSxNQUMzQixjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxrQkFBa0I7QUFBQSxNQUMzQjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBRWhCLFlBQUksS0FBSztBQUNMLGlCQUFPO0FBQ1gsbUJBQVcsUUFBUSxLQUFLLE1BQU07QUFDMUIsY0FBSSxLQUFLLFdBQVcsT0FBTyxHQUFHO0FBQzFCLG1CQUFRLEtBQUssa0JBQWtCO0FBQUEsVUFDbkM7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLG1CQUFXLFFBQVEsS0FBSyxNQUFNO0FBQzFCLGNBQUksOEJBQThCLEtBQUssaUJBQWlCLE9BQU8sR0FBRztBQUM5RCxpQkFBSyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsVUFDcEQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsWUFBSSxLQUFLLEtBQUssUUFBUTtBQUNsQiw4QkFBb0IsS0FBSyxNQUFNLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxPQUFPO0FBQUEsUUFDdEUsT0FDSztBQUNELGdCQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsUUFDOUI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sV0FBTixjQUF1QixXQUFXO0FBQUEsTUFDOUIsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssY0FBYztBQUNuQixhQUFLLGtCQUFrQjtBQUFBLE1BQzNCO0FBQUEsTUFDQSxRQUFRLE1BQU0sTUFBTTtBQUNoQixhQUFLLGtCQUFrQjtBQUN2QixlQUFPLEtBQUssTUFBTSxRQUFRLE1BQU0sa0JBQWtCO0FBQUEsTUFDdEQ7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLGNBQU0sMEJBQTBCLEtBQUssUUFBUSxRQUFRLFVBQ2hEO0FBQ0wsZUFBUyxLQUFLLE9BQU8sU0FBUyxtQkFBbUIsNEJBQTRCLFlBQ3pFLEtBQUssSUFBSSxXQUFXLE9BQU8sS0FDM0IsS0FBSyxNQUFNLFdBQVcsT0FBTztBQUFBLE1BQ3JDO0FBQUEsTUFDQSx5QkFBeUI7QUFDckIsYUFBSyxNQUFNLHVCQUF1QjtBQUFBLE1BQ3RDO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixZQUFJLENBQUMsS0FBSyxXQUFXO0FBQ2pCLGVBQUssSUFBSSxPQUFPLE1BQU0sT0FBTztBQUFBLFFBQ2pDO0FBQ0EsYUFBSyxNQUFNLE9BQU8sTUFBTSxTQUFTLEVBQUUscUJBQXFCLEtBQUssVUFBVSxDQUFDO0FBQUEsTUFDNUU7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsWUFBSSxLQUFLLG9CQUFvQixNQUFNO0FBQy9CLGVBQUssZ0JBQWdCLGVBQWUsQ0FBQyxZQUFZLFVBQVUsQ0FBQztBQUM1RCxlQUFLLFFBQVEsdUJBQXVCO0FBQUEsUUFDeEM7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0scUJBQU4sY0FBaUMsU0FBUztBQUFBLE1BQ3RDLGVBQWVBLE9BQU07QUFDakIsWUFBSTtBQUNKLFNBQUMsS0FBSyxLQUFLLFdBQVcsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLGVBQWVBLEtBQUk7QUFBQSxNQUNqRjtBQUFBLE1BQ0EsNEJBQTRCLE9BQU9BLE9BQU0sZUFBZSxrQkFBa0I7QUFDdEUsWUFBSTtBQUNKLFNBQUMsS0FBSyxLQUFLLFdBQVcsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsZ0JBQWdCO0FBQUEsTUFDdEk7QUFBQSxNQUNBLHNCQUFzQkEsT0FBTSxrQkFBa0IsUUFBUTtBQUNsRCxlQUFPLEtBQUssUUFDTixLQUFLLE1BQU0sc0JBQXNCQSxPQUFNLGtCQUFrQixNQUFNLElBQy9EO0FBQUEsTUFDVjtBQUFBLE1BQ0Esb0NBQW9DQSxPQUFNLGFBQWEsa0JBQWtCLFFBQVE7QUFDN0UsZUFBTyxLQUFLLFFBQ04sS0FBSyxNQUFNLG9DQUFvQ0EsT0FBTSxhQUFhLGtCQUFrQixNQUFNLElBQzFGO0FBQUEsTUFDVjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLGVBQVEsS0FBSyxJQUFJLFdBQVcsT0FBTyxLQUM5QixLQUFLLFVBQVUsS0FBSyxVQUFVLFFBQVEsS0FBSyxNQUFNLFdBQVcsT0FBTztBQUFBLE1BQzVFO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQy9FO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLENBQUMsS0FBSyxTQUFTLEtBQUssTUFBTSw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQy9FO0FBQUEsTUFDQSwyQkFBMkJBLE9BQU0sYUFBYSxTQUFTO0FBQ25ELGVBQU8sQ0FBQyxLQUFLLFNBQVMsS0FBSyxNQUFNLDJCQUEyQkEsT0FBTSxhQUFhLE9BQU87QUFBQSxNQUMxRjtBQUFBLElBQ0o7QUFFQSxJQUFNLGtCQUFOLGNBQThCLFNBQVM7QUFBQSxNQUNuQyxXQUFXLFNBQVM7QUFDaEIsWUFBSSxDQUFDLFFBQVEsT0FBTyxlQUNmLEtBQUssYUFBYSxRQUFRLEtBQUssU0FBUyxXQUFXLE9BQU87QUFDM0QsaUJBQU87QUFDWCxnQkFBUSxhQUFhO0FBQ3JCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixZQUFJLEtBQUssVUFBVTtBQUNmLGVBQUssU0FBUyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsUUFDN0Q7QUFDQSxnQkFBUSxhQUFhO0FBQUEsTUFDekI7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLE1BQU0sb0JBQW9CLEtBQUssWUFBWSxrQkFBa0I7QUFBQSxNQUN0RTtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsWUFBSSxLQUFLLFVBQVU7QUFDZixlQUFLLFNBQVMsT0FBTyxNQUFNLFNBQVMsRUFBRSxZQUFZLEtBQUssQ0FBQztBQUN4RCxjQUFJLEtBQUssU0FBUyxVQUFVLEtBQUssUUFBUSxHQUF5QjtBQUM5RCxpQkFBSyxZQUFZLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFBQSxVQUN4QztBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0scUJBQU4sY0FBaUMsU0FBUztBQUFBLE1BQ3RDLGVBQWVBLE9BQU07QUFDakIsYUFBSyxZQUFZLEtBQUssWUFBWSxTQUFTLEdBQUcsZUFBZUEsS0FBSTtBQUFBLE1BQ3JFO0FBQUEsTUFDQSw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGtCQUFrQjtBQUN0RSxhQUFLLFlBQVksS0FBSyxZQUFZLFNBQVMsR0FBRyw0QkFBNEIsT0FBT0EsT0FBTSxlQUFlLGdCQUFnQjtBQUFBLE1BQzFIO0FBQUEsTUFDQSxzQkFBc0JBLE9BQU0sa0JBQWtCLFFBQVE7QUFDbEQsZUFBTyxLQUFLLFlBQVksS0FBSyxZQUFZLFNBQVMsR0FBRyxzQkFBc0JBLE9BQU0sa0JBQWtCLE1BQU07QUFBQSxNQUM3RztBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLG1CQUFXLGNBQWMsS0FBSyxhQUFhO0FBQ3ZDLGNBQUksV0FBVyxXQUFXLE9BQU87QUFDN0IsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQVFBLE1BQUssU0FBUyxLQUNsQixLQUFLLFlBQVksS0FBSyxZQUFZLFNBQVMsR0FBRyw2QkFBNkJBLE9BQU0sT0FBTztBQUFBLE1BQ2hHO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU0sU0FBUztBQUN4QyxlQUFPLEtBQUssWUFBWSxLQUFLLFlBQVksU0FBUyxHQUFHLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDbkc7QUFBQSxNQUNBLDJCQUEyQkEsT0FBTSxhQUFhLFNBQVM7QUFDbkQsZUFBTyxLQUFLLFlBQVksS0FBSyxZQUFZLFNBQVMsR0FBRywyQkFBMkJBLE9BQU0sYUFBYSxPQUFPO0FBQUEsTUFDOUc7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLGNBQU0saUJBQWlCLEtBQUssWUFBWSxLQUFLLFlBQVksU0FBUztBQUNsRSxtQkFBVyxjQUFjLEtBQUssYUFBYTtBQUN2QyxjQUFJLDhCQUNDLGVBQWUsa0JBQWtCLEVBQUUsS0FBSyxrQkFBa0Isd0JBQzNELFdBQVcsaUJBQWlCLE9BQU87QUFDbkMsdUJBQVcsUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQzlEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsRUFBRSxvQkFBb0IsMEJBQTBCLFdBQVcsSUFBSSxPQUFPO0FBQ3hGLFlBQUksZ0JBQWdCO0FBQ3BCLFlBQUksbUJBQW1CO0FBQ3ZCLGNBQU0sV0FBVyxLQUFLLFlBQVksS0FBSyxZQUFZLFNBQVM7QUFDNUQsbUJBQVcsRUFBRSxNQUFNLFdBQVcsT0FBTyxJQUFJLEtBQUsscUNBQXFDLEtBQUssYUFBYSxNQUFNLEtBQUssT0FBTyxLQUFLLEdBQUcsR0FBRztBQUM5SCxjQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLDBCQUFjLE1BQU0sTUFBTSxPQUFPLEdBQUc7QUFDcEM7QUFBQSxVQUNKO0FBQ0E7QUFDQSw2QkFBbUI7QUFDbkIsY0FBSSxrQkFBa0IsS0FBSyxZQUFZO0FBQ25DLDZCQUFpQixNQUFNLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUM7QUFDQSxjQUFJLGtCQUFrQixHQUFHO0FBQ3JCLGtCQUFNLGFBQWEsc0JBQXNCLEtBQUssT0FBTztBQUNyRCxpQkFBSyxPQUFPLE1BQU0sU0FBUztBQUFBLGNBQ3ZCLDBCQUEwQiw0QkFBNEIsU0FBUztBQUFBLGNBQy9ELG9CQUFvQjtBQUFBLGNBQ3BCLDRCQUE0QjtBQUFBLFlBQ2hDLENBQUM7QUFBQSxVQUNMLE9BQ0s7QUFDRCxpQkFBSyxPQUFPLE1BQU0sT0FBTztBQUFBLFVBQzdCO0FBQUEsUUFDSjtBQUNBLFlBQUksa0JBQWtCO0FBQ2xCLGVBQUssT0FBTyxrQkFBa0IsS0FBSyxHQUFHO0FBQUEsUUFDMUM7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sY0FBTixjQUEwQixTQUFTO0FBQUEsTUFDL0IsWUFBWSxhQUFhO0FBQ3JCLGFBQUssUUFBUSxJQUFJLFdBQVcsV0FBVztBQUFBLE1BQzNDO0FBQUEsTUFDQSxXQUFXLFNBQVM7QUFDaEIsbUJBQVcsUUFBUSxLQUFLLE1BQU07QUFDMUIsY0FBSSxLQUFLLFdBQVcsT0FBTztBQUN2QixtQkFBTztBQUFBLFFBQ2Y7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsbUJBQVcsUUFBUSxLQUFLLE1BQU07QUFDMUIsY0FBSSw4QkFBOEIsS0FBSyxpQkFBaUIsT0FBTztBQUMzRCxpQkFBSyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsUUFDeEQ7QUFBQSxNQUNKO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixZQUFJLEtBQUssS0FBSyxRQUFRO0FBQ2xCLDhCQUFvQixLQUFLLE1BQU0sTUFBTSxLQUFLLFFBQVEsR0FBRyxLQUFLLE1BQU0sR0FBRyxPQUFPO0FBQUEsUUFDOUUsT0FDSztBQUNELGdCQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsUUFDOUI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sUUFBTixjQUFvQixTQUFTO0FBQUEsTUFDekIsT0FBTztBQUNILGFBQUssV0FBVyxLQUFLLE1BQU0sYUFBYSxNQUFNO0FBQUEsTUFDbEQ7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsYUFBSyxTQUFTLGVBQWVBLEtBQUk7QUFBQSxNQUNyQztBQUFBLE1BQ0EsVUFBVTtBQUNOLFlBQUksQ0FBQyxLQUFLLFVBQVU7QUFDaEIsZUFBSyxXQUFXO0FBQ2hCLGVBQUssUUFBUSx3QkFBd0IsS0FBSyxRQUFRO0FBQUEsUUFDdEQ7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0sYUFBTixjQUF5QixTQUFTO0FBQUEsTUFDOUIsV0FBVyxTQUFTO0FBQ2hCLFlBQUksS0FBSyxRQUFRLEtBQUssS0FBSyxXQUFXLE9BQU87QUFDekMsaUJBQU87QUFDWCxtQkFBVyxRQUFRLEtBQUssWUFBWTtBQUNoQyxjQUFJLFFBQVE7QUFDUjtBQUNKLGNBQUksS0FBSyxXQUFXLE9BQU87QUFDdkIsbUJBQU87QUFBQSxRQUNmO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLFlBQUksS0FBSztBQUNMLGVBQUssS0FBSyxRQUFRLFNBQVMsMEJBQTBCO0FBQ3pELG1CQUFXLFFBQVEsS0FBSyxZQUFZO0FBQ2hDLGNBQUksOEJBQThCLEtBQUssaUJBQWlCLE9BQU87QUFDM0QsaUJBQUssUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQ3hEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVMsbUJBQW1CO0FBQ3JDLFlBQUksS0FBSyxXQUFXLFFBQVE7QUFDeEIsZUFBSyxRQUFRLEtBQUssS0FBSyxPQUFPLE1BQU0sT0FBTztBQUMzQyxnQkFBTSxVQUFVLEtBQUssT0FDZixLQUFLLEtBQUssTUFDVixrQ0FBa0MsS0FBSyxVQUFVLFdBQVcsS0FBSyxLQUFLLElBQUk7QUFDaEYsZ0JBQU0sa0JBQWtCLGtDQUFrQyxLQUFLLFVBQVUsS0FBSyxPQUFPLElBQUk7QUFDekYsOEJBQW9CLEtBQUssWUFBWSxNQUFNLGlCQUFpQixrQkFBa0IsS0FBSyxPQUFPO0FBQUEsUUFDOUYsT0FDSztBQUNELGdCQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsUUFDOUI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLGVBQVcsVUFBVSxrQkFBa0I7QUFFdkMsSUFBTSxrQkFBTixjQUE4QixTQUFTO0FBQUEsTUFDbkMsWUFBWSxhQUFhO0FBQ3JCLGFBQUssUUFBUSxJQUFJLFdBQVcsV0FBVztBQUFBLE1BQzNDO0FBQUEsTUFDQSxXQUFXLFNBQVM7QUFDaEIsWUFBSSxLQUFLLGFBQWEsV0FBVyxPQUFPO0FBQ3BDLGlCQUFPO0FBQ1gsY0FBTSxFQUFFLFlBQVksUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJO0FBQzNDLFlBQUksZ0JBQWdCO0FBQ3BCLGdCQUFRLE9BQU8sU0FBUztBQUN4QixtQkFBVyxjQUFjLEtBQUssT0FBTztBQUNqQyxjQUFJLFdBQVcsV0FBVyxPQUFPO0FBQzdCLG1CQUFPO0FBQ1gsMEJBQWdCLFFBQVEsYUFBYSxnQkFBZ0IsUUFBUSxhQUFhO0FBQzFFLGtCQUFRLGFBQWE7QUFBQSxRQUN6QjtBQUNBLFlBQUksS0FBSyxnQkFBZ0IsUUFBUSxFQUFFLGtCQUFrQiw2QkFBNkI7QUFDOUUsa0JBQVEsYUFBYTtBQUFBLFFBQ3pCO0FBQ0EsZ0JBQVEsT0FBTyxTQUFTO0FBQ3hCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixhQUFLLGFBQWEsUUFBUSxTQUFTLDBCQUEwQjtBQUM3RCxjQUFNLEVBQUUsV0FBVyxJQUFJO0FBQ3ZCLFlBQUksZ0JBQWdCO0FBQ3BCLFlBQUksaUJBQWlCLDhCQUNoQixLQUFLLGdCQUFnQixRQUFRLEtBQUssY0FBYyxLQUFLLE1BQU0sU0FBUztBQUN6RSxpQkFBUyxZQUFZLEtBQUssTUFBTSxTQUFTLEdBQUcsYUFBYSxHQUFHLGFBQWE7QUFDckUsZ0JBQU0sYUFBYSxLQUFLLE1BQU07QUFDOUIsY0FBSSxXQUFXLFVBQVU7QUFDckIsNkJBQWlCO0FBQUEsVUFDckI7QUFDQSxjQUFJLENBQUMsZ0JBQWdCO0FBQ2pCLGtCQUFNLG9CQUFvQix3QkFBd0I7QUFDbEQsOEJBQWtCLE9BQU8sU0FBUztBQUNsQyw2QkFBaUIsV0FBVyxXQUFXLGlCQUFpQjtBQUFBLFVBQzVEO0FBQ0EsY0FBSSxnQkFBZ0I7QUFDaEIsdUJBQVcsUUFBUSxTQUFTLDBCQUEwQjtBQUN0RCw0QkFBZ0IsZ0JBQWdCLFFBQVEsYUFBYSxnQkFBZ0IsUUFBUTtBQUM3RSxvQkFBUSxhQUFhO0FBQUEsVUFDekIsT0FDSztBQUNELDRCQUFnQjtBQUFBLFVBQ3BCO0FBQUEsUUFDSjtBQUNBLFlBQUksa0JBQ0EsS0FBSyxnQkFBZ0IsUUFDckIsRUFBRSxrQkFBa0IsNkJBQTZCO0FBQ2pELGtCQUFRLGFBQWE7QUFBQSxRQUN6QjtBQUFBLE1BQ0o7QUFBQSxNQUNBLGFBQWE7QUFDVCxpQkFBUyxZQUFZLEdBQUcsWUFBWSxLQUFLLE1BQU0sUUFBUSxhQUFhO0FBQ2hFLGNBQUksS0FBSyxNQUFNLFdBQVcsU0FBUyxNQUFNO0FBQ3JDLGlCQUFLLGNBQWM7QUFDbkI7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLGFBQUssY0FBYztBQUFBLE1BQ3ZCO0FBQUEsTUFDQSxPQUFPLE1BQU0sU0FBUztBQUNsQixhQUFLLGFBQWEsT0FBTyxNQUFNLE9BQU87QUFDdEMsWUFBSSxLQUFLLE1BQU0sU0FBUyxHQUFHO0FBQ3ZCLDhCQUFvQixLQUFLLE9BQU8sTUFBTSxLQUFLLE1BQU0sR0FBRyxPQUFPLEtBQUssTUFBTSxHQUFHLE9BQU87QUFBQSxRQUNwRjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsSUFBTSwyQkFBTixjQUF1QyxTQUFTO0FBQUEsTUFDNUMsT0FBTztBQUNILGNBQU0sS0FBSztBQUNYLFlBQUksS0FBSyxJQUFJLFNBQVMsY0FBYztBQUNoQyxnQkFBTSxPQUFPLEtBQUssSUFBSTtBQUN0QixnQkFBTSxXQUFXLEtBQUssTUFBTSxhQUFhLElBQUk7QUFDN0MsY0FBSSxTQUFTLGFBQWE7QUFDdEIsaUJBQUssUUFBUSxLQUFLO0FBQUEsY0FDZCxNQUFNO0FBQUEsY0FDTixTQUFTLDZCQUE2QjtBQUFBLFlBQzFDLEdBQUcsS0FBSyxLQUFLO0FBQUEsVUFDakI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLGVBQVEsTUFBTSxXQUFXLE9BQU8sS0FDNUIsS0FBSyxJQUFJLDJCQUEyQixZQUFZLEtBQUssYUFBYSxPQUFPO0FBQUEsTUFDakY7QUFBQSxNQUNBLGFBQWE7QUFDVCxhQUFLLGNBQWM7QUFBQSxVQUNmLE1BQU07QUFBQSxVQUNOLFdBQVc7QUFBQSxVQUNYLFNBQVM7QUFBQSxRQUNiO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsYUFBSyxJQUFJLE9BQU8sTUFBTSxTQUFTLEVBQUUsMEJBQTBCLEtBQUssQ0FBQztBQUNqRSxhQUFLLE1BQU0sT0FBTyxNQUFNLE9BQU87QUFBQSxNQUNuQztBQUFBLElBQ0o7QUFFQSxJQUFNLGtCQUFOLGNBQThCLFNBQVM7QUFBQSxNQUVuQyxPQUFPO0FBQUEsTUFBRTtBQUFBLE1BQ1QsYUFBYTtBQUNULGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxVQUFVO0FBQ04sYUFBSyxXQUFXO0FBQUEsTUFDcEI7QUFBQSxNQUNBLFVBQVUsWUFBWTtBQUNsQixhQUFLLFFBQVEsV0FBVztBQUN4QixjQUFNLFVBQVUsVUFBVTtBQUFBLE1BQzlCO0FBQUEsTUFDQSxTQUFTO0FBQUEsTUFBRTtBQUFBLElBQ2Y7QUFFQSxJQUFNLGtCQUFOLGNBQThCLFNBQVM7QUFBQSxNQUNuQyxzQkFBc0JBLE9BQU07QUFDeEIsWUFBSUEsTUFBSyxTQUFTLEtBQUssS0FBSyxPQUFPLFdBQVcsR0FBRztBQUM3QyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxlQUFPLEtBQUssT0FBTyxHQUFHLE1BQU07QUFBQSxNQUNoQztBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsYUFBSyxzQkFBc0IsS0FBSyxDQUFDLEtBQUssT0FBTyxLQUFLLEdBQUcsQ0FBQztBQUN0RCxjQUFNLE9BQU8sTUFBTSxPQUFPO0FBQUEsTUFDOUI7QUFBQSxJQUNKO0FBRUEsSUFBTSxvQkFBTixjQUFnQyxTQUFTO0FBQUEsTUFDckMsY0FBYztBQUNWLGNBQU0sV0FBVztBQUFBLE1BQ3JCO0FBQUEsTUFDQSx3QkFBd0I7QUFDcEIsZUFBTztBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBRUEsSUFBTSx3QkFBTixjQUFvQyxjQUFjO0FBQUEsTUFDOUMsWUFBWSxNQUFNLDBCQUEwQixTQUFTO0FBQ2pELGNBQU0sTUFBTSwwQkFBMEIseUJBQXlCLGFBQWEsT0FBTztBQUNuRixhQUFLLFFBQVE7QUFDYixhQUFLLGFBQWE7QUFDbEIsYUFBSyxtQkFBbUI7QUFDeEIsY0FBTSxjQUFjLHlCQUF5QjtBQUM3QyxhQUFLLHVCQUF1Qix1QkFBdUIsdUJBQXVCLHFCQUN0RSxZQUFZLElBQUk7QUFDaEIsZUFBSyxRQUFRO0FBQ2IsZUFBSyxhQUFhLFlBQVk7QUFBQSxRQUNsQyxXQUNTLHVCQUF1QixZQUFZO0FBQ3hDLGVBQUssYUFBYTtBQUFBLFFBQ3RCO0FBQUEsTUFDSjtBQUFBLE1BQ0EsYUFBYSxZQUFZO0FBQ3JCLFlBQUksQ0FBQyxLQUFLLE9BQU87QUFDYixlQUFLLE9BQU8sV0FBVztBQUFBLFFBQzNCO0FBQUEsTUFDSjtBQUFBLE1BQ0EsMEJBQTBCO0FBQ3RCLGVBQVEsS0FBSyxjQUFjLEtBQUssV0FBVyxRQUFTO0FBQUEsTUFDeEQ7QUFBQSxNQUNBLHNCQUFzQjtBQUNsQixjQUFNLFdBQVcsS0FBSyxvQkFBb0I7QUFDMUMsWUFBSSxhQUFhLE1BQU07QUFDbkIsaUJBQU8sTUFBTSxvQkFBb0I7QUFBQSxRQUNyQyxPQUNLO0FBQ0QsaUJBQU8sU0FBUyxvQkFBb0I7QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFBQSxNQUNBLDRCQUE0QjtBQUN4QixlQUFPLEtBQUssZUFDUCxLQUFLLFNBQ0YsRUFBRSxLQUFLLFdBQVcsY0FBYyxLQUM1QixLQUFLLFdBQVcsU0FBUyxnQkFDekIsS0FBSyxXQUFXLG9CQUFvQixxQkFFcEMsd0JBQXdCLEtBQUssV0FBVyxhQUM5QyxLQUFLLFdBQVcsV0FDaEI7QUFBQSxNQUNWO0FBQUEsTUFDQSxRQUFRLG1CQUFtQjtBQUN2QixjQUFNLFdBQVcsS0FBSyxvQkFBb0I7QUFDMUMsWUFBSSxhQUFhLE1BQU07QUFDbkIsaUJBQU8sTUFBTSxRQUFRLGlCQUFpQjtBQUFBLFFBQzFDLE9BQ0s7QUFDRCxpQkFBTyxTQUFTLFFBQVEsaUJBQWlCO0FBQUEsUUFDN0M7QUFBQSxNQUNKO0FBQUEsTUFDQSxzQkFBc0I7QUFDbEIsWUFBSSxLQUFLO0FBQ0wsaUJBQU8sS0FBSztBQUVoQixZQUFJLFdBQVc7QUFDZixZQUFJO0FBQ0osY0FBTSxtQkFBbUIsb0JBQUksSUFBSTtBQUNqQyxXQUFHO0FBQ0MsMkJBQWlCLElBQUksUUFBUTtBQUM3Qiw0QkFBa0I7QUFDbEIscUJBQVcsZ0JBQWdCLDBCQUEwQjtBQUFBLFFBQ3pELFNBQVMsb0JBQW9CLHlCQUF5QixDQUFDLGlCQUFpQixJQUFJLFFBQVE7QUFDcEYsZUFBUSxLQUFLLG1CQUFtQixZQUFZO0FBQUEsTUFDaEQ7QUFBQSxJQUNKO0FBRUEsSUFBTSxjQUFOLGNBQTBCLFdBQVc7QUFBQSxNQUNqQyxZQUFZLFFBQVEsU0FBUztBQUN6QixjQUFNLE1BQU07QUFDWixhQUFLLFVBQVU7QUFDZixhQUFLLFVBQVUsSUFBSSxRQUFRLElBQUksY0FBYyxRQUFRLE1BQU0sc0JBQXNCLE9BQU8sQ0FBQztBQUFBLE1BQzdGO0FBQUEsTUFDQSw0QkFBNEIsTUFBTSwwQkFBMEIsU0FBUztBQUNqRSxjQUFNLFdBQVcsSUFBSSxzQkFBc0IsTUFBTSwwQkFBMEIsT0FBTztBQUNsRixhQUFLLFVBQVUsSUFBSSxXQUFXLFFBQVE7QUFDdEMsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDJCQUEyQjtBQUFBLE1BQUU7QUFBQSxNQUM3QixXQUFXLFFBQVEsdUJBQXVCLHdCQUF3QjtBQUU5RCxtQkFBVyxTQUFTLEtBQUs7QUFDckIsZ0JBQU0sV0FBVyxRQUFRLHVCQUF1QixzQkFBc0I7QUFBQSxNQUM5RTtBQUFBLE1BQ0Esc0JBQXNCO0FBQ2xCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxhQUFhLE1BQU07QUFDZixjQUFNLGdCQUFnQixLQUFLLFVBQVUsSUFBSSxJQUFJLEtBQUssS0FBSyx5QkFBeUIsSUFBSSxJQUFJO0FBQ3hGLFlBQUksZUFBZTtBQUNmLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGNBQU0sV0FBVyxLQUFLLFFBQVEsY0FBYyxJQUFJLEtBQUssS0FBSyxPQUFPLGFBQWEsSUFBSTtBQUNsRixZQUFJLG9CQUFvQixnQkFBZ0I7QUFDcEMsZUFBSyx5QkFBeUIsSUFBSSxNQUFNLFFBQVE7QUFBQSxRQUNwRDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsSUFDSjtBQUVBLElBQU0saUJBQU4sY0FBNkIsU0FBUztBQUFBLE1BQ2xDLE9BQU87QUFDSCxhQUFLLFdBQVcsS0FBSyxNQUFNLGFBQWEsTUFBTTtBQUFBLE1BQ2xEO0FBQUEsTUFDQSxlQUFlQSxPQUFNO0FBQ2pCLGFBQUssU0FBUyxlQUFlQSxLQUFJO0FBQUEsTUFDckM7QUFBQSxNQUNBLDRCQUE0QixPQUFPQSxPQUFNLGVBQWUsa0JBQWtCO0FBQ3RFLGFBQUssU0FBUztBQUFBLFVBQTRCO0FBQUEsVUFBT0E7QUFBQSxVQUVqRCxrQkFBa0IsT0FBTyxLQUFLLFdBQVc7QUFBQSxVQUFlO0FBQUEsUUFBZ0I7QUFBQSxNQUM1RTtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNLFNBQVM7QUFDeEMsZUFBT0EsTUFBSyxTQUFTLEtBQUssS0FBSyxTQUFTLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDdEY7QUFBQSxNQUNBLDZCQUE2QkEsT0FBTSxTQUFTO0FBQ3hDLGVBQU8sS0FBSyxTQUFTLDZCQUE2QkEsT0FBTSxPQUFPO0FBQUEsTUFDbkU7QUFBQSxNQUNBLFVBQVU7QUFDTixZQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGVBQUssV0FBVztBQUNoQixlQUFLLFFBQVEsd0JBQXdCLEtBQUssUUFBUTtBQUFBLFFBQ3REO0FBQUEsTUFDSjtBQUFBLE1BQ0EsYUFBYTtBQUNULGFBQUssUUFDRCxLQUFLLE1BQU0sb0JBQW9CLGFBQWEsY0FBYyxLQUFLLFFBQVEsZ0JBQWdCO0FBQzNGLFlBQUksS0FBSyxVQUFVLGFBQWE7QUFDNUIsZUFBSyxRQUFRLEtBQUs7QUFBQSxZQUNkLE1BQU07QUFBQSxZQUNOLFNBQVM7QUFBQSxZQUNULEtBQUs7QUFBQSxVQUNULEdBQUcsS0FBSyxLQUFLO0FBQUEsUUFDakI7QUFBQSxNQUNKO0FBQUEsTUFDQSxPQUFPLE1BQU07QUFDVCxZQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3JCLGVBQUssVUFBVSxLQUFLLE9BQU8sS0FBSyxLQUFLLEtBQUssT0FBTztBQUFBLFlBQzdDLGFBQWE7QUFBQSxZQUNiLFdBQVc7QUFBQSxVQUNmLENBQUM7QUFBQSxRQUNMO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFNLGlCQUFOLGNBQTZCLFNBQVM7QUFBQSxNQUNsQyxhQUFhO0FBQ1QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLGFBQUssU0FBUyxRQUFRLFNBQVMsMEJBQTBCO0FBQ3pELGdCQUFRLGFBQWE7QUFBQSxNQUN6QjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsYUFBSyxTQUFTLE9BQU8sTUFBTSxTQUFTLEVBQUUsWUFBWSxLQUFLLENBQUM7QUFDeEQsWUFBSSxLQUFLLFNBQVMsVUFBVSxLQUFLLFFBQVEsR0FBd0I7QUFDN0QsZUFBSyxZQUFZLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsSUFBTSxlQUFOLGNBQTJCLFNBQVM7QUFBQSxNQUNoQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxtQkFBbUI7QUFDeEIsYUFBSywyQkFBMkI7QUFBQSxNQUNwQztBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLGdCQUFTLEtBQUssUUFBUSxRQUFRLFVBQVUseUJBQ2xDLEtBQUssTUFBTSxLQUFLLFNBQVMsSUFDekIsS0FBSyxNQUFNLFdBQVcsT0FBTyxNQUM5QixLQUFLLGNBQWMsUUFBUSxLQUFLLFVBQVUsV0FBVyxPQUFPO0FBQUEsTUFDckU7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsWUFBSTtBQUNKLGNBQU0sMEJBQTBCLEtBQUssS0FBSyxRQUFRLFFBQVEsZUFBZSxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUc7QUFDN0csY0FBTSxFQUFFLFdBQVcsSUFBSTtBQUN2QixZQUFJLENBQUMsS0FBSyxvQkFBb0IsQ0FBQyx3QkFBd0I7QUFDbkQsZUFBSyxXQUFXO0FBQ2hCLGVBQUssbUJBQW1CO0FBQ3hCLGVBQUssTUFBTSxRQUFRLFNBQVMseUJBQXlCLHFCQUFxQiwwQkFBMEI7QUFDcEcsY0FBSSxRQUFRLGVBQWUsT0FBTyxHQUFHO0FBQ2pDLGlCQUFLLDJCQUEyQixDQUFDLEdBQUcsUUFBUSxjQUFjO0FBQUEsVUFDOUQ7QUFDQSxrQkFBUSxhQUFhO0FBQUEsUUFDekIsV0FDUyxLQUFLLDBCQUEwQjtBQUNwQyxxQkFBVyxTQUFTLEtBQUssMEJBQTBCO0FBQy9DLG9CQUFRLGVBQWUsSUFBSSxLQUFLO0FBQUEsVUFDcEM7QUFBQSxRQUNKO0FBQ0EsWUFBSSxLQUFLLFlBQVksTUFBTTtBQUN2QixlQUFLLFFBQVEsUUFBUSxTQUFTLDBCQUEwQjtBQUN4RCxrQkFBUSxhQUFhO0FBQUEsUUFDekI7QUFDQSxZQUFJLEtBQUssY0FBYyxNQUFNO0FBQ3pCLGVBQUssVUFBVSxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsUUFDOUQ7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUVBLElBQU0saUJBQWlCO0FBQUEsTUFDbkIsS0FBSyxXQUFTLENBQUM7QUFBQSxNQUNmLEtBQUssV0FBUyxDQUFDO0FBQUEsTUFDZixLQUFLLFdBQVMsQ0FBQztBQUFBLE1BQ2YsUUFBUSxNQUFNO0FBQUEsTUFDZCxRQUFRLFdBQVMsT0FBTztBQUFBLE1BQ3hCLE1BQU0sTUFBTTtBQUFBLE1BQ1osS0FBSyxXQUFTLENBQUM7QUFBQSxJQUNuQjtBQUNBLElBQU0sa0JBQU4sY0FBOEIsU0FBUztBQUFBLE1BQ25DLGNBQWM7QUFDVixjQUFNLEdBQUcsU0FBUztBQUNsQixhQUFLLGNBQWM7QUFBQSxNQUN2QjtBQUFBLE1BQ0Esc0JBQXNCQSxPQUFNLGtCQUFrQixRQUFRO0FBQ2xELFlBQUlBLE1BQUssU0FBUztBQUNkLGlCQUFPO0FBQ1gsY0FBTSxnQkFBZ0IsS0FBSyxTQUFTLHNCQUFzQixZQUFZLGtCQUFrQixNQUFNO0FBQzlGLFlBQUksa0JBQWtCO0FBQ2xCLGlCQUFPO0FBQ1gsZUFBTyxlQUFlLEtBQUssVUFBVSxhQUFhO0FBQUEsTUFDdEQ7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLFlBQUksS0FBSyxhQUFhLFlBQVksS0FBSyxvQkFBb0I7QUFDdkQsaUJBQU87QUFDWCxlQUFRLEtBQUssU0FBUyxXQUFXLE9BQU8sS0FDbkMsS0FBSyxhQUFhLFlBQ2YsS0FBSyxTQUFTLDZCQUE2QixZQUFZLE9BQU87QUFBQSxNQUMxRTtBQUFBLE1BQ0EsNkJBQTZCQSxPQUFNO0FBQy9CLFlBQUksS0FBSyxhQUFhLFFBQVE7QUFDMUIsaUJBQU9BLE1BQUssU0FBUztBQUFBLFFBQ3pCO0FBQ0EsZUFBT0EsTUFBSyxTQUFTO0FBQUEsTUFDekI7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsWUFBSSxLQUFLLGFBQWEsVUFBVTtBQUM1QixlQUFLLFNBQVMsZUFBZSxVQUFVO0FBQ3ZDLGVBQUssUUFBUSx1QkFBdUI7QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsSUFBTSxjQUFOLGNBQTBCLFNBQVM7QUFBQSxNQUMvQixhQUFhO0FBQ1QsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUztBQUNiLGNBQU0sUUFBUSxTQUFTLElBQUk7QUFBQSxNQUMvQjtBQUFBLElBQ0o7QUFFQSxJQUFNLG1CQUFOLGNBQStCLFNBQVM7QUFBQSxNQUNwQyxjQUFjO0FBQ1YsY0FBTSxHQUFHLFNBQVM7QUFDbEIsYUFBSyxjQUFjO0FBQUEsTUFDdkI7QUFBQSxNQUNBLFdBQVcsU0FBUztBQUNoQixZQUFJLENBQUMsS0FBSztBQUNOLGVBQUsscUJBQXFCO0FBQzlCLGVBQVEsS0FBSyxTQUFTLFdBQVcsT0FBTyxLQUNwQyxLQUFLLFNBQVMsNkJBQTZCLFlBQVksT0FBTztBQUFBLE1BQ3RFO0FBQUEsTUFDQSw2QkFBNkJBLE9BQU07QUFDL0IsZUFBT0EsTUFBSyxTQUFTO0FBQUEsTUFDekI7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTO0FBQ2xCLGNBQU0sRUFBRSx1QkFBdUIsUUFBUSxVQUFVLEVBQUUsRUFBRSxFQUFFLElBQUk7QUFDM0QsYUFBSyxTQUFTLE9BQU8sTUFBTSxPQUFPO0FBQ2xDLFlBQUksV0FBVyxVQUFVO0FBQ3JCLGdCQUFNLFdBQVcsS0FBSyxTQUFTO0FBQy9CLGdCQUFNLGNBQWMsc0JBQXNCLElBQUksUUFBUTtBQUN0RCxjQUFJLGFBQWE7QUFDYixnQkFBSSxLQUFLLFFBQVE7QUFDYixrQkFBSSxZQUFZLFdBQVcsR0FBRztBQUMxQiw2Q0FBNkIsVUFBVSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTztBQUFBLGNBQzlFLE9BQ0s7QUFDRCwwREFBMEMsVUFBVSxLQUFLLE9BQU8sS0FBSyxLQUFLLEtBQUssT0FBTyxTQUFTLHVCQUF1QixNQUFNLE9BQU87QUFBQSxjQUN2STtBQUFBLFlBQ0osT0FDSztBQUNELG9CQUFNLFdBQVcsS0FBSyxTQUFTO0FBQy9CLHlEQUEyQyxVQUFVLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSyxPQUFPLFNBQVMsdUJBQXVCLE1BQU0sU0FBUyxHQUFHLElBQUksV0FBVyxJQUFJO0FBQUEsWUFDaEs7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxTQUFTLGVBQWUsVUFBVTtBQUN2QyxZQUFJLEtBQUssb0JBQW9CLFlBQVk7QUFDckMsZ0JBQU0sV0FBVyxLQUFLLE1BQU0sYUFBYSxLQUFLLFNBQVMsSUFBSTtBQUMzRCxtQkFBUyxlQUFlO0FBQUEsUUFDNUI7QUFDQSxhQUFLLFFBQVEsdUJBQXVCO0FBQUEsTUFDeEM7QUFBQSxJQUNKO0FBdUJBLElBQU0sc0JBQU4sY0FBa0MsU0FBUztBQUFBLE1BQ3ZDLGlCQUFpQjtBQUNiLG1CQUFXLGNBQWMsS0FBSyxjQUFjO0FBQ3hDLHFCQUFXLGVBQWUsVUFBVTtBQUFBLFFBQ3hDO0FBQUEsTUFDSjtBQUFBLE1BQ0EsK0JBQStCO0FBQzNCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxRQUFRLFNBQVMsNEJBQTRCO0FBQ3pDLGFBQUssV0FBVztBQUNoQixtQkFBVyxjQUFjLEtBQUssY0FBYztBQUN4QyxjQUFJLDhCQUE4QixXQUFXLGlCQUFpQixPQUFPO0FBQ2pFLHVCQUFXLFFBQVEsU0FBUywwQkFBMEI7QUFBQSxRQUM5RDtBQUFBLE1BQ0o7QUFBQSxNQUNBLHlCQUF5QixTQUFTLDRCQUE0QjtBQUMxRCxhQUFLLFdBQVc7QUFDaEIsbUJBQVcsY0FBYyxLQUFLLGNBQWM7QUFDeEMsY0FBSSw4QkFBOEIsV0FBVyxpQkFBaUIsT0FBTyxHQUFHO0FBQ3BFLHVCQUFXLFFBQVEsU0FBUywwQkFBMEI7QUFDdEQsdUJBQVcsR0FBRyxRQUFRLFNBQVMsMEJBQTBCO0FBQUEsVUFDN0Q7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsYUFBYTtBQUNULG1CQUFXLGNBQWMsS0FBSyxjQUFjO0FBQ3hDLHFCQUFXLGtCQUFrQixLQUFLLElBQUk7QUFBQSxRQUMxQztBQUFBLE1BQ0o7QUFBQSxNQUNBLE9BQU8sTUFBTSxTQUFTLG9CQUFvQixPQUFPO0FBQzdDLFlBQUkseUNBQXlDLEtBQUssY0FBYyxRQUFRLHFCQUFxQixHQUFHO0FBQzVGLHFCQUFXLGNBQWMsS0FBSyxjQUFjO0FBQ3hDLHVCQUFXLE9BQU8sTUFBTSxPQUFPO0FBQUEsVUFDbkM7QUFDQSxjQUFJLENBQUMsa0JBQWtCLGlCQUNuQixLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQU0sQ0FBQyxNQUFNLElBQVk7QUFDdkQsaUJBQUssV0FBVyxLQUFLLEtBQUssR0FBRztBQUFBLFVBQ2pDO0FBQUEsUUFDSixPQUNLO0FBQ0QsZUFBSywyQkFBMkIsTUFBTSxTQUFTLGlCQUFpQjtBQUFBLFFBQ3BFO0FBQUEsTUFDSjtBQUFBLE1BQ0EscUJBQXFCLE1BQU0saUJBQWlCLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQixTQUFTLGVBQWU7QUFDOUksWUFBSSxLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQU0sQ0FBQyxNQUFNLElBQVk7QUFDdkQsZUFBSyxPQUFPLEtBQUssTUFBTSxHQUFHLEtBQUssR0FBRztBQUFBLFFBQ3RDO0FBQ0EsWUFBSSxDQUFDLGVBQWU7QUFDaEIsNkJBQW1CO0FBQUEsUUFDdkI7QUFDQSxZQUFJLHFCQUFxQixNQUFNO0FBQzNCLGNBQUksS0FBSyxTQUFTLFdBQVcsbUJBQW1CLENBQUMsTUFBTSxPQUNsRCxLQUFLLFNBQVMsV0FBVyxLQUFLLEdBQUcsTUFBTSxNQUNwQyxLQUFLLFNBQVMsV0FBVyxLQUFLLEdBQUcsTUFBTSxLQUFjO0FBQ3pEO0FBQ0EsZ0JBQUksS0FBSyxTQUFTLFdBQVcsZ0JBQWdCLE1BQU0sSUFBYTtBQUM1RDtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQ0EsY0FBSSxxQkFBcUIsbUJBQW1CLEdBQUc7QUFDM0MsaUJBQUssVUFBVSxrQkFBa0Isb0JBQW9CLGVBQWU7QUFBQSxVQUN4RSxPQUNLO0FBQ0QsaUJBQUssVUFBVSxrQkFBa0IsbUJBQW1CLEdBQUcsZUFBZTtBQUN0RSxpQkFBSyxPQUFPLGtCQUFrQixrQkFBa0I7QUFBQSxVQUNwRDtBQUFBLFFBQ0osT0FDSztBQUNELGVBQUssV0FBVyxvQkFBb0IsZUFBZTtBQUFBLFFBQ3ZEO0FBQ0EsWUFBSSxxQkFBcUIsU0FBUyxHQUFHO0FBQ2pDLGVBQUssV0FBVyxvQkFBb0IsSUFBSSx5QkFBeUIsc0JBQXNCLE9BQU8sSUFBSTtBQUFBLFFBQ3RHO0FBQUEsTUFDSjtBQUFBLE1BQ0EsMkJBQTJCLE1BQU0sU0FBUyxFQUFFLGNBQWMsR0FBRztBQUN6RCxjQUFNLGlCQUFpQixxQ0FBcUMsS0FBSyxjQUFjLE1BQU0sS0FBSyxRQUFRLEtBQUssS0FBSyxRQUFRLEtBQUssT0FBTyxLQUFLLFNBQVMsV0FBVyxLQUFLLE1BQU0sQ0FBQyxNQUFNLEtBQWEsSUFBSSxFQUFFO0FBQzlMLFlBQUksa0JBQWtCO0FBQ3RCLDZCQUFxQixrQkFBa0IsS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLEtBQUssTUFBTTtBQUNuRixZQUFJLG1CQUFtQixxQkFBcUI7QUFDNUMsYUFBSyxPQUFPLEtBQUssT0FBTyxnQkFBZ0I7QUFDeEMsWUFBSSxrQkFBa0I7QUFDdEIsWUFBSSxxQkFBcUI7QUFDekIsWUFBSSxrQkFBa0IsSUFBSSxlQUFlO0FBQ3pDLGNBQU0sMEJBQTBCLENBQUM7QUFDakMsY0FBTSxxQkFBcUIsc0NBQXNDLGdCQUFnQixTQUFTLHVCQUF1QjtBQUNqSCxtQkFBVyxFQUFFLE1BQU0sT0FBTyxXQUFXLFlBQVksSUFBSSxLQUFLLGdCQUFnQjtBQUN0RSxjQUFJLENBQUMsS0FBSyxVQUFVO0FBQ2hCLGlCQUFLLE9BQU8sT0FBTyxHQUFHO0FBQ3RCO0FBQUEsVUFDSjtBQUNBLGVBQUssT0FBTyxNQUFNLE9BQU87QUFDekIsMEJBQWdCO0FBQ2hCLGdDQUFzQjtBQUN0QixjQUFJLENBQUMsS0FBSyxHQUFHLFlBQ1IsS0FBSyxjQUFjLGNBQ2hCLDBCQUEwQixLQUFLLEdBQUcsVUFBVSxRQUFRLHFCQUFxQixHQUFJO0FBQ2pGLGdCQUFJLG9CQUFvQjtBQUNwQixpQ0FBbUI7QUFBQSxZQUN2QjtBQUNBLDhCQUFrQjtBQUFBLFVBQ3RCLE9BQ0s7QUFDRCxnQkFBSSxzQkFBc0IsdUJBQXVCLEtBQUssR0FBRyxVQUFVO0FBQy9ELG9CQUFNLGNBQWMsa0NBQWtDLEtBQUssVUFBVSxLQUFLLEtBQUssR0FBRyxHQUFHO0FBQ3JGLDJDQUE2QixvQkFBb0Isa0JBQWtCLEtBQUssVUFBVSxjQUFjLENBQUMsR0FBRyxjQUFjLE9BQU8sYUFBYSxXQUFXLE1BQU0sT0FBTztBQUFBLFlBQ2xLO0FBQ0EsZ0JBQUksaUJBQWlCO0FBQ2pCLGlDQUFtQjtBQUFBLFlBQ3ZCLE9BQ0s7QUFDRCxrQkFBSSxvQkFBb0I7QUFDcEIsbUNBQW1CO0FBQUEsY0FDdkI7QUFDQSwrQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLGdDQUFrQjtBQUFBLFlBQ3RCO0FBQUEsVUFDSjtBQUNBLGNBQUksdUJBQXVCLG1CQUFtQixHQUFHO0FBQzdDLGlCQUFLLFVBQVUsa0JBQWtCLG9CQUFvQixrQkFBa0IsYUFBYTtBQUFBLFVBQ3hGLE9BQ0s7QUFDRCxpQkFBSyxVQUFVLGtCQUFrQixtQkFBbUIsR0FBRyxlQUFlO0FBQ3RFLGlCQUFLLFdBQVcsb0JBQW9CLGFBQWE7QUFBQSxVQUNyRDtBQUNBLDZCQUFtQjtBQUNuQiwrQkFBcUI7QUFDckIsK0JBQXFCO0FBQ3JCLDZCQUFtQjtBQUNuQiw0QkFBa0I7QUFBQSxRQUN0QjtBQUNBLGFBQUsscUJBQXFCLE1BQU0saUJBQWlCLGtCQUFrQixrQkFBa0Isb0JBQW9CLHlCQUF5QixTQUFTLGFBQWE7QUFBQSxNQUM1SjtBQUFBLElBQ0o7QUEyQkEsSUFBTSxxQkFBTixjQUFpQyxTQUFTO0FBQUEsTUFDdEMsa0JBQWtCLE1BQU07QUFDcEIsYUFBSyxHQUFHLFFBQVEsTUFBTSxLQUFLLFFBQVEsb0JBQW9CO0FBQUEsTUFDM0Q7QUFBQSxNQUNBLGVBQWVBLE9BQU07QUFDakIsYUFBSyxHQUFHLGVBQWVBLEtBQUk7QUFBQSxNQUMvQjtBQUFBLE1BQ0EsV0FBVyxTQUFTO0FBQ2hCLGNBQU0sYUFBYSxLQUFLLFNBQVMsUUFBUSxLQUFLLEtBQUssV0FBVyxPQUFPO0FBQ3JFLGFBQUssR0FBRyx1QkFBdUI7QUFDL0IsZUFBTyxjQUFjLEtBQUssR0FBRyxXQUFXLE9BQU87QUFBQSxNQUNuRDtBQUFBLE1BQ0EsUUFBUSxTQUFTLDRCQUE0QjtBQUN6QyxhQUFLLFdBQVc7QUFDaEIsWUFBSSxLQUFLLE1BQU07QUFDWCxlQUFLLEtBQUssUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQ3pEO0FBQ0EsYUFBSyxHQUFHLHVCQUF1QjtBQUMvQixZQUFJLDhCQUE4QixLQUFLLEdBQUcsaUJBQWlCLE9BQU8sR0FBRztBQUNqRSxlQUFLLEdBQUcsUUFBUSxTQUFTLDBCQUEwQjtBQUFBLFFBQ3ZEO0FBQUEsTUFDSjtBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsY0FBTSxFQUFFLHVCQUF1QixVQUFVLEVBQUUsRUFBRSxFQUFFLElBQUk7QUFDbkQsY0FBTSxXQUFXLEtBQUssR0FBRztBQUN6QixZQUFJLFVBQVU7QUFDVixlQUFLLEdBQUcsT0FBTyxNQUFNLE9BQU87QUFBQSxRQUNoQyxPQUNLO0FBQ0QsZ0JBQU0sY0FBYyxrQ0FBa0MsS0FBSyxVQUFVLEtBQUssS0FBSyxHQUFHLEdBQUc7QUFDckYsZUFBSyxPQUFPLEtBQUssT0FBTyxrQkFBa0IsS0FBSyxVQUFVLGNBQWMsQ0FBQyxDQUFDO0FBQUEsUUFDN0U7QUFDQSxZQUFJLEtBQUssTUFBTTtBQUNYLGVBQUssS0FBSyxPQUFPLE1BQU0sU0FBUyxXQUFXLFFBQVEsRUFBRSw0QkFBNEIsc0JBQXNCLENBQUM7QUFBQSxRQUM1RyxXQUNTLEtBQUssY0FBYyxjQUN4QiwwQkFBMEIsS0FBSyxHQUFHLFVBQVUscUJBQXFCLEdBQUc7QUFDcEUsZUFBSyxXQUFXLEtBQUssS0FBSyxHQUFHLEtBQUssU0FBUztBQUFBLFFBQy9DO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFFQSxJQUFNLGlCQUFOLGNBQTZCLFNBQVM7QUFBQSxNQUNsQyxXQUFXLFNBQVM7QUFDaEIsWUFBSSxLQUFLLEtBQUssV0FBVyxPQUFPO0FBQzVCLGlCQUFPO0FBQ1gsY0FBTSxFQUFFLFlBQVksUUFBUSxFQUFFLFFBQVEsVUFBVSxFQUFFLElBQUk7QUFDdEQsZ0JBQVEsT0FBTyxTQUFTO0FBQ3hCLGdCQUFRLE9BQU8sWUFBWTtBQUMzQixZQUFJLEtBQUssS0FBSyxXQUFXLE9BQU87QUFDNUIsaUJBQU87QUFDWCxnQkFBUSxPQUFPLFNBQVM7QUFDeEIsZ0JBQVEsT0FBTyxZQUFZO0FBQzNCLGdCQUFRLGFBQWE7QUFDckIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFFBQVEsU0FBUyw0QkFBNEI7QUFDekMsYUFBSyxXQUFXO0FBQ2hCLGFBQUssS0FBSyxRQUFRLFNBQVMsMEJBQTBCO0FBQ3JELGNBQU0sRUFBRSxXQUFXLElBQUk7QUFDdkIsYUFBSyxLQUFLLHlCQUF5QixTQUFTLDBCQUEwQjtBQUN0RSxnQkFBUSxhQUFhO0FBQUEsTUFDekI7QUFBQSxJQUNKO0FBRUEsSUFBTSxrQkFBTixjQUE4QixTQUFTO0FBQUEsTUFDbkMsY0FBYztBQUNWLGNBQU0sR0FBRyxTQUFTO0FBQ2xCLGFBQUssY0FBYztBQUFBLE1BQ3ZCO0FBQUEsTUFDQSxXQUFXLFNBQVM7QUFDaEIsWUFBSSxDQUFDLEtBQUs7QUFDTixlQUFLLHFCQUFxQjtBQUM5QixlQUFRLENBQUMsUUFBUSxPQUFPLGVBQWdCLEtBQUssYUFBYSxRQUFRLEtBQUssU0FBUyxXQUFXLE9BQU87QUFBQSxNQUN0RztBQUFBLE1BQ0EsT0FBTyxNQUFNLFNBQVM7QUFDbEIsWUFBSSxLQUFLLFVBQVU7QUFDZixlQUFLLFNBQVMsT0FBTyxNQUFNLFNBQVMsRUFBRSxZQUFZLEtBQUssQ0FBQztBQUN4RCxjQUFJLEtBQUssU0FBUyxVQUFVLEtBQUssUUFBUSxHQUF3QjtBQUM3RCxpQkFBSyxZQUFZLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFBQSxVQUN4QztBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSx1QkFBdUI7QUFDbkIsYUFBSyxjQUFjO0FBQ25CLGNBQU0sRUFBRSxTQUFTLElBQUk7QUFDckIsWUFBSSxVQUFVO0FBQ1YsbUJBQVMsZUFBZSxZQUFZO0FBQ3BDLGVBQUssUUFBUSx1QkFBdUI7QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsSUFBTSxtQkFBbUI7QUFBQSxNQUNyQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFFQSxJQUFNLCtCQUErQjtBQUVyQyxJQUFNLHFCQUFOLGNBQWlDLFNBQVM7QUFBQSxNQUN0QyxZQUFZRyxTQUFRO0FBQ2hCLGNBQU0sNEJBQTRCO0FBQ2xDLGFBQUssU0FBU0E7QUFBQSxNQUNsQjtBQUFBLE1BQ0EsVUFBVTtBQUNOLGNBQU0sUUFBUTtBQUNkLGFBQUssT0FBTyxrQkFBa0I7QUFBQSxNQUNsQztBQUFBLElBQ0o7QUFFQSxJQUFNLG9CQUFOLGNBQWdDLFNBQVM7QUFBQSxNQUNyQyxZQUFZLFNBQVM7QUFDakIsY0FBTSxRQUFRLGNBQWMsQ0FBQztBQUM3QixhQUFLLGtCQUFrQjtBQUN2QixhQUFLLG1CQUFtQixDQUFDO0FBQ3pCLGFBQUssa0JBQWtCO0FBQ3ZCLGFBQUssYUFBYSxDQUFDO0FBQ25CLGFBQUssVUFBVTtBQUNmLGFBQUssU0FBUyxRQUFRO0FBQUEsTUFDMUI7QUFBQSxNQUNBLGFBQWEsWUFBWTtBQUNyQixhQUFLLFdBQVcsS0FBSyxVQUFVO0FBQy9CLGFBQUssT0FBTyxXQUFXO0FBQUEsTUFDM0I7QUFBQSxNQUNBLHFCQUFxQjtBQUNqQixZQUFJLEtBQUssaUJBQWlCO0FBQ3RCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLGNBQU0sa0JBQWtCLHVCQUFPLE9BQU8sSUFBSTtBQUMxQyxtQkFBVyxRQUFRLEtBQUssUUFBUSxXQUFXLEVBQUUsT0FBTyxLQUFLLFFBQVEsYUFBYSxDQUFDLEdBQUc7QUFDOUUsY0FBSSxLQUFLLE9BQU8sT0FBTyxTQUFTLEtBQUssT0FBTyxLQUFLLHVCQUF1QjtBQUNwRSxrQkFBTSxtQkFBbUIsS0FBSyxRQUFRLFlBQVksSUFBSTtBQUN0RCxnQkFBSSxrQkFBa0I7QUFDbEIsOEJBQWdCLFFBQVE7QUFBQSxZQUM1QjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsZUFBUSxLQUFLLGtCQUFrQjtBQUFBLE1BQ25DO0FBQUEsTUFDQSxVQUFVO0FBQ04sYUFBSyxXQUFXO0FBQ2hCLGFBQUssUUFBUSxrQkFBa0I7QUFBQSxNQUNuQztBQUFBLE1BQ0EsUUFBUSx3QkFBd0I7QUFDNUIsWUFBSSxLQUFLLGlCQUFpQixTQUFTLEdBQUc7QUFDbEMsZUFBSyxPQUFPLE1BQU0sbUJBQW1CLENBQUMseUJBQXlCLEdBQUcsc0JBQXNCO0FBQUEsUUFDNUY7QUFBQSxNQUNKO0FBQUEsTUFDQSxZQUFZLFNBQVM7QUFDakIsY0FBTSxFQUFFLHVCQUF1QixRQUFRLFFBQVEsUUFBUSxHQUFHLHNCQUFzQixVQUFVLEVBQUUsR0FBRyxNQUFNLFdBQVcsbUJBQW1CLEdBQUFJLElBQUcsRUFBRSxFQUFFLElBQUk7QUFDOUksY0FBTSxrQkFBa0IsS0FBSyxtQkFBbUI7QUFDaEQsY0FBTSxVQUFVLE9BQU8sUUFBUSxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUNvRSxPQUFNLFFBQVEsTUFBTTtBQUN0RSxjQUFJLEtBQUssbUJBQW1CLFNBQVMsY0FBYztBQUMvQyxtQkFBTztBQUFBLGNBQ0g7QUFBQSxjQUNBLE9BQU9BLFFBQU8sTUFBTSxLQUFLLFdBQVcsU0FBUyxRQUFRLGlCQUFpQixJQUFJLElBQUk7QUFBQSxZQUNsRjtBQUFBLFVBQ0o7QUFDQSxpQkFBTyxDQUFDQSxPQUFNLFNBQVMsUUFBUSxpQkFBaUIsQ0FBQztBQUFBLFFBQ3JELENBQUM7QUFDRCxnQkFBUSxRQUFRLENBQUMsTUFBTSxhQUFhLE9BQU8sQ0FBQztBQUM1QyxZQUFJLFNBQVMsVUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxJQUFJLEVBQUUsRUFBRSxDQUFDO0FBQ3BFLFlBQUksS0FBSyxpQkFBaUIsU0FBUyxHQUFHO0FBQ2xDLGdCQUFNLGlCQUFpQixLQUFLLGlCQUFpQixJQUFJLGNBQVksU0FBUyxRQUFRLGlCQUFpQixDQUFDO0FBQ2hHLG1CQUFTLGdCQUFnQiw2QkFBNkIsVUFBVSxLQUFLLGVBQWUsS0FBSyxJQUFJLEdBQUc7QUFBQSxRQUNwRyxPQUNLO0FBRUQsY0FBSSxzQkFBc0I7QUFDdEIscUJBQVMsc0NBQXNDLFVBQVUsdUJBQXVCLElBQUksb0JBQW9CLFNBQVM7QUFBQSxVQUNySDtBQUNBLGNBQUksUUFBUTtBQUNSLHFCQUFTLDhCQUE4QjtBQUFBLFVBQzNDO0FBQUEsUUFDSjtBQUNBLGNBQU0sT0FBTyxLQUFLLFFBQVEsaUJBQWlCO0FBQzNDLGlCQUFTLEdBQUcsUUFBUSxPQUFPLEtBQUssSUFBSTtBQUNwQyxZQUFJLFdBQVcsWUFBWSxzQkFBc0IsSUFBSSxJQUFJLEdBQUc7QUFDeEQsb0JBQVUsR0FBR3BFLEtBQUkseUJBQXlCLENBQUMsSUFBSSxHQUFHLE9BQU87QUFBQSxRQUM3RDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxjQUFjO0FBQ1YsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxNQUNBLG9CQUFvQixrQkFBa0I7QUFDbEMsYUFBSyxtQkFBbUI7QUFDeEIsY0FBTSxrQkFBa0IsS0FBSyxRQUFRLG1CQUFtQjtBQUN4RCxtQkFBVyxjQUFjLEtBQUssWUFBWTtBQUN0QyxjQUFJLFdBQVcsUUFBUSxtQkFBbUIsS0FBSyxpQkFBaUI7QUFDNUQsaUJBQUssa0JBQWtCO0FBQ3ZCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLHNCQUFrQixVQUFVLGNBQWM7QUFFMUMsSUFBTSwrQkFBTixjQUEyQyxTQUFTO0FBQUEsTUFDaEQsWUFBWSxTQUFTLE1BQU0sb0JBQW9CO0FBQzNDLGNBQU0sSUFBSTtBQUNWLGFBQUssZUFBZTtBQUNwQixhQUFLLFVBQVU7QUFDZixhQUFLLFNBQVMsUUFBUTtBQUN0QixhQUFLLHFCQUFxQjtBQUFBLE1BQzlCO0FBQUEsTUFDQSxrQkFBa0I7QUFDZCxZQUFJLEtBQUs7QUFDTCxpQkFBTyxLQUFLO0FBQ2hCLFlBQUksZUFBZSxLQUFLO0FBQ3hCLGVBQU8sd0JBQXdCLHlCQUMzQix3QkFBd0IsOEJBQThCO0FBQ3RELGNBQUksd0JBQXdCLHVCQUF1QjtBQUMvQyxrQkFBTSxXQUFXLGFBQWEsb0JBQW9CO0FBQ2xELGdCQUFJLGFBQWE7QUFDYjtBQUNKLDJCQUFlO0FBQUEsVUFDbkI7QUFDQSxjQUFJLHdCQUF3Qiw4QkFBOEI7QUFDdEQsMkJBQWUsYUFBYTtBQUFBLFVBQ2hDO0FBQUEsUUFDSjtBQUNBLGVBQVEsS0FBSyxlQUFlO0FBQUEsTUFDaEM7QUFBQSxNQUNBLHNCQUFzQjtBQUNsQixlQUFPLEtBQUssbUJBQW1CLG9CQUFvQjtBQUFBLE1BQ3ZEO0FBQUEsTUFDQSxRQUFRLG1CQUFtQjtBQUN2QixlQUFPLEdBQUcsS0FBSyxtQkFBbUIsUUFBUSxpQkFBaUIsSUFBSSxrQkFBa0IsS0FBSyxJQUFJO0FBQUEsTUFDOUY7QUFBQSxNQUNBLFVBQVU7QUFDTixhQUFLLFdBQVc7QUFDaEIsYUFBSyxRQUFRLHdCQUF3QixLQUFLLGtCQUFrQjtBQUFBLE1BQ2hFO0FBQUEsTUFDQSxlQUFlLFVBQVUsTUFBTTtBQUMzQixjQUFNLGVBQWUsVUFBVSxJQUFJO0FBQUEsTUFDdkM7QUFBQSxJQUNKO0FBR0EsS0FBQyxTQUFVcUUsYUFBWTtBQUNuQixNQUFBQSxZQUFXQSxZQUFXLG9CQUFvQixLQUFLO0FBQy9DLE1BQUFBLFlBQVdBLFlBQVcsYUFBYSxLQUFLO0FBQ3hDLE1BQUFBLFlBQVdBLFlBQVcsY0FBYyxLQUFLO0FBQUEsSUFDN0MsR0FBRyxlQUFlLGFBQWEsQ0FBQyxFQUFFO0FBNkJsQyxJQUFNLE9BQU8sTUFBTTtBQUFBLElBQUU7QUFDckIsSUFBSSxTQUFTLG9CQUFJLElBQUk7QUFpRHJCLElBQUksWUFBWTtBQUNoQixJQUFJLFVBQVU7QUFDZCxJQUFNLHFCQUFxQixDQUFDLFFBQVEsd0JBQXdCLGFBQWEsV0FBVztBQTBEcEYsSUFBTSxrQ0FBa0M7QUFBQSxNQUNwQyxZQUFZO0FBQUEsTUFDWixXQUFXO0FBQUEsSUFDZjtBQTRDQSxJQUFNLFNBQU4sTUFBYTtBQUFBLE1BQ1QsWUFBWSxPQUFPLElBQUksU0FBUyxTQUFTLG1CQUFtQix1QkFBdUIsTUFBTTtBQUNyRixhQUFLLFFBQVE7QUFDYixhQUFLLEtBQUs7QUFDVixhQUFLLFVBQVU7QUFDZixhQUFLLDZCQUE2QixvQkFBSSxJQUFJO0FBQzFDLGFBQUssaUJBQWlCLG9CQUFJLElBQUk7QUFDOUIsYUFBSyxhQUFhLENBQUM7QUFDbkIsYUFBSyxTQUFTLG9CQUFJLElBQUk7QUFDdEIsYUFBSyxlQUFlLG9CQUFJLElBQUk7QUFDNUIsYUFBSyxzQkFBc0Isb0JBQUksSUFBSTtBQUNuQyxhQUFLLG1CQUFtQixDQUFDO0FBQ3pCLGFBQUssaUJBQWlCLENBQUM7QUFDdkIsYUFBSyxZQUFZO0FBQ2pCLGFBQUssd0JBQXdCLG9CQUFJLElBQUk7QUFDckMsYUFBSyx5QkFBeUIsb0JBQUksSUFBSTtBQUN0QyxhQUFLLHFCQUFxQixvQkFBSSxJQUFJO0FBQ2xDLGFBQUssY0FBYyxDQUFDO0FBQ3BCLGFBQUssNEJBQTRCO0FBQ2pDLGFBQUssWUFBWSxDQUFDO0FBQ2xCLGFBQUssVUFBVSxvQkFBSSxJQUFJO0FBQ3ZCLGFBQUssMkJBQTJCLENBQUM7QUFDakMsYUFBSyxhQUFhO0FBQ2xCLGFBQUssMEJBQTBCO0FBQy9CLGFBQUssa0JBQWtCO0FBQ3ZCLGFBQUssbUNBQW1DLG9CQUFJLElBQUk7QUFDaEQsYUFBSyxVQUFVLG9CQUFJLElBQUk7QUFDdkIsYUFBSyxvQkFBb0I7QUFDekIsYUFBSyxpQkFBaUI7QUFDdEIsYUFBSyxNQUFNO0FBQ1gsYUFBSyxtQkFBbUIsQ0FBQztBQUN6QixhQUFLLG1CQUFtQixvQkFBSSxJQUFJO0FBQ2hDLGFBQUssd0JBQXdCO0FBQzdCLGFBQUsscUJBQXFCLElBQUksbUJBQW1CLElBQUk7QUFDckQsYUFBSyxVQUFVLG9CQUFJLElBQUk7QUFDdkIsYUFBSywyQkFBMkIsb0JBQUksSUFBSTtBQUN4QyxhQUFLLHVCQUF1QixvQkFBSSxJQUFJO0FBQ3BDLGFBQUssdUJBQXVCO0FBQzVCLGFBQUssbUJBQW1CLG9CQUFJLElBQUk7QUFDaEMsYUFBSyxxQkFBcUI7QUFDMUIsYUFBSyx3QkFBd0IsQ0FBQztBQUM5QixhQUFLLHNCQUFzQjtBQUMzQixhQUFLLHVCQUF1QixLQUFLLEtBQUssRUFBRTtBQUN4QyxhQUFLLFVBQVUsUUFBUSxjQUFjLEVBQUU7QUFDdkMsYUFBSyxvQkFBb0IsS0FBSyxRQUFRO0FBRXRDLGNBQU16RSxVQUFTO0FBQ2YsY0FBTSxFQUFFLGdCQUFnQixrQkFBa0IsdUJBQXVCLHdCQUF3QixXQUFXLHNCQUFzQixRQUFRLElBQUk7QUFDdEksYUFBSyxPQUFPO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixJQUFJLG1DQUFtQztBQUNuQyxtQkFBTyxlQUNGLElBQUksQ0FBQyxFQUFFLFNBQVMsTUFBTSxPQUFPLGFBQWEsWUFBWUEsUUFBTyxZQUFZLFNBQVMsRUFDbEYsT0FBTyxPQUFPO0FBQUEsVUFDdkI7QUFBQSxVQUNBLElBQUkseUJBQXlCO0FBR3pCLG1CQUFPLGVBQWUsSUFBSSxDQUFDLEVBQUUsSUFBQWtCLElBQUcsTUFBTUEsR0FBRSxFQUFFLE9BQU8sQ0FBQ0EsUUFBT0EsT0FBTSxJQUFJO0FBQUEsVUFDdkU7QUFBQSxVQUNBLElBQUksbUJBQW1CO0FBQ25CLG1CQUFPLGlCQUFpQixLQUFLO0FBQUEsVUFDakM7QUFBQSxVQUNBLElBQUksbUJBQW1CO0FBRW5CLGdCQUFJLENBQUNsQixRQUFPLEtBQUs7QUFDYixxQkFBTztBQUFBLFlBQ1g7QUFDQSxtQkFBT0EsUUFBTyxRQUFRLElBQUksU0FBUyxLQUFLLHFCQUFxQixJQUFJLFNBQVM7QUFBQSxVQUM5RTtBQUFBLFVBQ0EsSUFBSSx1QkFBdUI7QUFDdkIsNEJBQWdCLDBIQUEwSCxPQUFPLE9BQU87QUFDeEosbUJBQU8sS0FBSztBQUFBLFVBQ2hCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsSUFBSSw2QkFBNkI7QUFDN0IsbUJBQU8sTUFBTSxLQUFLLHVCQUF1QixLQUFLLEVBQUUsS0FBSztBQUFBLFVBQ3pEO0FBQUEsVUFDQSxJQUFJLHlCQUF5QjtBQUN6QixtQkFBTyxNQUFNLEtBQUssd0JBQXdCLEtBQUssRUFBRSxLQUFLO0FBQUEsVUFDMUQ7QUFBQSxVQUNBLElBQUksd0JBQXdCO0FBQ3hCLG1CQUFPLE1BQU0sS0FBSyxTQUFTLFlBQVVBLFFBQU8sWUFBWSxPQUFPLEVBQUUsT0FBTyxPQUFPO0FBQUEsVUFDbkY7QUFBQSxVQUNBLElBQUksY0FBYztBQUdkLG1CQUFPLE1BQU0sS0FBSyxTQUFTLFlBQVU7QUFBRSxrQkFBSTtBQUFJLHNCQUFRLEtBQUtBLFFBQU8sWUFBWSxhQUFhLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRztBQUFBLFlBQUksQ0FBQyxFQUFFLE9BQU8sT0FBTztBQUFBLFVBQ3pKO0FBQUEsVUFDQSxJQUFJLFlBQVk7QUFDWixtQkFBTyxVQUFVLEtBQUs7QUFBQSxVQUMxQjtBQUFBLFVBQ0E7QUFBQSxVQUNBLFlBQVk7QUFBQSxVQUNaLElBQUksYUFBYTtBQUNiLGdCQUFJLE1BQU0sVUFBVSxXQUFXLFVBQVU7QUFDckMscUJBQU87QUFBQSxZQUNYO0FBQ0EsbUJBQU9BLFFBQU8sV0FBVztBQUFBLFVBQzdCO0FBQUEsVUFDQSxNQUFNLEVBQUUsR0FBRyxLQUFLO0FBQUEsVUFDaEI7QUFBQSxVQUNBO0FBQUEsUUFDSjtBQUVBLGVBQU8sZUFBZSxLQUFLLE1BQU0sd0JBQXdCO0FBQUEsVUFDckQsWUFBWTtBQUFBLFFBQ2hCLENBQUM7QUFBQSxNQUNMO0FBQUEsTUFDQSxXQUFXO0FBQ1AsY0FBTUYsWUFBTyxzQkFBUyxLQUFLLEVBQUU7QUFDN0IsY0FBTSxVQUFNLHFCQUFRLEtBQUssRUFBRTtBQUMzQixlQUFPLFVBQVUsTUFBTUEsTUFBSyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE1BQU0sSUFBSUEsS0FBSTtBQUFBLE1BQzVEO0FBQUEsTUFDQSxpQkFBaUI7QUFDYixhQUFLLElBQUksS0FBSztBQUFBLE1BQ2xCO0FBQUEsTUFDQSxNQUFNLE9BQU8sS0FBSztBQUNkLGFBQUssc0JBQXNCLE9BQU8sR0FBRztBQUNyQyxlQUFPLE1BQU0sS0FBSztBQUFBLE1BQ3RCO0FBQUEsTUFDQSxvQkFBb0I7QUFDaEIsWUFBSSxLQUFLLGdCQUFnQjtBQUNyQixpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFDQSxhQUFLLGlCQUFpQixvQkFBSSxJQUFJLENBQUMsR0FBRyxLQUFLLFFBQVEsS0FBSyxHQUFHLEdBQUcsS0FBSyxxQkFBcUIsS0FBSyxDQUFDLENBQUM7QUFDM0YsbUJBQVdFLFdBQVUsS0FBSyxrQkFBa0I7QUFDeEMsY0FBSUEsbUJBQWtCLGdCQUFnQjtBQUNsQyxpQkFBSyxlQUFlLElBQUksSUFBSUEsUUFBTyxJQUFJO0FBQ3ZDO0FBQUEsVUFDSjtBQUNBLHFCQUFXLFFBQVFBLFFBQU8sa0JBQWtCLEdBQUc7QUFDM0MsZ0JBQUksU0FBUztBQUNULG1CQUFLLGVBQWUsSUFBSSxJQUFJO0FBQUEsVUFDcEM7QUFBQSxRQUNKO0FBR0EsWUFBSSxPQUFPLEtBQUssS0FBSywwQkFBMEIsVUFBVTtBQUNyRCxlQUFLLGVBQWUsT0FBTyxLQUFLLEtBQUsscUJBQXFCO0FBQUEsUUFDOUQ7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUFBLE1BQ0EsOEJBQThCO0FBQzFCLFlBQUksS0FBSztBQUNMLGlCQUFPLEtBQUs7QUFDaEIsYUFBSyx1QkFBdUIsb0JBQUksSUFBSTtBQUNwQyxjQUFNLHdCQUF3QixvQkFBSSxJQUFJO0FBQ3RDLGNBQU0sNEJBQTRCLG9CQUFJLElBQUk7QUFDMUMsY0FBTSxzQkFBc0IsSUFBSSxJQUFJLEtBQUssT0FBTztBQUNoRCxZQUFJLEtBQUssS0FBSyxXQUNWLEtBQUsseUJBQXlCLFNBQVMsS0FDdkMsS0FBSyxVQUFVLFlBQ2YsS0FBSyxzQkFBc0IsT0FBTyxHQUFHO0FBQ3JDLHFCQUFXLGNBQWMsQ0FBQyxHQUFHLEtBQUssYUFBYSxHQUFHLEdBQUcsS0FBSyxXQUFXLENBQUMsR0FBRztBQUNyRSxrQkFBTSxDQUFDLGdCQUFnQixJQUFJLEtBQUsseUJBQXlCLFVBQVU7QUFDbkUsZ0JBQUksa0JBQWtCO0FBQ2xCLGtDQUFvQixJQUFJLGdCQUFnQjtBQUFBLFlBQzVDO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxpQkFBUyxZQUFZLHFCQUFxQjtBQUN0QyxnQkFBTSx5QkFBeUIsS0FBSyxpQ0FBaUMsSUFBSSxRQUFRO0FBQ2pGLGNBQUksd0JBQXdCO0FBQ3hCLHVCQUFXQSxXQUFVLHdCQUF3QjtBQUN6Qyx3Q0FBMEIsSUFBSUEsT0FBTTtBQUFBLFlBQ3hDO0FBQUEsVUFDSjtBQUNBLGNBQUksb0JBQW9CLDhCQUE4QjtBQUNsRCx1QkFBVyxTQUFTLGdCQUFnQjtBQUFBLFVBQ3hDLFdBQ1Msb0JBQW9CLHVCQUF1QjtBQUNoRCx1QkFBVyxTQUFTLG9CQUFvQjtBQUFBLFVBQzVDO0FBQ0EsZ0NBQXNCLElBQUksU0FBUyxNQUFNO0FBQUEsUUFDN0M7QUFDQSxZQUFJLENBQUMsS0FBSyxRQUFRLGFBQWEsS0FBSyxLQUFLLHNCQUFzQixnQkFBZ0I7QUFDM0UscUJBQVcsY0FBYyxLQUFLLGNBQWM7QUFDeEMsaUJBQUsscUJBQXFCLElBQUksVUFBVTtBQUFBLFVBQzVDO0FBQUEsUUFDSixPQUNLO0FBQ0QsZUFBSyxrQ0FBa0MsS0FBSyxzQkFBc0IsdUJBQXVCLHlCQUF5QjtBQUFBLFFBQ3RIO0FBQ0EsbUJBQVcsY0FBYyx1QkFBdUI7QUFDNUMsZUFBSyxxQkFBcUIsSUFBSSxVQUFVO0FBQUEsUUFDNUM7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUFBLE1BQ0EsMkJBQTJCO0FBQ3ZCLFlBQUksS0FBSyx1QkFBdUI7QUFDNUIsaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBQ0EsY0FBTSx3QkFBd0Isb0JBQUksSUFBSTtBQUN0QyxtQkFBVyxjQUFjLEtBQUssa0JBQWtCLEdBQUc7QUFDL0MsY0FBSSxDQUFDLGNBQWMsSUFBSSxLQUFLLHlCQUF5QixVQUFVO0FBQy9ELGNBQUksMEJBQTBCLHVCQUF1QjtBQUNqRCw2QkFBaUIsZUFBZSxvQkFBb0I7QUFBQSxVQUN4RDtBQUNBLGNBQUksQ0FBQyxrQkFDRCxFQUFFLGVBQWUsWUFBWSwwQkFBMEIsbUJBQW1CO0FBQzFFO0FBQUEsVUFDSjtBQUNBLGdCQUFNLHNCQUFzQixzQkFBc0IsSUFBSSxjQUFjO0FBQ3BFLGNBQUkscUJBQXFCO0FBQ3JCLGdDQUFvQixLQUFLLFVBQVU7QUFBQSxVQUN2QyxPQUNLO0FBQ0Qsa0NBQXNCLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDO0FBQUEsVUFDMUQ7QUFBQSxRQUNKO0FBQ0EsZUFBUSxLQUFLLHdCQUF3QjtBQUFBLE1BQ3pDO0FBQUEsTUFDQSxhQUFhO0FBQ1QsZUFBTyxNQUFNLEtBQUssS0FBSyxRQUFRLEtBQUssQ0FBQztBQUFBLE1BQ3pDO0FBQUEsTUFDQSxlQUFlO0FBQ1gsWUFBSSxLQUFLLHFCQUFxQjtBQUMxQixpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFFQSxhQUFLLHNCQUFzQixDQUFDO0FBQzVCLGNBQU0sWUFBWSxJQUFJLElBQUksS0FBSyxxQkFBcUIsS0FBSyxDQUFDO0FBQzFELG1CQUFXQSxXQUFVLEtBQUssa0JBQWtCO0FBQ3hDLGNBQUlBLG1CQUFrQixnQkFBZ0I7QUFDbEMsc0JBQVUsSUFBSSxJQUFJQSxRQUFPLElBQUk7QUFBQSxVQUNqQyxPQUNLO0FBQ0QsdUJBQVcsUUFBUSxDQUFDLEdBQUdBLFFBQU8sYUFBYSxHQUFHLEdBQUdBLFFBQU8sV0FBVyxDQUFDLEdBQUc7QUFDbkUsa0JBQUksU0FBUztBQUNULDBCQUFVLElBQUksSUFBSTtBQUFBLFlBQzFCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxlQUFRLEtBQUssc0JBQXNCLENBQUMsR0FBRyxTQUFTO0FBQUEsTUFDcEQ7QUFBQSxNQUNBLHFCQUFxQjtBQUVqQixjQUFNLGtCQUFrQixDQUFDO0FBQ3pCLGNBQU0saUJBQWlCLENBQUM7QUFDeEIsbUJBQVcsY0FBYyxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQzFDLGdCQUFNLENBQUMsUUFBUSxJQUFJLEtBQUsseUJBQXlCLFVBQVU7QUFDM0QsV0FBQyxZQUFZLFNBQVMsV0FBVyxrQkFBa0IsZ0JBQWdCLEtBQUssVUFBVTtBQUFBLFFBQ3RGO0FBQ0EsZUFBTyxFQUFFLGdCQUFnQixnQkFBZ0I7QUFBQSxNQUM3QztBQUFBLE1BQ0Esd0JBQXdCO0FBQ3BCLFlBQUksS0FBSyx1QkFBdUIsTUFBTTtBQUNsQyxlQUFLLHFCQUFxQjtBQUMxQixXQUFDLEtBQUssa0JBQWtCLElBQUksS0FBSyx5QkFBeUIsT0FBTyxLQUFLLEtBQUssMEJBQTBCLFdBQy9GLEtBQUssS0FBSyx3QkFDVixXQUFXLEVBQUUsY0FBYyxLQUFLLENBQUM7QUFBQSxRQUMzQztBQUNBLFlBQUksQ0FBQyxLQUFLLG9CQUFvQjtBQUMxQixpQkFBTyxNQUFNLDRDQUE0QyxLQUFLLElBQUksS0FBSyxLQUFLLHFCQUFxQixDQUFDO0FBQUEsUUFDdEc7QUFDQSxlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUFBLE1BQ0EseUJBQXlCLE1BQU0sRUFBRSx3QkFBd0IsbUJBQW1CLGNBQWMsd0JBQXdCLElBQUksY0FBYztBQUNoSSxZQUFJO0FBQ0osWUFBSSxLQUFLLE9BQU8sS0FBSztBQUNqQixjQUFJLEtBQUssV0FBVyxHQUFHO0FBRW5CLG1CQUFPLENBQUMsS0FBSyxTQUFTO0FBQUEsVUFDMUI7QUFFQSxnQkFBTUEsVUFBUyxLQUFLLE1BQU0sWUFBWSxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUM7QUFDdkQsaUJBQU9BLFFBQU8seUJBQXlCLEdBQUc7QUFBQSxRQUM5QztBQUVBLGNBQU0sc0JBQXNCLEtBQUsscUJBQXFCLElBQUksSUFBSTtBQUM5RCxZQUFJLHFCQUFxQjtBQUNyQixnQkFBTSxDQUFDLFFBQVEsSUFBSSxrQ0FBa0Msb0JBQW9CLFFBQVEsb0JBQW9CLFdBQVcsd0JBQXdCLE9BQU8sdUJBQXVCO0FBQ3RLLGNBQUksQ0FBQyxVQUFVO0FBQ1gsbUJBQU8sS0FBSyxNQUFNLGlCQUFpQixvQkFBb0IsV0FBVyxLQUFLLElBQUksb0JBQW9CLE9BQU8sRUFBRSxHQUFHLG9CQUFvQixLQUFLO0FBQUEsVUFDeEk7QUFDQSxjQUFJLHdCQUF3QjtBQUN4QiwyQ0FBK0IsVUFBVSx3QkFBd0IsSUFBSTtBQUFBLFVBQ3pFO0FBQ0EsaUJBQU8sQ0FBQyxRQUFRO0FBQUEsUUFDcEI7QUFDQSxjQUFNLG9CQUFvQixLQUFLLFFBQVEsSUFBSSxJQUFJO0FBQy9DLFlBQUksbUJBQW1CO0FBQ25CLGNBQUksc0JBQXNCLGlDQUFpQztBQUN2RCxtQkFBTyxDQUFDLEtBQUssa0JBQWtCO0FBQUEsVUFDbkM7QUFDQSxnQkFBTXdFLFFBQU8sa0JBQWtCO0FBQy9CLGdCQUFNLFdBQVcsS0FBSyxjQUFjQSxPQUFNLHNCQUFzQjtBQUNoRSxjQUFJLHdCQUF3QjtBQUN4Qix3QkFBWSx1QkFBdUIsa0NBQWtDLFVBQVUsTUFBTSxvQkFBSSxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUk7QUFDeEcsMkNBQStCLFVBQVUsd0JBQXdCLElBQUk7QUFBQSxVQUN6RTtBQUNBLGlCQUFPLENBQUMsUUFBUTtBQUFBLFFBQ3BCO0FBQ0EsWUFBSSxjQUFjO0FBQ2QsaUJBQU8sQ0FBQyxJQUFJO0FBQUEsUUFDaEI7QUFDQSxZQUFJLFNBQVMsV0FBVztBQUNwQixnQkFBTSwwQkFBMEIsS0FBSyxLQUFLLHlCQUF5QixJQUFJLElBQUksT0FBTyxRQUFRLE9BQU8sU0FBUyxLQUFLLEtBQUssa0NBQWtDLE1BQU0sd0JBQXdCLHVCQUF1QjtBQUMzTSxlQUFLLHlCQUF5QixJQUFJLE1BQU0sc0JBQXNCO0FBQzlELGNBQUksdUJBQXVCLElBQUk7QUFDM0IsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUNBLFlBQUksS0FBSyxLQUFLLHVCQUF1QjtBQUNqQyxpQkFBTztBQUFBLFlBQ0gsWUFBWSxLQUFLLGtCQUFrQixNQUFNLE1BQU0sSUFBSSw2QkFBNkIsS0FBSyxZQUFZLE1BQU0sS0FBSyxzQkFBc0IsQ0FBQyxDQUFDO0FBQUEsVUFDeEk7QUFBQSxRQUNKO0FBR0EsWUFBSSxDQUFDLG1CQUFtQjtBQUNwQixjQUFJLEtBQUssUUFBUSxvQkFBb0I7QUFDakMsaUJBQUssa0JBQWtCLElBQUk7QUFDM0IsbUJBQU8sQ0FBQyxLQUFLLGtCQUFrQjtBQUFBLFVBQ25DO0FBQUEsUUFDSjtBQUNBLGVBQU8sQ0FBQyxJQUFJO0FBQUEsTUFDaEI7QUFBQSxNQUNBLGFBQWE7QUFDVCxlQUFRLEtBQUssS0FBSyxzQkFBc0Isa0JBQ25DLEtBQUssSUFBSSxZQUFZLEtBQUssSUFBSSxXQUFXLHdCQUF3QixDQUFDO0FBQUEsTUFDM0U7QUFBQSxNQUNBLFVBQVU7QUFDTixjQUFNLFVBQVUsdUJBQXVCO0FBQ3ZDLFlBQUksS0FBSyxJQUFJLGlCQUFpQixPQUFPO0FBQ2pDLGVBQUssSUFBSSxRQUFRLFNBQVMsS0FBSztBQUFBLE1BQ3ZDO0FBQUEsTUFDQSxrQkFBa0IseUJBQXlCO0FBQ3ZDLFlBQUksQ0FBQyxLQUFLLFlBQVk7QUFDbEIsb0RBQTBDLElBQUk7QUFDOUMsZUFBSyxNQUFNLHVCQUF1QjtBQUFBLFFBQ3RDO0FBQ0EsbUJBQVcsY0FBYyxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQzFDLGNBQUksMkJBQTJCLGVBQWUsS0FBSyxLQUFLLHVCQUF1QjtBQUMzRSxrQkFBTSxXQUFXLEtBQUsseUJBQXlCLFVBQVUsRUFBRTtBQUMzRCxxQkFBUyxlQUFlLFlBQVk7QUFDcEMsZ0JBQUksQ0FBQyxTQUFTLFVBQVU7QUFDcEIsbUJBQUssZ0JBQWdCLFFBQVE7QUFBQSxZQUNqQztBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsbUJBQVcsUUFBUSxLQUFLLGFBQWEsR0FBRztBQUNwQyxnQkFBTSxDQUFDLFFBQVEsSUFBSSxLQUFLLHlCQUF5QixJQUFJO0FBQ3JELGNBQUksVUFBVTtBQUNWLHFCQUFTLGVBQWUsWUFBWTtBQUNwQyxnQkFBSSxDQUFDLFNBQVMsVUFBVTtBQUNwQixtQkFBSyxnQkFBZ0IsUUFBUTtBQUFBLFlBQ2pDO0FBQ0EsZ0JBQUksb0JBQW9CLGtCQUFrQjtBQUN0Qyx1QkFBUyxPQUFPLGFBQWE7QUFBQSxZQUNqQztBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsWUFBSSx5QkFBeUI7QUFDekIsZUFBSyxVQUFVLG9CQUFvQixLQUFLLHdDQUF3QyxDQUFDO0FBQUEsUUFDckY7QUFBQSxNQUNKO0FBQUEsTUFDQSxxQkFBcUI7QUFDakIsYUFBSyxJQUFJLFFBQVEsdUJBQXVCLEdBQUcsSUFBSTtBQUMvQyxhQUFLLGtCQUFrQixLQUFLO0FBQUEsTUFDaEM7QUFBQSxNQUNBLGFBQWE7QUFDVCxlQUFPLEtBQUssSUFBSSxZQUFZLEtBQUssVUFBVSxZQUFZLEtBQUs7QUFBQSxNQUNoRTtBQUFBLE1BQ0EsY0FBYztBQUNWLGFBQUssK0JBQStCLEtBQUssa0JBQWtCO0FBQzNELGFBQUssK0JBQStCLEtBQUssb0JBQW9CO0FBQzdELGNBQU0sMkJBQTJCLENBQUM7QUFDbEMsbUJBQVcsVUFBVSxLQUFLLGtCQUFrQjtBQUN4QyxnQkFBTXhFLFVBQVMsS0FBSyxNQUFNLFlBQVksSUFBSSxLQUFLLFlBQVksUUFBUSxFQUFFO0FBQ3JFLGNBQUlBLG1CQUFrQixnQkFBZ0I7QUFDbEMscUNBQXlCLEtBQUtBLE9BQU07QUFDcEM7QUFBQSxVQUNKO0FBQ0EsZUFBSyxpQkFBaUIsS0FBS0EsT0FBTTtBQUFBLFFBQ3JDO0FBQ0EsYUFBSyxpQkFBaUIsS0FBSyxHQUFHLHdCQUF3QjtBQUFBLE1BQzFEO0FBQUEsTUFDQSxPQUFPLFNBQVM7QUFDWixjQUFNLGNBQWMsS0FBSyxZQUFZLE1BQU07QUFDM0MsYUFBSyxJQUFJLE9BQU8sYUFBYSxPQUFPO0FBQ3BDLGFBQUssb0JBQW9CLEtBQUssV0FBVztBQUN6QyxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsVUFBVSxFQUFFLEtBQUssTUFBTSxzQkFBc0IsY0FBYyxtQkFBbUIsYUFBYSxnQkFBZ0IsdUJBQXVCLG1CQUFtQixjQUFjLEdBQUc7QUFDbEssYUFBSyxLQUFLLE9BQU87QUFDakIsYUFBSyxlQUFlO0FBQ3BCLGFBQUssb0JBQW9CO0FBQ3pCLGFBQUssaUJBQWlCO0FBQ3RCLFlBQUksZ0JBQWdCO0FBQ2hCLGVBQUssaUJBQWlCO0FBQUEsUUFDMUI7QUFDQSxhQUFLLHdCQUF3QjtBQUM3QixhQUFLLHVCQUF1QjtBQUM1QixhQUFLLGNBQWMsYUFBYTtBQUNoQyxrQkFBVSxnQkFBZ0IsQ0FBQztBQUMzQixZQUFJLENBQUMsS0FBSztBQUNOLGdCQUFNLEtBQUssU0FBUztBQUFBLFFBQ3hCO0FBQ0EsZ0JBQVEsZ0JBQWdCLENBQUM7QUFDekIsYUFBSyxjQUFjLGVBQWUsdUJBQU8sT0FBTyxJQUFJO0FBR3BELGNBQU0sV0FBVyxLQUFLO0FBQ3RCLGFBQUssY0FBYyxJQUFJLGNBQWMsTUFBTTtBQUFBLFVBQ3ZDLFVBQVcsS0FBSyx1QkFBdUIsT0FBTztBQUFBLFVBQzlDLHVCQUF1QixDQUFDO0FBQUEsUUFDNUIsQ0FBQztBQUNELGtCQUFVLGVBQWUsQ0FBQztBQUMxQixhQUFLLGFBQWE7QUFBQSxVQUNkLGtCQUFrQixLQUFLLGlCQUFpQixLQUFLLElBQUk7QUFBQSxVQUNqRCxXQUFXLEtBQUssVUFBVSxLQUFLLElBQUk7QUFBQSxVQUNuQyxXQUFXLEtBQUssVUFBVSxLQUFLLElBQUk7QUFBQSxVQUNuQyxlQUFlLEtBQUssY0FBYyxLQUFLLElBQUk7QUFBQSxVQUMzQztBQUFBLFVBQ0EsdUJBQXVCLEtBQUssTUFBTTtBQUFBLFVBQ2xDLE9BQU8sS0FBSyxNQUFNLEtBQUssSUFBSTtBQUFBLFVBQzNCO0FBQUEsVUFDQSxZQUFZLEtBQUssV0FBVyxLQUFLLElBQUk7QUFBQSxVQUNyQyxvQkFBb0IsTUFBTSxLQUFLO0FBQUEsVUFDL0IsZUFBZSxLQUFLLFNBQVMsS0FBSyxJQUFJO0FBQUEsVUFDdEMsb0JBQW9CLENBQUMsU0FBUyxpQkFBaUIsU0FBUyxpQkFBaUI7QUFBQSxVQUN6RSxjQUFjLEtBQUssYUFBYSxLQUFLLElBQUk7QUFBQSxVQUN6QyxvQkFBb0IsS0FBSztBQUFBLFVBQ3pCLG1CQUFtQixNQUFNLEtBQUssa0JBQWtCLElBQUk7QUFBQSxVQUNwRCxzQkFBc0IsS0FBSyxxQkFBcUIsS0FBSyxJQUFJO0FBQUEsVUFDekQseUJBQXlCLEtBQUssd0JBQXdCLEtBQUssSUFBSTtBQUFBLFVBQy9ELGFBQWEsS0FBSztBQUFBLFVBQ2xCLFFBQVE7QUFBQSxVQUNSLGVBQWUsS0FBSztBQUFBLFVBQ3BCLFNBQVMsS0FBSztBQUFBLFVBQ2Qsd0JBQXdCLE1BQU8sS0FBSyxNQUFNLHVCQUF1QjtBQUFBLFVBQ2pFLGFBQWEsQ0FBQyxTQUFTLEtBQUsseUJBQXlCLElBQUksRUFBRTtBQUFBLFVBQzNELGVBQWUsS0FBSyxjQUFjLEtBQUssSUFBSTtBQUFBLFVBQzNDLG1CQUFtQjtBQUFBLFVBQ25CLE1BQU0sS0FBSyxLQUFLLEtBQUssSUFBSTtBQUFBLFFBQzdCO0FBQ0EsYUFBSyxRQUFRLElBQUksWUFBWSxLQUFLLE1BQU0sT0FBTyxLQUFLLFVBQVU7QUFDOUQsYUFBSyxZQUFZLElBQUksa0JBQWtCLEtBQUssVUFBVTtBQUN0RCxhQUFLLE1BQU0sSUFBSSxRQUFRLEtBQUssRUFBRSxTQUFTLEtBQUssWUFBWSxNQUFNLFNBQVMsR0FBRyxLQUFLLEtBQUs7QUFDcEYsYUFBSyxLQUFLLE1BQU07QUFDaEIsZ0JBQVEsZUFBZSxDQUFDO0FBQUEsTUFDNUI7QUFBQSxNQUNBLFNBQVM7QUFDTCxlQUFPO0FBQUEsVUFDSCxLQUFLLEtBQUssSUFBSTtBQUFBLFVBQ2QsTUFBTSxLQUFLLEtBQUs7QUFBQSxVQUNoQixzQkFBc0IsS0FBSztBQUFBLFVBQzNCLGNBQWMsTUFBTSxLQUFLLEtBQUssY0FBYyxLQUFLO0FBQUEsVUFDakQsSUFBSSxLQUFLO0FBQUEsVUFDVCxNQUFNLEtBQUssS0FBSztBQUFBLFVBQ2hCLG1CQUFtQixLQUFLLEtBQUs7QUFBQSxVQUM3QixjQUFjLEtBQUs7QUFBQSxVQUNuQixtQkFBbUIsS0FBSztBQUFBLFVBQ3hCLGFBQWEsS0FBSztBQUFBLFVBQ2xCLGdCQUFnQixLQUFLO0FBQUEsVUFDckIsdUJBQXVCLEtBQUssS0FBSztBQUFBLFVBQ2pDLHVCQUF1QixLQUFLO0FBQUEsVUFDNUIsZ0JBQWdCLEtBQUs7QUFBQSxRQUN6QjtBQUFBLE1BQ0o7QUFBQSxNQUNBLGNBQWMsTUFBTSx3QkFBd0I7QUFDeEMsY0FBTSxnQkFBZ0IsS0FBSyxNQUFNLFVBQVUsSUFBSSxJQUFJO0FBQ25ELFlBQUksZUFBZTtBQUNmLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGNBQU0sb0JBQW9CLEtBQUssbUJBQW1CLElBQUksSUFBSTtBQUMxRCxZQUFJLG1CQUFtQjtBQUNuQixnQkFBTSxjQUFjLGtCQUFrQjtBQUN0QyxjQUFJLHVCQUF1QixVQUFVLGtCQUFrQixTQUFTLEtBQUs7QUFDakUsbUJBQU8sWUFBWTtBQUFBLFVBQ3ZCO0FBQ0EsZ0JBQU0sQ0FBQyxXQUFXLElBQUksWUFBWSx5QkFBeUIsa0JBQWtCLE1BQU07QUFBQSxZQUMvRSx3QkFBd0IsMEJBQTBCO0FBQUEsVUFDdEQsQ0FBQztBQUNELGNBQUksQ0FBQyxhQUFhO0FBQ2QsbUJBQU8sS0FBSyxNQUFNLGlCQUFpQixrQkFBa0IsTUFBTSxLQUFLLElBQUksWUFBWSxFQUFFLEdBQUcsa0JBQWtCLEtBQUs7QUFBQSxVQUNoSDtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxXQUFXO0FBQ1AsWUFBSTtBQUNBLGlCQUFPLEtBQUssTUFBTSxhQUFhLEtBQUssS0FBSyxJQUFJO0FBQUEsUUFDakQsU0FDTyxLQUFQO0FBQ0ksY0FBSSxVQUFVLElBQUksUUFBUSxRQUFRLGlCQUFpQixFQUFFO0FBQ3JELGNBQUksS0FBSyxHQUFHLFNBQVMsT0FBTyxHQUFHO0FBQzNCLHVCQUFXO0FBQUEsVUFDZixXQUNTLENBQUMsS0FBSyxHQUFHLFNBQVMsS0FBSyxHQUFHO0FBQy9CLHVCQUFXO0FBQUEsVUFDZjtBQUNBLGlCQUFPLEtBQUssTUFBTTtBQUFBLFlBQ2QsTUFBTTtBQUFBLFlBQ047QUFBQSxZQUNBLGFBQWE7QUFBQSxVQUNqQixHQUFHLElBQUksR0FBRztBQUFBLFFBQ2Q7QUFBQSxNQUNKO0FBQUEsTUFDQSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsc0JBQXNCLEdBQUc7QUFDOUQsWUFBSSxxQkFBcUIsTUFBTTtBQUMzQixlQUFLLEtBQUssb0JBQW9CO0FBQUEsUUFDbEM7QUFDQSxZQUFJLHlCQUF5QixNQUFNO0FBQy9CLGVBQUssS0FBSyx3QkFBd0I7QUFBQSxRQUN0QztBQUNBLFlBQUksUUFBUSxNQUFNO0FBQ2QsaUJBQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxJQUFJO0FBQUEsUUFDdEM7QUFBQSxNQUNKO0FBQUEsTUFDQSxLQUFLLE9BQU8sS0FBSztBQUNiLGFBQUssc0JBQXNCLE9BQU8sR0FBRztBQUNyQyxhQUFLLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDN0I7QUFBQSxNQUNBLGlCQUFpQixNQUFNO0FBQ25CLFlBQUksV0FBVyxLQUFLO0FBQ3BCLFlBQUksb0JBQW9CLGlCQUFpQjtBQUNyQyxjQUFJLFNBQVMsT0FBTyxXQUFXLEtBQUssU0FBUyxPQUFPLEdBQUcsTUFBTSxRQUFRO0FBQ2pFLHVCQUFXLFNBQVMsT0FBTyxHQUFHLE1BQU07QUFBQSxVQUN4QztBQUFBLFFBQ0osV0FDUyxvQkFBb0IsV0FBVyxPQUFPLFNBQVMsVUFBVSxVQUFVO0FBQ3hFLHFCQUFXLFNBQVM7QUFBQSxRQUN4QjtBQUNBLGFBQUssZUFBZSxLQUFLLEVBQUUsVUFBVSxJQUFJLE1BQU0sTUFBTSxZQUFZLEtBQUssQ0FBQztBQUFBLE1BQzNFO0FBQUEsTUFDQSxVQUFVLE1BQU07QUFDWixZQUFJLGdCQUFnQiwwQkFBMEI7QUFFMUMsZUFBSyxRQUFRLElBQUksV0FBVztBQUFBLFlBQ3hCLFlBQVksS0FBSyxTQUFTLHdCQUF3QjtBQUFBLFlBQ2xELFdBQVc7QUFBQSxVQUNmLENBQUM7QUFBQSxRQUNMLFdBQ1MsZ0JBQWdCLHNCQUFzQjtBQUMzQyxnQkFBTSxTQUFTLEtBQUssT0FBTztBQUMzQixlQUFLLFFBQVEsSUFBSSxNQUFNO0FBQ3ZCLGNBQUksS0FBSyxVQUFVO0FBRWYsa0JBQU0sT0FBTyxLQUFLLFNBQVM7QUFDM0IsaUJBQUsscUJBQXFCLElBQUksTUFBTTtBQUFBLGNBQ2hDLFdBQVc7QUFBQSxjQUNYLFFBQVE7QUFBQSxjQUNSO0FBQUEsY0FDQSxPQUFPLEtBQUs7QUFBQSxZQUNoQixDQUFDO0FBQUEsVUFDTCxPQUNLO0FBRUQsaUJBQUssaUJBQWlCLElBQUksTUFBTTtBQUFBLFVBQ3BDO0FBQUEsUUFDSixXQUNTLEtBQUssa0JBQWtCLFNBQVM7QUFFckMsZ0JBQU0sU0FBUyxLQUFLLE9BQU87QUFDM0IsZUFBSyxRQUFRLElBQUksTUFBTTtBQUN2QixxQkFBVyxhQUFhLEtBQUssWUFBWTtBQUNyQyxrQkFBTSxPQUFPLFVBQVUsU0FBUztBQUNoQyxpQkFBSyxxQkFBcUIsSUFBSSxNQUFNO0FBQUEsY0FDaEMsV0FBVyxVQUFVLE1BQU07QUFBQSxjQUMzQixRQUFRO0FBQUEsY0FDUjtBQUFBLGNBQ0EsT0FBTyxVQUFVO0FBQUEsWUFDckIsQ0FBQztBQUFBLFVBQ0w7QUFBQSxRQUNKLFdBQ1MsS0FBSyxhQUFhO0FBQ3ZCLGdCQUFNLGNBQWMsS0FBSztBQUN6QixjQUFJLHVCQUF1QixxQkFBcUI7QUFHNUMsdUJBQVcsY0FBYyxZQUFZLGNBQWM7QUFDL0MseUJBQVcsYUFBYSxxQkFBcUIsV0FBVyxFQUFFLEdBQUc7QUFDekQscUJBQUssUUFBUSxJQUFJLFdBQVcsRUFBRSxZQUFZLE1BQU0sVUFBVSxDQUFDO0FBQUEsY0FDL0Q7QUFBQSxZQUNKO0FBQUEsVUFDSixPQUNLO0FBRUQsa0JBQU0sWUFBWSxZQUFZLEdBQUc7QUFDakMsaUJBQUssUUFBUSxJQUFJLFdBQVcsRUFBRSxZQUFZLE1BQU0sVUFBVSxDQUFDO0FBQUEsVUFDL0Q7QUFBQSxRQUNKLE9BQ0s7QUFFRCxxQkFBVyxhQUFhLEtBQUssWUFBWTtBQUNyQyxrQkFBTSxZQUFZLFVBQVUsTUFBTTtBQUNsQyxrQkFBTSxlQUFlLFVBQVUsU0FBUztBQUN4QyxpQkFBSyxRQUFRLElBQUksY0FBYyxFQUFFLFlBQVksTUFBTSxVQUFVLENBQUM7QUFBQSxVQUNsRTtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSxVQUFVLE1BQU07QUFDWixjQUFNLFNBQVMsS0FBSyxPQUFPO0FBQzNCLGFBQUssUUFBUSxJQUFJLE1BQU07QUFDdkIsbUJBQVcsYUFBYSxLQUFLLFlBQVk7QUFDckMsZ0JBQU0sWUFBWSxVQUFVLFNBQVM7QUFDckMsZ0JBQU0sY0FBYyxVQUFVLFNBQVM7QUFDdkMsZ0JBQU0sT0FBTyxZQUFZLFlBQVksY0FBYyxNQUFNLFVBQVUsU0FBUztBQUM1RSxlQUFLLG1CQUFtQixJQUFJLFVBQVUsTUFBTSxNQUFNO0FBQUEsWUFDOUMsUUFBUTtBQUFBLFlBQ1I7QUFBQSxZQUNBO0FBQUEsWUFDQSxPQUFPLFVBQVU7QUFBQSxVQUNyQixDQUFDO0FBQUEsUUFDTDtBQUFBLE1BQ0o7QUFBQSxNQUNBLGNBQWMsTUFBTTtBQUNoQixhQUFLLFlBQVksS0FBSyxJQUFJO0FBQUEsTUFDOUI7QUFBQSxNQUNBLHNCQUFzQixPQUFPLEtBQUs7QUFDOUIsY0FBTSxLQUFLLEtBQUs7QUFDaEIsY0FBTSxNQUFNO0FBQ1osWUFBSSxPQUFPLEtBQUssS0FBSztBQUNyQixjQUFNLFdBQVcsT0FBTyxNQUFNLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQztBQUNwRCxZQUFJLFVBQVU7QUFDVixjQUFJLEVBQUUsUUFBUSxLQUFLLElBQUk7QUFDdkIsY0FBSTtBQUNBLGFBQUMsRUFBRSxRQUFRLEtBQUssSUFBSSxvQkFBb0IsS0FBSyxnQkFBZ0IsRUFBRSxRQUFRLEtBQUssQ0FBQztBQUM3RSxtQkFBTyxLQUFLO0FBQUEsVUFDaEIsU0FDTyxLQUFQO0FBQ0ksaUJBQUssUUFBUSxPQUFPO0FBQUEsY0FDaEIsTUFBTTtBQUFBLGNBQ04sSUFBSSxLQUFLO0FBQUEsY0FDVCxLQUFLO0FBQUEsZ0JBQ0Q7QUFBQSxnQkFDQSxNQUFNLEtBQUs7QUFBQSxnQkFDWDtBQUFBLGNBQ0o7QUFBQSxjQUNBLFNBQVMsc0RBQXNELElBQUk7QUFBQSxjQUNuRTtBQUFBLFlBQ0osQ0FBQztBQUFBLFVBQ0w7QUFDQSw4QkFBb0IsT0FBTyxFQUFFLFFBQVEsS0FBSyxHQUFHLE1BQU0sS0FBSyxFQUFFO0FBQUEsUUFDOUQ7QUFBQSxNQUNKO0FBQUEsTUFDQSwrQkFBK0IsbUJBQW1CO0FBQzlDLG1CQUFXLGFBQWEsa0JBQWtCLE9BQU8sR0FBRztBQUNoRCxnQkFBTSxFQUFFLEdBQUcsSUFBSSxLQUFLLFlBQVksVUFBVTtBQUMxQyxvQkFBVSxTQUFTLEtBQUssTUFBTSxZQUFZLElBQUksRUFBRTtBQUFBLFFBQ3BEO0FBQUEsTUFDSjtBQUFBLE1BQ0Esa0NBQWtDLHNCQUFzQix1QkFBdUIsMkJBQTJCO0FBQ3RHLGNBQU0sc0JBQXNCLG9CQUFJLElBQUk7QUFDcEMsY0FBTSw0QkFBNEIsQ0FBQyx5QkFBeUI7QUFDeEQscUJBQVcsY0FBYyxzQkFBc0I7QUFDM0MsZ0JBQUksb0JBQW9CLElBQUksVUFBVSxHQUFHO0FBQ3JDO0FBQUEsWUFDSjtBQUNBLGdDQUFvQixJQUFJLFVBQVU7QUFDbEMsZ0JBQUksc0JBQXNCLElBQUksVUFBVSxHQUFHO0FBQ3ZDLG1DQUFxQixJQUFJLFVBQVU7QUFDbkM7QUFBQSxZQUNKO0FBQ0EsZ0JBQUksRUFBRSxXQUFXLEtBQUsscUJBQXFCLDBCQUEwQixJQUFJLFVBQVUsSUFBSTtBQUNuRjtBQUFBLFlBQ0o7QUFDQSxnQkFBSSxzQkFBc0Isa0JBQWtCLFdBQVcsV0FBVyxHQUFHO0FBQ2pFLG1DQUFxQixJQUFJLFVBQVU7QUFDbkM7QUFBQSxZQUNKO0FBQ0Esc0NBQTBCLFdBQVcsWUFBWTtBQUFBLFVBQ3JEO0FBQUEsUUFDSjtBQUNBLGtDQUEwQixLQUFLLFlBQVk7QUFDM0Msa0NBQTBCLHlCQUF5QjtBQUFBLE1BQ3ZEO0FBQUEsTUFDQSxrQ0FBa0MsTUFBTSx3QkFBd0IseUJBQXlCO0FBQ3JGLFlBQUksNEJBQTRCO0FBQ2hDLGNBQU0sNEJBQTRCLG9CQUFJLElBQUk7QUFDMUMsY0FBTSw0QkFBNEIsb0JBQUksSUFBSTtBQUMxQyxtQkFBV0EsV0FBVSxLQUFLLGtCQUFrQjtBQUV4QyxjQUFJQSxRQUFPLEtBQUssMEJBQTBCLE1BQU07QUFDNUM7QUFBQSxVQUNKO0FBQ0EsZ0JBQU0sQ0FBQyxVQUFVLGdCQUFnQixJQUFJLGtDQUFrQ0EsU0FBUSxNQUFNLHdCQUF3QixNQUFNLHVCQUF1QjtBQUMxSSxjQUFJQSxtQkFBa0Isa0JBQWtCLGtCQUFrQjtBQUN0RCxzQ0FBMEIsSUFBSSxRQUFRO0FBQUEsVUFDMUMsV0FDUyxvQkFBb0IsOEJBQThCO0FBQ3ZELGdCQUFJLENBQUMsMkJBQTJCO0FBQzVCLDBDQUE0QjtBQUFBLFlBQ2hDO0FBQUEsVUFDSixXQUNTLFVBQVU7QUFDZixzQ0FBMEIsSUFBSSxVQUFVQSxPQUFNO0FBQUEsVUFDbEQ7QUFBQSxRQUNKO0FBQ0EsWUFBSSwwQkFBMEIsT0FBTyxHQUFHO0FBQ3BDLGdCQUFNLHVCQUF1QixDQUFDLEdBQUcseUJBQXlCO0FBQzFELGdCQUFNLGtCQUFrQixxQkFBcUIsR0FBRztBQUNoRCxjQUFJLHFCQUFxQixXQUFXLEdBQUc7QUFDbkMsbUJBQU8sQ0FBQyxlQUFlO0FBQUEsVUFDM0I7QUFDQSxlQUFLLFFBQVEsT0FBTyxxQkFBcUIsTUFBTSxLQUFLLElBQUkscUJBQXFCLElBQUksQ0FBQyxDQUFDLEVBQUVBLE9BQU0sTUFBTUEsUUFBTyxFQUFFLENBQUMsQ0FBQztBQUU1RyxpQkFBTyxDQUFDLElBQUk7QUFBQSxRQUNoQjtBQUNBLFlBQUksMEJBQTBCLE9BQU8sR0FBRztBQUNwQyxnQkFBTSx1QkFBdUIsQ0FBQyxHQUFHLHlCQUF5QjtBQUMxRCxnQkFBTSxrQkFBa0IscUJBQXFCO0FBQzdDLGNBQUkscUJBQXFCLFNBQVMsR0FBRztBQUNqQyxpQkFBSyxRQUFRLE9BQU8sK0JBQStCLE1BQU0sS0FBSyxJQUFJLGdCQUFnQixPQUFPLElBQUkscUJBQXFCLElBQUksaUJBQWUsWUFBWSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBQUEsVUFDaEs7QUFDQSxpQkFBTyxDQUFDLGlCQUFpQixJQUFJO0FBQUEsUUFDakM7QUFDQSxZQUFJLDJCQUEyQjtBQUMzQixpQkFBTyxDQUFDLHlCQUF5QjtBQUFBLFFBQ3JDO0FBQ0EsZUFBTyxDQUFDLElBQUk7QUFBQSxNQUNoQjtBQUFBLE1BQ0EsMENBQTBDO0FBQ3RDLGNBQU0scUJBQXFCLG9CQUFJLElBQUk7QUFDbkMsY0FBTSxzQkFBc0Isb0JBQUksSUFBSTtBQUNwQyxtQkFBV0EsV0FBVSxDQUFDLE1BQU0sR0FBRyxLQUFLLGdCQUFnQixHQUFHO0FBQ25ELGNBQUlBLG1CQUFrQixnQkFBZ0I7QUFDbEMsa0JBQU0sQ0FBQyxnQkFBZ0IsSUFBSUEsUUFBTyx5QkFBeUIsR0FBRztBQUM5RCw2QkFBaUIsUUFBUTtBQUN6QixpQkFBSyxRQUFRLElBQUksZ0JBQWdCO0FBQ2pDLCtCQUFtQixJQUFJLGdCQUFnQjtBQUFBLFVBQzNDLFdBQ1NBLFFBQU8sS0FBSyx1QkFBdUI7QUFDeEMsa0JBQU0scUJBQXFCQSxRQUFPLHNCQUFzQjtBQUN4RCwrQkFBbUIsUUFBUTtBQUMzQixpQkFBSyxRQUFRLElBQUksa0JBQWtCO0FBQ25DLGdDQUFvQixJQUFJLGtCQUFrQjtBQUFBLFVBQzlDO0FBQUEsUUFDSjtBQUNBLGVBQU8sQ0FBQyxHQUFHLHFCQUFxQixHQUFHLGtCQUFrQjtBQUFBLE1BQ3pEO0FBQUEsTUFDQSxxQkFBcUIsTUFBTTtBQUN2QixjQUFNLGFBQWEsS0FBSyxlQUFlLEtBQUssbUJBQWlCLGNBQWMsU0FBUyxJQUFJLEVBQUU7QUFDMUYsWUFBSSxzQkFBc0IsUUFBUTtBQUM5QixxQkFBVyx5QkFBeUIsS0FBSyxJQUFJO0FBQzdDLHFCQUFXLGtCQUFrQixJQUFJO0FBQUEsUUFDckM7QUFBQSxNQUNKO0FBQUEsTUFDQSxnQkFBZ0IsVUFBVTtBQUN0QixZQUFJLENBQUMsU0FBUyxVQUFVO0FBQ3BCLG1CQUFTLFFBQVE7QUFDakIsZUFBSyxNQUFNLHVCQUF1QjtBQUNsQyxnQkFBTSxpQkFBaUIsU0FBUztBQUNoQyxjQUFJLDBCQUEwQixRQUFRO0FBQ2xDLGdCQUFJLENBQUMsZUFBZSxZQUFZO0FBQzVCLHdEQUEwQyxjQUFjO0FBQUEsWUFDNUQ7QUFDQSxnQkFBSSxtQkFBbUIsTUFBTTtBQUN6QixvQkFBTSxvQkFBb0IsOEJBQThCLFVBQVUsSUFBSTtBQUN0RSx5QkFBV0EsV0FBVSxtQkFBbUI7QUFDcEMsb0JBQUksQ0FBQ0EsUUFBTyxZQUFZO0FBQ3BCLDREQUEwQ0EsT0FBTTtBQUFBLGdCQUNwRDtBQUFBLGNBQ0o7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSx3QkFBd0IsVUFBVTtBQUM5QixhQUFLLGdCQUFnQixRQUFRO0FBQzdCLGNBQU0saUJBQWlCLFNBQVM7QUFDaEMsWUFBSSxrQkFBa0IsbUJBQW1CLE1BQU07QUFDM0MsZUFBSyxRQUFRLElBQUksUUFBUTtBQUFBLFFBQzdCO0FBQUEsTUFDSjtBQUFBLE1BQ0Esa0JBQWtCLE1BQU07QUFDcEIsYUFBSyxRQUFRLE9BQU87QUFBQSxVQUNoQixNQUFNO0FBQUEsVUFDTixVQUFVLFdBQVcsS0FBSyxFQUFFO0FBQUEsVUFDNUIsWUFBWTtBQUFBLFVBQ1osU0FBUyxtQkFBbUIsb0NBQW9DLFdBQVcsS0FBSyxFQUFFO0FBQUEsUUFDdEYsQ0FBQztBQUNELGFBQUssUUFBUSxJQUFJLE1BQU0sK0JBQStCO0FBQUEsTUFDMUQ7QUFBQSxJQUNKO0FBeUpBLElBQU0sb0JBQW9CLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLEdBQUcseUJBQXlCLEdBQUFJLEdBQUUsTUFBTTtBQUN4RixVQUFJLGtCQUFrQjtBQUNsQixjQUFNLENBQUMsTUFBTSxLQUFLLElBQUksd0JBQXdCLENBQUMsR0FBRztBQUFBLFVBQzlDLGdCQUFnQjtBQUFBLFVBQ2hCLGlCQUFpQjtBQUFBLFVBQ2pCLE1BQU07QUFBQSxRQUNWLENBQUM7QUFDRCxlQUFRLGlDQUFpQyxNQUFNLEtBQUtBLEtBQzdDLElBQUksZUFBZSxTQUFTQSxLQUM1QixJQUFJLFFBQVEsSUFBSSxPQUFPLFVBQVUsUUFBUUEsS0FBSTtBQUFBLE1BQ3hEO0FBQ0EsYUFBTyxhQUFhLEtBQUssSUFBSTtBQUFBLElBQ2pDO0FBa0VBLElBQU0sV0FBVztBQUFBLE1BQ2IsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLE1BQ1QsV0FBVztBQUFBLE1BQ1gsUUFBUTtBQUFBLE1BQ1IsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLE1BQ1QsVUFBVTtBQUFBLE1BQ1YsYUFBYTtBQUFBLE1BQ2IsUUFBUTtBQUFBLE1BQ1IsZ0JBQWdCO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsTUFBTTtBQUFBLE1BQ04sSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLElBQ1Y7QUEyTUEsSUFBTSxVQUFVLENBQUNzRSxVQUFTLHNCQUFzQkEsU0FBUSxNQUFNLEdBQUcsRUFBRSxJQUFJLGlCQUFpQixFQUFFLEtBQUssRUFBRTtBQW9NakcsSUFBTSxrQkFBa0IsQ0FBQyxFQUFFLGNBQWMsUUFBUSxNQUFNO0FBQ25ELFlBQU0sZUFBZSxJQUFJLElBQUksUUFBUSxJQUFJLFVBQVEsS0FBSyxRQUFRLENBQUM7QUFDL0QsbUJBQWEsSUFBSSxTQUFTO0FBQzFCLGlCQUFXLEVBQUUsVUFBVSxLQUFLLGNBQWM7QUFDdEMsWUFBSSxXQUFXO0FBQ1gscUJBQVcsWUFBWSxXQUFXO0FBQzlCLGdCQUFJLFNBQVMsZUFBZTtBQUN4QiwyQkFBYSxJQUFJLFNBQVMsVUFBVTtBQUFBLFVBQzVDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUNBLElBQU0sdUJBQXVCLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxNQUFNLFdBQVcsR0FBQXRFLEdBQUUsTUFBTSxlQUN2RSxHQUFHQSxLQUFJLElBQUkscUJBQXFCLEtBQUssSUFBSSxVQUFVLENBQUMsR0FBRyxZQUFZLEVBQUUsSUFBSSxVQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUUsQ0FBQyxPQUNsSTtBQUNOLElBQU0seUJBQXlCLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHLEdBQUFBLEdBQUUsTUFBTyxlQUFlLFNBQVMsR0FBR0EsS0FBSSxRQUFRLGVBQWUsS0FBSyxJQUFJLEdBQUcsT0FBTztBQUMxSSxJQUFNLHlCQUF5QixDQUFDLFNBQVMsR0FBRyxhQUFhLGdCQUFnQixRQUFRLE9BQU8sVUFBUSxLQUFLLE9BQU8sRUFBRSxJQUFJLFdBQVMsRUFBRSxNQUFNLEtBQUssVUFBVSxPQUFPLEtBQUssTUFBTSxFQUFFLEdBQUcsR0FBRyxRQUFRO0FBWXBMLElBQU0sMkJBQTJCLENBQUMsU0FBUyxHQUFHLGFBQWEsZ0JBQWdCLFFBQ3RFLE9BQU8sVUFBUSxLQUFLLFVBQVUsRUFDOUIsSUFBSSxXQUFTLEVBQUUsTUFBTSxLQUFLLFVBQVUsT0FBTyxLQUFLLE1BQU0sRUFBRSxHQUFHLEdBQUcsUUFBUTtBQUMzRSxJQUFNLHlCQUF5QixDQUFDLFNBQVMsR0FBRyxhQUFhLGdCQUFnQixRQUNwRSxPQUFPLFVBQVEsS0FBSyxVQUFVLDRCQUE0QixFQUMxRCxJQUFJLFdBQVMsRUFBRSxNQUFNLEtBQUssVUFBVSxPQUFPLDZCQUE2QixFQUFFLEdBQUcsR0FBRyxRQUFRO0FBMkc3RixJQUFNLGFBQWEsRUFBRSxLQUFLLEtBQUssSUFBSSxNQUFNLFFBQVEsSUFBSTtBQUVyRCxJQUFNLFNBQU4sTUFBYTtBQUFBLE1BQ1QsWUFBWSxVQUFVLFNBQVM7QUFDM0IsYUFBSyxhQUFhO0FBQ2xCLGFBQUssV0FBVztBQUNoQixhQUFLLFVBQVU7QUFBQSxNQUNuQjtBQUFBLE1BQ0EsYUFBYSxNQUFNLFFBQVEsTUFBTTtBQUM3QixlQUFPLEVBQUUsUUFBUSxNQUFNLE1BQU0sUUFBUSxLQUFLO0FBQUEsTUFDOUM7QUFBQSxJQUNKO0FBQ0EsSUFBTSxPQUFOLE1BQVc7QUFBQSxNQUNQLFlBQVksS0FBSyxTQUFTO0FBQ3RCLGFBQUssVUFBVTtBQUNmLGFBQUssUUFBUSxJQUFJO0FBQ2pCLGFBQUssV0FBVyxJQUFJO0FBQUEsTUFDeEI7QUFBQSxNQUNBLGdCQUFnQjtBQUNaLGNBQU0sVUFBVSxDQUFDO0FBQ2pCLGNBQU0saUJBQWlCLG9CQUFJLElBQUk7QUFDL0IsY0FBTSxpQkFBaUIsQ0FBQztBQUN4QixjQUFNLFFBQVEsQ0FBQztBQUNmLGNBQU0sZUFBZSxvQkFBSSxJQUFJO0FBQzdCLGNBQU0sV0FBVyxDQUFDO0FBQ2xCLG1CQUFXLFFBQVEsS0FBSyxVQUFVO0FBQzlCLGdCQUFNLGFBQWEsQ0FBQztBQUNwQixxQkFBVyxXQUFXLE1BQU07QUFDeEIsZ0JBQUksUUFBUSxXQUFXO0FBQ25CO0FBQ0osa0JBQU0sU0FBUyxLQUFLLFFBQVEsUUFBUTtBQUNwQyxnQkFBSSxDQUFDO0FBQ0Q7QUFDSixrQkFBTSxTQUFTLE9BQU8sYUFBYSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsV0FBVyxJQUFJLEtBQUssTUFBTSxRQUFRLE1BQU0sRUFBRTtBQUM3RyxnQkFBSSxRQUFRO0FBQ1Isb0JBQU0sRUFBRSxRQUFRLE1BQUF1RSxPQUFNLE1BQU0sUUFBUSxFQUFFLFNBQVMsU0FBUyxFQUFFLElBQUk7QUFDOUQsa0JBQUksY0FBYyxlQUFlLElBQUksUUFBUTtBQUM3QyxrQkFBSSxnQkFBZ0IsUUFBVztBQUMzQiw4QkFBYyxRQUFRO0FBQ3RCLHdCQUFRLEtBQUssUUFBUTtBQUNyQiwrQkFBZSxJQUFJLFVBQVUsV0FBVztBQUN4QywrQkFBZSxlQUFlO0FBQUEsY0FDbEMsV0FDUyxlQUFlLGdCQUFnQixNQUFNO0FBQzFDLCtCQUFlLGVBQWU7QUFBQSxjQUNsQyxXQUNTLFdBQVcsUUFBUSxlQUFlLGlCQUFpQixTQUFTO0FBQ2pFLHVCQUFPLE1BQU07QUFBQSxrQkFDVCxTQUFTLHNEQUFzRDtBQUFBLGdCQUNuRSxDQUFDO0FBQUEsY0FDTDtBQUNBLG9CQUFNLGdCQUFnQixDQUFDLFFBQVEsSUFBSSxhQUFhQSxPQUFNLE1BQU07QUFDNUQsa0JBQUksTUFBTTtBQUNOLG9CQUFJLFlBQVksYUFBYSxJQUFJLElBQUk7QUFDckMsb0JBQUksY0FBYyxRQUFXO0FBQ3pCLDhCQUFZLE1BQU07QUFDbEIsd0JBQU0sS0FBSyxJQUFJO0FBQ2YsK0JBQWEsSUFBSSxNQUFNLFNBQVM7QUFBQSxnQkFDcEM7QUFDQSw4QkFBYyxLQUFLO0FBQUEsY0FDdkI7QUFDQSx5QkFBVyxLQUFLLGFBQWE7QUFBQSxZQUNqQztBQUFBLFVBQ0o7QUFDQSxtQkFBUyxLQUFLLFVBQVU7QUFBQSxRQUM1QjtBQUNBLGVBQU8sRUFBRSxVQUFVLE9BQU8sU0FBUyxlQUFlO0FBQUEsTUFDdEQ7QUFBQSxNQUNBLGFBQWEsTUFBTSxRQUFRLE1BQU07QUFDN0IsY0FBTSxXQUFXLEtBQUssU0FBUztBQUMvQixZQUFJLENBQUM7QUFDRCxpQkFBTztBQUVYLFlBQUksY0FBYztBQUNsQixZQUFJLFlBQVksU0FBUyxTQUFTO0FBQ2xDLGVBQU8sZUFBZSxXQUFXO0FBQzdCLGdCQUFNLElBQUssY0FBYyxhQUFjO0FBQ3ZDLGdCQUFNLFVBQVUsU0FBUztBQUl6QixjQUFJLFFBQVEsT0FBTyxVQUFVLGdCQUFnQixXQUFXO0FBQ3BELGdCQUFJLFFBQVEsVUFBVTtBQUNsQixxQkFBTztBQUNYLGtCQUFNLFNBQVMsS0FBSyxRQUFRLFFBQVE7QUFDcEMsZ0JBQUksQ0FBQztBQUNELHFCQUFPO0FBQ1gsbUJBQU8sT0FBTyxhQUFhLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxXQUFXLElBQUksS0FBSyxNQUFNLFFBQVEsTUFBTSxJQUFJO0FBQUEsVUFDM0c7QUFDQSxjQUFJLFFBQVEsS0FBSyxRQUFRO0FBQ3JCLHdCQUFZLElBQUk7QUFBQSxVQUNwQixPQUNLO0FBQ0QsMEJBQWMsSUFBSTtBQUFBLFVBQ3RCO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsSUFDSjtBQTREQSxJQUFNLGFBQWEsVUFBTSxjQUFBQyxZQUFhLFFBQVE7QUFFOUMsSUFBTSwwQ0FBMEM7QUFBQSxNQUM1QyxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixLQUFLO0FBQUEsSUFDVDtBQStHQSxJQUFNLG1CQUFtQjtBQUN6QixJQUFNLG9CQUFvQjtBQUMxQixJQUFNLGlCQUFpQjtBQXNNdkIsSUFBTSx1QkFBdUIsQ0FBQyxPQUFPLFFBQVEsT0FBTyxNQUFNO0FBZ0IxRCxJQUFNdEQsU0FBTixNQUFZO0FBQUEsTUFDUixZQUFZLGdCQUFnQixjQUFjLGVBQWUsY0FBYyxjQUFjLGFBQWEsZUFBZSxxQkFBcUIsb0JBQW9CLGtCQUFrQjtBQUN4SyxhQUFLLGlCQUFpQjtBQUN0QixhQUFLLGVBQWU7QUFDcEIsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSyxlQUFlO0FBQ3BCLGFBQUssZUFBZTtBQUNwQixhQUFLLGNBQWM7QUFDbkIsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSyxzQkFBc0I7QUFDM0IsYUFBSyxxQkFBcUI7QUFDMUIsYUFBSyxtQkFBbUI7QUFDeEIsYUFBSyxlQUFlLENBQUM7QUFDckIsYUFBSyxhQUFhO0FBQ2xCLGFBQUssZUFBZTtBQUNwQixhQUFLLEtBQUs7QUFDVixhQUFLLHdCQUF3QjtBQUM3QixhQUFLLG1CQUFtQjtBQUN4QixhQUFLLGVBQWU7QUFDcEIsYUFBSyx5QkFBeUIsb0JBQUksSUFBSTtBQUN0QyxhQUFLLGVBQWUsb0JBQUksSUFBSTtBQUM1QixhQUFLLHNCQUFzQixvQkFBSSxJQUFJO0FBQ25DLGFBQUssc0JBQXNCLENBQUM7QUFDNUIsYUFBSyxjQUFjO0FBQ25CLGFBQUssd0JBQXdCLG9CQUFJLElBQUk7QUFDckMsYUFBSyxVQUFVLG9CQUFJLElBQUk7QUFDdkIsYUFBSyxnQkFBZ0Isb0JBQUksSUFBSTtBQUM3QixhQUFLLFdBQVc7QUFDaEIsYUFBSyx1QkFBdUIsQ0FBQztBQUM3QixhQUFLLHlCQUF5QixvQkFBSSxJQUFJO0FBQ3RDLGFBQUssVUFBVSxvQkFBSSxJQUFJO0FBQ3ZCLGFBQUssZUFBZTtBQUVwQixhQUFLLFVBQVU7QUFDZixhQUFLLE9BQU87QUFDWixhQUFLLHVCQUF1QjtBQUM1QixhQUFLLGtCQUFrQjtBQUN2QixhQUFLLGVBQWU7QUFDcEIsYUFBSyx3QkFBd0Isb0JBQUksSUFBSTtBQUNyQyxhQUFLLGtCQUFrQix1QkFBTyxPQUFPLElBQUk7QUFDekMsYUFBSyxpQkFBaUI7QUFDdEIsYUFBSyxvQkFBb0I7QUFDekIsYUFBSyxlQUFlO0FBQ3BCLGFBQUssY0FBYztBQUNuQixhQUFLLFlBQVksZUFBZSxTQUFTLElBQUksZUFBZSxHQUFHLFlBQVk7QUFDM0UsY0FBTSxlQUFlLElBQUksSUFBSSxjQUFjO0FBQzNDLG1CQUFXdEIsV0FBVSxnQkFBZ0I7QUFDakMsY0FBSUEsUUFBTyxVQUFVLFVBQVU7QUFDM0IsK0JBQW1CLElBQUlBLE9BQU07QUFBQSxVQUNqQztBQUNBLGNBQUksS0FBSyxXQUFXQSxRQUFPLFdBQVcsR0FBRztBQUNyQyxpQkFBSyxVQUFVO0FBQUEsVUFDbkI7QUFDQSxjQUFJQSxRQUFPLEtBQUssV0FBVyxjQUFjLGlCQUFpQjtBQUN0RCxpQkFBSyxhQUFhLEtBQUtBLE9BQU07QUFBQSxVQUNqQztBQUNBLHFCQUFXLFlBQVlBLFFBQU8sMEJBQTBCO0FBQ3BELGdCQUFJLENBQUMsYUFBYSxJQUFJLFFBQVEsR0FBRztBQUM3QixtQkFBSyxvQkFBb0IsS0FBS0EsT0FBTTtBQUVwQyxrQkFBSUEsUUFBTyxLQUFLLHlCQUF5QixDQUFDLGNBQWMsaUJBQWlCO0FBQ3JFLG1DQUFtQixJQUFJQSxPQUFNO0FBQzdCLHFCQUFLLFFBQVEsSUFBSUEsUUFBTyxTQUFTO0FBQUEsY0FDckM7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUNBLGNBQUlBLFFBQU8sc0JBQXNCLE9BQU8sR0FBRztBQUN2QyxpQkFBSyxxQkFBcUIsS0FBS0EsT0FBTTtBQUFBLFVBQ3pDO0FBQUEsUUFDSjtBQUNBLGFBQUssd0JBQXdCLFVBQVUsS0FBSyxxQkFBcUIsQ0FBQztBQUFBLE1BQ3RFO0FBQUEsTUFDQSxPQUFPLGVBQWUsY0FBYyxlQUFlLGNBQWMsY0FBYyxhQUFhLGVBQWUscUJBQXFCLG9CQUFvQixlQUFlLFlBQVk7QUFDM0ssY0FBTSxRQUFRLElBQUlzQixPQUFNLENBQUMsR0FBRyxjQUFjLGVBQWUsY0FBYyxjQUFjLGFBQWEsZUFBZSxxQkFBcUIsb0JBQW9CLElBQUk7QUFDOUosY0FBTSxpQkFBaUIsWUFBWSxhQUFhO0FBQ2hELFlBQUksQ0FBQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDekMsOEJBQW9CLElBQUksZUFBZSxLQUFLO0FBQUEsUUFDaEQ7QUFDQSxtQkFBVyxjQUFjLGNBQWMsNEJBQTRCLEdBQUc7QUFDbEUsZ0JBQU0sYUFBYSxJQUFJLHNCQUFzQixTQUFTLGNBQWMsSUFBSSxVQUFVLElBQUksVUFBVTtBQUFBLFFBQ3BHO0FBQ0EsWUFBSSxDQUFDLE1BQU0sYUFBYSxJQUFJLGNBQWMsSUFBSSxhQUFhLENBQUMsS0FDeEQsY0FBYyxLQUFLLHFCQUNuQixjQUFjLFdBQVcsR0FBRztBQUM1QixnQkFBTSxhQUFhLElBQUksY0FBYyxJQUFJLGFBQWEsQ0FBQztBQUFBLFFBQzNEO0FBQ0EsY0FBTSxxQ0FBcUMsYUFBYTtBQUN4RCxjQUFNLGVBQWU7QUFDckIsY0FBTSxlQUFlO0FBQ3JCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxrQkFBa0J0QixTQUFRLGtCQUFrQjtBQUN4QyxjQUFNLDhCQUE4QkEsUUFBTyx5QkFBeUI7QUFDcEUsbUJBQVcsbUJBQW1CLEtBQUssU0FBUztBQUN4QyxjQUFJLENBQUMsNEJBQTRCLElBQUksZUFBZSxHQUFHO0FBQ25ELGdCQUFJLDRCQUE0QixTQUFTLEtBQ3JDQSxRQUFPLDJCQUNQQSxRQUFPLHNCQUFzQixZQUM3QixLQUFLLGFBQWEsSUFBSSx5QkFBeUIsR0FBRztBQUNsRCxtQkFBSyxhQUFhLE9BQU87QUFBQSxnQkFDckIsTUFBTTtBQUFBLGdCQUNOLElBQUlBLFFBQU87QUFBQSxnQkFDWCxTQUFTLHlEQUF5RCxXQUFXQSxRQUFPLEVBQUU7QUFBQSxnQkFDdEYsS0FBSztBQUFBLGNBQ1QsQ0FBQztBQUFBLFlBQ0w7QUFDQSxtQkFBTztBQUFBLFVBQ1g7QUFBQSxRQUNKO0FBQ0EsbUJBQVcsbUJBQW1CLGtCQUFrQjtBQUM1QyxjQUFJLEVBQUUsNEJBQTRCLElBQUksZUFBZSxLQUFLLGdCQUFnQixXQUFXQSxVQUFTO0FBQzFGLG1CQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0Esa0JBQWtCO0FBQ2QsYUFBSyxvQkFBb0I7QUFDekIsY0FBTSxtQkFBbUIsSUFBSSxJQUFJLEtBQUssT0FBTztBQUM3QyxZQUFJLEtBQUssaUJBQWlCLFNBQ3JCLEtBQUssYUFBYSxzQkFBc0IsU0FBUyxLQUFLLGVBQWU7QUFDdEUsZ0JBQU0sd0JBQXdCLEtBQUssYUFBYSx5QkFBeUI7QUFDekUscUJBQVcsQ0FBQyxVQUFVLFdBQVcsS0FBSyx1QkFBdUI7QUFDekQsaUJBQUssc0JBQXNCLElBQUksVUFBVSxDQUFDLEdBQUcsV0FBVyxDQUFDO0FBQ3pELHVCQUFXLGNBQWMsYUFBYTtBQUNsQyxtQkFBSyxjQUFjLElBQUksWUFBWSxRQUFRO0FBQUEsWUFDL0M7QUFDQSw2QkFBaUIsT0FBTyxRQUFRO0FBQUEsVUFDcEM7QUFBQSxRQUNKO0FBQ0EsWUFBSSxLQUFLLGNBQWMsdUJBQXVCO0FBQzFDLHNDQUE0QixrQkFBa0IsS0FBSyxlQUFlLEtBQUsscUJBQXFCO0FBQUEsUUFDaEcsT0FDSztBQUNELCtCQUFxQixrQkFBa0IsS0FBSyxlQUFlLEtBQUsscUJBQXFCO0FBQUEsUUFDekY7QUFDQSxZQUFJLEtBQUssY0FBYyxtQkFBb0IsS0FBSyxnQkFBZ0IsS0FBSyxhQUFhLEtBQUs7QUFDbkYsZUFBSyxhQUFhLGNBQWMsTUFBTSxLQUFLLGVBQWUsS0FBSyxjQUFjLEtBQUssYUFBYSxJQUFJLEtBQUssYUFBYSxNQUFNO0FBQUEsTUFDbkk7QUFBQSxNQUNBLGtCQUFrQjtBQUNkLFlBQUk7QUFDSixjQUFNLFVBQVUsQ0FBQztBQUNqQixjQUFNLGVBQWUsb0JBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxjQUFjLEdBQUcsS0FBSyxvQkFBb0IsQ0FBQztBQUNqRixjQUFNLG1CQUFtQixJQUFJLElBQUksS0FBSyxvQkFBb0IsSUFBSSxDQUFDLEVBQUUsVUFBVSxNQUFNLFNBQVMsQ0FBQztBQUMzRixtQkFBV0EsV0FBVSxjQUFjO0FBQy9CLGNBQUlBLFFBQU8sbUJBQW1CO0FBQzFCLHVCQUFXLG9CQUFvQkEsUUFBTyx5QkFBeUIsRUFBRSxLQUFLLEdBQUc7QUFDckUsK0JBQWlCLElBQUksZ0JBQWdCO0FBQUEsWUFDekM7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLG1CQUFXQSxXQUFVLGNBQWM7QUFDL0IsZ0JBQU0sa0JBQWtCLE1BQU07QUFBQSxZQUFLLElBQUksSUFBSUEsUUFBTyxXQUFXLE9BQU8sQ0FBQyxFQUFFLGNBQWMsTUFBTSxhQUFhLEVBQUUsSUFBSSxDQUFDLEVBQUUsS0FBSyxNQUFNLElBQUksQ0FBQztBQUFBLFlBRWpJLFdBQVM7QUFBQSxjQUNMO0FBQUEsWUFDSjtBQUFBLFVBQUU7QUFDRixjQUFJLGdCQUFnQixXQUFXLEtBQUtBLFFBQU8seUJBQXlCO0FBQ2hFLDRCQUFnQixLQUFLLENBQUMsQ0FBQztBQUFBLFVBQzNCO0FBQ0EsMEJBQWdCLEtBQUssR0FBRyxNQUFNLEtBQUtBLFFBQU8sZ0JBQWdCLGVBQWEsRUFBRSxTQUFTLEVBQUUsQ0FBQztBQUNyRixjQUFJLGdCQUFnQixXQUFXLEdBQUc7QUFDOUIsNEJBQWdCLEtBQUssQ0FBQyxDQUFDO0FBQUEsVUFDM0I7QUFDQSxjQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGtCQUFNLG9CQUFvQkEsUUFBTyxzQkFBc0IsWUFDbERBLFFBQU8sc0JBQXNCLGtCQUMxQkEsUUFBTyx5QkFBeUIsRUFBRSxTQUFTO0FBQ25ELGdCQUFJLENBQUMscUJBQ0QsS0FBSyxjQUFjLG1CQUNuQixLQUFLLGtCQUFrQkEsU0FBUSxnQkFBZ0IsR0FBRztBQUNsRCxtQkFBSyxlQUFlQTtBQUNwQixtQkFBSyxvQkFBb0IsSUFBSUEsU0FBUSxJQUFJO0FBQ3pDLGtCQUFJQSxRQUFPLG1CQUFtQjtBQUMxQixxQkFBSyxlQUFlO0FBQUEsY0FDeEI7QUFDQSxtQkFBSyxpQkFBaUIsZ0JBQWdCLE1BQU0sR0FBR0EsT0FBTTtBQUFBLFlBQ3pEO0FBQUEsVUFDSjtBQUNBLHFCQUFXLGNBQWMsaUJBQWlCO0FBQ3RDLG9CQUFRLEtBQUtzQixPQUFNLGVBQWUsS0FBSyxjQUFjLEtBQUssZUFBZSxLQUFLLGNBQWMsS0FBSyxjQUFjLEtBQUssYUFBYSxLQUFLLGVBQWUsS0FBSyxxQkFBcUIsS0FBSyxvQkFBb0J0QixTQUFRLFVBQVUsQ0FBQztBQUFBLFVBQy9OO0FBQUEsUUFDSjtBQUNBLG1CQUFXQSxXQUFVLEtBQUsscUJBQXFCO0FBQzNDLGNBQUlBLFFBQU8sS0FBSztBQUNaO0FBQ0osY0FBSSxDQUFDLEtBQUssZ0JBQWdCLEtBQUssa0JBQWtCQSxTQUFRLGdCQUFnQixHQUFHO0FBQ3hFLGlCQUFLLGVBQWVBO0FBQ3BCLGlCQUFLLG9CQUFvQixJQUFJQSxTQUFRLElBQUk7QUFDekMsaUJBQUssZUFBZTtBQUNwQixpQkFBSyxjQUFjLHVCQUF1QkEsT0FBTTtBQUFBLFVBQ3BELFdBQ1MsS0FBSyxpQkFBaUJBLFdBQzNCLENBQUMsS0FBSyxnQkFDTixLQUFLLGtCQUFrQkEsU0FBUSxnQkFBZ0IsR0FBRztBQUNsRCxpQkFBSyxlQUFlO0FBQUEsVUFDeEIsV0FDUyxHQUFHLEtBQUssS0FBSyxvQkFBb0IsSUFBSUEsT0FBTSxPQUFPLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxlQUFlO0FBQzFHLGlCQUFLLG1CQUFtQixJQUFJQSxPQUFNO0FBQ2xDLGlCQUFLLFFBQVEsSUFBSUEsUUFBTyxTQUFTO0FBQUEsVUFDckM7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFdBQVcsUUFBUSxTQUFTLGVBQWUsYUFBYTtBQUNwRCxZQUFJLEtBQUssYUFBYSxNQUFNO0FBQ3hCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLGNBQU0sQ0FBQyxTQUFTLFdBQVcsSUFBSSxLQUFLLGdCQUFnQixLQUFLLGFBQWEsMEJBQ2hFLENBQUMsUUFBUSxnQkFBZ0IsdUJBQXVCLElBQ2hELENBQUMsUUFBUSxnQkFBZ0IsdUJBQXVCO0FBQ3RELGVBQU8sV0FBVyxrQkFBa0IsT0FBTyxZQUFZLGFBQWEsUUFBUSxLQUFLLGFBQWEsQ0FBQyxJQUFJLFNBQVMsYUFBYTtBQUFBLFVBQ3JILFFBQVEsTUFBTSxRQUFRO0FBQUEsVUFDdEIsTUFBTSxNQUFNLGNBQ04sS0FBSyxtQ0FBbUMsUUFBUSxTQUFTLGFBQWEsSUFDdEU7QUFBQSxVQUNOLE1BQU0sTUFBTSxLQUFLLGFBQWE7QUFBQSxRQUNsQyxDQUFDLEdBQUcsYUFBYTtBQUFBLE1BQ3JCO0FBQUEsTUFDQSwwQkFBMEIsNEJBQTRCLFNBQVMsZUFBZSxjQUFjO0FBQ3hGLGNBQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLEtBQUs7QUFDdEIsY0FBTSxjQUFjLEtBQUssY0FBYyxpQkFBaUIsR0FBRyxNQUFNLGtCQUFrQixDQUFDLEVBQUUsRUFBRTtBQUN4RixZQUFJSDtBQUNKLGNBQU0sYUFBYSxhQUFhLElBQUksZ0JBQWdCLElBQzlDLDRCQUNBLFFBQVE7QUFDZCxjQUFNLFVBQVUsT0FBTyxlQUFlLGFBQWEsV0FBVyxLQUFLLGFBQWEsQ0FBQyxJQUFJO0FBQ3JGLFlBQUksV0FBVyxXQUFXLEdBQUc7QUFDekIsZ0JBQU0saUJBQWEscUJBQVEsV0FBVztBQUN0QyxnQkFBTSxnQkFBWSxxQkFBUSxXQUFXO0FBQ3JDLGdCQUFNLFdBQVcsa0JBQWtCLFNBQVMseUJBQXlCO0FBQUEsWUFDakUsY0FBYyxNQUFPLHFCQUFxQixTQUFTLFNBQVMsSUFBSSxLQUFLO0FBQUEsWUFDckUsS0FBSyxNQUFNLFVBQVUsVUFBVSxDQUFDO0FBQUEsWUFDaEMsU0FBUyxNQUFNO0FBQUEsWUFDZixRQUFRLE1BQU0sUUFBUTtBQUFBLFlBQ3RCLE1BQU0sTUFBTSxLQUFLLGFBQWE7QUFBQSxVQUNsQyxDQUFDO0FBQ0QsZ0JBQU0sY0FBYyxHQUFHLGNBQWM7QUFDckMsZ0JBQU0sRUFBRSxvQkFBb0IsSUFBSTtBQUNoQyxjQUFJLHVCQUF1QixZQUFZLFdBQVcsbUJBQW1CLEdBQUc7QUFDcEUsWUFBQUEsUUFBTyxZQUFZLE1BQU0sb0JBQW9CLE1BQU0sRUFBRSxRQUFRLFVBQVUsRUFBRTtBQUFBLFVBQzdFLE9BQ0s7QUFDRCxZQUFBQSxRQUFPLFNBQVMsNEJBQTRCLFdBQVc7QUFBQSxVQUMzRDtBQUFBLFFBQ0osT0FDSztBQUNELGdCQUFNLGdCQUFZLHFCQUFRLFdBQVc7QUFDckMsZ0JBQU0sV0FBVyxrQkFBa0IsU0FBUyx5QkFBeUI7QUFBQSxZQUNqRSxjQUFjLE1BQU8scUJBQXFCLFNBQVMsU0FBUyxJQUFJLEtBQUs7QUFBQSxZQUNyRSxLQUFLLE1BQU0sVUFBVSxVQUFVLENBQUM7QUFBQSxZQUNoQyxTQUFTLE1BQU07QUFBQSxZQUNmLFFBQVEsTUFBTSxRQUFRO0FBQUEsWUFDdEIsTUFBTSxNQUFNLGFBQWEsV0FBVztBQUFBLFVBQ3hDLENBQUM7QUFDRCxVQUFBQSxRQUFPLFlBQVk7QUFBQSxRQUN2QjtBQUNBLGVBQU8sV0FBVyxVQUFVQSxLQUFJLEdBQUcsYUFBYTtBQUFBLE1BQ3BEO0FBQUEsTUFDQSxlQUFlO0FBQ1gsY0FBTSxlQUFlLEtBQUs7QUFDMUIsY0FBTSxlQUFlLEtBQUssYUFBYSxLQUFLLElBQUk7QUFDaEQsZUFBTztBQUFBLFVBQ0gsU0FBUyxLQUFLLGVBQWU7QUFBQSxVQUM3QixnQkFBZ0IsZ0JBQWdCLGFBQWE7QUFBQSxVQUM3QyxnQkFBZ0IsS0FBSyxvQkFBb0IsU0FBUztBQUFBLFVBQ2xELFNBQVMsaUJBQWlCLFFBQVEsYUFBYSxLQUFLO0FBQUEsVUFDcEQsaUJBQWlCLEtBQUsscUJBQXFCLFNBQVM7QUFBQSxVQUNwRCxTQUFTLEtBQUs7QUFBQSxVQUNkLElBQUksT0FBTztBQUNQLG1CQUFPLGFBQWE7QUFBQSxVQUN4QjtBQUFBLFVBQ0EsTUFBTTtBQUFBLFFBQ1Y7QUFBQSxNQUNKO0FBQUEsTUFDQSw0QkFBNEI7QUFDeEIsZUFBTyxPQUFPLE9BQU8sS0FBSyxhQUFhLEdBQUc7QUFBQSxVQUN0QyxNQUFNO0FBQUEsVUFDTixnQkFBZ0IsTUFBTSxLQUFLLEtBQUsscUJBQXFCLEtBQUs7QUFBQSxVQUMxRCxVQUFVLEtBQUs7QUFBQSxVQUNmLHdCQUF3QixNQUFNLEtBQUssS0FBSyx3QkFBd0IsS0FBSztBQUFBLFVBQ3JFLGtCQUFrQixLQUFLLGlDQUFpQztBQUFBLFVBQ3hELFNBQVMsTUFBTSxLQUFLLEtBQUssY0FBYyxLQUFLO0FBQUEsVUFDNUMsS0FBSztBQUFBLFVBQ0wsaUJBQWlCLEtBQUssbUJBQW1CO0FBQUEsUUFDN0MsQ0FBQztBQUFBLE1BQ0w7QUFBQSxNQUNBLGVBQWU7QUFDWCxZQUFJO0FBQ0osZ0JBQVMsS0FBSyxLQUFLLFVBQVUsUUFBUSxPQUFPLFNBQVMsS0FBTSxLQUFLLE9BQU8sS0FBSyxjQUFjLGlCQUFpQixLQUFLLHFCQUFxQixDQUFDO0FBQUEsTUFDMUk7QUFBQSxNQUNBLGlCQUFpQjtBQUNiLFlBQUk7QUFDSixnQkFBUyxLQUFLLEtBQUssdUJBQXVCLFFBQVEsT0FBTyxTQUFTLEtBQU0sS0FBSyxvQkFBb0IsTUFBTSxLQUFLLEtBQUssY0FBYyxLQUFLLENBQUMsRUFBRSxLQUFLO0FBQUEsTUFDaEo7QUFBQSxNQUNBLGtCQUFrQjtBQUNkLFlBQUksS0FBSztBQUNMLGlCQUFPLEtBQUs7QUFDaEIsY0FBTSxPQUFPLFdBQVc7QUFDeEIsY0FBTSxtQkFBbUIsS0FBSyxhQUFhLG9CQUFvQixvQkFBb0IsSUFBSSxDQUFDLEtBQUssYUFBYSxDQUFDLEdBQUcsQ0FBQyxjQUFjLGVBQWU7QUFDeEksY0FBSSxZQUFZO0FBQ1osNEJBQWdCO0FBQUEsVUFDcEI7QUFDQSxpQkFBTztBQUFBLFFBQ1gsQ0FBQztBQUNELGFBQUssT0FBTyxnQkFBZ0I7QUFDNUIsYUFBSyxPQUFPLEtBQUssZUFBZSxTQUFTLENBQUM7QUFDMUMsYUFBSyxPQUFPLEtBQUssZUFBZSxFQUMzQixJQUFJLGdCQUFjO0FBQ25CLGdCQUFNLFdBQVcsS0FBSyxjQUFjLElBQUksVUFBVTtBQUNsRCxpQkFBTyxHQUFHLFdBQVcsU0FBUyxPQUFPLEVBQUUsRUFBRSxRQUFRLE9BQU8sR0FBRyxLQUFLLFNBQVMsUUFBUTtBQUFBLFFBQ3JGLENBQUMsRUFDSSxLQUFLLEdBQUcsQ0FBQztBQUNkLGVBQVEsS0FBSyxlQUFlLEtBQUssT0FBTyxLQUFLO0FBQUEsTUFDakQ7QUFBQSxNQUNBLHNCQUFzQixVQUFVO0FBQzVCLFlBQUksS0FBSyxjQUFjLG1CQUFtQixvQkFBb0IsbUJBQW1CO0FBQzdFLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU8sS0FBSyxzQkFBc0IsSUFBSSxRQUFRLEVBQUU7QUFBQSxNQUNwRDtBQUFBLE1BQ0EsT0FBTztBQUNILGFBQUssZUFBZSxzQkFBc0IsTUFBTSxLQUFLLGdCQUFnQixLQUFLLGFBQWE7QUFDdkYsbUJBQVdHLFdBQVUsS0FBSyxnQkFBZ0I7QUFDdEMsZUFBSyx1QkFBdUJBLFFBQU8scUJBQXFCLEtBQUssbUJBQW1CO0FBQ2hGLGVBQUssdUJBQXVCQSxRQUFPLHdCQUF3QixLQUFLLHNCQUFzQjtBQUN0RixlQUFLLHFDQUFxQ0EsT0FBTTtBQUFBLFFBQ3BEO0FBQUEsTUFDSjtBQUFBLE1BRUEsVUFBVSxTQUFTLFdBQVcsVUFBVTtBQUNwQyxjQUFNLEVBQUUsR0FBRyxtQkFBbUIsR0FBQUksR0FBRSxJQUFJO0FBQ3BDLGNBQU0sY0FBYyxJQUFJLFNBQVMsRUFBRSxXQUFXLEdBQUdBLEtBQUlBLEtBQUksQ0FBQztBQUMxRCxhQUFLLGNBQWMsQ0FBQztBQUNwQixhQUFLLGVBQWVPLGlCQUFnQixLQUFLLGdCQUFnQixPQUFPO0FBQ2hFLGNBQU0sZ0JBQWdCO0FBQUEsVUFDbEIsdUJBQXVCLFFBQVE7QUFBQSxVQUMvQix1QkFBdUIsS0FBSztBQUFBLFVBQzVCLFFBQVEsUUFBUTtBQUFBLFVBQ2hCLFFBQVEsUUFBUTtBQUFBLFVBQ2hCLFFBQVEsS0FBSztBQUFBLFVBQ2Isc0JBQXNCLFFBQVE7QUFBQSxVQUM5QixvQkFBb0IsS0FBSztBQUFBLFVBQ3pCO0FBQUEsUUFDSjtBQUVBLFlBQUksUUFBUSwwQkFDUixDQUFDLEtBQUssY0FBYyxtQkFDcEIsS0FBSyxpQkFBaUIsTUFBTTtBQUM1QixxQkFBVyxPQUFPLEtBQUssY0FBYztBQUNqQyxnQkFBSSxlQUFlVztBQUNmLG1CQUFLLHdCQUF3QixHQUFHO0FBQUEsVUFDeEM7QUFBQSxRQUNKO0FBQ0EsYUFBSywyQkFBMkIsUUFBUTtBQUN4QyxhQUFLLCtCQUErQixPQUFPO0FBQzNDLFlBQUksZ0JBQWdCO0FBQ3BCLGNBQU0sa0JBQWtCLEtBQUs7QUFDN0IsbUJBQVd0QixXQUFVLEtBQUssZ0JBQWdCO0FBQ3RDLGNBQUksaUJBQWlCO0FBQ3JCLGNBQUlBLFFBQU8sV0FBVyxLQUFLLEtBQUssbUJBQW1CLElBQUlBLE9BQU0sR0FBRztBQUM1RCxrQkFBTSxTQUFTQSxRQUFPLE9BQU8sYUFBYSxFQUFFLEtBQUs7QUFDakQsNkJBQWlCLE9BQU8sT0FBTztBQUMvQixnQkFBSSxnQkFBZ0I7QUFDaEIsa0JBQUksUUFBUSxXQUFXLE9BQU8sU0FBUyxFQUFFLFNBQVMsSUFBSTtBQUNsRCx1QkFBTyxPQUFPLElBQUk7QUFDdEIsbUJBQUssc0JBQXNCLElBQUlBLFNBQVEsTUFBTTtBQUM3QywwQkFBWSxVQUFVLE1BQU07QUFDNUIsbUJBQUssWUFBWSxLQUFLQSxPQUFNO0FBQUEsWUFDaEM7QUFDQSxrQkFBTSxZQUFZQSxRQUFPO0FBQ3pCLGdCQUFJLEtBQUssbUJBQW1CLElBQUlBLE9BQU0sS0FBSyxDQUFDLEtBQUssY0FBYyxpQkFBaUI7QUFDNUUsb0JBQU0sV0FBVyxVQUFVLFlBQVksYUFBYTtBQUNwRCxrQkFBSSxVQUFVLFlBQVk7QUFDdEIsaUNBQWlCSSxLQUFJO0FBQUE7QUFFckIsNEJBQVksVUFBVSxJQUFJLGNBQWMsUUFBUSxDQUFDO0FBQUEsWUFDekQ7QUFBQSxVQUNKO0FBQ0EsZ0JBQU0sRUFBRSxpQkFBaUIsZUFBZSxJQUFJSixRQUFPLG1CQUFtQjtBQUN0RSxnQkFBTSxFQUFFLHNCQUFzQixJQUFJO0FBQ2xDLDBCQUFnQkEsUUFBTyxNQUFNO0FBQUEsWUFDekIsSUFBSSxPQUFPO0FBQ1Asa0JBQUksSUFBSTtBQUNSLHNCQUFRLE1BQU0sS0FBSyxzQkFBc0IsSUFBSUEsT0FBTSxPQUFPLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxTQUFTLE9BQU8sUUFBUSxPQUFPLFNBQVMsS0FBSztBQUFBLFlBQy9JO0FBQUEsWUFDQSxnQkFBZ0JBLFFBQU8sYUFBYTtBQUFBLFlBQ3BDO0FBQUEsWUFDQTtBQUFBLFlBQ0E7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLFlBQUk7QUFDQSxzQkFBWSxRQUFRLGdCQUFnQkksS0FBSUEsRUFBQztBQUM3QyxZQUFJLEtBQUssa0JBQWtCO0FBQ3ZCLHNCQUFZLFFBQVEsR0FBR0EsS0FBSSxTQUFTLFFBQVEsK0JBQStCLEtBQUssV0FBV0EsS0FBSUEsSUFBRztBQUFBLFFBQ3RHO0FBQ0EsWUFBSSxRQUFRLFNBQVM7QUFDakIsZUFBSyxpQkFBaUI7QUFBQSxRQUMxQixPQUNLO0FBQ0QsZUFBSyxpQkFBaUIsWUFBWSxLQUFLO0FBQUEsUUFDM0M7QUFDQSxhQUFLLGVBQWU7QUFDcEIsWUFBSSxLQUFLLFdBQVcsS0FBSyxlQUFlLEVBQUUsV0FBVyxLQUFLLEtBQUssYUFBYSxTQUFTLEdBQUc7QUFDcEYsZ0JBQU0sWUFBWSxLQUFLLGFBQWE7QUFDcEMsZUFBSyxhQUFhLE9BQU87QUFBQSxZQUNyQjtBQUFBLFlBQ0EsTUFBTTtBQUFBLFlBQ04sU0FBUyw4QkFBOEI7QUFBQSxVQUMzQyxDQUFDO0FBQUEsUUFDTDtBQUNBLGFBQUssdUJBQXVCLFNBQVMsU0FBUztBQUM5QyxhQUFLLHVCQUF1QixLQUFLLCtCQUErQixTQUFTLGlCQUFpQjtBQUMxRixhQUFLLGtCQUNELEtBQUssZUFBZSxTQUNkLENBQUMsSUFDRCxLQUFLLDJCQUEyQixRQUFRLFFBQVEsaUJBQWlCO0FBQUEsTUFDL0U7QUFBQSxNQUNBLE1BQU0sT0FBTyxTQUFTLFFBQVEsYUFBYSxVQUFVO0FBQ2pELGtCQUFVLGlCQUFpQixDQUFDO0FBQzVCLGNBQU0sU0FBUyxRQUFRO0FBQ3ZCLGNBQU0sV0FBVyxXQUFXO0FBQzVCLFlBQUksUUFBUSx5QkFBeUIsV0FBVyxNQUFNO0FBQ2xELGVBQUssYUFBYSxPQUFPLGlCQUFpQixnQ0FBZ0MsK0JBQStCLG9EQUFvRCxDQUFDO0FBQUEsUUFDbEs7QUFHQSxtQkFBVyxjQUFjLEtBQUssY0FBYztBQUN4QyxnQkFBTSxxQkFBcUIsS0FBSyxxQkFBcUIsSUFBSSxVQUFVO0FBQ25FLGNBQUksc0JBQXNCLGdCQUFnQjtBQUN0QyxrQkFBTSxhQUFhLFdBQVc7QUFDOUIsK0JBQW1CLEtBQUssU0FBUyxXQUFXLHdCQUN0QyxjQUFjLEtBQUssSUFBSSxZQUFZLE9BQU8sS0FBSyxJQUMvQyxVQUFVO0FBQUEsVUFDcEIsT0FDSztBQUNELCtCQUFtQixtQkFBbUIsV0FBVyxlQUFlO0FBQ2hFLCtCQUFtQixLQUFLLFNBQVMsY0FBYyxLQUFLLElBQUksV0FBVyxJQUFJLE9BQU8sSUFBSSxDQUFDO0FBQUEsVUFDdkY7QUFBQSxRQUNKO0FBQ0EsYUFBSyx1QkFBdUIsU0FBUyxRQUFRO0FBQzdDLGFBQUssb0JBQW9CLFFBQVEsUUFBUTtBQUN6QyxjQUFNLGFBQWEsS0FBSyxnQkFBZ0IsV0FBVyxLQUMvQyxDQUFDLEdBQUcsS0FBSyxxQkFBcUIsT0FBTyxDQUFDLEVBQUUsS0FBSyxTQUFRLElBQUksYUFBYSxJQUFJLFVBQVUsV0FBVyxDQUFFO0FBQ3JHLFlBQUksc0JBQXNCO0FBQzFCLGNBQU0sa0JBQWtCLG9CQUFJLElBQUk7QUFDaEMsbUJBQVdKLFdBQVUsS0FBSyxnQkFBZ0I7QUFDdEMsY0FBSUEsUUFBTyxtQkFBbUI7QUFDMUIsa0NBQXNCQSxRQUFPO0FBQUEsVUFDakM7QUFDQSxnQkFBTSwwQkFBMEIsS0FBSyx1QkFBdUIsSUFBSUEsUUFBTyxLQUFLO0FBQzVFLGNBQUkseUJBQXlCO0FBQ3pCLHVCQUFXLFFBQVEseUJBQXlCO0FBQ3hDLDhCQUFnQixJQUFJLElBQUk7QUFBQSxZQUM1QjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsWUFBSSx3QkFBd0IsUUFBUSxXQUFXLFFBQVEsV0FBVyxVQUFVO0FBQ3hFLGlCQUFPLE1BQU07QUFBQSxZQUNULE1BQU07QUFBQSxZQUNOLElBQUk7QUFBQSxZQUNKLFNBQVMsaUJBQWlCO0FBQUEsVUFDOUIsQ0FBQztBQUFBLFFBQ0w7QUFFQSxZQUFJLENBQUMsS0FBSyxJQUFJO0FBQ1YsZ0JBQU0sSUFBSSxNQUFNLG9DQUFvQztBQUFBLFFBQ3hEO0FBQ0EsY0FBTSxjQUFjLFNBQVMsS0FBSyxnQkFBZ0I7QUFBQSxVQUM5QztBQUFBLFVBQ0EsY0FBYyxDQUFDLEdBQUcsS0FBSyxxQkFBcUIsT0FBTyxDQUFDO0FBQUEsVUFDcEQsU0FBUyxLQUFLO0FBQUEsVUFDZDtBQUFBLFVBQ0EsSUFBSSxLQUFLO0FBQUEsVUFDVCxRQUFRLEtBQUs7QUFBQSxVQUNiLE9BQU8sT0FBTztBQUFBLFVBQ2QsZUFBZSxLQUFLLGNBQWMsbUJBQzdCLEtBQUssaUJBQWlCLFFBQVEsS0FBSyxhQUFhLEtBQUs7QUFBQSxVQUMxRCxnQkFBZ0IsS0FBSyxpQkFBaUI7QUFBQSxVQUN0QyxrQkFBa0IsS0FBSyxlQUFlO0FBQUEsVUFDdEMsT0FBTyxPQUFPO0FBQUEsVUFDZDtBQUFBLFVBQ0EsbUJBQW1CLHdCQUF3QjtBQUFBLFVBQzNDLE1BQU0sS0FBSyxhQUFhO0FBQUEsUUFDNUIsR0FBRyxPQUFPO0FBQ1YsWUFBSSxPQUFPO0FBQ1Asc0JBQVksUUFBUSxPQUFPLE1BQU07QUFDckMsWUFBSSxPQUFPO0FBQ1Asc0JBQVksT0FBTyxPQUFPLE1BQU07QUFDcEMsY0FBTSxXQUFXLFlBQVksU0FBUztBQUN0QyxnQkFBUSxpQkFBaUIsQ0FBQztBQUMxQixZQUFJLE1BQU07QUFDVixjQUFNLHNCQUFzQixDQUFDO0FBQzdCLFlBQUksT0FBTyxNQUFNLFlBQVk7QUFBQSxVQUN6QixNQUFNO0FBQUEsVUFDTjtBQUFBLFVBQ0Esb0JBQW9CLEtBQUs7QUFBQSxVQUN6QixhQUFhO0FBQUEsVUFDYixnQkFBZ0I7QUFBQSxRQUNwQixDQUFDO0FBQ0QsWUFBSSxRQUFRLFdBQVc7QUFDbkIsb0JBQVUsYUFBYSxDQUFDO0FBQ3hCLGNBQUk7QUFDSixjQUFJLFFBQVE7QUFDUix1QkFBTyxxQkFBUSxRQUFRLGlCQUFpQixRQUFRLElBQUk7QUFBQSxtQkFDL0MsUUFBUTtBQUNiLHVCQUFPLHFCQUFRLFFBQVEsS0FBSyxLQUFLLEVBQUU7QUFBQTtBQUVuQyx1QkFBTyxxQkFBUSxLQUFLLEVBQUU7QUFDMUIsZ0JBQU0sYUFBYSxZQUFZLG1CQUFtQixDQUFDLENBQUM7QUFDcEQsZ0JBQU0sbUJBQW1CLE1BQU0sWUFBWSxLQUFLLGFBQWEscUJBQXFCLFFBQVEseUJBQXlCLEtBQUssYUFBYSxNQUFNO0FBQzNJLGNBQUksVUFBVSxJQUFJLFFBQ2IsSUFBSSxnQkFBYztBQUNuQixrQkFBTSxFQUFFLHVCQUF1QixJQUFJO0FBQ25DLGdCQUFJLHdCQUF3QjtBQUN4QixvQkFBTSxnQkFBZ0IsdUJBQXVCLFlBQVksR0FBRyxVQUFVO0FBQ3RFLGtCQUFJLE9BQU8sa0JBQWtCLFVBQVU7QUFDbkMsc0JBQU0sb0JBQW9CLHVEQUF1RCxDQUFDO0FBQUEsY0FDdEY7QUFDQSxxQkFBTztBQUFBLFlBQ1g7QUFDQSxtQkFBTztBQUFBLFVBQ1gsQ0FBQyxFQUNJLElBQUksU0FBUztBQUNsQixrQkFBUSxhQUFhLENBQUM7QUFBQSxRQUMxQjtBQUNBLFlBQUksQ0FBQyxRQUFRLFdBQVcsS0FBSyxLQUFLLFNBQVMsT0FBTztBQUM5QyxrQkFBUTtBQUNaLGVBQU8sRUFBRSxNQUFNLElBQUk7QUFBQSxNQUN2QjtBQUFBLE1BQ0EsdUJBQXVCLG9CQUFvQixtQkFBbUI7QUFDMUQsbUJBQVdBLFdBQVUsb0JBQW9CO0FBQ3JDLGNBQUlBLG1CQUFrQixRQUFRO0FBQzFCLGtCQUFNLFFBQVEsS0FBSyxjQUFjLElBQUlBLE9BQU07QUFDM0MsZ0JBQUksU0FBUyxVQUFVLE1BQU07QUFDekIsZ0NBQWtCLElBQUksS0FBSztBQUFBLFlBQy9CO0FBQUEsVUFDSixPQUNLO0FBQ0QsOEJBQWtCLElBQUlBLE9BQU07QUFBQSxVQUNoQztBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSxpQkFBaUIsRUFBRSxVQUFVLEtBQUssR0FBRyxlQUFlO0FBQ2hELFlBQUksVUFBVTtBQUNWLGVBQUssV0FBVztBQUFBLFFBQ3BCLE9BQ0s7QUFDRCxlQUFLLE9BQU8sS0FBSyxjQUFjLGlCQUFpQixRQUFRLHVCQUF1QixhQUFhLENBQUM7QUFBQSxRQUNqRztBQUFBLE1BQ0o7QUFBQSxNQUNBLDhCQUE4QixVQUFVLGlCQUFpQjtBQUNyRCxjQUFNLGlCQUFpQixTQUFTO0FBQ2hDLFlBQUksMEJBQTBCLFFBQVE7QUFDbEMsZ0JBQU0sY0FBYyxLQUFLLGNBQWMsSUFBSSxjQUFjO0FBQ3pELGNBQUk7QUFDSixhQUFHO0FBQ0Msd0NBQTRCLGdCQUFnQiwyQkFBMkIsSUFBSSxRQUFRO0FBQ25GLGdCQUFJLDJCQUEyQjtBQUMzQixvQkFBTSxpQkFBaUIsS0FBSyxjQUFjLElBQUkseUJBQXlCO0FBQ3ZFLGtCQUFJLGtCQUFrQixtQkFBbUIsYUFBYTtBQUNsRCxxQkFBSyxhQUFhLE9BQU8sNEJBQTRCLGVBQWUseUJBQXlCLEVBQUUsSUFBSSxRQUFRLEVBQUUsSUFBSSxlQUFlLElBQUksMEJBQTBCLElBQUksZ0JBQWdCLEVBQUUsQ0FBQztBQUFBLGNBQ3pMO0FBQ0EsZ0NBQWtCO0FBQUEsWUFDdEI7QUFBQSxVQUNKLFNBQVM7QUFBQSxRQUNiO0FBQUEsTUFDSjtBQUFBLE1BQ0EsbUNBQW1DLFFBQVEsU0FBUyxlQUFlO0FBQy9ELGNBQU0sT0FBTyxXQUFXO0FBQ3hCLGFBQUssT0FBTyxDQUFDLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxRQUFRLE9BQU8sTUFBTSxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQ2hGLGFBQUssT0FBTyxRQUFRLE1BQU07QUFDMUIsY0FBTSx5QkFBeUIsb0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQztBQUM3QyxtQkFBV04sWUFBVyx3QkFBd0I7QUFDMUMsY0FBSUEsb0JBQW1CLGdCQUFnQjtBQUNuQyxpQkFBSyxPQUFPLElBQUlBLFNBQVEsWUFBWTtBQUFBLFVBQ3hDLE9BQ0s7QUFDRCxpQkFBSyxPQUFPQSxTQUFRLGdCQUFnQixDQUFDO0FBQ3JDLGlCQUFLLE9BQU9BLFNBQVEsV0FBVyxRQUFRLFNBQVMsZUFBZSxLQUFLLENBQUM7QUFBQSxVQUN6RTtBQUNBLGNBQUlBLG9CQUFtQjtBQUNuQjtBQUNKLHFCQUFXLGNBQWMsQ0FBQyxHQUFHQSxTQUFRLGNBQWMsR0FBR0EsU0FBUSxtQkFBbUIsR0FBRztBQUNoRixtQ0FBdUIsSUFBSSxVQUFVO0FBQUEsVUFDekM7QUFBQSxRQUNKO0FBQ0EsZUFBTyxLQUFLLE9BQU8sS0FBSyxFQUFFLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDekM7QUFBQSxNQUNBLHFDQUFxQ00sU0FBUTtBQUN6QyxjQUFNLE1BQU1BLFFBQU8seUJBQXlCO0FBQzVDLG1CQUFXLG9CQUFvQixJQUFJLEtBQUssR0FBRztBQUN2QyxnQkFBTSxjQUFjLDRCQUE0QjtBQUNoRCxnQkFBTSxtQkFBbUIsY0FDbkIsaUJBQWlCLGdCQUFnQixJQUNqQztBQUNOLGNBQUksRUFBRSw0QkFBNEIscUJBQXFCLEtBQUssY0FBYyxrQkFBa0I7QUFDeEYsaUJBQUssOEJBQThCLGtCQUFrQkEsT0FBTTtBQUMzRCxrQkFBTSxrQkFBa0IsaUJBQWlCO0FBQ3pDLGdCQUFJLDJCQUEyQixRQUFRO0FBQ25DLG9CQUFNLFFBQVEsS0FBSyxjQUFjLElBQUksZUFBZTtBQUNwRCxrQkFBSSxTQUFTLFVBQVUsTUFBTTtBQUN6QixzQkFBTSxRQUFRLElBQUksZ0JBQWdCO0FBQ2xDLG9CQUFJLGFBQWE7QUFDYix1QkFBSyxRQUFRLElBQUksZ0JBQWdCO0FBQUEsZ0JBQ3JDO0FBQUEsY0FDSjtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLHVCQUF1QixTQUFTLFVBQVU7QUFDdEMsY0FBTSx5QkFBeUIsUUFBUSxXQUFXO0FBQ2xELG1CQUFXLENBQUNBLFNBQVEsSUFBSSxLQUFLLEtBQUssdUJBQXVCO0FBQ3JELHFCQUFXLEVBQUUsTUFBTSxXQUFXLEtBQUtBLFFBQU8sZ0JBQWdCO0FBQ3RELGtCQUFNLFFBQVEsS0FBSyxjQUFjLElBQUksVUFBVTtBQUMvQyxrQkFBTSxjQUFjLEtBQUssb0JBQW9CLElBQUksVUFBVTtBQUMzRCxnQkFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLFlBQVksVUFBVSxNQUFNO0FBQ2pEO0FBQUEsWUFDSjtBQUNBLGtCQUFNLHFCQUFxQixzQkFBc0IsU0FDM0MsSUFBSSxTQUFTLGNBQWMsS0FBSyxLQUFLLGVBQWUsT0FBTyxJQUFJLHdCQUF3QixJQUFJLENBQUMsT0FDNUYsc0JBQXNCLGlCQUNsQixJQUFJLFNBQVMsV0FBVyx3QkFDcEIsY0FBYyxLQUFLLElBQUksV0FBVyxZQUFZLHdCQUF3QixLQUFLLElBQzNFLFdBQVcsVUFBVSxPQUN6QjtBQUNWLGlCQUFLLHNCQUFzQixNQUFNLG9CQUFvQixzQkFBc0IsVUFDdkUsRUFBRSxnQkFBZ0IsUUFBUSxnQkFBZ0IsU0FBUyxTQUFTLFlBQVksaUJBQ3hFLE1BQU0sc0JBQXNCLElBQUksV0FBVyxTQUFTLEVBQUUsSUFBSSxRQUFRO0FBQUEsVUFDMUU7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0Esb0JBQW9CLFFBQVEsVUFBVTtBQUNsQyxtQkFBVyxDQUFDQSxTQUFRLElBQUksS0FBSyxLQUFLLHVCQUF1QjtBQUNyRCxxQkFBVyxjQUFjQSxRQUFPLGFBQWE7QUFDekMsdUJBQVcscUJBQXFCLE1BQU0sS0FBSyxJQUFJLFFBQVEsVUFBVSxLQUFLLFlBQVk7QUFBQSxVQUN0RjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSx1QkFBdUI7QUFDbkIsWUFBSSxLQUFLLGtCQUFrQjtBQUN2QixpQkFBTyxLQUFLO0FBQUEsUUFDaEI7QUFDQSxjQUFNLGtCQUFrQixLQUFLLGFBQWEsTUFDdEMsS0FBSyxxQkFBcUIsTUFDMUIsS0FBSyxvQkFBb0IsTUFDekIsS0FBSyxlQUFlLEtBQUssZUFBZSxTQUFTO0FBQ3JELFlBQUksaUJBQWlCO0FBQ2pCLGlCQUFPLHVCQUF1QixlQUFlO0FBQUEsUUFDakQ7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLE1BQ0EsK0JBQStCLFNBQVMsbUJBQW1CO0FBQ3ZELGNBQU0sbUJBQW1CLEtBQUssb0JBQW9CLGlCQUFpQjtBQUNuRSxjQUFNLHFCQUFxQixLQUFLLHNCQUFzQjtBQUN0RCxjQUFNLHdCQUF3QixvQkFBSSxJQUFJO0FBQ3RDLG1CQUFXLE9BQU8sS0FBSyxjQUFjO0FBQ2pDLGdCQUFNLFVBQVUsaUJBQWlCLElBQUksR0FBRyxLQUFLO0FBQzdDLGdCQUFNLFlBQVksbUJBQW1CLElBQUksR0FBRyxLQUFLO0FBQ2pELGdCQUFNLG1CQUFtQixlQUFlLGtCQUFrQixJQUFJLGVBQWU7QUFDN0UsZ0NBQXNCLElBQUksS0FBSztBQUFBLFlBQzNCLHFCQUFxQixJQUFJO0FBQUEsWUFDekIsWUFBYSxlQUFlLG1CQUN2QixRQUFRLFdBQVcsU0FBUyxRQUFRLFdBQVcsV0FDaEQsY0FBYyxLQUFLLFFBQVEsVUFBVSxXQUFXLGVBQWUsTUFBTSxLQUFLLGFBQWEsTUFBTTtBQUFBLFlBQ2pHLElBQUk7QUFBQSxZQUNKO0FBQUEsWUFDQSxTQUFTLGVBQWVzQjtBQUFBLFlBQ3hCLE1BQU0sSUFBSTtBQUFBLFlBQ1Y7QUFBQSxZQUNBLHVCQUF1QixJQUFJO0FBQUEsWUFDM0I7QUFBQSxVQUNKLENBQUM7QUFBQSxRQUNMO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLDJCQUEyQixRQUFRLG1CQUFtQjtBQUNsRCxjQUFNLFVBQVUsQ0FBQztBQUNqQixtQkFBVyxjQUFjLEtBQUssZUFBZSxHQUFHO0FBQzVDLGNBQUksV0FBVyxPQUFPO0FBQ2xCO0FBQ0osZ0JBQU0sV0FBVyxLQUFLLGNBQWMsSUFBSSxVQUFVO0FBQ2xELGNBQUksRUFBRSxvQkFBb0IsK0JBQStCO0FBQ3JELGtCQUFNdEIsVUFBUyxTQUFTO0FBQ3hCLGdCQUFJQSxXQUFVLEtBQUssY0FBYyxJQUFJQSxPQUFNLE1BQU07QUFDN0M7QUFBQSxVQUNSO0FBQ0EsY0FBSSxhQUFhO0FBQ2pCLGNBQUksVUFBVTtBQUNkLGNBQUksUUFBUSxTQUFTLFFBQVEsaUJBQWlCO0FBQzlDLGNBQUksb0JBQW9CLGVBQWU7QUFDbkMsdUJBQVcsZUFBZSxTQUFTLGNBQWM7QUFDN0Msa0JBQUksWUFBWSxrQkFBa0IsdUJBQzdCLHVCQUF1Qiw0QkFDcEIsWUFBWSx1QkFBdUIscUJBQXNCO0FBQzdELDBCQUFVO0FBQ1Y7QUFBQSxjQUNKO0FBQUEsWUFDSjtBQUFBLFVBQ0osV0FDUyxvQkFBb0IsOEJBQThCO0FBQ3ZELHlCQUFhO0FBQ2IsZ0JBQUksV0FBVyxNQUFNO0FBQ2pCLHNCQUFRLFNBQVM7QUFBQSxZQUNyQjtBQUFBLFVBQ0o7QUFDQSxrQkFBUSxLQUFLO0FBQUEsWUFDVCxVQUFVO0FBQUEsWUFDVjtBQUFBLFlBQ0E7QUFBQSxZQUNBO0FBQUEsVUFDSixDQUFDO0FBQUEsUUFDTDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxnQ0FBZ0MsbUNBQW1DLGdDQUFnQyxTQUFTO0FBQ3hHLGNBQU0sZUFBZSxvQkFBSSxJQUFJO0FBQzdCLGNBQU0sc0JBQXNCLG9CQUFJLElBQUk7QUFDcEMsY0FBTSx3QkFBd0Isb0JBQUksSUFBSTtBQUN0QyxtQkFBVyxZQUFZLENBQUMsR0FBRyxLQUFLLHNCQUFzQixLQUFLLEdBQUcsR0FBRyxLQUFLLE9BQU8sR0FBRztBQUM1RSxjQUFJLHFDQUFxQyxTQUFTLGFBQWE7QUFDM0Qsa0JBQU1BLFVBQVMsU0FBUztBQUN4QixnQkFBSUEsbUJBQWtCLGdCQUFnQjtBQUNsQywyQkFBYSxJQUFJQSxPQUFNO0FBQ3ZCLGtCQUFJLG1DQUFtQztBQUNuQyxvQkFBSSxTQUFTLFNBQVMsV0FBVztBQUM3QixzQkFBSSxtQ0FBbUMsT0FBTyxRQUFRQSxRQUFPLEVBQUUsQ0FBQyxJQUFJO0FBQ2hFLHdDQUFvQixJQUFJQSxPQUFNO0FBQUEsa0JBQ2xDO0FBQUEsZ0JBQ0osV0FDUyxTQUFTLFNBQVMsS0FBSztBQUM1QixzQkFBSSxxQ0FBcUMsT0FBTyxRQUFRQSxRQUFPLEVBQUUsQ0FBQyxJQUFJO0FBQ2xFLDBDQUFzQixJQUFJQSxPQUFNO0FBQUEsa0JBQ3BDO0FBQUEsZ0JBQ0o7QUFBQSxjQUNKO0FBQUEsWUFDSixPQUNLO0FBQ0Qsb0JBQU0sUUFBUSxLQUFLLGNBQWMsSUFBSUEsT0FBTTtBQUMzQyxrQkFBSSxVQUFVLE1BQU07QUFDaEIsNkJBQWEsSUFBSSxLQUFLO0FBQ3RCLG9CQUFJLHFDQUNBLE1BQU0sZUFBZSxhQUNyQixTQUFTLGFBQWE7QUFDdEIsd0NBQXNCLElBQUksS0FBSztBQUFBLGdCQUNuQztBQUFBLGNBQ0o7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxZQUFJLGdDQUFnQztBQUNoQyxxQkFBVyxjQUFjLEtBQUssY0FBYztBQUN4Qyx5QkFBYSxJQUFJLFVBQVU7QUFBQSxVQUMvQjtBQUFBLFFBQ0o7QUFDQSxlQUFPLEVBQUUscUJBQXFCLHVCQUF1QixhQUFhO0FBQUEsTUFDdEU7QUFBQSxNQUNBLHVCQUF1QjtBQUNuQixZQUFJLEtBQUssa0JBQWtCO0FBQ3ZCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLFlBQUksS0FBSyxhQUFhO0FBQ2xCLGlCQUFPLEtBQUs7QUFBQSxRQUNoQjtBQUNBLFlBQUksS0FBSyxVQUFVO0FBQ2YsaUJBQU8sYUFBYSxLQUFLLFFBQVE7QUFBQSxRQUNyQztBQUNBLGVBQU8sYUFBYSxLQUFLLGVBQWUsS0FBSyxlQUFlLFNBQVMsR0FBRyxFQUFFO0FBQUEsTUFDOUU7QUFBQSxNQUNBLG9CQUFvQixtQkFBbUI7QUFDbkMsY0FBTSxFQUFFLFFBQVEsSUFBSSxLQUFLO0FBQ3pCLGNBQU0sc0JBQXNCLG9CQUFJLElBQUk7QUFDcEMsbUJBQVcsWUFBWSxLQUFLLFNBQVM7QUFDakMsZ0JBQU1BLFVBQVMsU0FBUztBQUN4QixjQUFJO0FBQ0osY0FBSTtBQUNKLGNBQUlBLG1CQUFrQixnQkFBZ0I7QUFDbEMseUJBQWFBO0FBQ2IsdUJBQVcsU0FBUztBQUNwQixnQkFBSSxhQUFhLGFBQWEsYUFBYSxPQUFPLFFBQVFBLFFBQU8sRUFBRSxNQUFNLGVBQWU7QUFDcEYscUJBQU8sTUFBTSx5QkFBeUJBLFFBQU8sSUFBSSxVQUFVLEtBQUssQ0FBQztBQUFBLFlBQ3JFO0FBQUEsVUFDSixPQUNLO0FBQ0QseUJBQWEsS0FBSyxjQUFjLElBQUlBLE9BQU07QUFDMUMsdUJBQVcsV0FBVyxzQkFBc0IsUUFBUTtBQUFBLFVBQ3hEO0FBQ0Esc0JBQVkscUJBQXFCLFlBQVksTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLO0FBQUEsWUFDeEQ7QUFBQSxZQUNBLE9BQU8sU0FBUyxRQUFRLGlCQUFpQjtBQUFBLFVBQzdDLENBQUM7QUFBQSxRQUNMO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLG1DQUFtQztBQUMvQixjQUFNLG1CQUFtQixDQUFDO0FBQzFCLG1CQUFXLENBQUMsWUFBWSxXQUFXLEtBQUssS0FBSyxzQkFBc0I7QUFDL0QsZ0JBQU0sYUFBYSxvQkFBSSxJQUFJO0FBQzNCLGNBQUksWUFBWSxTQUFTO0FBQ3JCLHVCQUFXLEVBQUUsU0FBUyxLQUFLLFlBQVksU0FBUztBQUM1Qyx5QkFBVyxJQUFJLFFBQVE7QUFBQSxZQUMzQjtBQUFBLFVBQ0o7QUFDQSxjQUFJLFlBQVksV0FBVztBQUN2Qix1QkFBVyxFQUFFLFNBQVMsS0FBSyxZQUFZLFdBQVc7QUFDOUMseUJBQVcsSUFBSSxRQUFRO0FBQUEsWUFDM0I7QUFBQSxVQUNKO0FBQ0EsMkJBQWlCLFdBQVcsTUFBTSxDQUFDLEdBQUcsVUFBVTtBQUFBLFFBQ3BEO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLHdCQUF3QjtBQUNwQixjQUFNLEVBQUUsc0JBQXNCLFFBQVEsSUFBSSxLQUFLO0FBQy9DLGNBQU0scUJBQXFCLG9CQUFJLElBQUk7QUFDbkMsaUJBQVMsY0FBYyxLQUFLLGVBQWUsR0FBRztBQUMxQyxjQUFJO0FBQ0osY0FBSTtBQUNKLGNBQUksbUJBQW1CO0FBQ3ZCLGNBQUksV0FBVyxPQUFPLEtBQUs7QUFDdkIsa0JBQU0sS0FBSyxXQUFXLFVBQVUsQ0FBQztBQUNqQyxnQkFBSSxRQUFRLEVBQUUsTUFBTSxlQUFlO0FBQy9CLG1CQUFLLGFBQWEsT0FBTywrQkFBK0IsRUFBRSxDQUFDO0FBQUEsWUFDL0Q7QUFDQSwrQkFBbUI7QUFDbkIseUJBQWEsS0FBSyxZQUFZLElBQUksRUFBRTtBQUNwQyx1QkFBVyxhQUFhO0FBQUEsVUFDNUIsT0FDSztBQUNELGtCQUFNLFdBQVcsS0FBSyxjQUFjLElBQUksVUFBVTtBQUNsRCxnQkFBSSxvQkFBb0I7QUFDcEI7QUFDSixrQkFBTUEsVUFBUyxTQUFTO0FBQ3hCLGdCQUFJQSxtQkFBa0IsUUFBUTtBQUMxQiwyQkFBYSxLQUFLLGNBQWMsSUFBSUEsT0FBTTtBQUMxQyxrQkFBSSxlQUFlO0FBQ2Y7QUFDSix5QkFBVyxXQUFXLHNCQUFzQixRQUFRO0FBQ3BELGlDQUFtQixTQUFTO0FBQUEsWUFDaEMsT0FDSztBQUNELDJCQUFhQTtBQUNiLHlCQUFXLFNBQVM7QUFDcEIsa0JBQUksYUFBYSxhQUFhLGFBQWEsT0FBTyxRQUFRQSxRQUFPLEVBQUUsTUFBTSxlQUFlO0FBQ3BGLHVCQUFPLE1BQU0seUJBQXlCQSxRQUFPLElBQUksVUFBVSxJQUFJLENBQUM7QUFBQSxjQUNwRTtBQUNBLGlDQUNJLHlCQUNLLGFBQWEsYUFBYSxtQkFBbUIsT0FBTyxRQUFRQSxRQUFPLEVBQUUsQ0FBQyxHQUFHLElBQUk7QUFBQSxZQUMxRjtBQUFBLFVBQ0o7QUFDQSxzQkFBWSxvQkFBb0IsWUFBWSxNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUs7QUFBQSxZQUN2RDtBQUFBLFlBQ0E7QUFBQSxZQUNBLFlBQVk7QUFBQSxVQUNoQixDQUFDO0FBQUEsUUFDTDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxxQkFBcUI7QUFDakIsY0FBTSxrQkFBa0IsQ0FBQztBQUN6QixtQkFBV0EsV0FBVSxLQUFLLGdCQUFnQjtBQUN0QyxxQkFBVyxRQUFRQSxRQUFPLGFBQWE7QUFDbkMsa0JBQU0sV0FBVyxLQUFLLHNCQUFzQixLQUFLLFlBQVk7QUFDN0QsZ0JBQUksVUFBVTtBQUNWLDhCQUFnQixLQUFLLFFBQVE7QUFBQSxZQUNqQztBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLHdCQUF3QixPQUFPO0FBQzNCLG1CQUFXLE9BQU8sTUFBTSxjQUFjO0FBQ2xDLGNBQUksS0FBSyxhQUFhLElBQUksR0FBRztBQUN6QjtBQUNKLGVBQUssYUFBYSxJQUFJLEdBQUc7QUFDekIsY0FBSSxlQUFlc0IsUUFBTztBQUN0QixpQkFBSyx3QkFBd0IsR0FBRztBQUFBLFVBQ3BDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxNQUNBLDJCQUEyQixVQUFVO0FBQ2pDLFlBQUk7QUFDSixjQUFNLHlCQUF5QixLQUFLO0FBQ3BDLG1CQUFXdEIsV0FBVSxLQUFLLGdCQUFnQjtBQUN0QyxxQkFBVyxFQUFFLE1BQU0sV0FBVyxLQUFLQSxRQUFPLGdCQUFnQjtBQUN0RCxnQkFBSSxLQUFLLFVBQVU7QUFDZixrQkFBSSxzQkFBc0IsUUFBUTtBQUM5QixzQkFBTSxRQUFRLEtBQUssY0FBYyxJQUFJLFVBQVU7QUFDL0Msb0JBQUksVUFBVSxNQUFNO0FBQ2hCLHVCQUFLLHNCQUFzQixXQUFXLFNBQVM7QUFBQSxnQkFDbkQsT0FDSztBQUNELHVCQUFLLHdCQUF3QixLQUFLLEtBQUssb0JBQW9CLElBQUksVUFBVSxPQUFPLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxlQUFlLE1BQU0sWUFBWSxZQUFZLEtBQUssZUFBZSxVQUFVLEtBQUssY0FBYyxzQkFBc0I7QUFBQSxnQkFDNU87QUFBQSxjQUNKLE9BQ0s7QUFDRCxxQkFBSyxzQkFBc0IsWUFBWSxZQUFZLEtBQUssZUFBZSxVQUFVLEtBQUssY0FBYyxzQkFBc0I7QUFBQSxjQUM5SDtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQ0EscUJBQVcsY0FBY0EsUUFBTyxhQUFhO0FBQ3pDLHVCQUFXLG1CQUFtQixLQUFLLGNBQWMsUUFBUSxzQkFBc0I7QUFBQSxVQUNuRjtBQUNBLGNBQUksS0FBSyxtQkFBbUIsSUFBSUEsT0FBTSxLQUFLLENBQUMsS0FBSyxjQUFjLGlCQUFpQjtBQUM1RSxZQUFBQSxRQUFPLFVBQVUsUUFBUSxzQkFBc0I7QUFBQSxVQUNuRDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsTUFDQSx1QkFBdUIsU0FBUyxXQUFXO0FBQ3ZDLG1CQUFXLGNBQWMsQ0FBQyxHQUFHLEtBQUssY0FBYyxHQUFHLEtBQUssbUJBQW1CLEdBQUc7QUFDMUUsY0FBSSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHVCQUFXLGNBQWMsU0FBUyxTQUFTO0FBQUEsVUFDL0M7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsK0JBQStCLEVBQUUsUUFBUSxTQUFTLHFCQUFxQixHQUFHO0FBQ3RFLGNBQU0sbUJBQW1CLG9CQUFJLElBQUk7QUFDakMsbUJBQVcsY0FBYyxLQUFLLGVBQWUsR0FBRztBQUM1QyxnQkFBTSxpQkFBaUIsS0FBSyxjQUFjLElBQUksVUFBVTtBQUN4RCxjQUFJLFdBQVcsUUFDWCxXQUFXLFlBQ1gsZUFBZSxnQkFDZixDQUFDLGVBQWUsTUFBTTtBQUN0QiwyQkFBZSxlQUFlLFdBQVcsVUFBVTtBQUFBLFVBQ3ZELFdBQ1MsMEJBQTBCLDhCQUE4QjtBQUM3RCw2QkFBaUIsSUFBSSxjQUFjO0FBQUEsVUFDdkMsT0FDSztBQUNELDJCQUFlLGVBQWUsTUFBTSxJQUFJO0FBQUEsVUFDNUM7QUFBQSxRQUNKO0FBQ0EsbUJBQVdBLFdBQVUsS0FBSyxnQkFBZ0I7QUFDdEMsY0FBSUEsUUFBTyxpQkFBaUI7QUFDeEIsaUJBQUssbUJBQW1CO0FBQ3hCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxjQUFNLFlBQVksb0JBQUksSUFBSSxDQUFDLFVBQVUsU0FBUyxDQUFDO0FBQy9DLFlBQUksS0FBSyxrQkFBa0I7QUFDdkIsb0JBQVUsSUFBSSw0QkFBNEI7QUFBQSxRQUM5QztBQUNBLFlBQUksc0JBQXNCO0FBQ3RCLG9CQUFVLElBQUksUUFBUTtBQUFBLFFBQzFCO0FBQ0EsZ0JBQVEsUUFBUTtBQUFBLFVBQ1osS0FBSztBQUNELHNCQUFVLElBQUksUUFBUSxFQUFFLElBQUksU0FBUztBQUNyQztBQUFBLFVBQ0osS0FBSztBQUNEO0FBQUEsVUFDSixLQUFLO0FBQ0Qsc0JBQVUsSUFBSSxRQUFRLEVBQUUsSUFBSSxTQUFTLEVBQUUsSUFBSSxZQUFZLEVBQUUsSUFBSSxXQUFXO0FBQUEsVUFFNUU7QUFDSSxzQkFBVSxJQUFJLFNBQVM7QUFDdkIsdUJBQVcsVUFBVSxjQUFjO0FBQy9CLHdCQUFVLElBQUksTUFBTTtBQUFBLFlBQ3hCO0FBQUEsUUFDUjtBQUNBLHdCQUFnQixLQUFLLGdCQUFnQixLQUFLLGdDQUFnQyxXQUFXLFFBQVEsV0FBVyxVQUFVLFdBQVcsU0FBUyxXQUFXLFNBQVMsV0FBVyxRQUFRLE9BQU8sR0FBRyxLQUFLLFNBQVMsV0FBVyxRQUFRLFNBQVMsS0FBSyxjQUFjLGlCQUFpQixLQUFLLGNBQWMsc0JBQXNCLEtBQUssZUFBZSxrQkFBa0IsS0FBSyx1QkFBdUIsS0FBSyx3QkFBd0IsS0FBSyxrQkFBa0I7QUFBQSxNQUN4YTtBQUFBLE1BQ0EscUNBQXFDQSxTQUFRO0FBQ3pDLGNBQU0sZ0JBQWdCLElBQUksSUFBSUEsUUFBTyxPQUFPO0FBRzVDLFlBQUksQ0FBQyxLQUFLLGNBQWMsaUJBQWlCO0FBQ3JDLGNBQUksS0FBSyxtQkFBbUIsSUFBSUEsT0FBTSxHQUFHO0FBQ3JDLGtCQUFNLGtCQUFrQkEsUUFBTyxVQUFVLG1CQUFtQjtBQUM1RCx1QkFBVyxZQUFZLE9BQU8sT0FBTyxlQUFlLEdBQUc7QUFDbkQsNEJBQWMsSUFBSSxRQUFRO0FBQUEsWUFDOUI7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLGlCQUFTLFlBQVksZUFBZTtBQUNoQyxjQUFJLG9CQUFvQix1QkFBdUI7QUFDM0MsdUJBQVcsU0FBUyxvQkFBb0I7QUFBQSxVQUM1QztBQUNBLGNBQUksb0JBQW9CLDhCQUE4QjtBQUNsRCx1QkFBVyxTQUFTLGdCQUFnQjtBQUFBLFVBQ3hDO0FBQ0EsZ0JBQU0sUUFBUSxLQUFLLGNBQWMsSUFBSSxTQUFTLE1BQU07QUFDcEQsY0FBSSxVQUFVLE1BQU07QUFDaEIsaUJBQUssUUFBUSxJQUFJLFFBQVE7QUFDekIsZ0JBQUksRUFBRSxvQkFBb0IscUJBQXFCLEtBQUssY0FBYyxvQkFDOUQsU0FBUyxrQkFBa0IsUUFBUTtBQUNuQyxvQkFBTSxRQUFRLElBQUksUUFBUTtBQUMxQixtQkFBSyw4QkFBOEIsVUFBVUEsT0FBTTtBQUFBLFlBQ3ZEO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxZQUFJLEtBQUssbUJBQW1CLElBQUlBLE9BQU0sS0FDakNBLFFBQU8sS0FBSyxXQUFXQSxRQUFPLHNCQUFzQixTQUNyREEsUUFBTyx5QkFBeUIsS0FBSyxjQUFZLEtBQUssY0FBYyxJQUFJLFFBQVEsTUFBTSxJQUFJLEdBQUc7QUFDN0YsZUFBSyxxQ0FBcUNBLE9BQU07QUFBQSxRQUNwRDtBQUNBLG1CQUFXLEVBQUUsTUFBTSxXQUFXLEtBQUtBLFFBQU8sZ0JBQWdCO0FBQ3RELGNBQUksS0FBSyxZQUNMLHNCQUFzQixVQUN0QixLQUFLLGNBQWMsSUFBSSxVQUFVLE1BQU0sUUFDdkMsQ0FBQyxLQUFLLG1CQUFtQixJQUFJLFVBQVUsR0FBRztBQUMxQyxpQkFBSyxtQkFBbUIsSUFBSSxVQUFVO0FBQ3RDLGlCQUFLLHFDQUFxQyxVQUFVO0FBQUEsVUFDeEQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFLQSxJQUFNLG1CQUFtQjtBQTBCekIsSUFBTSxtQkFBbUI7QUFBQSxNQUNyQixNQUFNO0FBQUEsSUFDVjtBQThCQSxJQUFNLGNBQU4sTUFBa0I7QUFBQSxNQUNkLFlBQVksT0FBTyxTQUFTLGlCQUFpQjtBQUN6QyxhQUFLLFFBQVE7QUFDYixhQUFLLFVBQVU7QUFDZixhQUFLLFNBQVM7QUFDZCxhQUFLLHNCQUFzQjtBQUMzQixhQUFLLGdCQUFnQjtBQUNyQixhQUFLLHdCQUF3QixNQUFNO0FBQy9CLHFCQUFXLENBQUMsYUFBYSxXQUFXLEtBQUssS0FBSyxvQkFBb0I7QUFDOUQsZ0JBQUksWUFBWSxTQUFTLFdBQVcsT0FBTyxZQUFZLGFBQWE7QUFDaEUscUJBQU8sTUFBTSxvQkFBb0IsWUFBWSxRQUFRLFdBQVcsQ0FBQztBQUFBLFVBQ3pFO0FBQUEsUUFDSjtBQUNBLGFBQUssV0FBVyxDQUFDLGdCQUFnQjtBQUM3QixjQUFJLENBQUMsYUFBYSxXQUFXLEdBQUc7QUFDNUIsbUJBQU8sTUFBTSxvQkFBb0IsK0RBQStELGVBQWUsWUFBWSxRQUFRLENBQUM7QUFBQSxVQUN4STtBQUNBLGNBQUksQ0FBQyxhQUFhLFdBQVcsR0FBRztBQUM1QixtQkFBTyxNQUFNLG9CQUFvQixnSUFBZ0ksWUFBWSxZQUFZLFlBQVksUUFBUSxDQUFDO0FBQUEsVUFDbE47QUFDQSxjQUFJLFlBQVksU0FBUyxTQUFTO0FBQzlCLG1CQUFPLEtBQUssVUFBVSxXQUFXO0FBQUEsVUFDckM7QUFDQSxpQkFBTyxLQUFLLFVBQVUsV0FBVztBQUFBLFFBQ3JDO0FBQ0EsYUFBSyxjQUFjLENBQUMsb0JBQW9CO0FBQ3BDLGdCQUFNLGNBQWMsS0FBSyxtQkFBbUIsSUFBSSxlQUFlO0FBQy9ELGNBQUksQ0FBQztBQUNELG1CQUFPLE1BQU0sc0NBQXNDLGVBQWUsQ0FBQztBQUN2RSxjQUFJLFlBQVksU0FBUyxTQUFTO0FBQzlCLG1CQUFPLGlCQUFpQixhQUFhLEtBQUssbUJBQW1CO0FBQUEsVUFDakU7QUFDQSxpQkFBTyxpQkFBaUIsYUFBYSxlQUFlO0FBQUEsUUFDeEQ7QUFDQSxhQUFLLGlCQUFpQixDQUFDLGFBQWEsb0JBQW9CO0FBQ3BELGdCQUFNLGVBQWUsS0FBSyxtQkFBbUIsSUFBSSxXQUFXO0FBQzVELGNBQUksQ0FBQztBQUNELG1CQUFPLE1BQU0sd0NBQXdDLFdBQVcsQ0FBQztBQUNyRSxjQUFJLGFBQWEsU0FBUyxTQUFTO0FBQy9CLG1CQUFPLE1BQU0sb0JBQW9CLHlEQUF5RCxtQ0FBbUMsQ0FBQztBQUFBLFVBQ2xJO0FBQ0EsY0FBSSxhQUFhLFdBQVcsUUFBVztBQUNuQyxtQkFBTyxNQUFNLHlCQUF5QixhQUFhLFFBQVEsV0FBVyxDQUFDO0FBQUEsVUFDM0U7QUFDQSxnQkFBTSxTQUFTLGVBQWUsaUJBQWlCLGNBQWMsV0FBVztBQUN4RSxjQUFJLEtBQUssUUFBUTtBQUNiLGlCQUFLLGNBQWMsY0FBYyxRQUFRLGFBQWEsS0FBSyxNQUFNO0FBQUEsVUFDckUsT0FDSztBQUNELHlCQUFhLFNBQVM7QUFBQSxVQUMxQjtBQUFBLFFBQ0o7QUFDQSxhQUFLLGtCQUFrQixDQUFDLGNBQWMsZUFBZSx3QkFBd0I7QUFDekUsZUFBSyxnQkFBZ0I7QUFDckIsZUFBSyxTQUFTO0FBQ2QsZUFBSyxzQkFBc0I7QUFDM0IscUJBQVcsZUFBZSxLQUFLLG1CQUFtQixPQUFPLEdBQUc7QUFDeEQsZ0JBQUksWUFBWSxVQUFVO0FBQ3RCLHNDQUF3QixZQUFZLFVBQVUsS0FBSyxRQUFRLEtBQUssUUFBUSxNQUFNO0FBQUEsWUFDbEY7QUFBQSxVQUNKO0FBQ0EscUJBQVcsQ0FBQyxhQUFhLFlBQVksS0FBSyxLQUFLLG9CQUFvQjtBQUMvRCxnQkFBSSxhQUFhLFNBQVMsV0FBVyxhQUFhLFdBQVcsUUFBVztBQUNwRSxtQkFBSyxjQUFjLGNBQWMsYUFBYSxRQUFRLGFBQWEsS0FBSyxNQUFNO0FBQUEsWUFDbEY7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLGFBQUsscUJBQXFCLGtCQUNwQixJQUFJLElBQUksZ0JBQWdCLGtCQUFrQixJQUMxQyxvQkFBSSxJQUFJO0FBQUEsTUFDbEI7QUFBQSxNQUNBLGtCQUFrQixNQUFNLFFBQVE7QUFDNUIsWUFBSTtBQUNKLFdBQUc7QUFDQyx3QkFBYyxXQUFXLEVBQ3BCLE9BQU8sZUFBZSxNQUFNLEVBQzVCLE9BQU8sS0FBSyxFQUNaLFVBQVUsR0FBRyxDQUFDO0FBQUEsUUFDdkIsU0FBUyxLQUFLLG1CQUFtQixJQUFJLFdBQVc7QUFDaEQsYUFBSyxtQkFBbUIsSUFBSSxhQUFhLElBQUk7QUFDN0MsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLFVBQVUsY0FBYztBQUNwQixjQUFNLFNBQVMsT0FBTyxhQUFhLFdBQVcsY0FDeEMsZUFBZSxhQUFhLFFBQVEsY0FBYyxJQUFJLElBQ3REO0FBQ04sY0FBTSxnQkFBZ0I7QUFBQSxVQUNsQixVQUFVLGFBQWE7QUFBQSxVQUN2QixNQUFNLGFBQWE7QUFBQSxVQUNuQjtBQUFBLFVBQ0EsTUFBTTtBQUFBLFFBQ1Y7QUFDQSxjQUFNLGNBQWMsS0FBSyxrQkFBa0IsZUFBZSxhQUFhLFlBQVksYUFBYSxRQUFRLGFBQWEsSUFBSTtBQUN6SCxZQUFJLEtBQUssUUFBUTtBQUNiLGNBQUksYUFBYSxVQUFVO0FBQ3ZCLG9DQUF3QixhQUFhLFVBQVUsS0FBSyxRQUFRLEtBQUssUUFBUSxNQUFNO0FBQUEsVUFDbkY7QUFDQSxjQUFJLFdBQVcsUUFBVztBQUN0QixpQkFBSyxjQUFjLGVBQWUsUUFBUSxhQUFhLEtBQUssTUFBTTtBQUFBLFVBQ3RFO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxVQUFVLGNBQWM7QUFDcEIsWUFBSSxLQUFLLE1BQU0sUUFBUSxXQUFXLGdCQUFnQjtBQUM5QyxpQkFBTyxNQUFNLHNDQUFzQyxDQUFDO0FBQUEsUUFDeEQ7QUFDQSxZQUFJLE9BQU8sYUFBYSxPQUFPLFVBQVU7QUFDckMsaUJBQU8sTUFBTSxvQkFBb0IsNERBQTRELGFBQWEsS0FBSyxDQUFDO0FBQUEsUUFDcEg7QUFDQSxjQUFNLGdCQUFnQjtBQUFBLFVBQ2xCLFVBQVUsYUFBYTtBQUFBLFVBQ3ZCLFFBQVE7QUFBQSxVQUNSLE1BQU0sYUFBYSxRQUFRLGFBQWE7QUFBQSxVQUN4QyxNQUFNO0FBQUEsUUFDVjtBQUNBLGFBQUssTUFBTSxhQUNOLFVBQVUsWUFBWSxFQUN0QixLQUFLLENBQUFBLFlBQVcsY0FBYyxTQUFTQSxPQUFPLEVBQzlDLE1BQU0sTUFBTTtBQUFBLFFBR2pCLENBQUM7QUFDRCxlQUFPLEtBQUssa0JBQWtCLGVBQWUsYUFBYSxFQUFFO0FBQUEsTUFDaEU7QUFBQSxNQUNBLGNBQWMsY0FBYyxRQUFRLGFBQWEsUUFBUTtBQUNyRCxjQUFNLFdBQVcsYUFBYSxZQUMxQixvQ0FBb0MsUUFBUSxNQUFNLEtBQ2xELHNCQUFzQixhQUFhLE1BQU0sUUFBUSxLQUFLLGVBQWUsTUFBTTtBQUUvRSxjQUFNLG9CQUFvQixFQUFFLEdBQUcsY0FBYyxVQUFVLE9BQU87QUFDOUQsYUFBSyxtQkFBbUIsSUFBSSxhQUFhLGlCQUFpQjtBQUMxRCxjQUFNLEVBQUUsUUFBUSxJQUFJO0FBQ3BCLGVBQU8sWUFBWTtBQUFBLFVBQ2Y7QUFBQSxVQUNBLElBQUksVUFBVTtBQUNWLDRCQUFnQixtR0FBcUcsTUFBTSxPQUFPO0FBQ2xJLG1CQUFPO0FBQUEsVUFDWDtBQUFBLFVBQ0EsTUFBTSxhQUFhO0FBQUEsVUFDbkI7QUFBQSxVQUNBLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUE2QkEsSUFBTSxZQUFZLENBQUMsS0FBSyxTQUFVLE9BQU8sR0FBRztBQUFBLEVBQVEsU0FBUztBQUM3RCxJQUFNLGVBQWUsQ0FBQyxLQUFLLFNBQVUsT0FBTyxHQUFHO0FBQUE7QUFBQSxFQUFVLFNBQVM7QUFzTGxFLElBQU0sbUJBQW1CLENBQUMsT0FBTyxVQUFVLE1BQU0sWUFBWSxNQUFNLFlBQVksSUFBSTtBQTRIbkYsSUFBTSxlQUFlLENBQUMsTUFBTSxnQkFBZ0IsY0FBYyxJQUFJLFVBQVU7QUFDeEUsSUFBTSxnQkFBZ0I7QUFFdEIsSUFBTXFCLFVBQU4sTUFBYTtBQUFBLE1BQ1QsWUFBWSxlQUFlLGNBQWMsY0FBYyxjQUFjLE9BQU87QUFDeEUsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSyxlQUFlO0FBQ3BCLGFBQUssZUFBZTtBQUNwQixhQUFLLGVBQWU7QUFDcEIsYUFBSyxRQUFRO0FBQ2IsYUFBSyxzQkFBc0Isb0JBQUksSUFBSTtBQUNuQyxhQUFLLHFCQUFxQixvQkFBSSxJQUFJO0FBQUEsTUFDdEM7QUFBQSxNQUNBLE1BQU0sU0FBUyxTQUFTO0FBQ3BCLGtCQUFVLFlBQVksQ0FBQztBQUN2QixjQUFNLGVBQWUsdUJBQU8sT0FBTyxJQUFJO0FBQ3ZDLGFBQUssYUFBYSxnQkFBZ0IsY0FBYyxLQUFLLGVBQWUsS0FBSyxtQkFBbUI7QUFDNUYsWUFBSTtBQUNBLGdCQUFNLEtBQUssYUFBYSxhQUFhLGVBQWUsQ0FBQyxLQUFLLGVBQWUsS0FBSyxZQUFZLENBQUM7QUFDM0Ysb0JBQVUsbUJBQW1CLENBQUM7QUFDOUIsZ0JBQU0sU0FBUyxNQUFNLEtBQUssZUFBZTtBQUN6QyxjQUFJLE9BQU8sU0FBUyxHQUFHO0FBQ25CLCtDQUFtQyxLQUFLLGVBQWUsS0FBSyxhQUFhLE1BQU07QUFBQSxVQUNuRjtBQUNBLGdCQUFNLFlBQVksVUFBVSw0QkFBNEIsTUFBTSxDQUFDO0FBQy9ELGtCQUFRLG1CQUFtQixDQUFDO0FBQzVCLG9CQUFVLGtCQUFrQixDQUFDO0FBRzdCLGdCQUFNLFNBQVMsTUFBTSxhQUFhLEtBQUssZUFBZSxLQUFLLFlBQVk7QUFDdkUsZ0JBQU0sV0FBVyx3QkFBd0IsS0FBSyxhQUFhO0FBQzNELGVBQUssZ0JBQWdCLFFBQVEsV0FBVyxRQUFRO0FBQ2hELGtCQUFRLGtCQUFrQixDQUFDO0FBQzNCLGdCQUFNLEtBQUssMkJBQTJCLFFBQVEsV0FBVyxRQUFRLGNBQWMsUUFBUTtBQUFBLFFBQzNGLFNBQ08sS0FBUDtBQUNJLGdCQUFNLEtBQUssYUFBYSxhQUFhLGVBQWUsQ0FBQyxHQUFHLENBQUM7QUFDekQsZ0JBQU07QUFBQSxRQUNWO0FBQ0EsY0FBTSxLQUFLLGFBQWEsUUFBUSxrQkFBa0I7QUFBQSxVQUM5QyxLQUFLO0FBQUEsVUFDTDtBQUFBLFVBQ0E7QUFBQSxRQUNKLENBQUM7QUFDRCxhQUFLLGVBQWUsWUFBWTtBQUNoQyxnQkFBUSxZQUFZLENBQUM7QUFDckIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLE1BQU0sMkJBQTJCLFFBQVEsV0FBVyxRQUFRLGNBQWMsVUFBVTtBQUNoRixhQUFLLGVBQWUsUUFBUSxXQUFXLFFBQVEsWUFBWTtBQUMzRCxtQkFBVyxTQUFTLFFBQVE7QUFDeEIsdUJBQWEsTUFBTSxNQUFNLE1BQU0sMEJBQTBCO0FBQUEsUUFDN0Q7QUFDQSxjQUFNLFFBQVEsSUFBSSxPQUFPLElBQUksT0FBTyxVQUFVO0FBQzFDLGdCQUFNLGNBQWMsYUFBYSxNQUFNO0FBQ3ZDLGlCQUFPLE9BQU8sYUFBYSxNQUFNLE1BQU0sT0FBTyxLQUFLLGVBQWUsUUFBUSxhQUFhLFFBQVEsQ0FBQztBQUFBLFFBQ3BHLENBQUMsQ0FBQztBQUFBLE1BQ047QUFBQSxNQUNBLE1BQU0sZ0JBQWdCLGNBQWM7QUFDaEMsY0FBTSwwQkFBMEIsb0JBQUksSUFBSTtBQUN4QyxjQUFNLGVBQWUsTUFBTSxRQUFRLElBQUksT0FBTyxRQUFRLFlBQVksRUFBRSxJQUFJLE9BQU8sQ0FBQyxPQUFPLEtBQUssT0FBTztBQUFBLFVBQy9GO0FBQUEsVUFDQSxTQUFTLE1BQU0sS0FBSyxNQUFNLGFBQWEscUJBQXFCLEtBQUs7QUFBQSxRQUNyRSxFQUFFLENBQUM7QUFDSCxtQkFBVyxFQUFFLE9BQU8sUUFBUSxLQUFLLGNBQWM7QUFDM0MscUJBQVcsU0FBUyxTQUFTO0FBQ3pCLG1DQUF1QixPQUFPLE9BQU8sdUJBQXVCO0FBQUEsVUFDaEU7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLGVBQWUsUUFBUSxXQUFXLFFBQVEsUUFBUTtBQUM5QyxjQUFNLGNBQWMsQ0FBQztBQUNyQixjQUFNLGNBQWMsQ0FBQztBQUNyQixtQkFBVyxTQUFTLFFBQVE7QUFDeEIsV0FBQyxNQUFNLGdCQUFnQixNQUFNLGFBQWEsMEJBQ3BDLGNBQ0EsYUFBYSxLQUFLLEtBQUs7QUFBQSxRQUNqQztBQUVBLGNBQU0sa0JBQWtCLFlBQVksT0FBTyxXQUFXO0FBQ3RELG1CQUFXLFNBQVMsaUJBQWlCO0FBQ2pDLGNBQUksS0FBSyxjQUFjLE1BQU07QUFDekIsa0JBQU0sU0FBSyxzQkFBUyxLQUFLLGNBQWMsSUFBSTtBQUFBLFVBQy9DLFdBQ1MsS0FBSyxjQUFjLGlCQUFpQjtBQUN6QyxrQkFBTSxLQUFLLE1BQU0sMEJBQTBCLFdBQVcsS0FBSyxlQUFlLFFBQVEsS0FBSyxZQUFZO0FBQUEsVUFDdkcsT0FDSztBQUNELGtCQUFNLEtBQUssTUFBTSxXQUFXLFFBQVEsS0FBSyxlQUFlLFFBQVEsSUFBSTtBQUFBLFVBQ3hFO0FBQ0EsaUJBQU8sTUFBTSxNQUFNO0FBQUEsUUFDdkI7QUFBQSxNQUNKO0FBQUEsTUFDQSxtQkFBbUIsZ0JBQWdCO0FBQy9CLGNBQU0sOEJBQThCLENBQUM7QUFDckMsY0FBTSxrQkFBa0I7QUFBQSxVQUNwQixjQUFjLE1BQU0sS0FBSyxNQUFNLFlBQVksS0FBSztBQUFBLFVBQ2hELGVBQWUsS0FBSyxNQUFNO0FBQUEsUUFDOUI7QUFDQSxtQkFBV3JCLFdBQVUsS0FBSyxNQUFNLFlBQVksT0FBTyxHQUFHO0FBQ2xELGNBQUlBLG1CQUFrQixRQUFRO0FBQzFCLGtCQUFNLG1CQUFtQixlQUFlQSxRQUFPLElBQUksZUFBZTtBQUNsRSxnQkFBSSxPQUFPLHFCQUFxQixVQUFVO0FBQ3RDLDBDQUE0QixLQUFLLENBQUMsa0JBQWtCQSxPQUFNLENBQUM7QUFBQSxZQUMvRDtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0Esb0NBQTRCLEtBQUssQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLE1BQU0sTUFBTSxTQUFTLFNBQVMsSUFBSSxTQUFTLFNBQVMsS0FBSyxDQUFDO0FBQ3ZHLGNBQU0sMEJBQTBCLG9CQUFJLElBQUk7QUFDeEMsbUJBQVcsQ0FBQyxPQUFPQSxPQUFNLEtBQUssNkJBQTZCO0FBQ3ZELGlDQUF1QixPQUFPQSxTQUFRLHVCQUF1QjtBQUFBLFFBQ2pFO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLGVBQWUsY0FBYztBQUN6QixtQkFBVyxRQUFRLE9BQU8sT0FBTyxZQUFZLEdBQUc7QUFDNUMsY0FBSSxDQUFDLEtBQUssTUFBTTtBQUNaLDRCQUFnQixvTUFBb00sTUFBTSxLQUFLLFlBQVk7QUFDM08saUJBQUssT0FBTztBQUFBLFVBQ2hCO0FBQ0EsY0FBSSxLQUFLLGNBQWMsWUFBWSxVQUFVLE1BQU07QUFDL0MsZ0JBQUk7QUFDQSxtQkFBSyxNQUFNLGFBQWEsS0FBSyxNQUFNO0FBQUEsZ0JBQy9CLGVBQWU7QUFBQSxnQkFDZixhQUFhO0FBQUEsY0FDakIsQ0FBQztBQUFBLFlBQ0wsU0FDTyxLQUFQO0FBQ0ksbUJBQUssYUFBYSxPQUFPLGdCQUFnQixNQUFNLEdBQUcsQ0FBQztBQUFBLFlBQ3ZEO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxhQUFLLGFBQWEsZUFBZTtBQUFBLE1BQ3JDO0FBQUEsTUFDQSxNQUFNLGlCQUFpQjtBQUNuQixjQUFNLEVBQUUsYUFBYSxJQUFJLEtBQUs7QUFDOUIsY0FBTSwwQkFBMEIsT0FBTyxpQkFBaUIsV0FDbEQsTUFBTSxLQUFLLGdCQUFnQixZQUFZLElBQ3ZDLEtBQUssbUJBQW1CLFlBQVk7QUFDMUMsY0FBTSxTQUFTLENBQUM7QUFDaEIsY0FBTSxnQkFBZ0Isb0JBQUksSUFBSTtBQUM5QixtQkFBVyxFQUFFLE9BQU8sUUFBUSxLQUFLLEtBQUssY0FBYyx1QkFDOUMsQ0FBQyxFQUFFLE9BQU8sTUFBTSxTQUFTLG1CQUFtQixLQUFLLE1BQU0sV0FBVyxFQUFFLENBQUMsSUFDckUsS0FBSyxjQUFjLGtCQUNmLG1CQUFtQixLQUFLLE1BQU0sV0FBVyxFQUFFLElBQUksQ0FBQUEsYUFBVztBQUFBLFVBQ3hELE9BQU87QUFBQSxVQUNQLFNBQVMsQ0FBQ0EsT0FBTTtBQUFBLFFBQ3BCLEVBQUUsSUFDQSxvQkFBb0IsS0FBSyxNQUFNLGNBQWMsdUJBQXVCLEdBQUc7QUFDN0UsK0JBQXFCLE9BQU87QUFDNUIsZ0JBQU0sUUFBUSxJQUFJc0IsT0FBTSxTQUFTLEtBQUssY0FBYyxLQUFLLGVBQWUsS0FBSyxjQUFjLEtBQUssY0FBYyxLQUFLLE1BQU0sYUFBYSxlQUFlLEtBQUsscUJBQXFCLEtBQUssb0JBQW9CLEtBQUs7QUFDN00saUJBQU8sS0FBSyxLQUFLO0FBQ2pCLHFCQUFXdEIsV0FBVSxTQUFTO0FBQzFCLDBCQUFjLElBQUlBLFNBQVEsS0FBSztBQUFBLFVBQ25DO0FBQUEsUUFDSjtBQUNBLG1CQUFXLFNBQVMsUUFBUTtBQUN4QixnQkFBTSxLQUFLO0FBQUEsUUFDZjtBQUNBLGNBQU0sVUFBVSxDQUFDO0FBQ2pCLG1CQUFXLFNBQVMsUUFBUTtBQUN4QixrQkFBUSxLQUFLLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQztBQUFBLFFBQzNDO0FBQ0EsZUFBTyxDQUFDLEdBQUcsUUFBUSxHQUFHLE9BQU87QUFBQSxNQUNqQztBQUFBLE1BQ0EsZ0JBQWdCLFFBQVEsV0FBVyxVQUFVO0FBQ3pDLG1CQUFXLFNBQVMsUUFBUTtBQUN4QixnQkFBTSxnQkFBZ0I7QUFBQSxRQUMxQjtBQUNBLG1CQUFXLFNBQVMsUUFBUTtBQUN4QixnQkFBTSxVQUFVLEtBQUssZUFBZSxXQUFXLFFBQVE7QUFBQSxRQUMzRDtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBb0NBLElBQUksZ0JBQWdCO0FBQUEsTUFDbEIsR0FBRztBQUFBLE1BQ0gsR0FBRztBQUFBLE1BQ0gsR0FBRztBQUFBLE1BQ0gsUUFBUTtBQUFBLE1BQ1IsWUFBWTtBQUFBLElBQ2Q7QUFJQSxJQUFJLHVCQUF1QjtBQUUzQixJQUFJLGFBQWE7QUFBQSxNQUNmLEdBQUc7QUFBQSxNQUNILFdBQVcsdUJBQXVCO0FBQUEsTUFDbEMsR0FBRyx1QkFBdUI7QUFBQSxJQUM1QjtBQUVBLElBQUksNEJBQTRCO0FBU2hDLElBQUksK0JBQStCO0FBQ25DLElBQUksMEJBQTBCO0FBRTlCLElBQUksMEJBQTBCLElBQUksT0FBTyxNQUFNLCtCQUErQixHQUFHO0FBQ2pGLElBQUkscUJBQXFCLElBQUksT0FBTyxNQUFNLCtCQUErQiwwQkFBMEIsR0FBRztBQUV0RyxtQ0FBK0IsMEJBQTBCO0FBU3pELElBQUksNkJBQTZCLENBQUMsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsSUFBRyxLQUFJLElBQUcsSUFBRyxLQUFJLElBQUcsR0FBRSxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxJQUFHLEtBQUksSUFBRyxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxLQUFJLElBQUcsSUFBRyxJQUFHLEdBQUUsSUFBRyxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsR0FBRSxHQUFFLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLEdBQUUsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxJQUFHLEdBQUUsSUFBRyxJQUFHLEdBQUUsR0FBRSxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxLQUFJLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsS0FBSSxJQUFHLEdBQUUsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLEdBQUUsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxHQUFFLEdBQUUsR0FBRSxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsSUFBRyxJQUFHLElBQUcsR0FBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxHQUFFLElBQUcsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsS0FBSSxJQUFHLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxJQUFHLElBQUcsR0FBRSxHQUFFLEdBQUUsS0FBSSxJQUFHLElBQUcsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLElBQUcsSUFBRyxJQUFHLEdBQUUsSUFBRyxJQUFHLElBQUcsR0FBRSxLQUFJLElBQUcsS0FBSSxJQUFHLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxHQUFFLEdBQUUsR0FBRSxJQUFHLEdBQUUsR0FBRSxJQUFHLElBQUcsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsSUFBRyxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsSUFBRyxJQUFHLEdBQUUsSUFBRyxJQUFHLEtBQUksR0FBRSxHQUFFLElBQUcsSUFBRyxHQUFFLElBQUcsSUFBRyxLQUFJLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxJQUFHLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsSUFBRyxHQUFFLEtBQUksSUFBRyxLQUFJLEdBQUUsSUFBRyxLQUFJLEtBQUksS0FBSSxJQUFHLEtBQUksTUFBSyxJQUFHLElBQUcsTUFBSyxNQUFLLEtBQUksTUFBSyxLQUFJLEdBQUUsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLEdBQUUsSUFBRyxJQUFHLEdBQUUsSUFBRyxLQUFJLElBQUcsS0FBSSxJQUFHLEdBQUUsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLEdBQUUsR0FBRSxJQUFHLE1BQUssR0FBRSxNQUFLLElBQUcsR0FBRSxNQUFLLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEtBQUksSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLEtBQUksTUFBSyxLQUFJLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLE1BQUssSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsS0FBSSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLE1BQUssSUFBRyxLQUFJLElBQUcsSUFBRyxHQUFFLElBQUcsR0FBRSxLQUFJLElBQUcsSUFBRyxJQUFHLE1BQUssR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEtBQUksSUFBRyxJQUFHLEdBQUUsR0FBRSxNQUFLLEdBQUUsR0FBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxNQUFLLE9BQU0sSUFBRyxNQUFLLEdBQUUsS0FBSSxHQUFFLE1BQUssSUFBRyxNQUFLLE1BQUssS0FBSSxNQUFLLElBQUk7QUFHcDZDLElBQUksd0JBQXdCLENBQUMsS0FBSSxHQUFFLEtBQUksR0FBRSxLQUFJLEdBQUUsS0FBSSxHQUFFLE1BQUssR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsS0FBSSxHQUFFLEtBQUksR0FBRSxHQUFFLEdBQUUsS0FBSSxHQUFFLEtBQUksSUFBRyxJQUFHLEdBQUUsS0FBSSxHQUFFLElBQUcsSUFBRyxJQUFHLElBQUcsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLElBQUcsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsSUFBRyxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLElBQUcsR0FBRSxHQUFFLEdBQUUsSUFBRyxJQUFHLElBQUcsR0FBRSxHQUFFLEtBQUksSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsS0FBSSxJQUFHLElBQUcsR0FBRSxHQUFFLEdBQUUsSUFBRyxJQUFHLElBQUcsR0FBRSxLQUFJLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLElBQUcsSUFBRyxHQUFFLElBQUcsSUFBRyxHQUFFLEdBQUUsSUFBRyxJQUFHLEdBQUUsR0FBRSxLQUFJLElBQUcsS0FBSSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEtBQUksR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxJQUFHLElBQUcsSUFBRyxJQUFHLEtBQUksR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLElBQUcsSUFBRyxHQUFFLElBQUcsS0FBSSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEtBQUksR0FBRSxPQUFNLEdBQUUsSUFBRyxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsSUFBRyxHQUFFLE1BQUssR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsT0FBTSxHQUFFLE1BQUssSUFBRyxHQUFFLElBQUcsS0FBSSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLElBQUcsR0FBRSxLQUFJLEdBQUUsTUFBSyxJQUFHLEtBQUksSUFBRyxHQUFFLElBQUcsR0FBRSxHQUFFLElBQUcsR0FBRSxJQUFHLEdBQUUsR0FBRSxJQUFHLE1BQUssR0FBRSxHQUFFLElBQUcsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsS0FB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SSxDQUFDLG9CQUFvQjtBQUN2QixjQUFRO0FBQUEsUUFDTjtBQUFBLE1BQ0Y7QUFDQTtBQUFBLElBQ0Y7QUFDQSxZQUFRO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBRUEsVUFBTSxTQUFTLE1BQU0sT0FBTztBQUFBLE1BQzFCLE9BQU87QUFBQSxNQUNQLFNBQVMsQ0FBQyxZQUFRLE9BQUcsdUJBQUFJLFNBQVMsQ0FBQztBQUFBLE1BQy9CLFVBQVUsQ0FBQyxTQUFTLFlBQVksb0JBQW9CLFdBQVc7QUFBQSxJQUNqRSxDQUFDO0FBRUQsUUFBSTtBQUNGLFlBQU0sRUFBQyxPQUFNLElBQUksTUFBTSxPQUFPLFNBQVM7QUFBQSxRQUNyQyxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixvQkFBb0I7QUFBQSxVQUNwQixhQUFhO0FBQUEsUUFDZjtBQUFBLE1BQ0YsQ0FBQztBQUNELGFBQU8sT0FBTyxHQUFHO0FBQUEsSUFDbkIsVUFBRTtBQUNBLFlBQU0sT0FBTyxNQUFNO0FBQUEsSUFDckI7QUFBQSxFQUNGLENBQUM7QUFFRCxTQUFPLFlBQVk7QUFDakIsWUFBUSxNQUFNLHVEQUF1RDtBQUNyRSxRQUFJLEtBQUs7QUFDUCxjQUFRO0FBQUEsUUFDTjtBQUFBLE1BQ0Y7QUFDQSxZQUFNLElBQUk7QUFBQSxRQUFjLENBQUNDLFVBQVMsV0FHaEMsSUFBSyxNQUFNLENBQUMsUUFBUyxNQUFNLE9BQU8sR0FBRyxJQUFJQSxTQUFRLENBQUU7QUFBQSxNQUNyRDtBQUNBLGNBQVEsTUFBTSwwREFBMEQ7QUFBQSxJQUMxRTtBQUFBLEVBQ0Y7QUFDRjtBQUVBLElBQU8sc0JBQVE7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCAiZGF0YSIsICJlcnJvciIsICJlcnIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJvZmZzZXQiLCAibGVuZ3RoIiwgImRhdGEiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJkYXRhIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiUmVjZWl2ZXIiLCAibiIsICJvZmZzZXQiLCAiZXJyb3IiLCAiZGF0YSIsICJtb2R1bGUiLCAiU2VuZGVyIiwgImRhdGEiLCAib2Zmc2V0IiwgImxlbmd0aCIsICJtb2R1bGUiLCAiZGF0YSIsICJvbkVycm9yIiwgImVycm9yIiwgIm1vZHVsZSIsICJwYXJzZSIsICJtb2R1bGUiLCAiY3JlYXRlSGFzaCIsICJVUkwiLCAiUmVjZWl2ZXIiLCAiU2VuZGVyIiwgIk5PT1AiLCAicGFyc2UiLCAiV2ViU29ja2V0IiwgImRhdGEiLCAia2V5IiwgImxlbmd0aCIsICJtb2R1bGUiLCAicGFyc2UiLCAicHJvdG9jb2wiLCAibW9kdWxlIiwgImNyZWF0ZUhhc2giLCAiV2ViU29ja2V0IiwgIldlYlNvY2tldFNlcnZlciIsICJ2ZXJzaW9uIiwgImN1cnJlbnQiLCAibG9jYXRlIiwgImkiLCAicGF0aCIsICJiYXNlIiwgImtleXMiLCAibW9kdWxlIiwgIm5vZGUiLCAibmV4dEluZGV4IiwgInByb2Nlc3MkMSIsICJuIiwgImluZGVudCIsICJhbWQiLCAiZXh0ZW5kIiwgImRlZmluZSIsICJzb3VyY2UiLCAicmVsYXRpdmUkMSIsICJnZXRJbmRlbnRTdHJpbmciLCAicmVuZGVyQ2h1bmsiLCAiY29kZSIsICJjb21tb25TZWdtZW50cyIsICJvZmZzZXQiLCAiaW1wb3J0ZXIiLCAiaXNFbnRyeSIsICJpZCIsICJvcHRpb25zIiwgInJlc29sdmVJZCIsICJCdW5kbGUiLCAiQ2h1bmsiLCAidG9TdHJpbmciLCAiQml0U2V0IiwgIlNvdXJjZU1hcCIsICJNYXBwaW5ncyIsICJNYWdpY1N0cmluZyIsICJhcHBlbmRMZWZ0IiwgImFwcGVuZFJpZ2h0IiwgImNsb25lIiwgInByZXBlbmRMZWZ0IiwgInByZXBlbmRSaWdodCIsICJsZW5ndGgiLCAidHJpbUVuZCIsICJ0cmltU3RhcnQiLCAiYXBwZW5kIiwgImdlbmVyYXRlRGVjb2RlZE1hcCIsICJnZW5lcmF0ZU1hcCIsICJwcmVwZW5kIiwgImlzRW1wdHkiLCAidHJpbUxpbmVzIiwgInRyaW0iLCAiRXJyb3JzIiwgInJlcXVpcmUkJDAiLCAiY2hhcnMiLCAid2luMzIiLCAiYWR2YW5jZSIsICJET1RfTElURVJBTCIsICJQTFVTX0xJVEVSQUwiLCAiU0xBU0hfTElURVJBTCIsICJPTkVfQ0hBUiIsICJET1RTX1NMQVNIIiwgIk5PX0RPVCIsICJOT19ET1RfU0xBU0giLCAiTk9fRE9UU19TTEFTSCIsICJRTUFSSyIsICJRTUFSS19OT19ET1QiLCAiU1RBUiIsICJTVEFSVF9BTkNIT1IiLCAib3B0cyIsICJ2YWx1ZSIsICJyZXN0IiwgInBvc2l4IiwgIk5PX0RPVFMiLCAic3RhdGUiLCAiZXh0cmFjdEFzc2lnbmVkTmFtZXMiLCAiaWdub3JlIiwgInJlc29sdmUiLCAicmVwbGFjZW1lbnQiLCAiVVJMIiwgInVtZCIsICJuYW1lIiwgIkJ1aWxkUGhhc2UiLCAia2V5cGF0aCIsICJsaW5lIiwgImNyZWF0ZUhhc2gkMSIsICJUb2tlblR5cGUiLCAiUG9zaXRpb24iLCAiU291cmNlTG9jYXRpb24iLCAiUGFyc2VyIiwgInBhcnNlIiwgInJlZiIsICJUb2tDb250ZXh0IiwgIlNjb3BlIiwgIk5vZGUiLCAiUmVnRXhwVmFsaWRhdGlvblN0YXRlIiwgIlRva2VuIiwgImV4dGVybmFsIiwgInByb21pc2VzIiwgImFyZzAiLCAiU29ydGluZ0ZpbGVUeXBlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiaXNNZXJnZWFibGVPYmplY3QiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAic3RhY2siLCAibW9kdWxlIiwgIndpbjMyIiwgInBvc2l4IiwgIm1vZHVsZSIsICJwYXRoIiwgInBhcnNlIiwgImdldE5vZGVNb2R1bGVzRGlycyIsICJtb2R1bGUiLCAibW9kdWxlIiwgInNsaWNlIiwgIkVtcHR5IiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImhhcyIsICJjdXJyZW50IiwgImRhdGEiLCAibW9kdWxlIiwgImZzIiwgInBhdGgiLCAic3RhdCIsICJyZWFscGF0aCIsICJtYXliZVJlYWxwYXRoIiwgImRlZmF1bHRSZWFkUGFja2FnZSIsICJyZWFkRmlsZSIsICJnZXRQYWNrYWdlQ2FuZGlkYXRlcyIsICJyZXNvbHZlIiwgImVyciIsICJiYXNlZGlyIiwgIm4iLCAicGtnIiwgIngiLCAiY2FsbGJhY2siLCAiY2IiLCAiZXh0cyIsICJpc2RpciIsICJvbmZpbGUiLCAicmVxdWlyZV9jb3JlIiwgIm1vZHVsZSIsICJjdXJyZW50IiwgImRhdGEiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJmcyIsICJwYXRoIiwgInN0YXQiLCAicmVhbHBhdGhTeW5jIiwgIm1heWJlUmVhbHBhdGhTeW5jIiwgImRlZmF1bHRSZWFkUGFja2FnZVN5bmMiLCAiZ2V0UGFja2FnZUNhbmRpZGF0ZXMiLCAibiIsICJ4IiwgIm0iLCAibW9kdWxlIiwgInJlcXVpcmVfY29uc3RhbnRzIiwgIm1vZHVsZSIsICJwYXRoIiwgIldJTl9TTEFTSCIsICJXSU5fTk9fU0xBU0giLCAiRE9UX0xJVEVSQUwiLCAiUExVU19MSVRFUkFMIiwgIlFNQVJLX0xJVEVSQUwiLCAiU0xBU0hfTElURVJBTCIsICJPTkVfQ0hBUiIsICJRTUFSSyIsICJFTkRfQU5DSE9SIiwgIlNUQVJUX0FOQ0hPUiIsICJET1RTX1NMQVNIIiwgIk5PX0RPVCIsICJOT19ET1RTIiwgIk5PX0RPVF9TTEFTSCIsICJOT19ET1RTX1NMQVNIIiwgIlFNQVJLX05PX0RPVCIsICJTVEFSIiwgIlBPU0lYX0NIQVJTIiwgIldJTkRPV1NfQ0hBUlMiLCAiUE9TSVhfUkVHRVhfU09VUkNFIiwgImNoYXJzIiwgIndpbjMyIiwgInBhdGgiLCAid2luMzIiLCAicHJlcGVuZCIsICJhcHBlbmQiLCAibW9kdWxlIiwgInV0aWxzIiwgIkNIQVJfQVNURVJJU0siLCAiQ0hBUl9BVCIsICJDSEFSX0JBQ0tXQVJEX1NMQVNIIiwgIkNIQVJfQ09NTUEiLCAiQ0hBUl9ET1QiLCAiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwgIkNIQVJfRk9SV0FSRF9TTEFTSCIsICJDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UiLCAiQ0hBUl9MRUZUX1BBUkVOVEhFU0VTIiwgIkNIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCIsICJDSEFSX1BMVVMiLCAiQ0hBUl9RVUVTVElPTl9NQVJLIiwgIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0UiLCAiQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUyIsICJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwgImlzUGF0aFNlcGFyYXRvciIsICJkZXB0aCIsICJzY2FuIiwgImxlbmd0aCIsICJhZHZhbmNlIiwgImJhc2UiLCAibiIsICJtb2R1bGUiLCAiY29uc3RhbnRzIiwgInV0aWxzIiwgIk1BWF9MRU5HVEgiLCAiUE9TSVhfUkVHRVhfU09VUkNFIiwgIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwgIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsICJSRVBMQUNFTUVOVFMiLCAiZXhwYW5kUmFuZ2UiLCAic3ludGF4RXJyb3IiLCAicGFyc2UiLCAid2luMzIiLCAiRE9UX0xJVEVSQUwiLCAiUExVU19MSVRFUkFMIiwgIlNMQVNIX0xJVEVSQUwiLCAiT05FX0NIQVIiLCAiRE9UU19TTEFTSCIsICJOT19ET1QiLCAiTk9fRE9UX1NMQVNIIiwgIk5PX0RPVFNfU0xBU0giLCAiUU1BUksiLCAiUU1BUktfTk9fRE9UIiwgIlNUQVIiLCAiU1RBUlRfQU5DSE9SIiwgIm9wdHMiLCAibiIsICJhZHZhbmNlIiwgInZhbHVlIiwgImFwcGVuZCIsICJjaGFycyIsICJyZXN0IiwgInBvc2l4IiwgIk5PX0RPVFMiLCAic291cmNlIiwgIm1vZHVsZSIsICJwYXRoIiwgInNjYW4iLCAicGFyc2UiLCAidXRpbHMiLCAiY29uc3RhbnRzIiwgImlzT2JqZWN0IiwgInN0YXRlIiwgInBvc2l4IiwgInByZXBlbmQiLCAiYXBwZW5kIiwgInJlcXVpcmVfcGljb21hdGNoIiwgIm1vZHVsZSIsICJyZXF1aXJlX2NqcyIsICJwYXRoIiwgInBtIiwgImFkZEV4dGVuc2lvbiIsICJpbmRleCIsICJyZW1vdmUiLCAiZXh0cmFjdG9ycyIsICJleHRyYWN0QXNzaWduZWROYW1lcyIsICJTY29wZSIsICJhdHRhY2hTY29wZXMiLCAibiIsICJpc0FycmF5IiwgImVuc3VyZUFycmF5IiwgImdldE1hdGNoZXJTdHJpbmciLCAiY3JlYXRlRmlsdGVyIiwgInJlc2VydmVkV29yZHMiLCAiYnVpbHRpbnMiLCAiZm9yYmlkZGVuSWRlbnRpZmllcnMiLCAibWFrZUxlZ2FsSWRlbnRpZmllciIsICJpbmRlbnQiLCAiZGF0YVRvRXNtIiwgImRhdGEiLCAibW9kdWxlIiwgInBhdGgiLCAiZnMiLCAibm9ybWFsaXplIiwgInJlYWxwYXRoU3luYyIsICJjdXJyZW50IiwgImJhc2UiLCAic3RhdCIsICJyZWFscGF0aCIsICJlcnIiLCAibW9kdWxlIiwgInJlYWxwYXRoIiwgInJlYWxwYXRoU3luYyIsICJmcyIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJpc0FycmF5IiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibiIsICJtb2R1bGUiLCAicGF0aCIsICJtaW5pbWF0Y2giLCAiTWluaW1hdGNoIiwgInNldCIsICJwYXJzZSIsICJzZWxmIiwgIm4iLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicG9zaXgiLCAicGF0aCIsICJ3aW4zMiIsICJmcyIsICJwYXRoIiwgImlzQWJzb2x1dGUiLCAic2VsZiIsICJsaXRlcmFsIiwgIm0iLCAicmVxdWlyZV9zeW5jIiwgIm1vZHVsZSIsICJwYXRoIiwgImlzQWJzb2x1dGUiLCAibiIsICJzZWxmIiwgInN0YXQiLCAiZXJyb3IiLCAibW9kdWxlIiwgImNiIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAic2xpY2UiLCAibGVuZ3RoIiwgIm1vZHVsZSIsICJwYXRoIiwgImlzQWJzb2x1dGUiLCAiZXh0ZW5kIiwgImFkZCIsICJrZXlzIiwgIm4iLCAic2VsZiIsICJlcnJvciIsICJzdGF0IiwgImVyIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImNoYXJUb0ludGVnZXIiLCAiY2hhcnMiLCAiZGVjb2RlIiwgImkiLCAic2VnbWVudGlmeSIsICJlbmNvZGUiLCAiZW5jb2RlSW50ZWdlciIsICJCaXRTZXQiLCAiYWRkIiwgIm4iLCAiaGFzIiwgIkNodW5rIiwgImFwcGVuZExlZnQiLCAiYXBwZW5kUmlnaHQiLCAiY2xvbmUiLCAiY29uc3QiLCAiY29udGFpbnMiLCAiZWFjaE5leHQiLCAibGV0IiwgImVhY2hQcmV2aW91cyIsICJlZGl0IiwgInByZXBlbmRMZWZ0IiwgInByZXBlbmRSaWdodCIsICJzcGxpdCIsICJ0b1N0cmluZyIsICJ0cmltRW5kIiwgInRyaW1TdGFydCIsICJidG9hIiwgIlNvdXJjZU1hcCIsICJlbmNvZGUiLCAidG9VcmwiLCAiZ3Vlc3NJbmRlbnQiLCAiY3VycmVudCIsICJnZXRSZWxhdGl2ZVBhdGgiLCAiaXNPYmplY3QiLCAiZ2V0TG9jYXRvciIsICJsb2NhdGUiLCAiaSIsICJNYXBwaW5ncyIsICJhZGRFZGl0IiwgImFkZFVuZWRpdGVkQ2h1bmsiLCAiYWR2YW5jZSIsICJ3YXJuZWQiLCAiTWFnaWNTdHJpbmciLCAiYWRkU291cmNlbWFwTG9jYXRpb24iLCAiYXBwZW5kIiwgImdlbmVyYXRlRGVjb2RlZE1hcCIsICJ0aGlzIiwgImdlbmVyYXRlTWFwIiwgImdldEluZGVudFN0cmluZyIsICJpbmRlbnQiLCAiaW5zZXJ0IiwgImluc2VydExlZnQiLCAiaW5zZXJ0UmlnaHQiLCAibW92ZSIsICJvdmVyd3JpdGUiLCAicHJlcGVuZCIsICJyZW1vdmUiLCAibGFzdENoYXIiLCAibGFzdExpbmUiLCAic2xpY2UiLCAic25pcCIsICJfc3BsaXQiLCAiX3NwbGl0Q2h1bmsiLCAiaXNFbXB0eSIsICJsZW5ndGgiLCAidHJpbUxpbmVzIiwgInRyaW0iLCAidHJpbUVuZEFib3J0ZWQiLCAidHJpbVN0YXJ0QWJvcnRlZCIsICJoYXNPd25Qcm9wIiwgIkJ1bmRsZSIsICJhZGRTb3VyY2UiLCAibW9kdWxlIiwgInBhcnNlIiwgIm1ha2VMZWdhbElkZW50aWZpZXIiLCAiYmFzZW5hbWUiLCAiZXh0bmFtZSIsICJkaXJuYW1lIiwgInBhdGgiLCAiZXhpc3RzU3luYyIsICJqb2luIiwgInJlYWRGaWxlU3luYyIsICJzdGF0U3luYyIsICJnbG9iIiwgInJlc29sdmUiLCAic2VwIiwgInJlc29sdmVJZCIsICJleHBvcnRzIiwgImdldEV4cG9ydHMiLCAibm9kZVJlc29sdmVTeW5jIiwgIk1hZ2ljU3RyaW5nIiwgImF0dGFjaFNjb3BlcyIsICJ3YWxrIiwgImV4dHJhY3RBc3NpZ25lZE5hbWVzIiwgImlzUmVmZXJlbmNlIiwgImNvbW1vbmpzIiwgImNyZWF0ZUZpbHRlciIsICJnZXRDb21tb25EaXIiLCAiaW1wb3J0X3BhdGgiLCAiaW1wb3J0X3BhdGgiLCAiaW1wb3J0X2ZzIiwgImltcG9ydF9wYXRoIiwgImlzQXJyYXkiLCAiZW5zdXJlQXJyYXkiLCAiY3JlYXRlRmlsdGVyIiwgInBtIiwgInJlc2VydmVkV29yZHMiLCAiYnVpbHRpbnMiLCAiZm9yYmlkZGVuSWRlbnRpZmllcnMiLCAidmVyc2lvbiIsICJmcyIsICJwYXRoIiwgImVycm9yIiwgInNwbGl0IiwgImN1cnJlbnQiLCAiYmFzZSIsICJrZXlzIiwgInJlc3VsdCIsICJyZXNvbHZlSWQiLCAicmVzb2x2ZSQxIiwgImJ1aWx0aW5zIiwgImJ1aWx0aW5MaXN0IiwgImRlZXBNZXJnZSIsICJpc01vZHVsZSIsICJvcHRpb25zIiwgInBhdGgiLCAiZXJyb3IiLCAid3NzIiwgIldlYlNvY2tldFNlcnZlciIsICJkYXRhIiwgIldlYlNvY2tldCIsICJjb21tb25qcyIsICJyZXNvbHZlIl0KfQo=
